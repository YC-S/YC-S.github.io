<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="life,think,work,blog,code" />
   
  <meta name="description" content="a place holder" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
	<div class="cover-frame">
		<div class="bg-box">
			<img src="/images/cover3.jpg" alt="image frame" />
		</div>
		<div class="cover-inner text-center text-white">
			<h1><a href="/">Blog</a></h1>
			<div id="subtitle-box">
				
				<span id="subtitle"></span>
				
			</div>
			<div>
				
			</div>
		</div>
	</div>
	<div class="cover-learn-more">
		<a href="javascript:void(0)" class="anchor"
			><i class="ri-arrow-down-line"></i
		></a>
	</div>
</section>
 
<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

<script>
	try {
	  var typed = new Typed("#subtitle", {
	    strings: ['It doesn&#39;t work...... why?', 'It works...... why?', 'I used to have a life... But Now I&#39;m a programmer.'],
	    startDelay: 100,
	    typeSpeed: 50,
	    loop: false,
	    backSpeed: 20,
	    showCursor: true
	  });
	} catch (err) {
	  console.log(err)
	}
</script>


<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-分布式锁"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/20/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"
    >分布式锁</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/20/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="article-date">
  <time datetime="2020-02-21T01:14:23.000Z" itemprop="datePublished">2020-02-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。在分布式系统下，这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。不管怎么样，分布式的锁服务需要有以下几个特点。</p>
<ul>
<li><strong>安全性（Safety）</strong>：在任意时刻，只有一个客户端可以获得锁（<strong>排他性</strong>）。</li>
<li><strong>避免死锁</strong>：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。</li>
<li><strong>容错性</strong>：只要锁服务集群中的大部分节点存活，Client 就可以进行加锁解锁操作。</li>
</ul>
<h1 id="Redis-的分布式锁服务"><a href="#Redis-的分布式锁服务" class="headerlink" title="Redis 的分布式锁服务"></a>Redis 的分布式锁服务</h1><p>这里提一下，避免死锁的问题。下面以 Redis 的锁服务为例（参考 <a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">Redis 的官方文档</a> ）。</p>
<p>通过以下命令对资源加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>

<p>解释一下：</p>
<ul>
<li><code>SET NX</code> 命令只会在 <code>key</code> 不存在的时候给 <code>key</code> 赋值，<code>PX</code> 命令通知 Redis 保存这个 key 30000ms。</li>
<li><code>my_random_value</code> 必须是全局唯一的值。这个随机数在释放锁时保证释放锁操作的安全性。</li>
<li>PX 操作后面的参数代表的是这个 key 的存活时间，称作锁过期时间。</li>
<li>当资源被锁定超过这个时间时，锁将自动释放。</li>
<li>获得锁的客户端如果没有在这个时间窗口内完成操作，就可能会有其他客户端获得锁，引起争用问题。</li>
</ul>
<p>这里的原理是，只有在某个 key 不存在的情况下才能设置（set）成功该 key。于是，这就可以让多个进程并发去设置同一个 key，只有一个进程能设置成功。而其它的进程因为之前有人把 key 设置成功了，而导致失败（也就是获得锁失败）。</p>
<p>通过下面的脚本为申请成功的锁解锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then </span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1]) </span><br><span class="line">else </span><br><span class="line">    return 0 </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>如果 key 对应的 value 一致，则删除这个 key。</p>
<p>通过这个方式释放锁是为了避免 Client 释放了其他 Client 申请的锁。</p>
<p>例如，下面的例子演示了不区分 Client 会出现的一种问题。</p>
<ol>
<li>Client A 获得了一个锁。</li>
<li>当尝试释放锁的请求发送给 Redis 时被阻塞，没有及时到达 Redis。</li>
<li>锁定时间超时，Redis 认为锁的租约到期，释放了这个锁。</li>
<li>Client B 重新申请到了这个锁。</li>
<li>Client A 的解锁请求到达，将 Client B 锁定的 key 解锁。</li>
<li>Client C 也获得了锁。</li>
<li>Client B 和 Client C 同时持有锁。</li>
</ol>
<p>通过执行上面脚本的方式释放锁，Client 的解锁操作只会解锁自己曾经加锁的资源，所以是安全的。</p>
<p>关于 value 的生成，官方推荐从 /dev/urandom 中取 20 个 byte 作为随机数。或者采用更加简单的方式，例如使用 RC4 加密算法在 /dev/urandom 中得到一个种子（Seed），然后生成一个伪随机流。</p>
<p>也可以采用更简单的方法，使用时间戳 + 客户端编号的方式生成随机数。Redis 的官方文档说：“这种方式的安全性较差一些，但对于绝大多数的场景来说已经足够安全了”。</p>
<h1 id="分布式锁服务的一个问题"><a href="#分布式锁服务的一个问题" class="headerlink" title="分布式锁服务的一个问题"></a>分布式锁服务的一个问题</h1><p>注意，虽然 Redis 文档里说他们的分布式锁是没有问题的，但其实还是很有问题的。尤其是上面那个为了避免 Client 端把锁占住不释放，然后，Redis 在超时后把其释放掉。不知道你怎么样想，但我觉得这事儿听起来就有点不靠谱。</p>
<p>我们来脑补一下，不难发现下面这个案例。</p>
<ul>
<li>如果 Client A 先取得了锁。</li>
<li>其它 Client（比如说 Client B）在等待 Client A 的工作完成。</li>
<li>这个时候，如果 Client A 被挂在了某些事上，比如一个外部的阻塞调用，或是 CPU 被别的进程吃满，或是不巧碰上了 Full GC，导致 Client A 花了超过平时几倍的时间。</li>
<li>然后，我们的锁服务因为怕死锁，就在一定时间后，把锁给释放掉了。</li>
<li>此时，Client B 获得了锁并更新了资源。</li>
<li>这个时候，Client A 服务缓过来了，然后也去更新了资源。于是乎，把 Client B 的更新给冲掉了。</li>
<li>这就造成了数据出错。</li>
</ul>
<p>这听起来挺严重的吧。示例一下。</p>
<p><img src="../images/937d9975899662d90a96f4cd70580d89.png" alt="img"></p>
<p>千万不要以为这是脑补出来的案例。其实，这个是真实案例。HBase 就曾经遇到过这样的问题，你可以在他们的 PPT（<a target="_blank" rel="noopener" href="https://www.slideshare.net/enissoz/hbase-and-hdfs-understanding-filesystem-usage">HBase and HDFS: Understanding FileSystem Usage in HBase</a>）中看到相关的描述。</p>
<p>要解决这个问题，你需要引入 fence（栅栏）技术。一般来说，这就是乐观锁机制，需要一个版本号排它。我们的流程就变成了下图中的这个样子。</p>
<p><img src="../images/ce3454e9a8bbfe4628899391c003a5c3.png" alt="img"></p>
<p>我们从图中可以看到：</p>
<ul>
<li>锁服务需要有一个单调递增的版本号。</li>
<li>写数据的时候，也需要带上自己的版本号。</li>
<li>数据库服务需要保存数据的版本号，然后对请求做检查。</li>
</ul>
<p>如果使用 ZooKeeper 做锁服务的话，那么可以使用 <code>zxid</code> 或 znode 的版本号来做这个 fence 版本号。</p>
<h1 id="从乐观锁到-CAS"><a href="#从乐观锁到-CAS" class="headerlink" title="从乐观锁到 CAS"></a>从乐观锁到 CAS</h1><p>但是，我们想想，如果数据库中也保留着版本号，那么完全可以用数据库来做这个锁服务，不就更方便了吗？下面的图展示了这个过程。</p>
<p><img src="../images/9557fb5b7269eb5d7d53568298803141.png" alt="img"></p>
<p>使用数据版本（Version）记录机制，即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现的。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加一。</p>
<p>当我们提交更新的时候，数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对。如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。更新语句写成 SQL 大概是下面这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET xxx &#x3D; #&#123;xxx&#125;, version&#x3D;version+1 where version &#x3D;#&#123;version&#125;;</span><br></pre></td></tr></table></figure>

<p>这不就是乐观锁吗？是的，这是乐观锁最常用的一种实现方式。<strong>是的，如果我们使用版本号，或是 fence token 这种方式，就不需要使用分布式锁服务了。</strong></p>
<p>另外，多说一下。这种 fence token 的玩法，在数据库那边一般会用 timestamp 时间截来玩。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。</p>
<p>还有，我们有时候都不需要增加额外的版本字段或是 fence token。比如，如果想更新库存，我们可以这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT stock FROM tb_product where product_id&#x3D;#&#123;product_id&#125;;</span><br><span class="line">UPDATE tb_product SET stock&#x3D;stock-#&#123;num&#125; WHERE product_id&#x3D;#&#123;product_id&#125; AND stock&#x3D;#&#123;stock&#125;;</span><br></pre></td></tr></table></figure>

<p>先把库存数量（stock）查出来，然后在更新的时候，检查一下是否是上次读出来的库存。如果不是，说明有别人更新过了，我的 UPDATE 操作就会失败，得重新再来。</p>
<p>细心的你一定发现了，这不就是计算机汇编指令中的原子操作 CAS（Compare And Swap）嘛，大量无锁的数据结构都需要用到这个。（关于 CAS 的话题，你可以看一下我在 CoolShell 上写的<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/8239.html">无锁队列的实现</a> ）。</p>
<p><strong>我们一步一步地从分布式锁服务到乐观锁，再到 CAS，你看到了什么？你是否得思考一个有趣的问题——我们还需要分布式锁服务吗？</strong></p>
<h1 id="分布式锁设计的重点"><a href="#分布式锁设计的重点" class="headerlink" title="分布式锁设计的重点"></a>分布式锁设计的重点</h1><p>最后，我们来谈谈分布式锁设计的重点。</p>
<p>一般情况下，我们可以使用数据库、Redis 或 ZooKeeper 来做分布式锁服务，这几种方式都可以用于实现分布式锁。</p>
<p>分布式锁的特点是，保证在一个集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。这就是所谓的分布式互斥。所以，大家在做某个事的时候，要去一个服务上去请求一个标识。如果请求到了，我们就可以操作，操作完后，把这个标识还回去，这样别的进程就可以请求到了。</p>
<p>首先，需要明确一下分布式锁服务的初衷和几个概念性的问题。</p>
<ul>
<li>如果获得锁的进程挂掉了怎么办？锁还不回来了，会导致死锁。一般的处理方法是在锁服务那边加上一个过期时间，如果在这个时间内锁没有被还回来，那么锁服务要自动解锁，以避免全部锁住。</li>
<li>如果锁服务自动解锁了，新的进程就拿到锁了，但之前的进程以为自己还有锁，那么就出现了两个进程拿到了同一个锁的问题，它们在更新数据的时候就会产生问题。对于这个问题，我想说：</li>
<li>像 Redis 那样也可以使用 Check and Set 的方式来保证数据的一致性。这就有点像计算机原子指令 CAS（Compare And Swap）一样。就是说，我在改变一个值的时候先检查一下是不是我之前读出来的值，这样来保证其间没有人改过。</li>
<li>如果通过像 CAS 这样的操作的话，我们还需要分布式锁服务吗？的确是不需要了，不是吗？</li>
<li>但现实生活中也有不需要更新某个数据的场景，只是为了同步或是互斥一下不同机器上的线程，这时候像 Redis 这样的分布式锁服务就有意义了。</li>
</ul>
<p>所以，需要分清楚：我是用来做修改某个共享源的，还是用来做不同进程间的同步或是互斥的。如果使用 CAS 这样的方式（无锁方式）来更新数据，那么我们是不需要使用分布式锁服务的，而后者可能是需要的。<strong>所以，这是我们在决定使用分布式锁服务前需要考虑的第一个问题——我们是否需要？</strong></p>
<p>如果确定要分布式锁服务，你需要考虑下面几个设计。</p>
<ul>
<li>需要给一个锁被释放的方式，以避免请求者不把锁还回来，导致死锁的问题。Redis 使用超时时间，ZooKeeper 可以依靠自身的 sessionTimeout 来删除节点。</li>
<li>分布式锁服务应该是高可用的，而且是需要持久化的。对此，你可以看一下 <a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">Redis 的文档 RedLock</a> 看看它是怎么做到高可用的。</li>
<li>要提供非阻塞方式的锁服务。</li>
<li>还要考虑锁的可重入性。</li>
</ul>
<p>我认为，Redis 也是不错的，ZooKeeper 在使用起来需要有一些变通的方式，好在 Apache 有 <a target="_blank" rel="noopener" href="https://curator.apache.org/">Curator</a> 帮我们封装了各种分布式锁的玩法。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>首先，介绍了为什么需要分布式锁。就像单机系统上的多线程程序需要用操作系统锁或数据库锁来互斥对共享资源的访问一样，分布式程序也需要通过分布式锁来互斥对共享资源的访问。</p>
<p>分布式锁服务一般可以通过 Redis 和 ZooKeeper 等实现。接着，以 Redis 为例，介绍了怎样用它来加锁和解锁，由此引出了锁超时后的潜在风险。类似于数据库的乐观并发控制，这种风险可以通过版本号的方式来解决。</p>
<p>进一步，数据库如果本身利用 CAS 等手段支持这种版本控制方式，其实也就没必要用一个独立的分布式锁服务了。最后，我们发现，分布式锁服务还能用来做同步，这是数据库锁做不了的事情。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-go语言和Docker"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/19/go%E8%AF%AD%E8%A8%80%E5%92%8CDocker/"
    >go语言和Docker</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/19/go%E8%AF%AD%E8%A8%80%E5%92%8CDocker/" class="article-date">
  <time datetime="2020-02-19T16:23:10.000Z" itemprop="datePublished">2020-02-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>上个月，作为 Go 语言的三位创始人之一，Unix 老牌黑客罗勃·派克（Rob Pike）在新文章“Go: Ten years and climbing”中，回顾了一下 Go 语言的发展过程。其中提到，Go 语言这十年的迅猛发展大到连他们自己都没有想到，并且还成为了云计算领域中新一代的开发语言。还提到了，中国程序员对 Go 语言的热爱完全超出了他们的想象，甚至他们都不敢相信是真的。</p>
<p>Docker 负责人也感叹：他们完全没有想到居然中国有那么多人喜欢 Docker，而且还有这么多人在为 Docker 做贡献，这让他们感到非常意外，中国是除了美国本土之外的另外一个如此喜欢 Docker 技术的国家，在其它国家都没有看到。</p>
<p>的确如他们所说，Go 语言和 Docker 这两种技术已经成为新一代的云计算技术，而且可以看到其发展态势非常迅猛。而中国也成为了像美国一样在强力推动这两种技术的国家。这的确是一件让人感到非常高兴的事，因为中国在跟随时代潮流这件事上已经做得非常不错了。</p>
<p>然而，从 2014-2015 年我在阿里推动 Docker 和 Go 语言的痛苦和失败过程中，以及这许多年来，有很多很多人问我是否要学 Go 语言，是否要学 Docker，Go 和 Docker 是否能用在生产线上，这些问题看来，对于 Go 语言和 Docker 这两种技术，在国内的技术圈中有相当大的一部分人和群体还在执观望或是不信任的态度。</p>
<p>这篇文章从两个方面来论述一下我的观点和看法。</p>
<ul>
<li>一个方面，为什么 Go 语言和 Docker 会是新一代的云计算技术。</li>
<li>另一个方面，作为技术人员，如何识别什么样的新技术会是未来的趋势。</li>
</ul>
<p>Go 语言是在 2009 年底开源的。go语言有以下特点。</p>
<p>第一，<strong>语言简单，上手快</strong>。Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。</p>
<p>第二，<strong>并行和异步编程几乎无痛点</strong>。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的我来说，完全就是让我眼前一亮的感觉。</p>
<p><img src="../images/8df5fd56cbb6343a9030265a5f3a565f.png" alt="img"><br>（图片来自 Medium：Why should you learn Go?）</p>
<p>第三，<strong>Go 语言的 lib 库麻雀虽小五脏俱全</strong>。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。</p>
<p>第四，<strong>C 语言的理念和 Python 的姿态</strong>。C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。</p>
<p><img src="../images/03ea333bf7b7bb2fe350c4f433047df7.png" alt="img"><br>（图片来自 Medium：Why should you learn Go?）</p>
<p>所以，即便 Go 语言存在诸多的问题，比如垃圾回收、异常处理、泛型编程等，但相较于上面这几个优势，我认为这些问题都是些小问题。于是就毫不犹豫地入坑了。</p>
<p>当然，一个技术能不能发展起来，关键还要看三点。</p>
<ul>
<li><strong>有没有一个比较好的社区</strong>。像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。</li>
<li><strong>有没有一个工业化的标准</strong>。像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。</li>
<li><strong>有没有一个或多个杀手级应用</strong>。C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。</li>
</ul>
<p>上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：</p>
<ul>
<li><strong>学习曲线是否低，上手是否快</strong>。这点非常重要，C++ 在这点上越做越不好了。</li>
<li><strong>有没有一个不错的提高开发效率的开发框架</strong>。如：Java 的 Spring 框架，C++ 的 STL 等。</li>
<li><strong>是否有一个或多个巨型的技术公司作为后盾</strong>。如：Java 和 Linux 后面的 IBM、Sun……</li>
<li><strong>有没有解决软件开发中的痛点</strong>。如：Java 解决了 C 和 C++ 的内存管理问题。</li>
</ul>
<p>用这些标尺来量一下 Go 语言，可以清楚地看到：</p>
<ul>
<li>Go 语言容易上手；</li>
<li>Go 语言解决了并发编程和写底层应用开发效率的痛点；</li>
<li>Go 语言有 Google 这个世界一流的技术公司在后面；</li>
<li>Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。</li>
</ul>
<p>所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。</p>
<p>也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是我的一个判断。</p>
<p>再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，会发现基本是一样的。</p>
<ul>
<li>Docker 上手很容易。</li>
<li>Docker 解决了运维中的环境问题以及服务调度的痛点。</li>
<li>Docker 的生态圈中有大公司在后面助力。比如 Google。</li>
<li>Docker 产出了工业界标准 OCI。</li>
<li>Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。</li>
<li>……</li>
</ul>
<p>所以，Docker 一定会是未来的技术。虽然坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。</p>
<p>同样，可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。</p>
<p>Docker 是云计算中 PaaS 的关键技术，虽然，这世上在出现 Docker 之前，几乎所有的要玩公有 PaaS 的公司和产品都玩不起来，比如：Google 的 GAE，国内的各种 XAE，如淘宝的 TAE，新浪的 SAE 等。<strong>PaaS 是一个被世界或是被产业界严重低估的平台</strong>。</p>
<p>PaaS 层是承上启下的关键技术，任何一个不重视 PaaS 的公司，其技术架构都不可能让这家公司成长为一个大型的公司。因为 PaaS 层的技术主要能解决下面这些问题。</p>
<ul>
<li><strong>软件生产线的问题</strong>。持续集成和持续发布，以及 DevOps 中的技术必需通过 PaaS。</li>
<li><strong>分布式服务化的问题</strong>。分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。</li>
<li><strong>提高服务的可用性 SLA</strong>。提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。</li>
<li><strong>软件能力的复用</strong>。软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。</li>
</ul>
<p>老实说，这些问题的关键程度已经到了能判断一家依托技术的公司的研发能力是否靠谱的程度。没有这些技术，依托技术拓展业务的公司几乎没有可能发展得规模很大。</p>
<p>最后，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。</p>
<ul>
<li><p><strong>技术的发展过程非常重要</strong>。</p>
</li>
<li><p><strong>这些关键新技术，可以让你拿到技术的先机</strong>。这些对一个需要技术领导力的个人或公司来说都是非常重要的。</p>
</li>
</ul>
<p>一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。</p>
<p>通讯行业、金融行业对于 PaaS 平台的理解已经超过了互联网公司。</p>
<p>所以，Go 语和 Docker 作为 PaaS 平台的关键技术前途是无限的，</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-微服务"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
    >微服务</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2020-02-18T15:34:22.000Z" itemprop="datePublished">2020-02-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>微服务是分布式系统中最近比较流行的架构模型，也是 SOA 架构的一个进化。微服务架构并不是银弹，所以，也不要寄希望于微服务构架能够解决所有的问题。微服务架构主要解决的是如何快速地开发和部署我们的服务，这对于一个能够适应快速开发和成长的公司是非常必要的。同时我也觉得，微服务中有很多很不错的想法和理念，所以学习微服务是每一个技术人员迈向卓越的架构师的必经之路。</p>
<p>首先，需要看一下，Martin Fowler 的这篇关于微服务架构的文档 - <a target="_blank" rel="noopener" href="http://martinfowler.com/articles/microservices.html">Microservice Architecture</a> （<a target="_blank" rel="noopener" href="https://blog.csdn.net/wurenhai/article/details/37659335">中译版</a>），这篇文章说明了微服务的架构与传统架构的不同之处在于，微服务的每个服务与其数据库都是独立的，可以无依赖地进行部署。你也可以看看 Martin Fowler 老人家现身说法的<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=wgdBVIX9ifA">视频</a>。</p>
<p>另外，你还可以简单地浏览一下，各家对微服务的理解。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://aws.amazon.com/microservices/">AWS 的理解 - What are Microservices?</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices">Microsoft 的理解 - Microservices architecture style</a>。</li>
<li><a target="_blank" rel="noopener" href="https://pivotal.io/microservices">Pivotal 的理解 - Microservices</a>。</li>
</ul>
<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p>接下来，可以看一下 <a target="_blank" rel="noopener" href="https://www.redbooks.ibm.com/redbooks/pdfs/sg248357.pdf">IBM 红皮书：Microservices Best Practices for Java</a> ，这本书非常好，不但有通过把 Spring Boot 和 Dropwizard 来架建 Java 的微服务，而且还谈到了一些标准的架构模型，如服务注册、服务发现、API 网关、服务通讯、数据处理、应用安全、测试、部署、运维等，是相当不错的一本书。</p>
<p>当然，有一本书也可以读一下—— <a target="_blank" rel="noopener" href="https://book.douban.com/subject/26772677/">微服务设计</a>。这本书全面介绍了微服务的建模、集成、测试、部署和监控，通过一个虚构的公司讲解了如何建立微服务架构。主要内容包括认识微服务在保证系统设计与组织目标统一上的重要性，学会把服务集成到已有系统中，采用递增手段拆分单块大型应用，通过持续集成部署微服务，等等。</p>
<p>与此相似的，也有其它的一系列文章，值得一读。</p>
<p>下面是 Nginx 上的一组微服务架构的系列文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/introduction-to-microservices/">Introduction to Microservices</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/">Building Microservices: Using an API Gateway</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/building-microservices-inter-process-communication/">Building Microservices: Inter-Process Communication in a Microservices Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/">Service Discovery in a Microservices Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/event-driven-data-management-microservices/">Event-Driven Data Management for Microservices</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/deploying-microservices/">Choosing a Microservices Deployment Strategy</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/">Refactoring a Monolith into Microservices</a></li>
</ul>
<p>下面这是 <a target="_blank" rel="noopener" href="https://auth0.com/blog/">Auto0 Blog</a> 上一系列的微服务的介绍，有代码演示。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://auth0.com/blog/an-introduction-to-microservices-part-1/">An Introduction to Microservices, Part 1</a></li>
<li><a target="_blank" rel="noopener" href="https://auth0.com/blog/an-introduction-to-microservices-part-2-API-gateway/">API Gateway. An Introduction to Microservices, Part 2</a></li>
<li><a target="_blank" rel="noopener" href="https://auth0.com/blog/an-introduction-to-microservices-part-3-the-service-registry/">An Introduction to Microservices, Part 3: The Service Registry</a></li>
<li><a target="_blank" rel="noopener" href="https://auth0.com/blog/introduction-to-microservices-part-4-dependencies/">Intro to Microservices, Part 4: Dependencies and Data Sharing</a></li>
<li><a target="_blank" rel="noopener" href="https://auth0.com/blog/apigateway-microservices-superglue/">API Gateway: the Microservices Superglue</a></li>
</ul>
<p>还有 Dzone 的这个 Spring boot 的教程。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/microservices-with-spring-boot-part-1-getting-star">Microservices With Spring Boot - Part 1 - Getting Started</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/microservices-with-spring-boot-part-2-creating-a-f">Microservices With Spring Boot - Part 2 - Creating a Forex Microservice</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/microservices-with-spring-boot-part-3-creating-cur">Microservices With Spring Boot - Part 3 - Creating Currency Conversion Microservice</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/microservices-with-spring-boot-part-4-using-ribbon">Microservices With Spring Boot - Part 4 - Using Ribbon for Load Balancing</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/microservices-with-spring-boot-part-5-using-eureka">Microservices With Spring Boot - Part 5 - Using Eureka Naming Server</a></li>
</ul>
<p>当然，如果你要玩得时髦一些的话，我推荐你使用下面的这套架构。</p>
<ul>
<li><strong>前端</strong>：<a target="_blank" rel="noopener" href="https://reactjs.org/">React.js</a> 或 <a target="_blank" rel="noopener" href="https://vuejs.org/">Vue.js</a>。</li>
<li><strong>后端</strong>：<a target="_blank" rel="noopener" href="https://golang.org/">Go 语言</a> + 微服务工具集 <a target="_blank" rel="noopener" href="https://gokit.io/">Go kit</a> ，因为是微服务了，所以，每个服务的代码就简单了。既然简单了，也就可以用任何语言了，所以，我推荐 Go 语言。</li>
<li><strong>通讯</strong>：<a target="_blank" rel="noopener" href="https://grpc.io/">gRPC</a>，这是 Google 远程调用的一个框架，它比 Restful 的调用要快 20 倍到 50 倍的样子。</li>
<li><strong>API</strong>：<a target="_blank" rel="noopener" href="https://swagger.io/">Swagger</a> ，Swagger 是一种 Restful API 的简单但强大的表示方式，标准的，语言无关，这种表示方式不但人可读，而且机器可读。可以作为 Restful API 的交互式文档，也可以作为 Restful API 形式化的接口描述，生成客户端和服务端的代码。今天，所有的 API 应该都通过 Swagger 来完成。</li>
<li><strong>网关</strong>：<a target="_blank" rel="noopener" href="https://envoyproxy.github.io/">Envoy</a> 其包含了服务发现、负载均衡和熔断等这些特性，也是一个很有潜力的网关。当然，Kubernetes 也是很好的，而且它也是高扩展的，所以，完全可以把 Envoy 通过 Ingress 集成进 Kubernetes。这里有一个开源项目就是干这个事的 - <a target="_blank" rel="noopener" href="https://github.com/heptio/contour">contour</a>。</li>
<li><strong>日志监控</strong>：<a target="_blank" rel="noopener" href="https://www.fluentd.org/">fluentd</a> + <a target="_blank" rel="noopener" href="https://www.elastic.co/webinars/introduction-elk-stack">ELK</a> 。</li>
<li><strong>指标监控</strong>：<a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus</a> 。</li>
<li><strong>调用跟踪</strong>：<a target="_blank" rel="noopener" href="http://jaeger.readthedocs.io/en/latest/">Jaeger</a> 或是 <a target="_blank" rel="noopener" href="http://zipkin.io/">Zipkin</a>，当然，后者比较传统一些，前者比较时髦，最重要的是，其可以和 Prometheus 和 Envory 集成。</li>
<li><strong>自动化运维</strong>：<a target="_blank" rel="noopener" href="https://docker.io/">Docker</a> + <a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a> 。</li>
</ul>
<h1 id="微服务和-SOA"><a href="#微服务和-SOA" class="headerlink" title="微服务和 SOA"></a>微服务和 SOA</h1><p>在对微服务有了一定的认识以后，一定有很多同学分不清楚微服务和 SOA 架构，对此，可以看一下这本电子书 - 《<a target="_blank" rel="noopener" href="https://www.nginx.com/resources/library/microservices-vs-soa/">Microservices vs. Service-Oriented Architecture</a>》。通过这本书，可以学到，服务化架构的一些事实，还有基础的 SOA 和微服务的架构知识，以及两种架构的不同。这本书的作者马克·理查兹（Mark Richards）同学拥有十年以上的 SOA 和微服务架构的设计和实现的经验。</p>
<p>另外，还有几篇其它对比 SOA 和微服务的文章你也可以看看。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/microservices-vs-soa-2">DZone: Microservices vs. SOA</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/microservices-vs-soa-is-there-any-difference-at-al">DZone: Microservices vs. SOA - Is There Any Difference at All?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/websphere/library/techarticles/1601_clark-trs/1601_clark.html">Microservices, SOA, and APIs: Friends or enemies?</a></li>
</ul>
<p>除此之外，我们还需要知道微服务和其它架构的一些不同和比较，这样我们就可以了解微服务架构的优缺点。下面几篇文章将帮助获得这些知识。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://blog.altoros.com/microservices-architectures-paas-vs-iaas-top-6-differences.html">PaaS vs. IaaS for Microservices Architectures: Top 6 Differences</a></li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/altoros/microservices-vs-monolithic-architectures-pros-and-cons">Microservices vs. Monolithic Architectures: Pros, Cons, and How Cloud Foundry (PaaS) Can Help</a></li>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">Microservices - Not A Free Lunch!</a></li>
<li><a target="_blank" rel="noopener" href="https://www.stackbuilders.com/news/the-hidden-costs-of-microservices">The Hidden Costs Of Microservices</a></li>
</ul>
<h1 id="设计模式和最佳实践"><a href="#设计模式和最佳实践" class="headerlink" title="设计模式和最佳实践"></a>设计模式和最佳实践</h1><p>然后，可以看一下微服务的一些设计模式。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://microservices.io/">Microservice Patterns</a>，微服务架构的设计模式和最佳实践。</li>
<li><a target="_blank" rel="noopener" href="https://www.oreilly.com/ideas/microservices-antipatterns-and-pitfalls">Microservice Antipatterns and Pitfalls</a>，微服务架构的一些已知的反模式和陷阱。</li>
<li><a target="_blank" rel="noopener" href="https://codingsans.com/blog/microservice-architecture-best-practices">Microservice Architecture: All The Best Practices You Need To Know</a>，这是一篇长文，里面讲述了什么是微服务、微服务架构的优缺点、微服务最大的挑战和解决方案是什么、如何避免出错，以及构建微服务架构的最佳实践等多方面的内容。推荐阅读。</li>
<li><a target="_blank" rel="noopener" href="https://www.vinaysahni.com/best-practices-for-building-a-microservice-architecture">Best Practices for Building a Microservice Architecture</a> ，这篇文章分享了构建微服务架构的最佳实践。</li>
<li><a target="_blank" rel="noopener" href="https://jobs.zalando.com/tech/blog/simplicity-by-distributing-complexity/">Simplicity by Distributing Complexity</a>，这是一篇讲如何使用事件驱动构建微服务架构的文章，其中有很多不错的设计上的基本原则。</li>
</ul>
<h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><ul>
<li><a target="_blank" rel="noopener" href="http://martinfowler.com/microservices/">Microservices Resource Guide</a> ，这个网页上是 Martin Fowler 为我们挑选的和微服务相关的文章、视频、书或是 podcast。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/mfornos/awesome-microservices/">Awesome Microservices</a> ，一个各种微服务资源和相关项目的集中地。</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>微服务中有很多很不错的想法和理念，所以学习微服务是每一个技术人员迈向卓越的架构师的必经之路。在这篇文章中，先给出了 AWS、Microsoft 和 Pivotal 对微服务的理解；然后给出了好几个系列的教程，帮你全面学习和理解微服务架构；然后通过一系列文章帮你来区分何为微服务，何为 SOA；最后给出了微服务架构的设计模式和最佳实践，以及相关资源。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-机器学习和人工智能"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"
    >机器学习和人工智能</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" class="article-date">
  <time datetime="2020-02-18T03:24:59.000Z" itemprop="datePublished">2020-02-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基本原理简介"><a href="#基本原理简介" class="headerlink" title="基本原理简介"></a>基本原理简介</h1><p>我们先来介绍一下机器学习的基本原理。</p>
<p>机器学习主要有两种方式，一种是监督式学习（Supervised Learning），另一种是非监督式学习（Unsupervised Learning）。下面简单地说一下这两者的不同。</p>
<ul>
<li><p><strong>监督式学习（Supervised Learning）</strong>。所谓监督式学习，也就是说，我们需要提供一组学习样本，包括相关的特征数据和相应的标签。我们的程序可以通过这组样本来学习相关的规律或是模式，然后通过得到的规律或模式来判断没有被打过标签的数据是什么样的数据。</p>
<p>举个例子，假设需要识别一些手写的数字，我们要找到尽可能多的手写体的数字的图像样本，然后人工或是通过某种算法来明确地标注上什么是这些手写体的图片，谁是 1，谁是 2，谁是 3…… 这组数据叫样本数据，又叫训练数据（training data）。然后通过机器学习的算法，找到每个数字在不同手写体下的特征，找到规律和模式。通过得到的规律或模式来识别那些没有被打过标签的手写数据，以此完成识别手写体数字的目的。</p>
</li>
<li><p><strong>非监督式学习（Unsupervised Learning）</strong>。对于非监督式学习，也就是说，数据是没有被标注过的，所以相关的机器学习算法需要找到这些数据中的共性。因为大量的数据是没被被标识过的，所以这种学习方式可以让大量的未标识的数据能够更有价值。而且，非监督式学习，可以为我们找到人类很难发现的数据里的规律或模型，所以也有人称这种学习为 “ 特征点学习 “，其可以让我们自动地为数据进行分类，并找到分类的模型。</p>
<p>一般来说，非监督式学习会应用在一些交易型的数据中。比如，你有一堆堆的用户购买数据，但是对于人类来说，我们很难找到用户属性和购买商品类型之间的关系。所以，非监督式学习算法可以帮助我们找到它们之间的关系。比如，一个在某个年龄段的女性购买了某种肥皂，有可能说明这个女性在怀孕期，或是某人购买儿童用品，有可能说明这个人的关系链中有孩子，等等。于是，这些信息会被用作一些所谓的精准市场营销活动，从而可以增加商品销量。</p>
</li>
</ul>
<p>监督式学习是在被告诉过了正确的答案后的学习，而非监督式学习是在没有被告诉正确答案时的学习。所以，非监督式学习是在大量的非常乱的数据中找寻一些潜在的关系，这个成本也比较高。非监督式学习经常被用来检测一些不正常的事情发生，比如信用卡的诈骗或是盗刷。也被用在推荐系统，比如买了这个商品的人又买了别的什么商品，或是如果某个人喜欢某篇文章、某个音乐、某个餐馆，那么他可能会喜欢某个车、某个明星或某个地方。</p>
<p>在监督式学习算法下，可以用一组 “ 狗 “ 的照片来确定某个照片中的物体是不是狗。而在非监督式学习算法下，我们可以通过一个照片来找到其中有与其相似的事物的照片。这两种学习方式都有些有用的场景。</p>
<p>关于机器学习，你可以读一读 <a target="_blank" rel="noopener" href="https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471">Machine Learning is Fun!</a> ，这篇文章（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24339995">中文翻译版</a>）恐怕是全世界最简单的入门资料了。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://becominghuman.ai/data-science-simplified-principles-and-process-b06304d63308">Data Science Simplified Part 1: Principles and Process</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-key-concepts-of-statistical-learning-45648049709e">Data Science Simplified Part 2: Key Concepts of Statistical Learning</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-hypothesis-testing-56e180ef2f71">Data Science Simplified Part 3: Hypothesis Testing</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-simple-linear-regression-models-3a97811a6a3d">Data Science Simplified Part 4: Simple Linear Regression Models</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-part-5-multivariate-regression-models-7684b0489015">Data Science Simplified Part 5: Multivariate Regression Models</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-part-6-model-selection-methods-2511cbdf7cb0">Data Science Simplified Part 6: Model Selection Methods</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-part-7-log-log-regression-models-499ecd1495f0">Data Science Simplified Part 7: Log-Log Regression Models</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-part-8-qualitative-variables-in-regression-models-d1817d56245c">Data Science Simplified Part 8: Qualitative Variables in Regression Models</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-part-9-interactions-and-limitations-of-regression-models-4702dff03820">Data Science Simplified Part 9: Interactions and Limitations of Regression Models</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-part-10-an-introduction-to-classification-models-82490f6c171f">Data Science Simplified Part 10: An Introduction to Classification Models</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/data-science-simplified-part-11-logistic-regression-5ae8d994bf0e">Data Science Simplified Part 11: Logistic Regression</a></li>
</ul>
<h1 id="相关课程"><a href="#相关课程" class="headerlink" title="相关课程"></a>相关课程</h1><p>在学习机器学习之前，我们需要学习数据分析，所以，我们得先学一些大数据相关的东西，也就是 Data Science 相关的内容。下面是两个不错的和数据科学相关的教程以及一个资源列表。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://data8.org/">UC Berkeley’s Data 8: The Foundations of Data Science</a> 和电子书 <a target="_blank" rel="noopener" href="https://www.inferentialthinking.com/">Computational and Inferential Thinking</a> 会讲述数据科学方面非常关键的概念，会教会你在数据中找到数据的关联、预测和相关的推断。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/nborwankar/LearnDataScience">Learn Data Science</a> ，这是 GitHub 上的一本电子书，主要是一些数据挖掘的算法，比如线性回归、逻辑回归、随机森林、K-Means 聚类的数据分析。然后，<a target="_blank" rel="noopener" href="https://github.com/donnemartin/data-science-ipython-notebooks#scikit-learn">donnemartin/data-science-ipython-notebooks</a> 这个代码仓库中用 TensorFlow、scikit-learn、Pandas、NumPy、Spark 等把这些经典的例子实现了个遍。</li>
<li><a target="_blank" rel="noopener" href="https://www.datascienceweekly.org/data-science-resources/the-big-list-of-data-science-resources">Data Science Resources List</a> ，这个网站上有一个非常长的和数据科学相关的资源列表，你可以从中得到很多你想要的东西。</li>
</ul>
<p>之后，有下面几门不错的在线机器学习的课程供你入门，也是非常不错。</p>
<ul>
<li>吴恩达教授（Andrew Ng）在 <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/machine-learning">Coursera 上的免费机器学习课程</a> 非常棒。我强烈建议从此入手。对于任何拥有计算机或科学学位的人，或是还能记住一点点数学知识的人来说，都应该非常容易入门。这个斯坦福大学的课程请尽量拿满分。可以在 <a target="_blank" rel="noopener" href="http://open.163.com/special/opencourse/machinelearning.html">网易公开课</a> 中找到这一课程。除此之外，吴恩达教授还有一组新的和深度学习相关的课程，现在可以在网易公开课上免费学习——<a target="_blank" rel="noopener" href="https://mooc.study.163.com/smartSpec/detail/1001319001.htm">Deep Learning Specialization</a>。</li>
<li><a target="_blank" rel="noopener" href="https://www.udacity.com/course/deep-learning--ud730">Deep Learning by Google</a> ，Google 的一个关于深度学习的在线免费课程，其支持中英文。这门课会教授你如何训练和优化基本神经网络、卷积神经网络和长短期记忆网络。你将通过项目和任务接触完整的机器学习系统 TensorFlow。</li>
<li>卡内基梅隆大学汤姆·米切尔（Tom Mitchell）的机器学习 <a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~tom/10701_sp11/lectures.shtml">英文原版视频与课件 PDF</a> 。</li>
<li>2013 年加利福尼亚理工学院亚瑟·阿布 - 穆斯塔法（Yaser Abu-Mostafa）的 Learning from Data <a target="_blank" rel="noopener" href="http://work.caltech.edu/lectures.html">课程视频及课件 PDF</a>，内容更适合进阶。</li>
<li>关于神经网络方面，YouTube 上有一个非常火的课程视频，由宾夕法尼亚大学的雨果·拉罗歇尔（Hugo Larochelle）的教学课程 - <a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PL6Xpj9I5qXYEcOhn7TqghAJ6NAPrNmUBH">Neural networks class - Université de Sherbrooke </a>。</li>
</ul>
<p>除此之外，还有很多的在线大学课程可以学习。比如：</p>
<ul>
<li>斯坦福大学的《<a target="_blank" rel="noopener" href="https://lagunita.stanford.edu/courses/HumanitiesandScience/StatLearning/Winter2015/about">统计学学习</a>》、《<a target="_blank" rel="noopener" href="http://cs229.stanford.edu/">机器学习</a>》、《<a target="_blank" rel="noopener" href="http://cs231n.stanford.edu/">卷积神经网络</a>》、《<a target="_blank" rel="noopener" href="http://cs224d.stanford.edu/">深度学习之自然语言处理</a>》等。</li>
<li>麻省理工大学的《<a target="_blank" rel="noopener" href="http://ocw.mit.edu/courses/brain-and-cognitive-sciences/9-641j-introduction-to-neural-networks-spring-2005/index.htm">神经网络介绍</a> 》、《<a target="_blank" rel="noopener" href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-867-machine-learning-fall-2006/">机器学习</a>》、《<a target="_blank" rel="noopener" href="http://ocw.mit.edu/courses/sloan-school-of-management/15-097-prediction-machine-learning-and-statistics-spring-2012/index.htm">预测</a>》等。</li>
</ul>
<p>更多的列表，请参看——<a target="_blank" rel="noopener" href="https://github.com/RatulGhosh/awesome-machine-learning">Awesome Machine Learning Courses</a>。</p>
<h1 id="相关图书"><a href="#相关图书" class="headerlink" title="相关图书"></a>相关图书</h1><ul>
<li><p>《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/2061116/">Pattern Recognition and Machine Learning</a>》，这本书是机器学习领域的圣经之作。该书也是众多高校机器学习研究生课程的教科书，Google 上有[PDF 版的下载](<a target="_blank" rel="noopener" href="http://users.isr.ist.utl.pt/~wurmd/Livros/school/Bishop">http://users.isr.ist.utl.pt/~wurmd/Livros/school/Bishop</a> - Pattern Recognition And Machine Learning - Springer  2006.pdf)。这本书很经典，但并不适合入门来看。GitHub 上有这本中的 <a target="_blank" rel="noopener" href="https://github.com/PRML/PRMLT">Matlab 实现</a>。</p>
</li>
<li><p>下面这两本电子书也是比较经典的，其中讲了很多机器学习的知识，可以当做手册或字典。</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/understanding-machine-learning-theory-algorithms.pdf">Understanding Machine Learning: From Theory to Algorithms</a>》。</li>
<li>《<a target="_blank" rel="noopener" href="https://web.stanford.edu/~hastie/Papers/ESLII.pdf">The Elements of Statistical Learning - Second Edition</a>》。</li>
</ul>
</li>
<li><p>《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/27087503/">Deep Learning: Adaptive Computation and Machine Learning series</a>》 中文翻译为《深度学习》，又叫 “ 花书 “。这本书由全球知名的三位专家伊恩·古德费洛（Ian Goodfellow）、友华·本吉奥（Yoshua Bengio）和亚伦·考维尔（Aaron Courville）撰写，是深度学习领域奠基性的经典教材。</p>
<p>全书内容包括 3 部分：第 1 部分介绍基本的数学工具和机器学习的概念，它们是深度学习的预备知识；第 2 部分系统深入地讲解现今已成熟的深度学习方法和技术；第 3 部分讨论某些具有前瞻性的方向和想法，它们被公认为是深度学习未来的研究重点。这本书的官网为 “<a target="_blank" rel="noopener" href="http://www.deeplearningbook.org/">deeplearningbook.org</a>”，在 GitHub 上也有中文翻译 - 《<a target="_blank" rel="noopener" href="https://github.com/exacity/deeplearningbook-chinese">Deep Learning 中文翻译</a>》。</p>
</li>
<li><p>《<a target="_blank" rel="noopener" href="http://neuralnetworksanddeeplearning.com/">Neural Networks and Deep Learning</a>》（<a target="_blank" rel="noopener" href="https://tigerneil.gitbooks.io/neural-networks-and-deep-learning-zh/content/">中文翻译版</a>），这是一本非常不错的神经网络的入门书，在<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26727997/">豆瓣上评分 9.5 分</a>，从理论讲到了代码。虽然有很多数学公式，但是有代码相助，就不难理解了。其中讲了很多如激活函数、代价函数、随机梯度下降、反向传播、过度拟合和规范化、权重初始化、超参数优化、卷积网络的局部感受野、混合层、特征映射的东西。</p>
</li>
<li><p>《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26279609/">Introduction to Machine Learning with Python</a>》，算是本不错的入门书，也是本比较易读的英文书。其是以 Scikit-Learn 框架来讲述的。如果你用过 Scikit 这个框架，那么你学这本书还是很不错的。</p>
</li>
<li><p>《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26840215/">Hands-On Machine Learning with Scikit-Learn and TensorFlow</a> 》，这是一门以 TensorFlow 为工具的入门书，其用丰富的例子从实站的角度来让你学习。这本书对于无基础的人也是适合的，对于小白来说虽然略难但是受益匪浅。</p>
</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p>除了上述的那些课程和图书外，下面这些文章也很不错。</p>
<ul>
<li>YouTube 上的 Google Developers 的 <a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal">Machine Learning Recipes with Josh Gordon</a> ，这 9 集视频，每集不到 10 分钟，从 Hello World 讲到如何使用 TensorFlow，非常值得一看。</li>
<li>还有 <a target="_blank" rel="noopener" href="https://pythonprogramming.net/machine-learning-tutorial-python-introduction/">Practical Machine Learning Tutorial with Python Introduction</a> 上面一系列的用 Python 带着你玩 Machine Learning 的教程。</li>
<li>Medium 上的 <a target="_blank" rel="noopener" href="https://medium.com/machine-learning-101">Machine Learning - 101</a> ，讲述了好些我们上面提到过的经典算法。</li>
<li>Medium 上的 <a target="_blank" rel="noopener" href="https://medium.com/machine-learning-for-humans">Marchine Learning for Humans</a>。</li>
<li><a target="_blank" rel="noopener" href="https://machinelearningmastery.com/blog/">Dr. Jason Brownlee 的博客</a> ，也非常值得一读，其中好多的 “How-To”，会让你有很多的收获。</li>
<li><a target="_blank" rel="noopener" href="http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf">Rules of Machine Learning: Best Practices for ML Engineering</a> ，一些机器学习相关的最佳实践。</li>
<li><a target="_blank" rel="noopener" href="http://iamtrask.github.io">i am trask</a> ，也是一个很不错的博客。</li>
<li>关于 Deep Learning 中的神经网络，YouTube 上有介绍视频 <a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi">Neural Networks</a>。</li>
<li>麻省理工学院的电子书 <a target="_blank" rel="noopener" href="http://www.deeplearningbook.org">Deep Learning</a>。</li>
<li>用 Python 做自然语言处理<a target="_blank" rel="noopener" href="http://www.nltk.org/book/">Natural Language Processing with Python</a>。</li>
<li>最后一个是 Machine Learning 和 Deep Learning 的相关教程列表，<a target="_blank" rel="noopener" href="https://github.com/ujjwalkarn/Machine-Learning-Tutorials">Machine Learning &amp; Deep Learning Tutorials</a>。</li>
</ul>
<p>下面是一些和神经网络相关的不错的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">The Unreasonable Effectiveness of Recurrent Neural Networks</a> ，这是一篇必读的文章 ，告诉你为什么要学 RNN，以及展示了最简单的 NLP 形式。</li>
<li><a target="_blank" rel="noopener" href="http://colah.github.io/posts/2014-03-NN-Manifolds-Topology/">Neural Networks, Manifolds, and Topology</a> ，这篇文章可以帮助你理解神经网络的一些概念。</li>
<li><a target="_blank" rel="noopener" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a> ，解释了什么是 LSTM 的内在工作原理。</li>
<li><a target="_blank" rel="noopener" href="http://distill.pub/2016/augmented-rnns/">Attention and Augmented Recurrent Neural Networks</a> ，用了好多图来说明了 RNN 的 attention 机制。</li>
<li><a target="_blank" rel="noopener" href="http://benanne.github.io/2014/08/05/spotify-cnns.html">Recommending music on Spotify with deep learning</a> ，一个在 Spotify 的实习生分享的音乐聚类的文章。</li>
</ul>
<h1 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h1><p>下面是 10 个非常经典的机器学习的算法。</p>
<ul>
<li>对于监督式学习，有如下经典算法。<ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Decision_tree">决策树（Decision Tree）</a>，比如自动化放贷、风控。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier">朴素贝叶斯分类器（Naive Bayesian classifier)</a>，可以用于判断垃圾邮件、对新闻的类别进行分类，比如科技、政治、运动、判断文本表达的感情是积极的还是消极的、人脸识别等。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ordinary_least_squares">最小二乘法（Ordinary Least Squares Regression）</a>，是一种线性回归。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Logistic_regression">逻辑回归（Logisitic Regression）</a>，一种强大的统计学方法，可以用一个或多个变量来表示一个二项式结果。可以用于信用评分，计算营销活动的成功率，预测某个产品的收入。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Support_vector_machine">支持向量机（Support Vector Machine，SVM）</a>，可以用于基于图像的性别检测、图像分类等。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ensemble_learning">集成方法（Ensemble methods）</a>，通过构建一组分类器，然后通过它们的预测结果进行加权投票来对新的数据点进行分类。原始的集成方法是贝叶斯平均，但最近的算法包括纠错输出编码、Bagging 和 Boosting。</li>
</ol>
</li>
<li>对于无监督式的学习，有如下经典算法。<ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cluster_analysis">聚类算法（Clustering Algorithms）</a>。聚类算法有很多，目标是给数据分类。有 5 个比较著名的聚类算法你必需要知道：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/K-means_clustering">K-Means</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mean_shift">Mean-Shift</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DBSCAN">DBSCAN</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Expectation–maximization_algorithm">EM/GMM</a>、和 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hierarchical_clustering">Agglomerative Hierarchical</a>。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Principal_component_analysis">主成分分析（Principal Component Analysis，PCA）</a>。PCA 的一些应用包括压缩、简化数据便于学习、可视化等。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Singular-value_decomposition">奇异值分解（Singular Value Decomposition，SVD）</a>。实际上，PCA 是 SVD 的一个简单应用。在计算机视觉中，第一个人脸识别算法使用 PCA 和 SVD 来将面部表示为 “ 特征面 “ 的线性组合，进行降维，然后通过简单的方法将面部匹配到身份。虽然现代方法更复杂，但很多方面仍然依赖于类似的技术。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Independent_component_analysis">独立成分分析（Independent Component Analysis，ICA）</a>。ICA 是一种统计技术，主要用于揭示随机变量、测量值或信号集中的隐藏因素。</li>
</ol>
</li>
</ul>
<p>如果你想了解更全的机器学习的算法列表，你可以看一下 Wikipedia 上的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Outline_of_machine_learning#Machine_learning_algorithms">List of Machine Learning Algorithms</a>。</p>
<p>在 <a target="_blank" rel="noopener" href="https://machinelearningmastery.com/a-tour-of-machine-learning-algorithms/">A Tour of Machine Learning Algorithms</a> ，这篇文章带你概览了一些机器学习算法，其中还有一个 “ 脑图 “ 可以下载，并还有一些 How-To 的文章供你参考。</p>
<p>对于这些算法，<a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/">SciKit-Learn</a>有一些文档供你学习。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/supervised_learning.html#supervised-learning">1. Supervised learning</a></li>
<li><a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/modules/clustering.html#clustering">2.3 Clustering</a></li>
<li><a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/modules/decomposition.html#decompositions">2.5. Decomposing signals in components (matrix factorization problems)</a></li>
<li><a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/model_selection.html#model-selection">3. Model selection and evaluation</a></li>
<li><a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing">4.3. Preprocessing data</a></li>
</ul>
<h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><ul>
<li>对于初学者来说，动手是非常非常重要的，不然，你会在理论的知识里迷失掉自己，这里有篇文章 “<a target="_blank" rel="noopener" href="https://elitedatascience.com/machine-learning-projects-for-beginners">8 Fun Machine Learning Projects for Beginners</a>“，其中为初学者准备了 8 个很有趣的项目，你可以跟着练练。</li>
<li>学习机器学习或是人工智能你需要数据，这里有一个非常足的列表给你足够多的公共数据 – 《<a target="_blank" rel="noopener" href="https://github.com/awesomedata/awesome-public-datasets">Awesome Public Datasets</a>》，其中包括农业、生物、天气、计算机网络、地球科学、经济、教育、金融、能源、政府、健康、自然语言、体育等。</li>
<li>GitHub 上的一些 Awesome 资源列表。<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ChristosChristofidis/awesome-deep-learning">Awesome Deep Learning</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/terryum/awesome-deep-learning-papers">Awesome - Most Cited Deep Learning Papers</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/endymecy/awesome-deeplearning-resources">Awesome Deep learning papers and other resources</a></li>
</ul>
</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总结一下今天的内容。首先介绍了机器学习的基本原理：监督式学习和非监督式学习，然后给出了全世界最简单的入门资料 <a target="_blank" rel="noopener" href="https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471">Machine Learning is Fun!</a>。随后给出了与机器学习密切相关的数据分析方面的内容和资料，然后推荐了深入学习机器学习知识的在线课程、图书和文章等，尤其列举了神经网络方面的学习资料。最后描述了机器学习的十大经典算法及相关的学习资料。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-容器化和自动化运维"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/16/%E5%AE%B9%E5%99%A8%E5%8C%96%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"
    >容器化和自动化运维</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/16/%E5%AE%B9%E5%99%A8%E5%8C%96%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/" class="article-date">
  <time datetime="2020-02-17T02:34:27.000Z" itemprop="datePublished">2020-02-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>这篇文章重点学习 Docker 和 Kubernetes，它们已经是分布式架构和自动化运维的必需品了，也是你必需要学习的。对于这两个东西，你千万不要害怕，因为技术方面都不算复杂，只是它们的玩法和传统运维不一样，所以你不用担心，只要你花上一点时间，一定会学好的。</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul>
<li>你可以先看一下 Docker 的官方介绍 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/docker-overview/">Docker Overview</a> 。</li>
<li>然后再去一个 Web 在线的 Playground 上体验一下， <a target="_blank" rel="noopener" href="https://www.katacoda.com/courses/docker/playground">Katacoda Docker Playground</a> 或者是 <a target="_blank" rel="noopener" href="https://training.play-with-docker.com/">Play With Docker</a> 。</li>
<li>接下来，跟着 <a target="_blank" rel="noopener" href="https://github.com/dwyl/learn-docker">Learn Docker</a> 这个文档中的教程自己安装一个 Docker 的环境，实操一把。</li>
<li>然后跟着 <a target="_blank" rel="noopener" href="https://docker-curriculum.com/">Docker Curriculum</a> 这个超详细的教程玩一下 Docker。</li>
</ul>
<p>有了上述的一些感性体会之后，你就可以阅读 Docker 官方文档 <a target="_blank" rel="noopener" href="https://docs.docker.com/">Docker Documentation</a> 了，这是学习 Docker 最好的方式。</p>
<p>如果你想了解一下 Docker 的底层技术细节，你可以参看我的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17010.html">Docker 基础技术：Linux Namespace（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17029.html">Docker 基础技术：Linux Namespace（下）</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17049.html">Docker 基础技术：Cgroup</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17061.html">Docker 基础技术：AUFS</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17200.html">Docker 基础技术：DeviceMapper</a></li>
</ul>
<p>还有一些不错的与 Docker 网络有关的文章需要阅读及实践一下。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://jvns.ca/blog/2016/12/22/container-networking/">A container networking overview</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/docker-networking-101-user-defined-networks/">Docker networking 101 - User defined networks</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/understanding-cni-container-networking-interface/">Understanding CNI (Container Networking Interface)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/using-cni-docker/">Using CNI with Docker</a></li>
</ul>
<p>Docker 有下面几种网络解决方案：<a target="_blank" rel="noopener" href="https://www.projectcalico.org/getting-started/docker/">Calico</a> 、<a target="_blank" rel="noopener" href="https://github.com/coreos/flannel/">Flannel</a> 和 <a target="_blank" rel="noopener" href="https://github.com/weaveworks/weave">Weave</a> ，你需要学习一下。另外，还需要学习一下 <a target="_blank" rel="noopener" href="https://github.com/nicolaka/netshoot">netshoot</a> 。这是一个很不错的用来诊断 Docker 网络问题的工具集。</p>
<p>关于这几个容器网络解决方案的性能对比，你可以看一下下面这几篇文章或报告。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://chunqi.li/2015/11/15/Battlefield-Calico-Flannel-Weave-and-Docker-Overlay-Network/">Battlefield: Calico, Flannel, Weave and Docker Overlay Network</a></li>
<li><a target="_blank" rel="noopener" href="http://machinezone.github.io/research/networking-solutions-for-kubernetes/">Comparison of Networking Solutions for Kubernetes</a></li>
<li><a target="_blank" rel="noopener" href="http://www.delaat.net/rp/2015-2016/p50/report.pdf">Docker Overlay Networks: Performance analysis in high-latency enviroments</a></li>
</ul>
<p>如果你对 Docker 的性能有什么问题的话，你可以看一下下面这些文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/$File/rc25482.pdf">IBM Research Report: An Updated Performance Comparison of Virtual Machines and Linux Containers</a></li>
<li><a target="_blank" rel="noopener" href="http://paper.ijcsns.org/07_book/201703/20170327.pdf">An Introduction to Docker and Analysis of its Performance</a></li>
</ul>
<p>下面是一些和存储相关的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://cloud-mechanic.blogspot.de/2014/10/storage-concepts-in-docker-network-and.html">Storage Concepts in Docker: Network and Cloud Storage</a></li>
<li><a target="_blank" rel="noopener" href="http://cloud-mechanic.blogspot.de/2014/10/storage-concepts-in-docker-persistent.html">Storage Concepts in Docker: Persistent Storage</a></li>
<li><a target="_blank" rel="noopener" href="http://cloud-mechanic.blogspot.de/2014/10/storage-concepts-in-docker.html">Storage Concepts in Docker: Shared Storage and the VOLUME directive</a></li>
</ul>
<p>然后是跟运维相关的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://logz.io/learn/docker-monitoring-elk-stack/">Docker Monitoring with the ELK Stack: A Step-by-Step Guide</a></li>
</ul>
<p>最后，推荐看看 <a target="_blank" rel="noopener" href="http://www.nkode.io/2014/08/24/valuable-docker-links.html">Valuable Docker Links</a> ，其中收集并罗列了一系列非常不错的 Docker 文章。</p>
<p><strong>最佳实践</strong></p>
<p>下面分享一些与 Docker 相关的最佳实践。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best Practices for Dockerfile</a> ，Docker 官方文档里的 Dockerfile 的最佳实践。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FuriKuri/docker-best-practices">Docker Best Practices</a> ，这里收集汇总了存在于各个地方的使用 Docker 的建议和实践。</li>
<li><a target="_blank" rel="noopener" href="http://docs.projectatomic.io/container-best-practices/">Container Best Practices</a> ，来自 Atomic 项目，是一个介绍容器化应用程序的架构、创建和管理的协作型文档项目。</li>
<li><a target="_blank" rel="noopener" href="http://hokstad.com/docker/patterns">Eight Docker Development Patterns</a> ，八个 Docker 的开发模式：共享基础容器、共享同一个卷的多个开发容器、开发工具专用容器、测试环境容器、编译构建容器、防手误的安装容器、默认服务容器、胶黏容器。</li>
</ul>
<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p>Kubernetes 是 Google 开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，也是 CNCF 最重要的项目之一，主要功能包括：</p>
<ul>
<li>基于容器的应用部署、维护和滚动升级；</li>
<li>负载均衡和服务发现；</li>
<li>跨机器和跨地区的集群调度；</li>
<li>自动伸缩；</li>
<li>无状态服务和有状态服务；</li>
<li>广泛的 Volume 支持；</li>
<li>插件机制保证扩展性。</li>
</ul>
<p>Kubernetes 发展非常迅速，已经成为容器编排领域的领导者。</p>
<p>首先，阅读 Kubernetes 前世今生的一篇论文。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/44843.pdf">Borg, Omega, and Kubernetes</a> ，看看 Google 这十几年来从这三个容器管理系统中得到的经验教训。</li>
</ul>
<p>学习 kubernetes，有两个免费的开源电子书。</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://jimmysong.io/kubernetes-handbook/">Kubernetes Handbook</a>》，这本书记录了作者从零开始学习和使用 Kubernetes 的心路历程，着重于经验分享和总结，同时也会有相关的概念解析。希望能够帮助你少踩坑，少走弯路，还会指引你关注 kubernetes 生态周边，如微服务构建、DevOps、大数据应用、Service Mesh、Cloud Native 等领域。</li>
<li>《<a target="_blank" rel="noopener" href="https://kubernetes.feisky.xyz/zh/">Kubernetes 指南</a>》，这本书旨在整理平时在开发和使用 Kubernetes 时的参考指南和实践总结，形成一个系统化的参考指南以方便查阅。</li>
</ul>
<p>这两本电子书都不错，前者更像是一本学习教程，而且面明显广一些，还包括 Cloud Natvie、Service Mesh 以及微服务相关的东西。而后者聚焦于 Kubernetes 本身，更像一本参考书。</p>
<p>但是也别忘了 Kubernetes 的官方网站：<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes.io</a>，上面不但有<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/home/">全面的文档</a> ，也包括一个很不错的 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">官方教程</a> 。</p>
<p>此外，还有一些交互式教程，帮助你理解掌握，以及一些很不错的文章推荐你阅读。</p>
<p><strong>一些交互式教程</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.katacoda.com/courses/kubernetes">Katacoda</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetesbootcamp.github.io/kubernetes-bootcamp/">Kubernetes Bootcamp</a></li>
</ul>
<p><strong>一些文章</strong></p>
<p>这里还有一些不错的文档，你应该去读一下。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://opsnotice.xyz/kubernetes-tips-tricks/">Kubernetes tips &amp; tricks</a></li>
<li><a target="_blank" rel="noopener" href="http://theremotelab.com/blog/achieving-ci-cd-with-k8s/">Achieving CI/CD with Kubernetes</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/how-to-setup-scalable-jenkins-on-top-of-a-kubernet">How to Set Up Scalable Jenkins on Top of a Kubernetes Cluster</a></li>
<li>10 Most Common Reasons Kubernetes Deployments Fail <a target="_blank" rel="noopener" href="https://kukulinski.com/10-most-common-reasons-kubernetes-deployments-fail-part-1/">Part I</a> 和 <a target="_blank" rel="noopener" href="https://kukulinski.com/10-most-common-reasons-kubernetes-deployments-fail-part-2/">Part II</a></li>
<li><a target="_blank" rel="noopener" href="http://sysdig.com/blog/monitoring-kubernetes-with-sysdig-cloud/">How to Monitor Kubernetes</a> ，一共有 4 个篇章</li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/logging-in-kubernetes-with-fluentd-and-elasticsearch/">Logging in Kubernetes with Fluentd and Elasticsearch</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/kubernetes-monitoring-best-practices-methods-and-e">Kubernetes Monitoring: Best Practices, Methods, and Existing Solutions</a></li>
</ul>
<p><strong>网络相关的文章</strong></p>
<p>要学习 Kubernetes，你只需要读一下，下面这个 Kubernetes 101 系列的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/kubernetes-101-networking/">Kubernetes 101 - Networking</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/kubernetes-networking-101-pods/">Kubernetes networking 101 - Pods</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/kubernetes-networking-101-services/">Kubernetes networking 101 - Services</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/kubernetes-networking-101-basic-external-access-into-the-cluster/">Kubernetes networking 101 - (Basic) External access into the cluster</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/kubernetes-networking-101-ingress-resources/">Kubernetes Networking 101 - Ingress resources</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dasblinkenlichten.com/getting-started-with-calico-on-kubernetes/">Getting started with Calico on Kubernetes</a></li>
</ul>
<p><strong>CI/CD 相关的文章</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/solutions/automated-build-images-with-jenkins-kubernetes#kubernetes_architecture">Automated Image Builds with Jenkins, Packer, and Kubernetes</a></li>
<li><a target="_blank" rel="noopener" href="http://iocanel.blogspot.in/2015/09/jenkins-setups-for-kubernetes-and.html">Jenkins setups for Kubernetes and Docker Workflow</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes">Lab: Build a Continuous Deployment Pipeline with Jenkins and Kubernetes</a></li>
</ul>
<p><strong>最佳实践</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@sachin.arote1/kubernetes-best-practices-9b1435a4cb53">Kubernetes Best Practices</a> by <a target="_blank" rel="noopener" href="https://medium.com/@sachin.arote1?source=post_header_lockup">Sachin Arote</a> ，AWS 工程师总结的最佳实践。</li>
<li><a target="_blank" rel="noopener" href="https://speakerdeck.com/thesandlord/kubernetes-best-practices">Kubernetes Best Practices</a> by <a target="_blank" rel="noopener" href="https://github.com/thesandlord">Sandeep Dinesh</a> ，Google 云平台工程师总结的最佳实践。</li>
</ul>
<p><strong>Docker 和 Kubernetes 资源汇总</strong></p>
<p>下面是 Github 上和 Docker &amp; Kubernetes 相关的 Awesome 系列。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/veggiemonk/awesome-docker">Awesome Docker</a>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/ramitsurana/awesome-kubernetes">Awesome Kubernetes</a>。</li>
</ul>
<p>虽然上面的这些系列非常全的罗列了很多资源，但是我觉得很不系统。对于系统的说明 Docker 和 Kubernetes 生态圈，我非常推荐大家看一下 The New Stack 为 Kubernetes 出的一系列的电子书或报告。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://thenewstack.io/ebookseries/">The New Stack eBook Series</a> ，非常完整和详实的 Docker 和 Kubernetes 生态圈的所有东西。<ul>
<li>Book 01: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/docker-and-containers/the-docker-container-ecosystem/">The Docker Container Ecosystem</a></li>
<li>Book 02: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/docker-and-containers/applications-microservices-docker-containers/">Applications &amp; Microservices with Docker &amp; Containers</a></li>
<li>Book 03: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/docker-and-containers/automation-orchestration-docker-containers/">Automation &amp; Orchestration with Docker &amp; Containers</a></li>
<li>Book 04: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/docker-and-containers/networking-security-storage-docker-containers/">Network, Security &amp; Storage with Docker &amp; Containers</a></li>
<li>Book 05: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/docker-and-containers/monitoring-management-docker-containers/">Monitoring &amp; Management with Docker &amp; Containers</a></li>
<li>Book 06: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/use-cases/use-cases-for-kubernetes/">Use Cases for Kubernetes</a></li>
<li>Book 07: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/kubernetes/state-of-kubernetes-ecosystem/">State of the Kubernetes Ecosystem</a></li>
<li>Book 08: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/kubernetes/kubernetes-deployment-and-security-patterns/">Kubernetes Deployment &amp; Security Patterns</a></li>
<li>Book 09: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/kubernetes/ci-cd-with-kubernetes/">CI/CD with Kubernetes</a></li>
<li>Book 10: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/kubernetes/kubernetes-solutions-directory/">Kubernetes solutions Directory</a></li>
<li>Book 11: <a target="_blank" rel="noopener" href="https://thenewstack.io/ebooks/microservices/cloud-native-microservices-2018/">Guid to Cloud-Native Microservices</a></li>
</ul>
</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总结一下今天的内容。Docker 和 Kubernetes 已经成为分布式架构和自动化运维方面的不可或缺的两大基本构成，是必需要学习的。虽然它们的玩法跟传统运维不一样，但技术方面并不算复杂，只要你花上一点时间，一定会学好的。</p>
<p>文章包括Docker 和 Kubernetes 基础技术方面的学习资料，并给出了存储、运维、网络、CI/CD 等多方面的资料，同时列出了与之相关的最佳实践。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kubernate/" rel="tag">Kubernate</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何超过大多数人"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/15/%E5%A6%82%E4%BD%95%E8%B6%85%E8%BF%87%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA/"
    >如何超过大多数人</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/15/%E5%A6%82%E4%BD%95%E8%B6%85%E8%BF%87%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA/" class="article-date">
  <time datetime="2020-02-15T14:38:10.000Z" itemprop="datePublished">2020-02-15</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="相关技巧和最佳实践"><a href="#相关技巧和最佳实践" class="headerlink" title="相关技巧和最佳实践"></a>相关技巧和最佳实践</h4><p>要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。<strong>所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了</strong>。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。</p>
<p>在信息获取上，你要不断地向大众鼓吹下面的这些事：</p>
<ul>
<li>让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。</li>
<li>让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。</li>
<li>把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。</li>
<li>让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场……</li>
<li>利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。</li>
</ul>
<p>然后，在知识学习和技能训练上，让他们不得要领并产生幻觉</p>
<ul>
<li>让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……</li>
<li>培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……</li>
<li>不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”……</li>
<li>让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃……</li>
<li>玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……</li>
<li>让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……</li>
<li>告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……</li>
<li>让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……</li>
<li>让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……</li>
</ul>
<p>最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。</p>
<ul>
<li>让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好……</li>
<li>宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……</li>
<li>告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……</li>
<li>多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……</li>
<li>多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……</li>
<li>让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……</li>
<li>让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……</li>
<li>告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春……</li>
<li>当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）</li>
<li>告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……</li>
<li>每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……</li>
</ul>
<p><strong>最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。</strong></p>
<h4 id="相关原理和思维模型"><a href="#相关原理和思维模型" class="headerlink" title="相关原理和思维模型"></a>相关原理和思维模型</h4><p>一般来说，超过别人一般来说就是两个维度：</p>
<ol>
<li><strong>在认知、知识和技能上</strong>。这是一个人赖以立足社会的能力（参看《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/4235.html">程序员的荒谬之言还是至理名言？</a>》和《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/2250.html">21天教你学会C++</a>》）</li>
<li><strong>在领导力上</strong>。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17583.html">技术人员发展之路</a>》）</li>
</ol>
<p>首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。</p>
<h5 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h5><p>要在认知上超过别人，就要在下面几个方面上做足功夫：</p>
<p>1）<strong>信息渠道</strong>。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？）</p>
<p>2）<strong>信息质量</strong>。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。</p>
<p>3）<strong>信息密度</strong>。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像<a target="_blank" rel="noopener" href="https://medium.com/netflix-techblog">Netflix的官方blog</a>和<a target="_blank" rel="noopener" href="https://www.allthingsdistributed.com/">AWS CTO的blog</a>等等地方也会经常有一些这样的文章。</p>
<h5 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h5><p>要在知识上超过别人，你就需要在下面几个方面上做足功夫：</p>
<p>1）<strong>知识树（图）</strong>。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，<strong>对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！</strong></p>
<p>2）<strong>知识缘由</strong>。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。<strong>能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。</strong></p>
<p>3）<strong>方法套路</strong>。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。<strong>你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路</strong>。</p>
<h5 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h5><p>要在技能上超过别人，你就需要在下面几个方面做足功夫：</p>
<p>1）<strong>精益求精</strong>。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。</p>
<p>2）<strong>让自己犯错</strong>。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！</p>
<p>3）<strong>找高手切磋</strong>。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！</p>
<h5 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h5><p>最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。</p>
<p>1）<strong>识别自己的特长和天赋</strong>。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。</p>
<p>2）<strong>识别自己的兴趣和事业</strong>。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。</p>
<p>3）<strong>建立高级的习惯和方法</strong>。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。</p>
<p>4）<strong>勤奋努力执着坚持</strong>。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/2250.html">21天教你学会C++</a>》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-git工作流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/14/git%E5%B7%A5%E4%BD%9C%E6%B5%81/"
    >git工作流</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/14/git%E5%B7%A5%E4%BD%9C%E6%B5%81/" class="article-date">
  <time datetime="2020-02-15T01:58:00.000Z" itemprop="datePublished">2020-02-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="../images/0011a6d80f3f9d9cc36bcef5ad1d7f77.jpg" alt="0011a6d80f3f9d9cc36bcef5ad1d7f77"></p>
<p>与传统的代码版本管理工具相比，Git 有很多的优势，因而越来越成为程序员喜欢的版本管理工具。Git 这个代码版本管理工具最大的优势有以下几个。</p>
<ul>
<li>Git 是一个分布式的版本管理工具，而且可以是单机版的，所以，你在没有网络的时候同样可以提交（commit）代码。对于我们来说，这意味着在出差途中或是没有网络的环境中依然可以工作写代码。</li>
</ul>
<p>这是不是听起来有点不对？一方面，以后再也不能以将没有网络作为不工作的借口了。另一方面，没有网络意味着没有 Google 和 StackOverflow，光有个本地的 Git 我也一样不能写代码啊……</p>
<p>（哈哈。好吧，这已经超出了 Git 这个技术的范畴了，这里就不讨论了。）</p>
<ul>
<li>Git 从一个分支向另一个分支合并代码的时候，会把要合并的分支上的所有提交一个一个应用到被合并的分支上，合并后也能看得到整个代码的变更记录。而其他的版本管理工具则不能。</li>
<li>Git 切换分支的时候通常很快。不像其他版本管理器，每个分支一份拷贝。</li>
<li>Git 有很多非常有用的命令，让你可以很方便地工作。</li>
</ul>
<p>比如<code>git stash</code>命令，可以把当前没有完成的事先暂存一下，然后去忙别的事。<code>git cherry-pick</code>命令可以让你有选择地合并提交。<code>git add -p</code>可以让你挑选改动提交，<code>git grep $regexp $(git rev-list --all)</code>可以用来在所有的提交中找代码。因为都是本地操作，所以你会觉得飞快。</p>
<p>除此之外，由 Git 衍生出来的 GitHub/GitLab 可以帮你很好地管理编程工作，比如 wiki、fork、pull request、issue……集成了与编程相关的工作，让人觉得这不是一个冷冰冰的工具，而真正和我们的日常工作发生了很好的交互。</p>
<p>GitHub/GitLab 这样工具的出现，让我们的工作可以呈现在一个工作平台上，并以此来规范整个团队的工作，这才正是 Git 这个版本管理工具成功的原因。</p>
<p>今天，我们不讲 Git 是怎么用的，因为互联网上有太多的文章和书了。而且，如果你还不会用 Git 的话，那么你已经严重落后于这个时代了。在这篇文章中讲一下 Git 的协同工作流，因为很多团队在使用 Git 时，并没有用好。</p>
<p>注意，因为 Git 是一个分布式的代码管理器，所以，是分布式就会出现数据不一致的情况，因此，需要一个协同工作流来让工作变得高效，并可以有效地让代码具有更好的一致性。</p>
<p>说到一致性，就是每个人手里的开发代码，还有测试和生产线上的代码，要有一个比较好的一致性的管理和协同方法。这就是 Git 协同工作流所需要解决的问题。</p>
<p>GitFlow 工作流太过复杂，GitFlow 工作流是一个好的工作流。如果你的团队在用这种工作流开发软件，你的感觉一定是糟透了。</p>
<p>所以，这篇文章会对比一些比较主流的协同工作流，然后，再抨击一下 GitFlow 工作流。</p>
<h1 id="中心式协同工作流"><a href="#中心式协同工作流" class="headerlink" title="中心式协同工作流"></a>中心式协同工作流</h1><p>首先，先说明一下，Git 是可以像 SVN 这样的中心工作流一样工作的。很多程序员都是在采用这样的工作方式。</p>
<p>这个过程一般是下面这个样子的。</p>
<ol>
<li>从服务器上做<code>git pull origin master</code>把代码同步下来。</li>
<li>改完后，<code>git commit</code>到本地仓库中。</li>
<li>然后<code>git push origin master</code>到远程仓库中，这样其他同学就可以得到你的代码了。</li>
</ol>
<p>如果在第 3 步发现 push 失败，因为别人已经提交了，那么你需要先把服务器上的代码给 pull 下来，为了避免有 merge 动作，你可以使用 <code>git pull --rebase</code> 。这样就可以把服务器上的提交直接合并到你的代码中，对此，Git 的操作是这样的。</p>
<ol>
<li>先把你本地提交的代码放到一边。</li>
<li>然后把服务器上的改动下载下来。</li>
<li>然后在本地把你之前的改动再重新一个一个地做 commit，直到全部成功。</li>
</ol>
<p>如下图所示。Git 会把 Origin/Master 的远程分支下载下来（紫色的），然后把本地的 Master 分支上的改动一个一个地提交上去（蓝色的）。</p>
<p><img src="../images/5974a4026acca1000cd21772c4c52a6b.png" alt="img"></p>
<p>如果有冲突，那么你要先解决冲突，然后做 <code>git rebase --continue</code> 。如下图所示，git 在做 pull –rebase 时，会一个一个地应用（apply）本地提交的代码，如果有冲突就会停下来，等你解决冲突。</p>
<p><img src="../images/75b3fea18fa91b837f4f3ae6db6ab6e7.png" alt="img"></p>
<h1 id="功能分支协同工作流"><a href="#功能分支协同工作流" class="headerlink" title="功能分支协同工作流"></a>功能分支协同工作流</h1><p>上面的那种方式有一个问题，就是大家都在一个主干上开发程序，对于小团队或是小项目你可以这么干，但是对比较大的项目或是人比较多的团队，这么干就会有很多问题。</p>
<p>最大的问题就是代码可能干扰太严重。尤其是，我们想安安静静地开发一个功能时，我们想把各个功能的代码变动隔离开来，同时各个功能又会有多个开发人员在开发。</p>
<p>这时，我们不想让各个功能的开发人员都在 Master 分支上共享他们的代码。我们想要的协同方式是这样的：同时开发一个功能的开发人员可以分享各自的代码，但是不会把代码分享给开发其他功能的开发人员，直到整个功能开发完毕后，才会分享给其他的开发人员（也就是进入主干分支）。</p>
<p>因此，我们引入“功能分支”。这个协同工作流的开发过程如下。</p>
<ol>
<li>首先使用 <code>git checkout -b new-feature</code> 创建 “new-feature”分支。</li>
<li>然后共同开发这个功能的程序员就在这个分支上工作，进行 add、commit 等操作。</li>
<li>然后通过 <code>git push -u origin new-feature</code> 把分支代码 push 到服务器上。</li>
<li>其他程序员可以通过<code>git pull --rebase</code>来拿到最新的这个分支的代码。</li>
<li>最后通过 Pull Request 的方式做完 Code Review 后合并到 Master 分支上。</li>
</ol>
<p><img src="../images/455b921b2d178c87fe66714910301aec.png" alt="img"></p>
<p>就像上面这个图显示的一样，紫色的分支就是功能分支，合并后就会像上面这个样子。</p>
<p>其实，这种开发也是以服务器为中心的开发，还不是 Git 分布式开发，它只不过是用分支来完成代码改动的隔离。</p>
<p>另外，为什么会叫“功能分支”，而不是“项目分支”？因为 Git 的最佳实践希望大家在开发的过程中，快速提交，快速合并，快速完成。这样可以少很多冲突的事，所以叫功能分支。</p>
<p>传统的项目分支开得太久，时间越长就越合不回去。这种玩法其实就是让我们把一个大项目切分成若干个小项目来执行（最好是一个小功能一个项目）。这样才是互联网式的快速迭代式的开发流程。</p>
<h1 id="GitFlow-协同工作流"><a href="#GitFlow-协同工作流" class="headerlink" title="GitFlow 协同工作流"></a>GitFlow 协同工作流</h1><p>在真实的生产过程中，前面的协同工作流还是不能满足工作的要求。这主要因为生产过程是比较复杂的，软件生产中会有各式各样的问题，并要面对不同的环境。我们要在不停地开发新代码的同时，维护线上的代码，于是，就有了下面这些需求。</p>
<ol>
<li>希望有一个分支是非常干净的，上面是可以发布的代码，上面的改动永远都是可以发布到生产环境中的。这个分支上不能有中间开发过程中不可以上生产线的代码提交。</li>
<li>希望当代码达到可以上线的状态时，也就是在 alpha/beta release 时，在测试和交付的过程中，依然可以开发下一个版本的代码。</li>
<li>最后，对于已经发布的代码，也会有一些 Bug-fix 的改动，不会将正在开发的代码提交到生产线上去。</li>
</ol>
<p>你看，面对这些需求，前面的那些协同方式就都不行了。因为我们不仅是要在整个团队中共享代码，我们要的更是管理好不同环境下的代码不互相干扰。说得技术一点儿就是，要管理好代码与环境的一致性。</p>
<p>为了解决这些问题，GitFlow 协同工作流就出来了。</p>
<p>GitFlow 协同工作流是由 Vincent Driessen 于 2010 年在 A successful Git branching model 这篇文章介绍给世人的。</p>
<p>这个协同工作流的核心思想如下图所示。</p>
<p><img src="../images/9cf4c9bc17bf11aa07d47f61d2137fca.png" alt="img"></p>
<p>整个代码库中一共有五种分支。</p>
<ul>
<li>Master 分支。也就是主干分支，用作发布环境，上面的每一次提交都是可以发布的。</li>
<li>Feature 分支。也就是功能分支，用于开发功能，其对应的是开发环境。</li>
<li>Developer 分支。是开发分支，一旦功能开发完成，就向 Developer 分支合并，合并完成后，删除功能分支。这个分支对应的是集成测试环境。</li>
<li>Release 分支。当 Developer 分支测试达到可以发布状态时，开出一个 Release 分支来，然后做发布前的准备工作。这个分支对应的是预发环境。之所以需要这个 Release 分支，是我们的开发可以继续向前，不会因为要发布而被 block 住而不能提交。</li>
</ul>
<p>一旦 Release 分支上的代码达到可以上线的状态，那么需要把 Release 分支向 Master 分支和 Developer 分支同时合并，以保证代码的一致性。然后再把 Release 分支删除掉。</p>
<ul>
<li>Hotfix 分支。是用于处理生产线上代码的 Bug-fix，每个线上代码的 Bug-fix 都需要开一个 Hotfix 分支，完成后，向 Developer 分支和 Master 分支上合并。合并完成后，删除 Hotfix 分支。</li>
</ul>
<p>这就是整个 GitFlow 协同工作流的工作过程。我们可以看到：</p>
<ol>
<li>需要长期维护 Master 和 Developer 两个分支。</li>
<li>这其中的方式还是有一定复杂度的，尤其是 Release 和 Hotfix 分支需要同时向两个分支作合并。所以，如果没有一个好的工具来支撑的话，这会因为我们可能会忘了做一些操作而导致代码不一致。</li>
<li>GitFlow 协同虽然工作流比较重。但是它几乎可以应对所有公司的各种开发流程，包括瀑布模型，或是快速迭代模型。</li>
</ol>
<h1 id="GitHub-GitLab-协同工作流"><a href="#GitHub-GitLab-协同工作流" class="headerlink" title="GitHub/GitLab 协同工作流"></a>GitHub/GitLab 协同工作流</h1><h2 id="GitFlow-的问题"><a href="#GitFlow-的问题" class="headerlink" title="GitFlow 的问题"></a>GitFlow 的问题</h2><p>对于 GitFlow 来说，虽然可以解决问题，但是也有很多问题。在 GitFlow 流行了一段时间后，圈内出现了一些不同的声音。参看下面两篇吐槽文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://endoflineblog.com/gitflow-considered-harmful">GitFlow considered harmful</a></li>
<li><a target="_blank" rel="noopener" href="http://luci.criosweb.ro/a-real-life-git-workflow-why-git-flow-does-not-work-for-us/">Why git flow does not work for us</a></li>
</ul>
<p>其中有个问题就是因为分支太多，所以会出现 git log 混乱的局面。具体来说，主要是 git-flow 使用<code>git merge --no-ff</code>来合并分支，在 git-flow 这样多个分支的环境下会让你的分支管理的 log 变得很难看。如下所示，左边是使用–no-ff 参数在多个分支下的问题。</p>
<p><img src="../images/13a78e9d493ba2737c3d6b8431be47b8.png" alt="img"></p>
<p>所谓–no-ff 参数的意思是——no fast forward 的意思。也就是说，合并的方法不要把这个分支的提交以前置合并的方式，而是留下一个 merge 的提交。这是把双刃剑，我们希望我们的–no-ff 能像右边那样，而不是像左边那样。</p>
<p>对此的建议是：只有 feature 合并到 developer 分支时，使用–no-ff 参数，其他的合并都不使用–no-ff 参数来做合并。</p>
<p>另外，还有一个问题就是，在开发得足够快的时候，你会觉得同时维护 Master 和 Developer 两个分支是一件很无聊的事，因为这两个分支在大多数情况下都是一样的。包括 Release 分支，你会觉得创建的这些分支太无聊。</p>
<p>而你的整个开发过程也会因为这么复杂的管理变得非常复杂。尤其当你想回滚某些人的提交时，你就会发现这事似乎有点儿不好干了。而且在工作过程中，你会来来回回地切换工作的分支，有时候一不小心没有切换，就提交到了不正确的分支上，你还要回滚和重新提交，等等。</p>
<p>GitLab 一开始是 GitFlow 的坚定支持者，后来因为这些吐槽，以及 Hacker News 和 Reddit 上大量的讨论，GitLab 也开始不玩了。他们写了<a target="_blank" rel="noopener" href="https://about.gitlab.com/2014/09/29/gitlab-flow/">一篇 blog</a>来创造了一个新的 Workflow——GitLab Flow，这个 GitLab Flow 是基于 GitHub Flow 来做的（参看：<a target="_blank" rel="noopener" href="http://scottchacon.com/2011/08/31/github-flow.html"> GitHub Flow</a> ）。</p>
<h2 id="GitHub-Flow"><a href="#GitHub-Flow" class="headerlink" title="GitHub Flow"></a>GitHub Flow</h2><p>所谓 GitHub Flow，其实也叫 Forking flow，也就是 GitHub 上的那个开发方式。</p>
<ol>
<li>每个开发人员都把“官方库”的代码 fork 到自己的代码仓库中。</li>
<li>然后，开发人员在自己的代码仓库中做开发，想干啥干啥。</li>
<li>因此，开发人员的代码库中，需要配两个远程仓库，一个是自己的库，一个是官方库（用户的库用于提交代码改动，官方库用于同步代码）。</li>
<li>然后在本地建“功能分支”，在这个分支上做代码开发。</li>
<li>这个功能分支被 push 到开发人员自己的代码仓库中。</li>
<li>然后，向“官方库”发起 pull request，并做 Code Review。</li>
<li>一旦通过，就向官方库进行合并。</li>
</ol>
<p>这就是 GitHub 的工作流程。</p>
<p>如果你有“官方库”的权限，那么就可以直接在“官方库”中建功能分支开发，然后提交 pull request。通过 Code Review 后，合并进 Master 分支，而 Master 一旦有代码被合并就可以马上 release。</p>
<p>这是一种非常 Geek 的玩法。这需要一个自动化的 CI/CD 工具做辅助。是的，CI/CD 应该是开发中的标配了。</p>
<h2 id="GitLab-Flow"><a href="#GitLab-Flow" class="headerlink" title="GitLab Flow"></a>GitLab Flow</h2><p>然而，GitHub Flow 这种玩法依然会有好多问题，因为其虽然变得很简单，但是没有把我们的代码和我们的运行环境给联系在一起。所以，GitLab 提出了几个优化点。</p>
<p>其中一个是引入环境分支，如下图所示，其包含了预发布（Pre-Production）和生产（Production）分支。</p>
<p><img src="../images/c9cf817612cc9d474cd253d26344e184.png" alt="img"></p>
<p>而有些时候，我们还会有不同版本的发布，所以，还需要有各种 release 的分支。如下图所示。Master 分支是一个 roadmap 分支，然后，一旦稳定了就建稳定版的分支，如 2.3.stable 分支和 2.4.stable 分支，其中可以 cherry-pick master 分支上的一些改动过去。</p>
<p><img src="../images/ed94b250461ca2bf6d7faa2d0aaa1a96.png" alt="img"></p>
<p>这样也就解决了两个问题：</p>
<ul>
<li>环境和代码分支对应的问题；</li>
<li>版本和代码分支对应的问题。</li>
</ul>
<p>老实说，对于互联网公司来说，环境和代码分支对应这个事，只要有个比较好的 CI/CD 生产线，这种环境分支应该也是没有必要的。而对于版本和代码分支的问题，我觉得这应该是有意义的，但是，最好不要维护太多的版本，版本应该是短暂的，等新的版本发布时，老的版本就应该删除掉了。</p>
<h1 id="协同工作流的本质"><a href="#协同工作流的本质" class="headerlink" title="协同工作流的本质"></a>协同工作流的本质</h1><p>对于上面这些各式各样的工作流的比较和思考，虽然，我个人非常喜欢 GitHub Flow，在必要的时候使用上 GitLab 中的版本或环境分支。不过，我们现实生活中，还是有一些开发工作不是以功能为主要，而是以项目为主的。也就是说，项目的改动量可能比较大，时间和周期可能也比较长。</p>
<p>我在想，是否有一种工作流，可以面对我们现实工作中的各种情况。但是，我想这个世界太复杂了，应该不存在一种一招鲜吃遍天的放之四海皆准的银弹方案。所以，我们还要根据自己的实际情况来挑选适合我们的协同工作的方式。</p>
<p>而代码的协同工作流属于 SCM（Software Configuration Management）的范畴，要挑选好适合自己的方式，我们需要知道软件工程配置管理的本质。根据这么多年来我在各个公司的经历，有互联网的，有金融的，有项目的，有快速迭代的等，我认为团队协同工作的本质不外乎这么几个事儿。</p>
<ol>
<li>不同的团队能够尽大可能地并行开发。</li>
<li>不同软件版本和代码的一致性。</li>
<li>不同环境和代码的一致性。</li>
<li>代码总是会在稳定和不稳定间交替。我们希望生产线上的代码总是能对应到稳定的代码上来。</li>
</ol>
<p>基本上述的四个事儿，上述的工作流大都是在以建立不同的分支，来做到开发并行、代码和环境版本一致，以及稳定的代码。</p>
<p>要选择适合自己的协同工作流，我们就不得不谈一下软件开发的工作模式。</p>
<p>首先，我们知道软件开发的趋势一定是下面这个样子的。</p>
<ul>
<li><strong>以微服务或是 SOA 为架构的方式</strong>。一个大型软件会被拆分成若干个服务，那么，我们的代码应该也会跟着服务拆解成若干个代码仓库。这样一来，我们的每个代码仓库都会变小，于是我们的协同工作流程就会变简单。</li>
</ul>
<p>对于每个服务的代码仓库，我们的开发和迭代速度也会变得很快，开发团队也会跟服务一样被拆分成多个小团队。这样一来， Gitflow 这种协同工作流程就非常重了，而 GitHub 这种方式或是功能分支这种方式会更适合我们的开发。</p>
<ul>
<li><strong>以 DevOps 为主的开发流程</strong>。DevOps 关注于 CI/CD，需要我们有自动化的集成测试和持续部署的工具。这样一来，我们的代码发布速度就会大大加快，每一次提交都能很快地被完整地集成测试，并很快地发布到生产线上。</li>
</ul>
<p>于是，就可以使用更简单的协同工作流程，不需要维护多个版本，也不需要关注不同的运行环境，只需要一套代码，就可以了。GitHub Flow 或是功能分支这种方式也更适应这种开发。</p>
<p>如果将软件开发升级并简化到 SOA 服务化以及 DevOps 上来，那么协同工作流就会变得非常简单。所以，协同工作流的本质，并不是怎么玩好代码仓库的分支策略，而是玩好我们的软件架构和软件开发流程。</p>
<p>当然，服务化和 DevOps 是每个开发团队需要去努力的目标，但就算是这样，也有某些情况需要用重的协同工作的模式。比如，整个公司在做一个大的升级项目，这其中会对代码做一个大的调整（很有可能是一次重大的重构）。</p>
<p>这个时候，可能还有一些并行的开发需要做，如一些小功能的优化，一些线上 Bug 的处理，可能还需要在生产线上做新旧两个版本的 A/B 测试。在这样的情况下，可能会或多或少地使用 GitFlow 协同工作流。</p>
<p>但是，这样的方式不会是常态，是特殊时期，不可能隔三差五地对系统做架构或是对代码做大规模的重构。所以，在大多数情况下，还是应该选择一个比较轻量的协同工作流，而在特殊时期特例特办。</p>
<p>最后，用一句话来结束这篇文章——<strong>与其花时间在 Git 协同工作流上，还不如把时间花在调整软件架构和自动化软件生产和运维流程上来，这才是真正简化协同工作流程的根本</strong>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-System-Design-Questions"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/13/System-Design-Questions/"
    >System_Design_Questions</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/13/System-Design-Questions/" class="article-date">
  <time datetime="2020-02-13T14:27:37.000Z" itemprop="datePublished">2020-02-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>System design questions are an important part of programming job interviews, and if you want to do well, you must prepare this topic. In the past, when I shared my list of <a target="_blank" rel="noopener" href="http://www.java67.com/2018/05/top-75-programming-interview-questions-answers.html">programming interview questions</a>, I shared a couple of system design questions, but my readers kept asking me for more questions, as it is a hard topic to master and more and more practice is needed.</p>
<p>I had my own list of questions that I collected from various interviews with friends and colleagues, but I needed more questions for this article and my own preparation. Then, I stumbled upon the <a target="_blank" rel="noopener" href="https://www.educative.io/collection/5668639101419520/5649050225344512?affiliate_id=5073518643380224">Grokking System Design Interview</a> course.</p>
<p>It’s an excellent resource because it not only asks you a lot of system design questions but also provides the knowledge and tools you need to solve these problems. I have yet to find a similar or better resource than this one on system design, one of the important topics for <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2012/06/20-design-pattern-and-software-design.html#axzz55mVSPFfH">software engineering interviews</a>.</p>
<p>In other words, this course teaches you to step by step how to proceed with designing a real-world system like Facebook, Twitter, Uber, etc.</p>
<p>When you combine this course with this list of questions, you have the best material to prepare for your system design interview. You can also first try all these questions by yourself before joining the course or looking at my solutions for some of the questions.</p>
<h2 id="System-Design-Interview-Questions-for-Programmers"><a href="#System-Design-Interview-Questions-for-Programmers" class="headerlink" title="System Design Interview Questions for Programmers"></a>System Design Interview Questions for Programmers</h2><p>Without any further ado, here is the list of some of the most popular system design or object-oriented analysis and design questions to crack any programming job interview.</p>
<h3 id="1-How-to-design-a-vending-machine-in-Java-solution"><a href="#1-How-to-design-a-vending-machine-in-Java-solution" class="headerlink" title="1. How to design a vending machine in Java? (solution)"></a><strong>1. How to design a vending machine in Java?</strong> (<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2016/06/design-vending-machine-in-java.html#axzz4sZVwtCgs">solution</a>)</h3><p>You need to write code to implement a vending machine that has a bunch of products, e.g. chocolates, candy, cold drinks, and accepts different coins, e.g. nickles, dimes, quarters, cent, etc. Make sure you insert a coin, get a product back, and get your change back. Also, write the unit test to demonstrate that these common use cases work. If you get stuck, you can read my two-part series (<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2016/06/design-vending-machine-in-java.html#axzz4sZVwtCgs">Part 1</a> and <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2016/06/java-object-oriented-analysis-and-design-vending-machine-part-2.html">Part 2</a>) about solving these classical system design questions.</p>
<h3 id="2-How-to-design-a-URL-shortening-service-like-goo-gl"><a href="#2-How-to-design-a-URL-shortening-service-like-goo-gl" class="headerlink" title="2. How to design a URL shortening service like goo.gl?"></a><strong>2. How to design a URL shortening service like goo.gl?</strong></h3><p>This one is another common system design question. If you are given a (typically) long URL, how would you design a service that would generate a shorter and unique alias for it? If you are not familiar with the URL shortener service, have a look at some of the popular ones like goo.gl from <a target="_blank" rel="noopener" href="https://javarevisited.blogspot.com/2012/01/google-interview-questions-answers-top.html">Google</a> and bit.ly, which is used by Twitter.</p>
<p>Make sure to provide a database schema and rationale behind some design decisions, e.g. how long you keep the data, how to get stats and analytics, etc. If you get stuck, you can follow the solution given on <a target="_blank" rel="noopener" href="https://www.educative.io/collection/5668639101419520/5649050225344512?affiliate_id=5073518643380224">System Design Interviews: Grokking the System Design Interview</a>.</p>
<h3 id="3-How-to-design-a-limit-order-book"><a href="#3-How-to-design-a-limit-order-book" class="headerlink" title="3. How to design a limit order book?"></a><strong>3. How to design a limit order book?</strong></h3><p>A limit order book is used in stock exchanges to match a buy order with a sell order based on price and time priority. How would you go about that? Which <a target="_blank" rel="noopener" href="https://hackernoon.com/10-data-structure-algorithms-and-programming-courses-to-crack-any-coding-interview-e1c50b30b927">data structure</a> you will use? Remember: the speed of matching is key, as well as the reliability. If you need a refresher on data structures, then you can check out a data structure and algorithm Java course, and if you feel stuck, you can check out my solution <a target="_blank" rel="noopener" href="https://javarevisited.blogspot.sg/2017/03/2-practical-data-structure-algorithm-interview-questions-java.html">here</a>.</p>
<h3 id="4-How-to-design-a-traffic-control-system"><a href="#4-How-to-design-a-traffic-control-system" class="headerlink" title="4. How to design a traffic control system?"></a><strong>4. How to design a traffic control system?</strong></h3><p>A classical system design question from old age is still popular. Make sure you know how to transition from one state to another like RED to GREEN and from GREEN to ORANGE to RED, etc. One tip is you can use the <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2014/04/difference-between-state-and-strategy-design-pattern-java.html">state design pattern</a> because there is a clear transition of state from one to other. For example, you cannot go from RED to GREEN before ORANGE or so on.</p>
<p>You can also use the <a target="_blank" rel="noopener" href="http://www.java67.com/2018/07/java-enum-tutorial-10-things-java-devs.html">Enum</a> to represent the state and implement the pattern, just as we did with the <a target="_blank" rel="noopener" href="https://javarevisited.blogspot.com/2014/11/strategy-design-pattern-in-java-using-Enum-Example.html">strategy design pattern</a> in my last article.</p>
<p>If you are not familiar with these essential patterns, then I suggest you to first take a look at this <strong><a target="_blank" rel="noopener" href="https://pluralsight.pxf.io/c/1193463/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fpatterns-library">Design Pattern Library </a></strong>course on Pluarslight, one of the better resources to learn this pattern and get insight on how and when to use them in the real world.</p>
<h3 id="5-How-to-design-a-website-like-Pastebin"><a href="#5-How-to-design-a-website-like-Pastebin" class="headerlink" title="5. How to design a website like Pastebin?"></a><strong>5. How to design a website like Pastebin?</strong></h3><p>Pastebin allows you to paste text or code and then share a link to that code anywhere you want. It’s not an online code editor but you can use this to store any kind of text.</p>
<h3 id="6-How-would-you-create-your-own-Instagram"><a href="#6-How-would-you-create-your-own-Instagram" class="headerlink" title="6. How would you create your own Instagram?"></a><strong>6. How would you create your own Instagram?</strong></h3><p>Instagram is a photo sharing application that provides some custom filters to enhance your photo quality.</p>
<h3 id="7-How-to-design-a-global-file-sharing-and-storage-apps-like-Google-Drive-or-Dropbox"><a href="#7-How-to-design-a-global-file-sharing-and-storage-apps-like-Google-Drive-or-Dropbox" class="headerlink" title="7. How to design a global file sharing and storage apps like Google Drive or Dropbox?"></a><strong>7. How to design a global file sharing and storage apps like Google Drive or Dropbox?</strong></h3><p>These are used to store and share files, photos, and other media. How do you go about designing things like allowing users to upload/view/search/share files or photos, track permissions for file sharing, and allow multiple users to edit the same document?</p>
<h3 id="8-How-to-design-a-chat-application-like-WhatsApp-or-Facebook-Messenger"><a href="#8-How-to-design-a-chat-application-like-WhatsApp-or-Facebook-Messenger" class="headerlink" title="8. How to design a chat application like WhatsApp or Facebook Messenger?"></a><strong>8. How to design a chat application like WhatsApp or Facebook Messenger?</strong></h3><p>You have surely used WhatsApp and Facebook, right? No? If not, let me tell you that a chat application allows you to send messages to your friend. It’s a point-to-point connection. You keep a friends list, view their status, and chat with them.</p>
<p>In WhatsApp, you can also connect groups, but that is for advanced and experienced developers. At a minimum, you should provide a design to keep the friends list and send and receive messages from them.</p>
<h3 id="9-How-to-design-a-Twitter-Clone"><a href="#9-How-to-design-a-Twitter-Clone" class="headerlink" title="9. How to design a Twitter Clone?"></a><strong>9. How to design a Twitter Clone?</strong></h3><p>Twitter is a popular messaging service that lets you broadcast messages to all of your followers. You post a tweet and your followers see those messages. Additionally, they can like or retweet your post. Make sure you implement common features like followers, hashtags, tweets, deletes, etc. If you do not feel like going anywhere and are stuck, you can follow the solution on <a target="_blank" rel="noopener" href="https://www.educative.io/collection/5668639101419520/5649050225344512?affiliate_id=5073518643380224">System Design Interviews: Grokking the System Design Interview</a>.</p>
<h3 id="10-How-to-design-a-global-video-streaming-service-e-g-YouTube-or-Netflix"><a href="#10-How-to-design-a-global-video-streaming-service-e-g-YouTube-or-Netflix" class="headerlink" title="10. How to design a global video streaming service, e.g. YouTube or Netflix?"></a><strong>10. How to design a global video streaming service, e.g. YouTube or Netflix?</strong></h3><p>While designing a video streaming service like NetFlix or YouTube, the key concept to remember is to smooth streaming and buffering and functioning over low bandwidth connection and how you manage those challenges.</p>
<h3 id="11-How-to-design-an-ATM-machine"><a href="#11-How-to-design-an-ATM-machine" class="headerlink" title="11. How to design an ATM machine?"></a><strong>11. How to design an ATM machine?</strong></h3><p>An ATM machine allows a user to deposit and withdraw cash. It also allows a user to check their balance. How do you design such a system? What are your main challenges?</p>
<h3 id="12-How-to-design-an-API-Rate-Limiter"><a href="#12-How-to-design-an-API-Rate-Limiter" class="headerlink" title="12. How to design an API Rate Limiter?"></a><strong>12. How to design an API Rate Limiter?</strong></h3><p>This is a challenging one. You may want to find more information about it, starting with a Google search.</p>
<h3 id="13-How-to-design-Twitter-Search"><a href="#13-How-to-design-Twitter-Search" class="headerlink" title="13. How to design Twitter Search?"></a><strong>13. How to design Twitter Search?</strong></h3><p>To be honest, Twitter search is poor — unless you enter the exact title of your tweet, you won’t be able to find anything. So, this one should be easy to implement<strong>.</strong></p>
<h3 id="14-How-to-design-a-web-crawler-like-Google"><a href="#14-How-to-design-a-web-crawler-like-Google" class="headerlink" title="14. How to design a web crawler like Google?"></a><strong>14. How to design a web crawler like Google?</strong></h3><p>A web crawler goes to a website and crawls all links and indexes, like Google, so that they can later appear in a search result. A crawler can also be used for searching a particular file in a set of directories. But be sure to ask yourself about some of the major challenges.</p>
<h3 id="15-How-to-design-Facebook’s-Newsfeed-What-kind-of-algorithm-will-you-use"><a href="#15-How-to-design-Facebook’s-Newsfeed-What-kind-of-algorithm-will-you-use" class="headerlink" title="15. How to design Facebook’s Newsfeed? What kind of algorithm will you use?"></a><strong>15. How to design Facebook’s Newsfeed? What kind of algorithm will you use?</strong></h3><p>The newsfeed is an important part of Facebook that allows a user to see what’s happening around the world, including friends, families, pages he has liked, a group he has followed, and of course, the Facebook ads.</p>
<p>The job of the newsfeed algorithm is to show messages that are most important to the user and which can generate high engagement. Obviously, messages from friends and family should take priority. If you feel not going anywhere and stuck, you can follow the solution on<strong><a target="_blank" rel="noopener" href="https://www.educative.io/collection/5668639101419520/5649050225344512?affiliate_id=5073518643380224">System Design Interviews: Grokking the System Design Interview</a>.</strong></p>
<h3 id="16-How-to-design-Yelp-or-Nearby-Friends"><a href="#16-How-to-design-Yelp-or-Nearby-Friends" class="headerlink" title="16. How to design Yelp or Nearby Friends?"></a><strong>16. How to design Yelp or Nearby Friends?</strong></h3><p>Have you used Yelp? If not first use it to understand how it works before you can design a similar system. For those who don’t know Yelp is a local-search service powered by crowd-sourced review forum</p>
<h3 id="17-How-to-design-a-global-ride-hailing-service-e-g-Uber-Grab-or-Ola-backend"><a href="#17-How-to-design-a-global-ride-hailing-service-e-g-Uber-Grab-or-Ola-backend" class="headerlink" title="17. How to design a global ride-hailing service e.g. Uber, Grab, or Ola backend?"></a><strong>17. How to design a global ride-hailing service e.g. Uber, Grab, or Ola backend?</strong></h3><p>Uber and Ola are two of the most popular ride-hailing services, it brings both drivers and passengers together. How do you go about designing to allow a passenger to see nearby taxis and book them?</p>
<h3 id="18-How-to-design-BookMyShow"><a href="#18-How-to-design-BookMyShow" class="headerlink" title="18. How to design BookMyShow?"></a><strong>18. How to design BookMyShow?</strong></h3><p>A website that allows you to book cinema and event tickets.</p>
<h3 id="19-How-to-design-a-social-network-message-board-service-sites-like-Quora-Reddit-or-HackerNews"><a href="#19-How-to-design-a-social-network-message-board-service-sites-like-Quora-Reddit-or-HackerNews" class="headerlink" title="19. How to design a social network + message board service sites like Quora, Reddit, or HackerNews?"></a><strong>19. How to design a social network + message board service sites like Quora, Reddit, or HackerNews?</strong></h3><p>Reddit, Quora, and HackerNews are some of the most popular social network sites where users can post questions or share links. Other users can answer questions or comment on the shared links.</p>
<h3 id="20-How-do-you-design-an-application-like-Airbnb"><a href="#20-How-do-you-design-an-application-like-Airbnb" class="headerlink" title="20. How do you design an application like Airbnb?"></a><strong>20. How do you design an application like Airbnb?</strong></h3><p>This allows users to upload rooms for rent and other users to rent them. Some features are only available to admins, publishers, and subscribers.</p>
<p>That’s all for now on some of the <strong>frequently asked system design interview questions for Java programmers</strong>. These questions are not just useful for Java programmers but also for <a target="_blank" rel="noopener" href="https://javarevisited.blogspot.com/2018/12/10-free-python-courses-for-programmers.html">Python</a>, <a target="_blank" rel="noopener" href="https://hackernoon.com/top-5-free-c-courses-to-learn-programming-in-2019-d27352277da0">C++</a>, and <a target="_blank" rel="noopener" href="http://www.java67.com/2018/02/5-free-ruby-and-rails-courses-to-learn-online.html">Ruby</a> programmers. These questions are actually independent of programming languages and test your software design and architecture skills.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-分布式系统技术栈"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A0%88/"
    >分布式系统技术栈</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A0%88/" class="article-date">
  <time datetime="2020-02-13T04:57:31.000Z" itemprop="datePublished">2020-02-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>构建分布式系统的目的是增加系统容量，提高系统的可用性，转换成技术方面，也就是完成下面两件事。</p>
<ul>
<li><strong>大流量处理</strong>。通过集群技术把大规模并发请求的负载分散到不同的机器上。</li>
<li><strong>关键业务保护</strong>。提高后台服务的可用性，把故障隔离起来阻止多米诺骨牌效应（雪崩效应）。如果流量过大，需要对业务降级，以保护关键业务流转。</li>
</ul>
<p>说白了就是干两件事。一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。</p>
<h1 id="提高架构的性能"><a href="#提高架构的性能" class="headerlink" title="提高架构的性能"></a>提高架构的性能</h1><p>咱们先来看看，提高系统性能的常用技术。</p>
<ul>
<li><p><strong>缓存系统</strong>。加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存，这是提高快速访问能力最有效的手段。对于分布式系统下的缓存系统，需要的是一个缓存集群。这其中需要一个 Proxy 来做缓存的分片和路由。</p>
</li>
<li><p><strong>负载均衡系统</strong>，是做水平扩展的关键技术。其可以用多台机器来共同分担一部分流量请求。</p>
</li>
<li><p><strong>异步调用</strong>。异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，而后端通过自己能够处理的速度来处理请求。这样可以增加系统的吞吐量，但是实时性就差很多了。同时，还会引入消息丢失的问题，所以要对消息做持久化，这会造成“有状态”的结点，从而增加了服务调度的难度。</p>
</li>
<li><p><strong>数据分区和数据镜像</strong>。<strong>数据分区</strong>是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。而<strong>数据镜像</strong>是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。</p>
</li>
</ul>
<p>对于一般公司来说，在初期，会使用读写分离的数据镜像方式，而后期会采用分库分表的方式。</p>
<h1 id="提高架构的稳定性"><a href="#提高架构的稳定性" class="headerlink" title="提高架构的稳定性"></a>提高架构的稳定性</h1><p>接下来，咱们来看看提高系统系统稳定性的一些常用技术。</p>
<ul>
<li><strong>服务拆分</strong>，主要有两个目的：一是为了隔离故障，二是为了重用服务模块。但服务拆分完之后，会引入服务调用间的依赖问题。</li>
<li><strong>服务冗余</strong>，是为了去除单点故障，并可以支持服务的弹性伸缩，以及故障迁移。然而，对于一些有状态的服务来说，冗余这些有状态的服务带来了更高的复杂性。其中一个是弹性伸缩时，需要考虑数据的复制或是重新分片，迁移的时候还要迁移数据到其它机器上。</li>
<li><strong>限流降级</strong>。当系统实在扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分服务，或是拒绝一部分用户，以确保整个架构不会挂掉。这些技术属于保护措施。</li>
<li><strong>高可用架构</strong>，通常来说是从冗余架构的角度来保障可用性。比如，多租户隔离，灾备多活，或是数据可以在其中复制保持一致性的集群。总之，就是为了不出单点故障。</li>
<li><strong>高可用运维</strong>，指的是 DevOps 中的 CI（持续集成）/CD（持续部署）。一个良好的运维应该是一条很流畅的软件发布管线，其中做了足够的自动化测试，还可以做相应的灰度发布，以及对线上系统的自动化控制。这样，可以做到“计划内”或是“非计划内”的宕机事件的时长最短。</li>
</ul>
<p>上述这些技术非常有技术含量，而且需要投入大量的时间和精力。</p>
<h1 id="分布式系统的关键技术"><a href="#分布式系统的关键技术" class="headerlink" title="分布式系统的关键技术"></a>分布式系统的关键技术</h1><p>而通过上面的分析，我们可以看到，引入分布式系统，会引入一堆技术问题，需要从以下几个方面来解决。</p>
<ul>
<li><strong>服务治理</strong>。服务拆分、服务调用、服务发现，服务依赖，服务的关键度定义……服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。</li>
<li><strong>架构软件管理</strong>。服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。</li>
<li><strong>DevOps</strong>。分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。</li>
<li><strong>自动化运维</strong>。有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。</li>
<li><strong>资源调度管理</strong>。应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。</li>
<li><strong>整体架构监控</strong>。如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。</li>
<li><strong>流量控制</strong>。最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。</li>
</ul>
<p>此时，你会发现，要做好这么多的技术，或是要具备这么多的能力，简直就是一个门槛，是一个成本巨高无比的技术栈，看着就都头晕。要实现出来得投入多少人力、物力和时间啊。是的，这就是分布式系统中最大的坑。</p>
<p>不过，我们应该庆幸自己生活在了一个非常不错的年代。今天有一个技术叫——Docker，通过 Docker 以及其衍生出来的 Kubernetes 之类的软件或解决方案，大大地降低了做上面很多事情的门槛。Docker 把软件和其运行的环境打成一个包，然后比较轻量级地启动和运行。在运行过程中，因为软件变成了服务可能会改变现有的环境。但是没关系，当你重新启动一个 Docker 的时候，环境又会变成初始化状态。</p>
<p>这样一来，我们就可以利用 Docker 的这个特性来把软件在不同的机器上进行部署、调度和管理。如果没有 Docker 或是 Kubernetes，那么你可以认为我们还活在“原始时代”。现在你知道为什么 Docker 这样的容器化虚拟化技术是未来了吧。因为分布式系统已经是完全不可逆转的技术趋势了。</p>
<p>但是，上面还有很多的技术是 Docker 及其周边技术没有解决的，所以，依然还有很多事情要做。那么，如果是一个一个地去做这些技术的话，就像是我们在撑开一张网里面一个一个的网眼，本质上这是使蛮力的做法。我们希望可以找到系统的“纲”，一把就能张开整张网。那么，这个纲在哪里呢？</p>
<h1 id="分布式系统的“纲”"><a href="#分布式系统的“纲”" class="headerlink" title="分布式系统的“纲”"></a>分布式系统的“纲”</h1><p>总结一下上面讲述的内容，你不难发现，分布式系统有五个关键技术，它们是：</p>
<ul>
<li>全栈系统监控；</li>
<li>服务 / 资源调度；</li>
<li>流量调度；</li>
<li>状态 / 数据调度；</li>
<li>开发和运维的自动化。</li>
</ul>
<p>而最后一项——开发和运维的自动化，是需要把前四项都做到了，才有可能实现的。所以，最为关键是下面这四项技术，即应用整体监控、资源和服务调度、状态和数据调度及流量调度，它们是构建分布式系统最最核心的东西。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>回顾一下今天的要点内容。首先，我总结了分布式系统需要干的两件事：一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。然后分别从这两个方面阐释，需要通过哪些技术来实现，并梳理出其中的技术难点及可能会带来的问题。最后，欢迎你分享一下你在解决系统的性能和可用性方面使用到的方法和技巧。</p>
<p>虽然 Docker 及其衍生出来的 Kubernetes 等软件或解决方案，能极大地降低很多事儿的门槛。但它们没有解决的问题还有很多，需要掌握分布式系统的五大关键技术，从根本上解决问题。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-分布式架构难点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E9%9A%BE%E7%82%B9/"
    >分布式架构难点</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E9%9A%BE%E7%82%B9/" class="article-date">
  <time datetime="2020-02-12T02:07:13.000Z" itemprop="datePublished">2020-02-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>对分布式服务化架构实践最早的应该是亚马逊。因为早在 2002 年的时候，亚马逊 CEO 杰夫·贝索斯（Jeff Bezos）就向全公司颁布了下面的这几条架构规定.</p>
<ol>
<li>所有团队的程序模块都要通过 Service Interface 方式将其数据与功能开放出来。</li>
<li>团队间程序模块的信息通信，都要通过这些接口。</li>
<li>除此之外没有其它的通信方式。其他形式一概不允许：不能直接链结别的程序（把其他团队的程序当做动态链接库来链接），不能直接读取其他团队的数据库，不能使用共享内存模式，不能使用别人模块的后门，等等。唯一允许的通信方式是调用 Service Interface。</li>
<li>任何技术都可以使用。比如：HTTP、CORBA、Pub/Sub、自定义的网络协议等。</li>
<li>所有的 Service Interface，毫无例外，都必须从骨子里到表面上设计成能对外界开放的。也就是说，团队必须做好规划与设计，以便未来把接口开放给全世界的程序员，没有任何例外。</li>
<li>不这样做的人会被炒鱿鱼。</li>
</ol>
<p>这应该就是 AWS（Amazon Web Service）出现的基因吧。当然，前面说过，采用分布式系统架构后会出现很多的问题。比如：</p>
<ul>
<li>一个线上故障的工单会在不同的服务和不同的团队中转过来转过去的。</li>
<li>每个团队都可能成为一个潜在的 DDoS 攻击者，除非每个服务都要做好配额和限流。</li>
<li>监控和查错变得更为复杂。除非有非常强大的监控手段。</li>
<li>服务发现和服务治理也变得非常复杂。</li>
</ul>
<p>为了克服这些问题，亚马逊这么多年的实践让其可以运维和管理极其复杂的分布式服务架构。主要有以下几点。</p>
<ol>
<li><strong>分布式服务的架构需要分布式的团队架构</strong>。在亚马逊，一个服务由一个小团队（Two Pizza Team 不超过 16 个人，两张 Pizza 可以喂饱的团队）负责，从前端负责到数据，从需求分析负责到上线运维。这是良性的分工策略——按职责分工，而不是按技能分工。</li>
<li><strong>分布式服务查错不容易</strong>。一旦出现比较严重的故障，需要整体查错。出现一个 S2 的故障，就可以看到每个团队的人都会上线。在工单系统里能看到，在故障发生的一开始，大家都在签到并自查自己的系统。如果没问题，也要在线待命（standby），等问题解决。</li>
<li><strong>没有专职的测试人员，也没有专职的运维人员，开发人员做所有的事情</strong>。开发人员做所有事情的好处是——吃自己的狗粮（Eat Your Own Dog Food） 最微观的实践。自己写的代码自己维护自己养，会让开发人员明白，写代码容易维护代码复杂。这样，开发人员在接需求、做设计、写代码、做工具时都会考虑到软件的长期维护性。</li>
<li><strong>运维优先，崇尚简化和自动化</strong>。为了能够运维如此复杂的系统，亚马逊内部在运维上下了非常大的功夫。现在人们所说的 DevOps 这个事，亚马逊在 10 多年前就做到了。亚马逊最为强大的就是运维，拼命地对系统进行简化和自动化，让亚马逊做到了可以轻松运维拥有上千万台虚机的 AWS 云平台。</li>
<li><strong>内部服务和外部服务一致</strong>。无论是从安全方面，还是接口设计方面，无论是从运维方面，还是故障处理的流程方面，亚马逊的内部系统都和外部系统一样对待。这样做的好处是，内部系统的服务随时都可以开放出来。而且，从第一天开始，服务提供方就有对外服务的能力。可以想像，以这样的标准运作的团队其能力会是什么样的。</li>
</ol>
<p>我们再来看一下分布式系统在技术上需要注意的问题。</p>
<h1 id="问题一：异构系统的不标准问题"><a href="#问题一：异构系统的不标准问题" class="headerlink" title="问题一：异构系统的不标准问题"></a>问题一：异构系统的不标准问题</h1><p>这主要表现在：</p>
<ul>
<li>软件和应用不标准。</li>
<li>通讯协议不标准。</li>
<li>数据格式不标准。</li>
<li>开发和运维的过程和方法不标准。</li>
</ul>
<p>不同的软件，不同的语言会出现不同的兼容性和不同的开发、测试、运维标准。不同的标准会让我们用不同的方式来开发和运维，引起架构复杂度的提升。比如：有的软件修改配置要改它的.conf 文件，而有的则是调用管理 API 接口。</p>
<p>在通讯方面，不同的软件用不同的协议，就算是相同的网络协议里也会出现不同的数据格式。还有，不同的团队因为用不同的技术，会有不同的开发和运维方式。这些不同的东西，会让我们的整个分布式系统架构变得异常复杂。所以，分布式系统架构需要有相应的规范。</p>
<p>比如，我看到，很多服务的 API 出错不返回 HTTP 的错误状态码，而是返回个正常的状态码 200，然后在 HTTP Body 里的 JSON 字符串中写着个：error，bla bla error message。这简直就是一种反人类的做法。我实在不明白为什么会有众多这样的设计。这让监控怎么做啊？现在，你应该使用 Swagger 的规范了。</p>
<p>再比如，我看到很多公司的软件配置管理里就是一个 key-value 的东西，这样的东西灵活到可以很容易地被滥用。不规范的配置命名，不规范的值，甚至在配置中直接嵌入前端展示内容……</p>
<p>一个好的配置管理，应该分成三层：底层和操作系统相关，中间层和中间件相关，最上面和业务应用相关。于是底层和中间层是不能让用户灵活修改的，而是只让用户选择。比如：操作系统的相关配置应该形成模板来让人选择，而不是让人乱配置的。只有配置系统形成了规范，我们才 hold 得住众多的系统。</p>
<p>再比如：数据通讯协议。通常来说，作为一个协议，一定要有协议头和协议体。协议头定义了最基本的协议数据，而协议体才是真正的业务数据。对于协议头，我们需要非常规范地让每一个使用这个协议的团队都使用一套标准的方式来定义，这样我们才容易对请求进行监控、调度和管理。</p>
<h1 id="问题二：系统架构中的服务依赖性问题"><a href="#问题二：系统架构中的服务依赖性问题" class="headerlink" title="问题二：系统架构中的服务依赖性问题"></a>问题二：系统架构中的服务依赖性问题</h1><p>对于传统的单体应用，一台机器挂了，整个软件就挂掉了。但是你千万不要以为在分布式的架构下不会发生这样的事。分布式架构下，服务是会有依赖的，于是一个服务依赖链上，某个服务挂掉了，会导致出现“多米诺骨牌”效应，会倒一片。</p>
<p>所以，在分布式系统中，服务的依赖也会带来一些问题。</p>
<ul>
<li>如果非关键业务被关键业务所依赖，会导致非关键业务变成一个关键业务。</li>
<li>服务依赖链中，出现“木桶短板效应”——整个 SLA 由最差的那个服务所决定。</li>
</ul>
<p>这是服务治理的内容了。服务治理不但需要我们定义出服务的关键程度，还需要我们定义或是描述出关键业务或服务调用的主要路径。没有这个事情，我们将无法运维或是管理整个系统。</p>
<p>这里需要注意的是，很多分布式架构在应用层上做到了业务隔离，然而，在数据库结点上并没有。如果一个非关键业务把数据库拖死，那么会导致全站不可用。所以，数据库方面也需要做相应的隔离。也就是说，最好一个业务线用一套自己的数据库。这就是亚马逊服务器的实践——系统间不能读取对方的数据库，只通过服务接口耦合。这也是微服务的要求。我们不但要拆分服务，还要为每个服务拆分相应的数据库。</p>
<h1 id="问题三：故障发生的概率更大"><a href="#问题三：故障发生的概率更大" class="headerlink" title="问题三：故障发生的概率更大"></a>问题三：故障发生的概率更大</h1><p>在分布式系统中，因为使用的机器和服务会非常多，所以，故障发生的频率会比传统的单体应用更大。只不过，单体应用的故障影响面很大，而分布式系统中，虽然故障的影响面可以被隔离，但是因为机器和服务多，出故障的频率也会多。另一方面，因为管理复杂，而且没人知道整个架构中有什么，所以非常容易犯错误。</p>
<p>你会发现，对分布式系统架构的运维，简直就是一场噩梦。我们会慢慢地明白下面这些道理。</p>
<ul>
<li>出现故障不可怕，故障恢复时间过长才可怕。</li>
<li>出现故障不可怕，故障影响面过大才可怕。</li>
</ul>
<p>运维团队在分布式系统下会非常忙，忙到每时每刻都要处理大大小小的故障。我看到，很多大公司，都在自己的系统里拼命地添加各种监控指标，有的能够添加出几万个监控指标。我觉得这完全是在“使蛮力”。一方面，信息太多等于没有信息，另一方面，SLA 要求我们定义出“Key Metrics”，也就是所谓的关键指标。然而，他们却没有。这其实是一种思维上的懒惰。</p>
<p>但是，上述的都是在“救火阶段”而不是“防火阶段”。所谓“防火胜于救火”，我们还要考虑如何防火，这需要我们在设计或运维系统时都要为这些故障考虑，即所谓 Design for Failure。在设计时就要考虑如何减轻故障。如果无法避免，也要使用自动化的方式恢复故障，减少故障影响面。</p>
<p>因为当机器和服务数量越来越多时，你会发现，人类的缺陷就成为了瓶颈。这个缺陷就是人类无法对复杂的事情做到事无巨细的管理，只有机器自动化才能帮助人类。 也就是，人管代码，代码管机器，人不管机器！</p>
<h1 id="问题四：多层架构的运维复杂度更大"><a href="#问题四：多层架构的运维复杂度更大" class="headerlink" title="问题四：多层架构的运维复杂度更大"></a>问题四：多层架构的运维复杂度更大</h1><p>通常来说，我们可以把系统分成四层：基础层、平台层、应用层和接入层。</p>
<ul>
<li>基础层就是我们的机器、网络和存储设备等。</li>
<li>平台层就是我们的中间件层，Tomcat、MySQL、Redis、Kafka 之类的软件。</li>
<li>应用层就是我们的业务软件，比如，各种功能的服务。</li>
<li>接入层就是接入用户请求的网关、负载均衡或是 CDN、DNS 这样的东西。</li>
</ul>
<p>对于这四层，我们需要知道：</p>
<ul>
<li>任何一层的问题都会导致整体的问题；</li>
<li>没有统一的视图和管理，导致运维被割裂开来，造成更大的复杂度。</li>
</ul>
<p>很多公司都是按技能分工是，把技术团队分为产品开发、中间件开发、业务运维、系统运维等子团队。这样的分工导致各管一摊，很多事情完全连不在一起。整个系统会像 “多米诺骨牌”一样，一个环节出现问题，就会倒下去一大片。因为没有一个统一的运维视图，不知道一个服务调用是如何经过每一个服务和资源，也就导致我们在出现故障时要花大量的时间在沟通和定位问题上。</p>
<p>从接入层到负载均衡，再到服务层，再到操作系统底层，设置的 KeepAlive 的参数完全不一致，导致用户发现，软件运行的行为和文档中定义的完全不一样。工程师查错的过程简直就是一场恶梦，以为找到了一个，结果还有一个，来来回回花了大量的时间才把所有 KeepAlive 的参数设置成一致的，浪费了太多的时间。</p>
<p><strong>分工不是问题，问题是分工后的协作是否统一和规范</strong>。这点，一定要重视。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好了，我们来总结一下今天分享的主要内容。首先，我以亚马逊为例，讲述了它是如何做分布式服务架构的，遇到了哪些问题，以及是如何解决的。我认为，亚马逊在分布式服务系统方面的这些实践和经验积累，是 AWS 出现的基因。随后分享了在分布式系统中需要注意的几个问题，同时给出了应对方案。</p>
<p>我认为，构建分布式服务需要从组织，到软件工程，再到技术上的一次大的改造，需要比较长的时间来磨合和改进，并不断地总结教训和成功经验。下篇文章中，我们讲述分布式系统的技术栈。希望对你有帮助。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-System/" rel="tag">Distributed System</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">prev page</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/19/">next page</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2021
        <i class="ri-heart-fill heart_icon"></i> Aaron
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">tags</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>