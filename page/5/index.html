<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/15/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E7%89%B9%E6%9C%97%E6%99%AE%E5%AE%A3%E5%B8%83%E6%9A%82%E5%81%9C%E8%B5%84%E5%8A%A9%E4%B8%96%E5%8D%AB%E7%BB%84%E7%BB%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E7%89%B9%E6%9C%97%E6%99%AE%E5%AE%A3%E5%B8%83%E6%9A%82%E5%81%9C%E8%B5%84%E5%8A%A9%E4%B8%96%E5%8D%AB%E7%BB%84%E7%BB%87/" class="post-title-link" itemprop="url">如何看待特朗普宣布暂停资助世卫组织</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-15 21:26:42 / Modified: 21:27:10" itemprop="dateCreated datePublished" datetime="2020-04-15T21:26:42-04:00">2020-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>抖个机灵：</p>
<p>建议WHO立刻改口，不再夸奖中国防疫措施好，应当宣传美国防疫措施好，并称：</p>
<p>“<strong>美国人民处于低风险中，可以随时复工。具有如此发达的医疗技术，美国复工不存在任何风险。</strong>”</p>
<p>特朗普：复工有了理论保障，立刻开始大规模复工，经济有了恢复，特朗普高兴坏了。</p>
<p>WHO：有经费，高兴坏了。</p>
<p>新冠病毒：可以指数传播繁殖，高兴坏了。</p>
<p>中国：出口美国的外贸恢复，可以赚钱，高兴坏了。</p>
<p>何乐而不为呢？</p>
<p>百姓：坏了（未能发声，骂两句推特被封，因此不高兴大家也看不到）</p>
<hr>
<p>正经的回答：</p>
<p>说句实话，美国政客到现在为止的行为表现，以及美股从特朗普四连断到现在的表现，都可以证明一个问题：<strong>百姓死，与我何干？</strong></p>
<p>Trump从未关心过人民的死活，在资本主义（或者说功利主义的角度看）拯救生命太贵，并且死的大多还是老年人，这些人需要社会的投入，却难以有什么产出。所以Trump可以做出这么多匪夷所思的决定。这在<strong>它（人格化的资本，是人乎？非人也。）</strong>眼里看来，是减轻负债的举动。</p>
<p>在道德和利益的两端，Trump坚定地站在了利益的一侧。</p>
<p>我曾经看过一本书《公正：该如何是好？》，里面就引用过这么一个小说：厄休拉·勒吉恩的《离开欧麦拉城的人》，讨论（讽刺）过目前这种现状。（<strong>这小说是我的语文作文素材……</strong>）</p>
<p>这个小说描述了一个天堂般的欧麦拉城，这里就像美国一样，人人有丰富的资源，幸福感爆表，想做什么就做什么，风调雨顺，年年丰收，人们自由自在，无所约束。</p>
<blockquote>
<p>在一阵惊飞了燕子的喧嚣铃声里，夏季庆典降临到欧梅拉斯这个醒目地矗立在海边的城市。港湾里船舶的帆缆上到处挂着旗子。游龘行队伍穿过红色房顶彩绘墙壁的房屋之间的街道，长满青苔的古老花园和马路的树荫，又经过漂亮的公园和公共建筑。身穿紫红和灰色长袍的老人们非常庄重，工匠大师们则严肃而安静，快乐的少妇们抱着孩子边走边聊天。别的街道上，音乐节奏越来越快，不时飘来铜铃和铃鼓的声音。人们开始跳舞，整个游龘行就是跳舞。孩子们蹦来蹦去，他们尖声的笑闹像燕子一样穿过歌声和乐声。所有的游龘行队伍都向城北进发，那儿有一大片丰美的水草，叫做“绿地”。瘦长胳膊的男孩女孩们脚上沾满泥巴，趁比赛前遛遛自己不听话的马儿。这些马都没上马具，只套着根缰绳，也没有嚼子。他们的鬃毛被编成金色银色绿色的很多条。他们实在太兴奋了，全都张着鼻孔，跳跃着，互相炫耀，马大概是唯一一种把人类庆典当成自己的事的动物。 <strong>远离北边和西边群山的海湾里，就是被山半包围的欧梅拉斯。早晨的空气是如此纯净，以至于可以看见深蓝的天幕下十八座戴着雪冠的山峰上，阳光燃烧起白金色的火焰。城里刮着风，把点缀赛马场的旗子吹得上下翻飞不时啪啪作响。在宽阔鲜绿的静谧草地上可以听见音乐在城市街道里盘旋，忽远忽近不停地移动。空气里淡淡的令人愉快的香甜一次次聚拢来，随即又被打散，融入铃铛的巨大快乐声响里。</strong></p>
</blockquote>
<p>但是，为了维持这种和平幸福（美国的经济），欧麦拉城必须做一件事情，那就是<strong>虐待一个孩子（牺牲老年人，让他们感染后自生自灭）</strong>。</p>
<p>如果你想要<strong>保护这个孩子（封城，保护老弱病残），那么整个城市的幸福快乐，风调雨顺，都会在顷刻间化为乌有（经济GDP马上垮掉）</strong></p>
<blockquote>
<p><strong>欧梅拉斯的公民，所有人都知道它。有些人去看过它，另一些只知道它在那就好，总之他们全都知道。有人明白其中原因，也有人不明白，不过有一点他们都清楚：他们城市的美景，他们之间温和的友情，他们孩子的健康，他们学者的智慧，他们工匠的技艺，甚至他们的好收成和风调雨顺的天气都无一例外地依赖于那孩子令人厌恶的惨状。</strong><br>孩子们一般是在八到十二岁之间，只要他们看起来明白事理了，就会被告知这件事。去看那个小孩的大多是年轻人，虽然时不时也会有个把成年人去去。无论对他们把这件事解释得怎样详细，<strong>这些年轻的观众还是会对眼前的情景感到震惊又恶心，他们一度自以为是高出“嫌恶”这种心情，不会为其所影响的。尽管早有完备的解释，他们还是会生气，感到怒不可遏或软弱无力。他们想为这个小孩做点事，但是却完全无事可做。如果这小孩离开这令人作呕的地方，被带到阳光下，洗干净，再让他吃饱，让他舒舒服服的，那当然是好事。但是如果这样做了的话，欧梅拉斯全部的繁荣、美丽、欢乐都会在顷刻间化为乌有。</strong>这是必然的。把欧梅拉斯所有的善良、优雅都拿去交换那一点点的善举，把千百个快乐的机会都拿丢开仅仅为了一点点安心，那无异于把罪恶请进欧梅拉斯。 所以可想而知那里的规定无疑是非常严格的：<strong>就连一句同情的话也不许和那个小孩讲。</strong><br><strong>它看上去大概六岁，但实际上已经快要十岁了。它是个低能儿。也许是天生低能，也许是恐惧，营养不良和无人照管把它变成低能。它弓着背，坐在离水桶和两个拖把最远的角落，抠抠鼻子，偶尔漫不经心地摸摸自己的脚趾</strong>和生殖器。它怕这拖把。他觉得拖把很可怕，它闭上眼睛，但是它知道拖把还在那，们还是锁着的，没有人会来。从来没有人来过，除了有时候——这孩子没什么时间观念——有时候门咯咯作响，然后就开了，门口站着一个或几个人。他们中有一个会进屋，踢踢这小孩，让它站起来。其他人从来不会走近，只是用恐惧厌恶的眼神往里瞧。盛食物的碗和盛水的钵被匆匆填满，然后门又被锁上，眼睛消失了。站在门口的人从来不说话，但是这小孩不是生来就住在这工具间里的，它还记得阳光和母亲的声音。<strong>“我一定不淘气。”它说，“请放我出去，我一定乖乖的，不淘气。”他们从不回答。孩子在过去晚上总大声呼救，大声地哭，而且哭很久，但是现在，只是发出一种“哎——啊，哎——啊”的哀鸣，话也说得越来越少了。它瘦极了，瘦到腿肚子都没有，肚子鼓着，每天就靠半碗玉米面和一点动物脂肪维持生命。它赤身裸龘体，臀部和大腿是一大串化脓的疮，因为它总是坐在自己的屎尿里。</strong><br><strong>凡是见过那个孩子，意识到那个可怕的悖论的年轻人常常是哭着回家的，要不就是愤怒得哭不出来。他们会想上几周或几年，不过随着时间的流逝，他们就会明白即使那个小孩被放出来了，它也不能从自由中得到任何好处：肯定会有一点点关于温饱的模糊的满足，但也就只是多了这么一点点。去弄清楚任何真正的快乐和满足都是低级且低能的。它被恐吓得太久了，以至于害怕自由，它过的生活太没教养了，以至于它不会对人类应有的待遇做出任何反应。事实上，它已经这样生活了很久了，要是没有墙壁来保护它，没有黑暗来遮蔽它的眼睛，没有那些污秽让它坐卧它多半会死的。</strong></p>
</blockquote>
<p>讽刺吗？这就是“生命和尊严可以被金钱衡量”的后果，是Trump所希望的样子。</p>
<p>我认为，人类不应该这样，我们从一个细胞开始进行奇迹般地进化了几十亿年，从自然那里夺得了科学的权柄，从人性那里衡量了我们存在于宇宙间的意义。一个立于天地之间的伟大的文明的发展，是逐渐退离了愚昧，发展我们的道德的过程。</p>
<p>在这个过程中，我们为什么要倒退回去？要知道，我们应该给<strong>岁月以文明，而不是给文明以岁月</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/14/%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">九种跨域方式实现原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-14 12:18:59 / Modified: 12:26:38" itemprop="dateCreated datePublished" datetime="2020-04-14T12:18:59-04:00">2020-04-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。</p>
<h2 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h2><h3 id="1-什么是同源策略及其限制内容？"><a href="#1-什么是同源策略及其限制内容？" class="headerlink" title="1.什么是同源策略及其限制内容？"></a>1.什么是同源策略及其限制内容？</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p><img src="../images/image-20200414122053700.png" alt="image-20200414122053700"></p>
<p><strong>同源策略限制内容有：</strong></p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求发送后，结果被浏览器拦截了</li>
</ul>
<p>但是有三个标签是允许跨域加载资源：</p>
<ul>
<li><pre><code class="html"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span>
<span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;html</span><br><span class="line">  &lt;link href&#x3D;XXX&gt;</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><pre><code class="html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span>
<span class="handlebars"><span class="xml"><span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.常见跨域场景</span><br><span class="line"></span><br><span class="line">**当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</span><br><span class="line"></span><br><span class="line">![image-20200414122216907](..&#x2F;images&#x2F;image-20200414122216907.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特别说明两点：</span><br><span class="line"></span><br><span class="line">**第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。**</span><br><span class="line"></span><br><span class="line">**第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”**。</span><br><span class="line"></span><br><span class="line">这里你或许有个疑问：**请求跨域了，那么请求到底发出去没有？**</span><br><span class="line"></span><br><span class="line">**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了**。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</span><br><span class="line"></span><br><span class="line">## 二、跨域解决方案</span><br><span class="line"></span><br><span class="line">### 1.jsonp</span><br><span class="line"></span><br><span class="line">#### 1) JSONP原理</span><br><span class="line"></span><br><span class="line">**利用 &#96;&#96; 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**</span><br><span class="line"></span><br><span class="line">#### 2) JSONP和AJAX对比</span><br><span class="line"></span><br><span class="line">JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</span><br><span class="line"></span><br><span class="line">#### 3) JSONP优缺点</span><br><span class="line"></span><br><span class="line">JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**</span><br><span class="line"></span><br><span class="line">#### 4) JSONP的实现流程</span><br><span class="line"></span><br><span class="line">- 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</span><br><span class="line">- 创建一个&#96;&#96;标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback&#x3D;show）。</span><br><span class="line">- 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是&#96;show(&#39;我不爱你&#39;)&#96;。</span><br><span class="line">- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</span><br><span class="line"></span><br><span class="line">在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javascript</span><br><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">function jsonp(&#123; url, params, callback &#125;) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    let script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">    window[callback] &#x3D; function(data) &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      document.body.removeChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params &#x3D; &#123; ...params, callback &#125; &#x2F;&#x2F; wd&#x3D;b&amp;callback&#x3D;show</span><br><span class="line">    let arrs &#x3D; []</span><br><span class="line">    for (let key in params) &#123;</span><br><span class="line">      arrs.push(&#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src &#x3D; &#96;$&#123;url&#125;?$&#123;arrs.join(&#39;&amp;&#39;)&#125;&#96;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;say&#39;,</span><br><span class="line">  params: &#123; wd: &#39;Iloveyou&#39; &#125;,</span><br><span class="line">  callback: &#39;show&#39;</span><br><span class="line">&#125;).then(data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></span></span></span>
</code></pre>
</li>
</ul>
<p>上面这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show(&#39;我不爱你&#39;)</code>，最后会运行show()这个函数，打印出’我不爱你’</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.get(<span class="string">'/say'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; wd, callback &#125; = req.query</span><br><span class="line">  <span class="built_in">console</span>.log(wd) <span class="comment">// Iloveyou</span></span><br><span class="line">  <span class="built_in">console</span>.log(callback) <span class="comment">// show</span></span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>('我不爱你')`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-jQuery的jsonp形式"><a href="#5-jQuery的jsonp形式" class="headerlink" title="5) jQuery的jsonp形式"></a>5) jQuery的jsonp形式</h4><p><strong>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:<span class="string">"http://crossdomain.com/jsonServerResponse"</span>,</span><br><span class="line">dataType:<span class="string">"jsonp"</span>,</span><br><span class="line">type:<span class="string">"get"</span>,<span class="comment">//可以省略</span></span><br><span class="line">jsonpCallback:<span class="string">"show"</span>,<span class="comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span></span><br><span class="line">jsonp:<span class="string">"callback"</span>,<span class="comment">//-&gt;把传递函数名的那个形参callback，可省略</span></span><br><span class="line">success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-cors"><a href="#2-cors" class="headerlink" title="2.cors"></a>2.cors</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p>
<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>
<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>
<h4 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1) 简单请求"></a>1) 简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求</p>
<p>条件1：使用下列方法之一：</p>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
<p>条件2：Content-Type 的值仅限于下列三者之一：</p>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p>
<h4 id="2-复杂请求"><a href="#2-复杂请求" class="headerlink" title="2) 复杂请求"></a>2) 复杂请求</h4><p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
<p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>)</span><br><span class="line"><span class="comment">// 预检的存活时间</span></span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">  res.end() </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义后台返回的内容</span></span><br><span class="line">app.put(<span class="string">'/getData'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.end(<span class="string">'我不爱你'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">let xhr = new XMLHttpRequest()</span><br><span class="line">document.cookie = 'name=xiamen' // cookie不能跨域</span><br><span class="line">xhr.withCredentials = true // 前端设置是否带cookie</span><br><span class="line">xhr.open('PUT', 'http://localhost:4000/getData', true)</span><br><span class="line">xhr.setRequestHeader('name', 'xiamen')</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (xhr.readyState === 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status <span class="tag">&lt; <span class="attr">300</span>) || <span class="attr">xhr.status</span> === <span class="string">304)</span> &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">console.log</span>(<span class="attr">xhr.response</span>)</span></span><br><span class="line"><span class="tag">      //得到响应头，后台需设置<span class="attr">Access-Control-Expose-Headers</span></span></span><br><span class="line"><span class="tag">      <span class="attr">console.log</span>(<span class="attr">xhr.getResponseHeader</span>('<span class="attr">name</span>'))</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag"><span class="attr">xhr.send</span>()</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">//<span class="attr">server1.js</span></span></span><br><span class="line"><span class="tag"><span class="attr">let</span> <span class="attr">express</span> = <span class="string">require(</span>'<span class="attr">express</span>');</span></span><br><span class="line"><span class="tag"><span class="attr">let</span> <span class="attr">app</span> = <span class="string">express();</span></span></span><br><span class="line"><span class="tag"><span class="attr">app.use</span>(<span class="attr">express.static</span>(<span class="attr">__dirname</span>));</span></span><br><span class="line"><span class="tag"><span class="attr">app.listen</span>(<span class="attr">3000</span>);</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">//<span class="attr">server2.js</span></span></span><br><span class="line"><span class="tag"><span class="attr">let</span> <span class="attr">express</span> = <span class="string">require(</span>'<span class="attr">express</span>')</span></span><br><span class="line"><span class="tag"><span class="attr">let</span> <span class="attr">app</span> = <span class="string">express()</span></span></span><br><span class="line"><span class="tag"><span class="attr">let</span> <span class="attr">whitList</span> = <span class="string">[</span>'<span class="attr">http:</span>//<span class="attr">localhost:3000</span>'] //设置白名单</span></span><br><span class="line"><span class="tag"><span class="attr">app.use</span>(<span class="attr">function</span>(<span class="attr">req</span>, <span class="attr">res</span>, <span class="attr">next</span>) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">let</span> <span class="attr">origin</span> = <span class="string">req.headers.origin</span></span></span><br><span class="line"><span class="tag">  <span class="attr">if</span> (<span class="attr">whitList.includes</span>(<span class="attr">origin</span>)) &#123;</span></span><br><span class="line"><span class="tag">    // 设置哪个源可以访问我</span></span><br><span class="line"><span class="tag">    <span class="attr">res.setHeader</span>('<span class="attr">Access-Control-Allow-Origin</span>', <span class="attr">origin</span>)</span></span><br><span class="line"><span class="tag">    // 允许携带哪个头访问我</span></span><br><span class="line"><span class="tag">    <span class="attr">res.setHeader</span>('<span class="attr">Access-Control-Allow-Headers</span>', '<span class="attr">name</span>')</span></span><br><span class="line"><span class="tag">    // 允许哪个方法访问我</span></span><br><span class="line"><span class="tag">    <span class="attr">res.setHeader</span>('<span class="attr">Access-Control-Allow-Methods</span>', '<span class="attr">PUT</span>')</span></span><br><span class="line"><span class="tag">    // 允许携带<span class="attr">cookie</span></span></span><br><span class="line"><span class="tag">    <span class="attr">res.setHeader</span>('<span class="attr">Access-Control-Allow-Credentials</span>', <span class="attr">true</span>)</span></span><br><span class="line"><span class="tag">    // 预检的存活时间</span></span><br><span class="line"><span class="tag">    <span class="attr">res.setHeader</span>('<span class="attr">Access-Control-Max-Age</span>', <span class="attr">6</span>)</span></span><br><span class="line"><span class="tag">    // 允许返回的头</span></span><br><span class="line"><span class="tag">    <span class="attr">res.setHeader</span>('<span class="attr">Access-Control-Expose-Headers</span>', '<span class="attr">name</span>')</span></span><br><span class="line"><span class="tag">    <span class="attr">if</span> (<span class="attr">req.method</span> === <span class="string">'OPTIONS'</span>) &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">res.end</span>() // <span class="attr">OPTIONS</span>请求不做任何处理</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">  <span class="attr">next</span>()</span></span><br><span class="line"><span class="tag">&#125;)</span></span><br><span class="line"><span class="tag"><span class="attr">app.put</span>('/<span class="attr">getData</span>', <span class="attr">function</span>(<span class="attr">req</span>, <span class="attr">res</span>) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">console.log</span>(<span class="attr">req.headers</span>)</span></span><br><span class="line"><span class="tag">  <span class="attr">res.setHeader</span>('<span class="attr">name</span>', '<span class="attr">jw</span>') //返回一个响应头，后台需设置</span></span><br><span class="line"><span class="tag">  <span class="attr">res.end</span>('我不爱你')</span></span><br><span class="line"><span class="tag">&#125;)</span></span><br><span class="line"><span class="tag"><span class="attr">app.get</span>('/<span class="attr">getData</span>', <span class="attr">function</span>(<span class="attr">req</span>, <span class="attr">res</span>) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">console.log</span>(<span class="attr">req.headers</span>)</span></span><br><span class="line"><span class="tag">  <span class="attr">res.end</span>('我不爱你')</span></span><br><span class="line"><span class="tag">&#125;)</span></span><br><span class="line"><span class="tag"><span class="attr">app.use</span>(<span class="attr">express.static</span>(<span class="attr">__dirname</span>))</span></span><br><span class="line"><span class="tag"><span class="attr">app.listen</span>(<span class="attr">4000</span>)</span></span><br></pre></td></tr></table></figure>

<p>上述代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p>
<h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p>
<blockquote>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
</blockquote>
<ul>
<li>message: 将要发送到其他 window的数据。</li>
<li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/b.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> //等它加载完触发一个事件</span><br><span class="line">  //内嵌在http://localhost:3000/a.html</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>)</span></span><br><span class="line"><span class="actionscript">        frame.contentWindow.postMessage(<span class="string">'我爱你'</span>, <span class="string">'http://localhost:4000'</span>) <span class="comment">//发送数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">//接受返回数据</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(e.data) <span class="comment">//我不爱你</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// b.html</span><br><span class="line">  window.onmessage = function(e) &#123;</span><br><span class="line">    console.log(e.data) //我爱你</span><br><span class="line">    e.source.postMessage('我不爱你', e.origin)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4.websocket"></a>4.websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// socket.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000'</span>);</span></span><br><span class="line"><span class="actionscript">    socket.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      socket.send(<span class="string">'我爱你'</span>);<span class="comment">//向服务器发送数据</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    socket.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data);<span class="comment">//接收服务器返回的数据</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// server.js</span><br><span class="line">let express = require('express');</span><br><span class="line">let app = express();</span><br><span class="line">let WebSocket = require('ws');//记得安装ws</span><br><span class="line">let wss = new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class="line">wss.on('connection',function(ws) &#123;</span><br><span class="line">  ws.on('message', function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    ws.send('我不爱你')</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-Node中间件代理-两次跨域"><a href="#5-Node中间件代理-两次跨域" class="headerlink" title="5. Node中间件代理(两次跨域)"></a>5. Node中间件代理(两次跨域)</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> 代理服务器，需要做以下几个步骤：</p>
<ul>
<li>接受客户端请求 。</li>
<li>将请求 转发给服务器。</li>
<li>拿到服务器 响应 数据。</li>
<li>将 响应 转发给客户端。</li>
</ul>
<p><img src="../images/image-20200414122242142.png" alt="image-20200414122242142"></p>
<p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html(http://127.0.0.1:5500)</span></span><br><span class="line"> &lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">      $.ajax(&#123;</span></span><br><span class="line"><span class="regexp">        url: 'http:/</span><span class="regexp">/localhost:3000',</span></span><br><span class="line"><span class="regexp">        type: 'post',</span></span><br><span class="line"><span class="regexp">        data: &#123; name: 'xiamen', password: '123456' &#125;,</span></span><br><span class="line"><span class="regexp">        contentType: 'application/</span>json;charset=utf<span class="number">-8</span><span class="string">',</span></span><br><span class="line"><span class="string">        success: function(result) &#123;</span></span><br><span class="line"><span class="string">          console.log(result) // &#123;"title":"fontend","password":"123456"&#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        error: function(msg) &#123;</span></span><br><span class="line"><span class="string">          console.log(msg)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">     &lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// server1.js 代理服务器(http://localhost:3000)</span></span><br><span class="line"><span class="string">const http = require('</span>http<span class="string">')</span></span><br><span class="line"><span class="string">// 第一步：接受客户端请求</span></span><br><span class="line"><span class="string">const server = http.createServer((request, response) =&gt; &#123;</span></span><br><span class="line"><span class="string">  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span></span><br><span class="line"><span class="string">  response.writeHead(200, &#123;</span></span><br><span class="line"><span class="string">    '</span>Access-Control-Allow-Origin<span class="string">': '</span>*<span class="string">',</span></span><br><span class="line"><span class="string">    '</span>Access-Control-Allow-Methods<span class="string">': '</span>*<span class="string">',</span></span><br><span class="line"><span class="string">    '</span>Access-Control-Allow-Headers<span class="string">': '</span>Content-Type<span class="string">'</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">  // 第二步：将请求转发给服务器</span></span><br><span class="line"><span class="string">  const proxyRequest = http</span></span><br><span class="line"><span class="string">    .request(</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        host: '</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">',</span></span><br><span class="line"><span class="string">        port: 4000,</span></span><br><span class="line"><span class="string">        url: '</span>/<span class="string">',</span></span><br><span class="line"><span class="string">        method: request.method,</span></span><br><span class="line"><span class="string">        headers: request.headers</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      serverResponse =&gt; &#123;</span></span><br><span class="line"><span class="string">        // 第三步：收到服务器的响应</span></span><br><span class="line"><span class="string">        var body = '</span><span class="string">'</span></span><br><span class="line"><span class="string">        serverResponse.on('</span>data<span class="string">', chunk =&gt; &#123;</span></span><br><span class="line"><span class="string">          body += chunk</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">        serverResponse.on('</span>end<span class="string">', () =&gt; &#123;</span></span><br><span class="line"><span class="string">          console.log('</span>The data is <span class="string">' + body)</span></span><br><span class="line"><span class="string">          // 第四步：将响应结果转发给浏览器</span></span><br><span class="line"><span class="string">          response.end(body)</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">    .end()</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">server.listen(3000, () =&gt; &#123;</span></span><br><span class="line"><span class="string">  console.log('</span>The proxyServer is running at http:<span class="comment">//localhost:3000')</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server2.js(http://localhost:4000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">title</span>: <span class="string">'fontend'</span>, <span class="attr">password</span>: <span class="string">'123456'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">    response.end(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">4000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://localhost:4000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;}</code></p>
<h3 id="6-nginx反向代理"><a href="#6-nginx反向代理" class="headerlink" title="6.nginx反向代理"></a>6.nginx反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p>
<p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<p>先下载<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// proxy服务器</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">81</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.domain1.com;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        <span class="attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin http://www.domain1.com;  <span class="comment">#当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过命令行<code>nginx -s reload</code>启动nginx</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// a.html(http://localhost:3000/b.html)</span><br><span class="line"> <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">onload</span>=<span class="string">"load()"</span> <span class="attr">id</span>=<span class="string">"iframe"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">let</span> first = <span class="literal">true</span></span></span><br><span class="line"><span class="actionscript">   <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span></span><br><span class="line"><span class="actionscript">   <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">     if(first)&#123;</span><br><span class="line"><span class="actionscript">     <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="javascript">       <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="actionscript">       iframe.src = <span class="string">'http://localhost:3000/b.html'</span>;</span></span><br><span class="line"><span class="actionscript">       first = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">     &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">     <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(iframe.contentWindow.name);</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b.html为中间代理页，与a.html同域，内容为空。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// c.html(http://localhost:4000/c.html)</span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.name = <span class="string">'我不爱你'</span>  </span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8.location.hash +  iframe"></a>8.location.hash +  iframe</h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"> <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html#iloveyou"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//检测hash的变化</span></span></span><br><span class="line"><span class="javascript">     <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line">   &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// b.html</span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.parent.parent.location.hash = location.hash </span></span><br><span class="line"><span class="actionscript">   <span class="comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// c.html</span><br><span class="line">console.log(location.hash);</span><br><span class="line"> let iframe = document.createElement('iframe');</span><br><span class="line"> iframe.src = 'http://localhost:3000/b.html#idontloveyou';</span><br><span class="line"> document.body.appendChild(iframe);</span><br></pre></td></tr></table></figure>

<h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> helloa</span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://b.zf1.cn:3000/b.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">onload</span>=<span class="string">"load()"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'zf1.cn'</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(frame.contentWindow.a);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   hellob</span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="built_in">document</span>.domain = <span class="string">'zf1.cn'</span></span></span><br><span class="line"><span class="actionscript">     <span class="keyword">var</span> a = <span class="number">100</span>;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul>
<li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li>
<li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li>
<li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li>
<li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/13/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/13/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0React/" class="post-title-link" itemprop="url">如何学习React</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-13 12:21:34 / Modified: 12:23:16" itemprop="dateCreated datePublished" datetime="2020-04-13T12:21:34-04:00">2020-04-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="如何学习React"><a href="#如何学习React" class="headerlink" title="如何学习React"></a>如何学习React</h1><p>如果你是一个 React (或者前端) 新手, 出于以下的原因, 你可能会对这个生态圈感到困惑:</p>
<ul>
<li>React 的目标群体历来是喜欢尝试新事物的开发者和前端专家.</li>
<li>Facebook 开源的内容是应用在他们的实际应用中, 因此他们没有关注那些比 Facebook 小的工程需求.</li>
<li>现有的 React 指引水平参差不齐.</li>
</ul>
<p>在本文中, 我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础.</p>
<h2 id="如何踏入-React-生态圈"><a href="#如何踏入-React-生态圈" class="headerlink" title="如何踏入 React 生态圈"></a>如何踏入 React 生态圈</h2><p>所有的软件都是建立在某个技术栈之上的, 你需要对整个技术栈有足够深入的理解, 才能建造你的应用. 为什么 React 生态圈的工具似乎总让人感觉压力山大呢, 因为它总是以错误的顺序被解释:</p>
<p>你应该按照以下的顺序进行学习, <strong>而不是跳着学或者同时学习</strong>:</p>
<ul>
<li><a href="#user-content-学习-react-本身">React</a></li>
<li><a href="#user-content-学习-npm"><code>npm</code></a></li>
<li><a href="#user-content-学习-javascript-打包工具">JavaScript “打包工具”</a></li>
<li><a href="#user-content-学习-es6">ES6</a></li>
<li><a href="#user-content-学习路由-routing">Routing</a></li>
<li><a href="#user-content-学习-flux">Flux</a></li>
</ul>
<p><strong>你不需要把这些都学完才去使用 React.</strong> 只需要在你遇到问题需要解决的时候, 才进入下一步的学习.</p>
<p>另外, 在 React 社区中, 有一些前沿主题是经常被提及到的, 以下的这些主题很有意思, 但也很难弄懂, 所以它们远没有上面的主题流行, <strong>大多数应用也不需要用到这些.</strong></p>
<ul>
<li><a href="#user-content-学习内联样式">内联样式</a></li>
<li><a href="#user-content-学习服务器端渲染">服务器端渲染</a></li>
<li><a href="#user-content-学习-immutablejs">Immutable.js</a></li>
<li><a href="#user-content-学习-relay-falcor-等">Relay, Falcor 等</a></li>
</ul>
<h2 id="学习-React-本身"><a href="#学习-React-本身" class="headerlink" title="学习 React 本身"></a>学习 React 本身</h2><p>有一种常见的误解是: 你需要花费大量时间在配置工具上, 然后才开始学习 React. 在官方文档里, 你可以找到 <a href="https://facebook.github.io/react/docs/getting-started.html#quick-start-without-npm" target="_blank" rel="noopener">copy-paste HTML template</a>. 只需要保存为 <code>.html</code> 文件, 你就可以马上开始学习了. <strong>这个步骤不需要任何工具, 你也无需额外学习工具使用, 直到你能熟练掌握 React 基础.</strong></p>
<p>我依然觉得, 学习 React 最简单的方法是通过官方教程 <a href="https://facebook.github.io/react/docs/tutorial.html" target="_blank" rel="noopener">the official tutorial</a>.</p>
<h2 id="学习-npm"><a href="#学习-npm" class="headerlink" title="学习 npm"></a>学习 <code>npm</code></h2><p><code>npm</code> 是 Node.js 包管理工具, 也是前端工程师和设计师分享 JavaScript 代码最流行的方式. 它包含了名为 <code>CommonJS</code> 的模块系统, 让你可以安装 JavaScript 写的命令行工具. 作为背景知识, 可以阅读 <a href="http://0fps.net/2013/01/22/commonjs-why-and-how/" target="_blank" rel="noopener">这篇文章</a> 了解 <code>CommonJS</code> 对于浏览器的重要性, 阅读  <a href="http://wiki.commonjs.org/wiki/Introduction" target="_blank" rel="noopener">CommonJS Spec Wiki</a> 了解关于 <code>CommonJS</code> API 的更多内容</p>
<p>在 React 生态圈中, 大部分可重用的组件、库和工具遵循 <code>CommonJS</code> 模块规范, 可通过 <code>npm</code> 来安装.</p>
<h2 id="学习-JavaScript-打包工具"><a href="#学习-JavaScript-打包工具" class="headerlink" title="学习 JavaScript 打包工具"></a>学习 JavaScript 打包工具</h2><p>出于若干技术原因, <code>CommonJS</code> 模块 (也就是 <code>npm</code> 里的所有内容) 不能直接用到浏览器. 你需要一个 JavaScript “打包工具(bundler)” 来把这些模块打包成 <code>.js</code> 文件, 使你可以在网页中通过 <code>&lt;script&gt;</code> 标签引入它们.</p>
<p>JavaScript 打包工具包括 <code>webpack</code> 和 <code>browserify</code>. 它们都是好的选择, 但我个人更喜欢 <code>webpack</code> , 因为它有许多功能简化大型应用开发. 鉴于 webpack 文档可能令人感到困惑, 我也写了两篇文章: <a href="https://github.com/petehunt/react-webpack-template" target="_blank" rel="noopener">plug-and-play template for getting started</a> 和针对更复杂用例的 <a href="https://github.com/petehunt/webpack-howto" target="_blank" rel="noopener">how-to guide for webpack</a>.</p>
<p>要记住的一点: <code>CommonJS</code> 使用了 <code>require()</code> 函数来引入模块, 因此许多人对此感到疑惑, 并认为需要导入 <code>require.js</code> 到工程里. 出于若干技术原因, 我建议你避免使用 <code>require.js</code>. 它在 React 生态圈并不流行.</p>
<h2 id="学习-ES6"><a href="#学习-ES6" class="headerlink" title="学习 ES6"></a>学习 ES6</h2><p>在 JSX (你会在 React tutorial 中学习到) 以外, 你可能会注意到 React 例子中一些有趣的语法. 这被称为 ECMAScript6, 是 JavaScript 的最新版本. 由于 ES6 很新, 你可能还没学习到, 浏览器也可能尚未兼容, 但别担心, 通过合适的配置, 你的打包工具会为你自动转换成兼容代码.</p>
<p>如果你只想要使用 React 来把事情做完, <strong>你可以跳过 ES6 的学习,</strong> 或者留到以后再学习.</p>
<p>你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件. 这并不是真的, 大多数人 (包括 Facebook) 用的还是 <code>React.createClass()</code>.</p>
<h2 id="学习路由-routing"><a href="#学习路由-routing" class="headerlink" title="学习路由 (routing)"></a>学习路由 (routing)</h2><p>“单页面应用” 是时下的技术热点. 当网页加载完成, 用户点击链接或者按钮的时候, JavaScript 会更新页面和改变地址栏, 但网页不会刷新. 地址栏的管理就是通过 <strong>路由(router)</strong> 来完成的.</p>
<p>目前 React 生态圈最受欢迎的路由解决方案是 <a href="https://github.com/rackt/react-router" target="_blank" rel="noopener">react-router</a>. 如果你正在创建一个单页面应用, 有什么理由不去使用它呢?</p>
<p><strong>如果你创建的并非单页面应用, 请不要使用路由.</strong> 无论如何, 大部分项目都是从大型应用中的小组件开始的.</p>
<h2 id="学习内联样式"><a href="#学习内联样式" class="headerlink" title="学习内联样式"></a>学习内联样式</h2><p>在 React 出现之前, 很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表. 鉴于 React 使开发可重用组件变得容易, 你的样式表可以变得没那么复杂了. 社区中许多人 (包括我) 正尝试完全抛弃样式表.</p>
<p>由于一些原因, 其实这是个相当疯狂的主意. 这让媒体查询 (media quries) 更加困难了, 而且这种技术可能有性能上的局限性. <strong>当你开始用 React 的时候, 只要用你平常使用的方法去写就好了.</strong></p>
<p>一旦你找到了用 React 开发的感觉, 你就可以关注那些可作为替代的技术了. 其中一种流行技术是 <a href="https://en.bem.info/" target="_blank" rel="noopener">BEM</a>. 我建议你逐渐停用 CSS 预处理器, 因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经<a href="https://www.youtube.com/watch?v=VkTCL6Nqm6Y" target="_blank" rel="noopener">在 OSCON 上发表过关于这个的演讲</a>). 说了这么多, 总之 React 就像其他 JavaScript 库一样, 可以和 CSS 预处理器很好地配合工作.</p>
<p>另一种可选项是 <a href="http://glenmaddern.com/articles/css-modules" target="_blank" rel="noopener">CSS 模块</a>, 更具体地说, 是 <a href="https://github.com/gajus/react-css-modules" target="_blank" rel="noopener">react-css-modules</a>. 虽然有了这些 CSS 模块, 你还是写 CSS (或者是 SASS/LESS/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件. 你也不需要担心用到 BEM 那样的方法学去管理类名, 因为模块系统在底层已经帮你处理好了.</p>
<h2 id="学习服务器端渲染"><a href="#学习服务器端渲染" class="headerlink" title="学习服务器端渲染"></a>学习服务器端渲染</h2><p>服务器端渲染经常被称为 “通用应用” 或 “同构应用”. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能, 因为用户不用等到 JS 下载完才看到初始界面, 并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成.</p>
<p>如果你发现首屏渲染速度过慢, 或者想提高网站在搜索引擎的排行, 你就需要服务器端渲染了. 尽管 Google 现在也会索引客户端渲染的内容, 但截至 2016 年 1 月, 这样做仍被证实会对排行有负面影响, 这可能是由于客户端渲染的性能问题所造成的.</p>
<p>服务器端渲染还需要许多工具的辅助, 因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的, 你应该先构建你的应用, 之后再关心服务器端渲染的问题. 不用担心, 你不需要重写所有组件去支持它.</p>
<h2 id="学习-Flux"><a href="#学习-Flux" class="headerlink" title="学习 Flux"></a>学习 Flux</h2><p>你可能听过 Flux, 不过关于 Flux 有大量的错误资讯.</p>
<p>许多人一坐下来刚开始构建应用, 就认为需要用 Flux 来定义他们的数据模型. <strong>这样采用 Flux 是不对的, Flux 应该在大量组件被建立完成以后才被引入.</strong></p>
<p>React 组件之间存在层级关系. 在很多时候, 你的数据模型也跟随这种层级. 这种情况下, Flux 不会给你很大帮助. 但有些时候, 你的数据模型没有层次, 当你的 React 组件开始接受没有关联的 <code>props</code> 的时候, 或者当小部分组件开始变得复杂的时候, 你才可能需要看看 Flux.</p>
<p><strong>你会知道什么时候需要用 Flux. 如果你不确定是否需要用它, 你就不需要它.</strong></p>
<p>如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 <a href="http://redux.js.org/" target="_blank" rel="noopener">Redux</a>. 当然也有许多其他选择, 你或者会有兴趣尝试使用它们, 但我的建议是只需要用最流行的 Redux 就足够了.</p>
<h2 id="学习-Immutable-js"><a href="#学习-Immutable-js" class="headerlink" title="学习 Immutable.js"></a>学习 Immutable.js</h2><p><a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">Immutable.js</a> 提供了一系列的数据结构, 以帮助解决构造 React 应用时的某些性能问题. 这是一个很棒的库, 你可能会在应用发展的过程里大量用到它, 但直到你在意识到性能问题以前, 它是完全不必要的.</p>
<h2 id="学习-Relay-Falcor-等"><a href="#学习-Relay-Falcor-等" class="headerlink" title="学习 Relay, Falcor 等"></a>学习 Relay, Falcor 等</h2><p>这些技术可以帮你减少 AJAX 请求数, 它们仍然是非常前沿的, 所以如果你没有遇到过多 AJAX 请求的问题, 就不需要用到 Relay 或者 Falcor.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/%E5%AD%A6%E4%B9%A0Spring%E4%B9%8B%E5%89%8D%E8%A6%81%E5%85%88%E5%AD%A6%E4%B9%A0%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/%E5%AD%A6%E4%B9%A0Spring%E4%B9%8B%E5%89%8D%E8%A6%81%E5%85%88%E5%AD%A6%E4%B9%A0%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">学习Spring之前要先学习什么</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-12 03:05:10 / Modified: 03:09:49" itemprop="dateCreated datePublished" datetime="2020-04-12T03:05:10-04:00">2020-04-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开门见山，先放结论。</p>
<p>要开始学习Spring（以IOC和Spring MVC为核心），只需要做好以下准备即可：</p>
<ol>
<li>《Java核心技术》前6章。</li>
<li>Java反射原理（选学）。</li>
<li>Servlet。</li>
</ol>
<p>而想理解上面的结论，则首先必须理解Spring是干什么的。</p>
<p>打开Spring的官方网站，点击projects页面，你会看到一个偌大的结构图。其中列出许多项目，包括：Spring Boot、Spring Cloud 、Spring Data…。对初学来说，乍一看着实吓一跳，完全不知道从何下手。</p>
<p>但透过表现看本质。无论是Spring Data，还是Spring Cloud，都是建立在Spring Framework上的一个个具体领域的应用.</p>
<p>在Spring Framwork中，包含了Spring体系的核心机制及应用，包括IOC、AOP，SpringMVC、Data Access等。而且，即使在Spring Framework内部，各个功能之间也不是水平的，而是存在依赖关系的。</p>
<p>其中最底层，最核心的概念有两个：IOC和AOP。两者之间，尤以IOC为重。</p>
<p>在实践中，Spring全家桶中使用最广泛就是IOC和Spring MVC。从上图中，我们也可以看到，Spring MVC是依赖于IOC的。因此要学习Spring MVC，就必须先学习IOC。</p>
<p>而在公司的内部培训，我都会有意把IOC 和SpringMVC完全独立起来进行，因为并不是所有的工程师（例如测试工程师）都对SpringMVC有需求。</p>
<p>到这里，思路就清晰了。如果要学习Spring，必须掌握的就是IOC。因此，所谓的Spring前置知识，某种意义上，就是Spring IOC的前置知识。</p>
<p>然后，我们再来简单讲解下IOC的概念。</p>
<p>对初学者来说，初听到IOC，会觉得特别高大上。但如果真掰开讲明白，你就会发现其实特别简单。</p>
<p>为了便于理解，我用一个例子的说明。</p>
<p>这里有一个应用，包含两个Jar包，一个是myApp.jar，一个是lib.jar。其中myApp.jar包含了程序的主逻辑，由程序员A编写。lib.jar中定义了一个接口，和该接口的实现类，由程序员员B编写。</p>
<p>如下图：</p>
<p><img src="../images/image-20200412030845603.png" alt="image-20200412030845603"></p>
<p>在lib.jar中，有一个接口Person，两个实现类Student、Teacher。在myApp.jar，通过代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">null</span>；</span><br></pre></td></tr></table></figure>

<p>从而导致myApp.jar依赖于lib.jar。但因为语句Person p只是做了定义，而没有实际赋值。这时候我们就称myApp.jar仅依赖于lib.jar（通过接口Person），但并没有实现“注入”。</p>
<p>然后，我们把程序进一步修改下，如图：</p>
<p><img src="../images/image-20200412030909037.png" alt="image-20200412030909037"></p>
<p>其中修改了语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>

<p>这样，MyApp.jar就把Student的实例“注入”到了对象p中，也就是说，通过new关键字创建对象，这就是最常见的依赖注入方法。</p>
<p>但这种写法有一个很大的缺点，那就是因为myApp.jar不仅依赖于Person接口，还依赖于具体的实现类Student，这是一种明显的<strong>强耦合</strong>。而如果哪天myApp.jar不想使用Student了，而想使用Teacher，那么程序员就不得不回过头来修改myApp.jar的代码。</p>
<p>而在实际应用中，myApp.jar中往往包含了程序主流程。而主流程一旦完成，就应该保持相对稳定。如果有改变，也应该通过扩展的方式。这也就是架构设计中著名的“<strong>开关原则</strong>”，即主业务对修改关闭，对扩展开放。而使用Spring就可以达到这样的目的。</p>
<p>下面我们就引入Spring IOC机制，把代码修改下。如图：</p>
<p><img src="../images/image-20200412030928800.png" alt="image-20200412030928800"></p>
<p>这样，在myApp.jar包中，就把对Person对象的具体注入从代码中移除，代之在spring.xml文件中定义。任何时候，只要修改Spring.xml的配置，就能改变myApp.jar中具体Person对象的注入。从而保证了“开关原则”。</p>
<p>而上面的整个过程，就是通过Spring框架中的IOC机制来实现的。</p>
<p>从中，你也能体察到Spring框架为什么对企业级程序这么重要性。因为企业级程序必然是复杂的，而要解决复杂度的前提就是解耦。可以说，没有解耦，所有企业级应用都会崩溃在千丝万缕的业务逻辑中。</p>
<p>看到这里，你可能已经发现，对Spring的核心概念IOC来说，并没有涉及任何高深的Java语法，最多也就是接口和抽象类。因此学习Spring IOC，参考《Java核心技术》，只要学到前6章就可以了。</p>
<p>因为Spring IOC的核心机制是建立在Java“反射”基础上的。因此，如果你有兴趣继续探究Spring IOC的核心原理，就有必要提前学习下Java与反射相关的概念。</p>
<p>再说下Spring中另一个最常用的功能Spring MVC。</p>
<p>Spring MVC的运行时建立在两个技术基础上：IOC和Servlet。如果不懂IOC，就搞不明不白Spring MVC是如何配置的。如果不懂Servlet，则就搞不理解Spring是如何注入及拦截Servlet消息的。而之后一旦Spring MVC在运行中出了问题，则必然会茫然不知所措。</p>
<p>虽然Spring MVC中的V（view），最常见的输出目标是JSP页面。但因为现代的企业应用越来越倾向于前后端分离，后端系统只负责输出REST接口。因此在Spring MVC框架中，View这一层就没有存在的必要，学习JSP也就没有价值了。</p>
<p>最后，再总结一下学习Spring（以IOC和Spring MVC为核心）必备的前置知识：</p>
<ol>
<li>《Java核心技术》前6章。</li>
<li>Java反射原理（选学）。</li>
<li>Servlet。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/11/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7Clojure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/11/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7Clojure/" class="post-title-link" itemprop="url">如何评价Clojure</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-11 17:36:40 / Modified: 17:37:52" itemprop="dateCreated datePublished" datetime="2020-04-11T17:36:40-04:00">2020-04-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。"><a href="#1-Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。" class="headerlink" title="1.Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。"></a><strong>1.Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键</strong>。</h4><p>首先，因为根植于JVM之上，并且做到了跟Java语言的相互调用，它能吸引很多成熟的Java开发者。其次，它可以使用Java社区丰富的开源软件，不需要从头去构建一个社区，你可以看到很多Clojure开源代码都是简单地包装Java的开源包，但是通过Clojure高度抽象简单的语法提供更便利的使用的方式；<br>第三，由于JVM平台本身的高度成熟和优化，clojure的编译器生成的byte code跟Java编译器生成的byte code并无二致（不完全是），它的性能和稳定性也能马上得到保证，这比从头构建一个新平台成本低得多。</p>
<p>构建于JVM之上，Clojure就是一门“严肃”的语言，而非很多人眼中的Lisp“玩具”语言，你学习后可以马上使用并且实践。但是Clojure又是Lisp方言，Lisp的神奇能力它还都保留，这样兼具美学和实用的语言如何让人不爱？我相信很多熟悉Scheme之类方言的童鞋，并且有Java背景的，都会对Clojure有相见恨晚的感觉。</p>
<h4 id="2-Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The-joy-of-clojure》概括的。"><a href="#2-Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The-joy-of-clojure》概括的。" class="headerlink" title="2.Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The joy of clojure》概括的。"></a><strong>2.Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The joy of clojure》概括的。</strong></h4><p>（1）简单： 鼓励纯函数，极简的语法（少数special form），个人也认为clojure不能算是多范式的语言（有部分OO特性），为了支持多范式引入的复杂度，我们在C++和Scala身上都看到了。<br>（2）专注：前缀运算符不需要去考虑优先级，也没有什么菱形继承的问题，动态类型系统（有利有弊），REPL提供的探索式编程方法（告别修改/编译/运行的死循环，所见即所得）。<br>（3）实用：前面提到，构建在JVM之上，跟Java语言的互操作非常容易。直接调用Java方法，不去发明一套新的调用语法，努力规避Java语言中繁琐的地方(doto,箭头宏等等）。<br>（4）清晰：纯函数（前面提到），immutable var，immutable数据结构，STM避免锁问题。不可变减少了心智的负担，降低了多线程编程的难度，纯函数也更利于测试和调试。<br>（5）一致：语法的一致性：例如doseq和for宏类似，都支持destructring,支持相同的guard语句（when,while）。数据结构的一致性：sequence抽象之上的各种高阶函数。</p>
<p>具体到STM，我个人认为这个特性在日常编程中，其实你用到的机会不多。在web编程里，你的并发模型Web Container已经帮你处理（tomcat,jetty），事务也是数据库帮你处理，几乎找不到场合去使用STM。这个特性在做一些中间件或者底层framework的时候才可能用到。这个特性的设计上面已经提到，跟clojure的设计目标是紧密相关的，跟immutable数据结构也是密不可分，同时它也不是没有代价，事务历史记录和慢事务频繁回滚的代价，有时候你还是需要退回去使用Java那套锁机制，庆幸的是Clojure不阻止你去使用，并且提供了类似locking这样的宏来方便你使用。</p>
<h4 id="3-Scheme我对它的了解也就是做过SICP的习题。"><a href="#3-Scheme我对它的了解也就是做过SICP的习题。" class="headerlink" title="3.Scheme我对它的了解也就是做过SICP的习题。"></a>3.Scheme我对它的了解也就是做过SICP的习题。</h4><p>粗粗看过《Programming Scheme》，两者对比的优缺点似乎谈不上来。需要对Scheme更熟悉的专家来做个对比。</p>
<p><strong>Clojure的设计缺陷不能说是缺陷，这是由于它设计的目标决定的，有得必有失</strong>。</p>
<p>首先还是JVM，基于JVM有种种好处，但是JVM的启动速度实在悲剧，因此用Clojure写一些小的script处理日常事务，显得还是不够得心应手，这样的工作我还是用Ruby，Python的脚本语言来搞定更便捷。不过目前Clojure有一些其他语言之上的实现，比如<a href="https://link.zhihu.com/?target=https%3A//github.com/rouge-lang/rouge">rouge-lang/rouge · GitHub</a> 和 <a href="https://link.zhihu.com/?target=https%3A//github.com/halgari/clojure-py">halgari/clojure-py 路 GitHub</a>  这些实现应该会比JVM的启动快很多（抱歉，我没测试过）。</p>
<p>不仅如此，因为Clojure跟JVM平台的绑定如此之深，并且为了真正发挥Clojure的威力，你还需要去熟悉Java平台的东西，熟悉Java语言、类库、内存模型、GC优化、多线程和网络编程、开源类库等等。可以这样认为：<strong>想成为一个好的Clojure程序员，首先需要是一名好的Java程序员</strong>。这也一定程度上阻碍了Clojure的推广，提高了学习成本。</p>
<p>其次，Clojure的API设计上，有时候不符合你的直觉，而是符合Clojure的哲学，比如contains?函数对vector等数组型集合的调用上。关于这一点，Rich的回答是“<strong>Elegance and familiarity are orthogonal.</strong>”，也就是优雅和熟悉是正交关系的。保持API内在的一致性，比直觉的“熟悉”更重要。Clojure不妥协于你的“直觉”。</p>
<p>第三，弱类型的好处足够多，灵活，减少声明代码，适合探索式编程；同样，坏处也不是没有，没有类型保障，错误可能要等到运行时才能发现，静态代码检查工具也没有办法帮你发现，这就需要你一定程度的测试代码来保证运行时行为。</p>
<p>第四，性能上，虽然clojure生成的字节码已经很高效，也有type hint这样的技术来帮助提升性能，但是会有不少的转型(checkcast)、装箱和拆箱（boxing and unboxing）以及类型判断分支跳转的多余指令，这在一些性能敏感的应用里可能会暴露出来。尽管我认为大多数网站型的应用瓶颈都会落在IO上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/10/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%A3%80%E5%AF%9F%E6%97%A5%E6%8A%A5%E7%A7%B0%E3%80%8E%E7%A6%81%E9%A3%9F%E7%8C%AB%E7%8B%97%E8%82%89%E3%80%8F%E7%AB%8B%E6%B3%95%E6%9C%89%E7%A0%B4%E5%86%B0%E6%84%8F%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%A3%80%E5%AF%9F%E6%97%A5%E6%8A%A5%E7%A7%B0%E3%80%8E%E7%A6%81%E9%A3%9F%E7%8C%AB%E7%8B%97%E8%82%89%E3%80%8F%E7%AB%8B%E6%B3%95%E6%9C%89%E7%A0%B4%E5%86%B0%E6%84%8F%E4%B9%89/" class="post-title-link" itemprop="url">如何看待检察日报称『禁食猫狗肉』立法有破冰意义</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-10 23:31:15 / Modified: 23:32:28" itemprop="dateCreated datePublished" datetime="2020-04-10T23:31:15-04:00">2020-04-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="../images/image-20200410233222992.png" alt="image-20200410233222992"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%9F%BA%E8%BE%9B%E6%A0%BC%E7%9A%84%E3%80%8A%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92%E5%A4%A7%E6%B5%81%E8%A1%8C%E5%B0%86%E6%B0%B8%E8%BF%9C%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%9F%BA%E8%BE%9B%E6%A0%BC%E7%9A%84%E3%80%8A%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92%E5%A4%A7%E6%B5%81%E8%A1%8C%E5%B0%86%E6%B0%B8%E8%BF%9C%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F%E3%80%8B/" class="post-title-link" itemprop="url">如何看待基辛格的《新冠病毒大流行将永远改变世界秩序》</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-09 21:02:19 / Modified: 21:09:06" itemprop="dateCreated datePublished" datetime="2020-04-09T21:02:19-04:00">2020-04-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="新冠疫情会永远改变世界秩序-全文翻译"><a href="#新冠疫情会永远改变世界秩序-全文翻译" class="headerlink" title="新冠疫情会永远改变世界秩序-全文翻译"></a>新冠疫情会永远改变世界秩序-全文翻译</h2><p>基辛格</p>
<p>新冠疫情的这种超现实氛围，让我想起当年突出部战役时，我在84步兵师作为一名年轻人的感受。现在，正如1944年后期，能感觉到一种未成形的危险，不盯着任何具体的人，而是随意打击并毁灭。但老黄历和当下有个重要区别：美国能扛过那时候，是因为被一种终极的国家目的武装了起来。现在，在一个分裂的国家里，要去克服一个在深度和全球广度上都前所未见的困难，高效和有远见的政府是必需的。维持公众信任对社会团结来说至关重要，在各个社会群体之间的关系上、在国际和平与稳定上，也是如此。</p>
<p>国家们能团结、繁荣，是基于一个信念：他们的体制可以<strong>预见灾难、控制其冲击、并恢复稳定</strong>。当新冠疫情结束后，很多国家的体制会被认为是<strong>失败的</strong>。这个论断是否客观公平，已经不重要。现实是，世界将不会再和疫情前一样。在现在去争辩过去，只会让<strong>必须要去做的事</strong>更难做。</p>
<p>新冠病毒打击的范围和严重程度前所未有。病毒呈指数传播，每五天美国的病例翻一倍。就在我写的时候，依然没有解药。医疗供给不足以应对正在扩大的病例波次，重症护理资源濒临极限，有些超出极限，有些已经过载崩溃。测试进度仍然不足以完成确认传染范围的工作，离扭转病毒传播还很远。一个有效的疫苗可能要12到18个月后。</p>
<p>美国政府已经做了扎实的工作来避免迫在眉睫的灾难。终极考验是： 遏制并扭转病毒传播的手段和效果范围，能否维系公众对美国人<strong>自我管理能力的认可</strong>。危机中的工作，不管多么繁重与必不可少，都不能挤压一个<strong>紧急任务</strong>：同时应对疫情后<strong>秩序转变</strong>的努力。</p>
<p>领导人们正在处理几乎牵扯全国的危机，但病毒瓦解社会的效果没有边界。在伤害人类健康（希望是暂时的）的同时，病毒所导致的政治与经济剧变可能会<strong>持续数代人</strong>。没有国家——包括美国在内——可以仅靠自身国家的努力来克服病毒。要应对当下的种种挑战，必须要形成全球合作思维和执行计划的结合。如果我们无法并行做到，那么我们将面对互相之间<strong>最糟糕的一面</strong>。</p>
<p>从<strong>马歇尔计划和曼哈顿计划</strong>的发展中吸取经验，美国有必要在三大方向采取重要行动：</p>
<p>首先，加强全球对传染性疾病的抵抗能力。小儿麻痹症疫苗和消灭天花这样的医学胜利，或者人工智能依据大数据进行医疗诊断的新兴奇迹，使得我们放松警惕，进入一种危险的自满。我们需要发展新方法和新技术，能够在大规模人口数量级上实现传染病的控制和疫苗研发生产。城市、国家和地区必须始终如一地准备，用现有的、合作计划并开发的前沿科学来保护自己的人民远离疫病大流行。</p>
<p>其次，努力去治愈世界经济的伤口。全球领导人已经从2008金融危机中学到重要教训。现有经济危机则更复杂：从速度和全球规模来看，新冠病毒的传染进程在历史上从未有过。所有必要的公共卫生手段，例如保持社交距离、关闭学校和商业场所，都会加重经济创伤。世界上最脆弱的人群面对即将到来的混乱，也要有减轻对他们影响的措施。</p>
<p>最后，<strong>捍卫自由世界秩序的原则</strong>。有个建立现代政府的<strong>古老概念</strong>：一个<strong>筑有高墙的城市</strong>，被<strong>强大</strong>的统治者所保护。他们有些暴虐，有些仁慈，但总能为人民远离<strong>外部</strong>敌人提供有力保护。启蒙思想家们<strong>改造</strong>了这个概念，认为<strong>正当国家</strong>的目标是要为人民提供基本所需：安全、秩序、良好的经济，还有公正。个体无法单凭自己确保这些事情的实现。疫情刺激了一个<strong>错误</strong>：一个繁荣依赖于全球贸易和人口流动的时代里，<strong>筑有高墙的城市将要复兴</strong>，。</p>
<p>世界的民主国家需要<strong>捍卫并维系启蒙思想的价值观</strong>。<strong>拥有合法性的制衡力量</strong>在全球衰减，将会造成国内与国际上社会交流的解体。当然，合法性与力量这个千年问题，不会仅靠克服新冠疫情的努力就能同时解决。因此<strong>全面的制约</strong>是必要的，不管是国内政治还是国际外交，<strong>优先级</strong>必须得到确定。</p>
<p>我们从突出部战役，走进了繁荣发展和人类尊严得以巩固的的世界。现在，我们生活在一个时代节点。对领导人们的历史性挑战，是要在处理危机的同时建立未来。<strong>失败会让世界陷入火海</strong>。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>国家的性格，很大程度上是由这个国家的平均年龄决定的。二战和冷战早期的各主要国家就像是几个二十多岁的壮小伙子，一言不合就要杀人全家。冷战中后期的美苏就像是三十多岁的成年人，也会发怒，但会考虑后果，如果能背后捅刀，绝对不会当面硬碰硬。而如今的各主要国家，宛如一群四五十岁的油腻中年，生活的主要矛盾已经从升官发财转移成了自己经常闹意见的前列腺，走两步都要喘半天，打完人一巴掌，第一件事就是去医院治手。</p>
<p>社会需要平衡，左了右了都不行。传统上，除了极特殊的年代外，决策层往往是中老年人把持，这确实有一定的科学性，毕竟年轻人太过鲁莽，容易坏事；但执行层，好歹一直都还是年轻人的天下，这就形成了某种制衡，倒逼上面进行改革。可是随着社会整体的老龄化和固化，各国的执行层也开始逐渐老去，年轻人就只能被逐渐挤到国家机器的边缘甚至外部。再发展下去，变成日本那样，就连体制外大大小小的岗位也都被老年人填满，这个国家连一个不老土的网页都已经做不出来，你还指望它能在国家决策上有什么改革的冲劲儿？</p>
<p>基辛格就像是一个老去的少年，用他所熟悉的少年思维去考量这个世界，把高楼幻化成古堡，把磨坊理解成巨龙，用他独特的方式去警告世界，宛如一个白发少年提醒着一群童颜老人，充满了魔幻的不真实感。</p>
<p><strong>可是，世界老了</strong>。</p>
<p>世界就像一个摇摇欲坠的老国企。欧洲早已开始了自己的退休生活，他们所关心的是在尽可能少费力气的基础上拿到尽可能多的退休金，那些明争暗斗仿佛发生在一亿年前。美国就像一个跃跃欲试的老领导，沉浸在自己当年的荣光里，就像那个笑话讲的，“坐在电梯里面上了18楼，过程中一直在做俯卧撑，于是就跟人吹嘘是因为自己努力做俯卧撑上到的18楼”。中国则像这个老国企里的顶梁柱，很努力地听话出活，但却因为一群老人占据着大大小小的岗位不肯退，混到快四十岁了也得不到晋升。是啊，就连这个全单位最年富力强的小伙子，也快四十岁了。官瘾，当然还是有的；可你让他为了当官去和所长斗一斗，把所长斗倒了他来当？开什么玩笑，要恰饭的，老婆要买包，孩子要上钢琴课。</p>
<p>现在，流感来了，这群大腹便便的老爷子全部病倒，你惊奇地发现，除了这个四十来岁的“小伙子”还算勉强坚持住了以外，竟然没有任何一个人的免疫力足以抵抗这场传染病。没病的时候，老干部们或许还下下象棋；病来了，病就是老干部们最要命的事儿。单位那档子事儿，哎……我上次去上班，是几月份了啊……</p>
<p>年轻人总是幻想不同。这是最好的时代，这是最坏的时代。无论好还是坏，年轻人都是喜欢的。</p>
<p>可恐怕事实不能如愿。这不是最好的时代，也不是最坏的时代。我宁可相信基辛格，甚至宁可相信亨廷顿。可惜世界不会那样。</p>
<p>这只是个衰老的时代。</p>
<p>大病过后，老人还会继续老下去。没有人会死去，他们只是在轮椅上继续默默衰老。老所长不会退休，四十岁的“小伙子”也不会接班，只是老领导的呓语越来越没人愿意听，每个人都在消磨着漫长的人生。留给未来的，只是这个效益越来越差的老厂子，和大同小异的冬去春来。</p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p><strong>巴菲特一辈子看了五次熔断，基辛格一辈子看到两次铁幕</strong></p>
<p>说到制裁，我的答复是“制裁有核国家，结果不过是中国俄罗斯东盟中亚一起，剩下的一起，铁幕徐徐落下罢了”百年未有之变局，最差也不过如此只不过上次是丘吉尔+杜鲁门与斯大林对垒，而现在的政坛，除了KGB出身的普京，全加起来也未必有丘吉尔一半够分量</p>
<p><strong>这次疫情根本性的改变了我们与西方世界之间的相互认知</strong></p>
<p>过去我们因为长期在科技、军事、经济上处于弱势，于是被灌输制度和主义需要抉择和进化，认为西式皿煮滋油是真正的解放，甚至把肤色当做一种耻辱急于强调“我虽然是黄种人，但我是美国人”。将舶来品奉为圭臬的代价是，在别人跑过的路上，你永远追不上他，越是在对方的语境里对话，你的话语权越低下西方看我们也是，我们是愚昧、肮脏、野蛮的代名词，同种同文的4V尚且认为我们极度落后吃不起茶叶蛋，却完全不知道我们已经发展到5分钟手机充值不到账就要砸营业厅。所以，大洋彼岸从来没到过中国的红脖子对我们的误解，该有多深呢？“这不文明”中“文明”的含义并非形容词，而是的名词，“这不是西方文明”。</p>
<p><strong>一次疫情把各自的老底全晾出来看清楚</strong></p>
<p>我们看他们，低效政府、无耻政客、堕落媒体、愚昧民众，这距离我们高呼媒体是第四权利的日子没过去多久他们看我们，爆表级别的工业能力和物资投放，为战争准备的社会结构，特别是经此一疫14亿令行禁止的民众怕的是，我们认为他们蠢却忽略了他们近百年来积累下在科技、经济、军事上的巨大优势更怕的是，他们从今往后会全方位铁腕对待中国</p>
<p><strong>东西方的隔阂真的是因为制度吗？</strong>当然不是，若是因为制度，沙特早就不是今天的沙特，朝鲜也断不能具备玩弄六方会谈的能力，普京也不值得英美各国如此的恐惧和排挤隔阂在于，地球的资源，不够14亿人过上美式生活，中国越发展，他们的话语权越小，中国人过上好日子，他们就得降低生活水平，中国在产业链上爬上去一环，就得有人从上面掉下来还记得贸易战吗？要求中国放弃2025中国智造计划，这种无耻条件等于是给中国发射一枚“智子”，你就踏踏实实吃糠咽菜，用资源和环境为代价给他们生产低端制造品才好如果中国放弃发展，相信我们会是人家最好的战略盟友，谁不希望有14亿跪着的韭菜呢？然而现在，所有对中国报以落后幻想的国家，无论承认与否，都不得不接受14亿站着也要把钱挣了的人民这才是隔阂，才是铁幕的根源</p>
<p><strong>未来会打仗吗？最差到什么地步？</strong></p>
<p>拥核国家正面刚的概率基本不存在，真的刚起来，劝架的比打架的多经济上提高门槛，产业链回流，去全球化，甚至可以叫做封锁的态势势不可挡，别迷信咱们好了他们还要很久才能缓过来，救股市不要人命在政客眼里，都不过是决策，甚至是更救命的决策最差莫过于国内产能积压严重，梧桐一把，出师有名还把东盟搞到手，一带一路和东盟，一个在手就足够全球化的推手是美国，目的在于收割财富，有11个航母编队推进这个事情，中国没那么强大的海军，两三只航母编队，维持东盟和一带一路中，已经可以保证国家继续发展</p>
<p><strong>该以什么心态面对？</strong></p>
<p>最可笑的莫过圣母心泛滥，千万别有，好似多读了几本书，就该对全人类负有责任。你所关心和体贴的，在大洋对岸的底层美国人，在政客的眼中，是不配拥有检测权的韭菜。最宣传善良博爱大国责任的美国都准备对疫情中的委内瑞拉动手了，性命攸关，你当他是程心？还是逼自己做程心？也别慌，接下来会有失业、断供等等各种艰难的事情需要面对，但仅仅疫情中国家不惜代价救命的操作，绝对可以放宽心，工业链条完整，粮食充足，过过苦日子也总比把刀把子交给别人好的多</p>
<p><strong>丢掉幻想，准备战斗</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/%E6%9B%BE%E5%9B%BD%E8%97%A9%E6%94%BB%E9%99%B7%E5%A4%A9%E4%BA%AC%E5%90%8E%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B1%A0%E5%9F%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/%E6%9B%BE%E5%9B%BD%E8%97%A9%E6%94%BB%E9%99%B7%E5%A4%A9%E4%BA%AC%E5%90%8E%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B1%A0%E5%9F%8E/" class="post-title-link" itemprop="url">曾国藩攻陷天京后为何要屠城</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-08 20:29:07 / Modified: 20:29:31" itemprop="dateCreated datePublished" datetime="2020-04-08T20:29:07-04:00">2020-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中国历史上就没几支不屠城的军队，抛开近现代的国军共军不谈，历史上以军纪好而著名的军队我第一时间能想起来的只有岳家军和戚家军，前者尤为知名。这种军队有什么特点呢？第一，中央军，虽然冠名岳家军和戚家军，但士兵正儿八经的效忠于帝国，并非将领私兵；第二，兵员质量较高，没有大量的囚犯少年犯之类的社会渣滓；第三，最根本的原因，有稳定的军饷供给。<br>所以归根结底还是经济问题啊！</p>
<p>第一个原因，举个例子，东汉末年那会儿的西凉军，效忠皇帝么？当然不，这是董卓的私兵，他们砍起关中和关东的百姓会觉得是在砍自己人么？人家压根没有什么国家观念好么，董大大说砍谁，就砍谁。同样，湘军本来就是曾国藩自己练出来的团练私兵，名义上效忠清帝国而已，大清的子民又与湘军何干？<br>第二个原因，战争年代当兵是件高风险的事情，安分守己的老百姓有几个愿意从军的？汉武帝为了征西域连“七科谪”都用上了，即商人、商人的子女孙子、商人的侄儿、原本有“市籍”者、罪吏、亡徒、赘婿这七种没有社会地位的人都拖上战场，类似黑五类。这种人本来就没啥社会地位，和囚犯一起干着炮灰的活，打下城池你猜他们会干什么？汉武拓边时期，那可是结结实实把四夷给屠了个爽。 同样，湘军的组成也是不敢恭维，特别是曾国藩前期第一波就打输了（靖港兵败），所训练的新兵损失惨重，这种情况下再招兵什么人会来？流氓无产者啊。<br>最后一个原因，清廷养不起湘军，没有钱粮，又要士兵玩命砍人，曾国藩除了放任士兵劫掠，还真没有啥好办法，后来他的一个老乡想出了一个办法缓解了这一矛盾——加入红军可以分到土地！当然，玩笑归玩笑，共军的组织体系比湘军这种封建军队强太多了，也高效的多。从农民手中收粮食不必被假手于地主，给士兵发饷也不必假手于将领，这两点极大的提高了效率，没有了中间环节抽油水，共军才能用非常低的成本养活一支庞大的军队，而湘军若想从后方的老乡手中获得粮饷，便要让地主们对老乡更加的敲骨吸髓，权衡之下，杀人劫财才是最高效的选择。至于什么太平天国是邪教之类的话就不用拿来给湘军洗地了，太平天国就算信了飞面教也是逃不过这一劫的，抢劫这么纯粹的事情，别用剿匪给玷污了。<br>这个世界还真是™的无情啊。</p>
<p>综合来看，这件事给我们一个启示，想要建立一支军纪严明的军队，第一件事就要解决经济问题。国家能直接给每一个士兵发饷，士兵才能效忠国家，反过来，国家不给钱了，让军队自己想办法，军队便不得不采用一些灰色的手段为士兵们或者军队的其他人员赚得粮饷，这样的军队还会想着去为国家杀敌么？活下去都成问题就别谈理想了吧，军人不是圣人，只要有一个军官为了利益出卖理想，他迟早会拉下水一群人，最后形成休戚与共的小团体，军队会逐渐变成军官的私兵。当他们的利益和国家的利益发生冲突的时候，卖国的时候到了。归根结底，军队是要像姨太太一样养起来的，千万不能让军队自己赚钱，放在现在就叫：军队一律不得经商！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92-2020%E9%BB%91%E5%A4%A9%E9%B9%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92-2020%E9%BB%91%E5%A4%A9%E9%B9%85/" class="post-title-link" itemprop="url">新冠病毒_2020黑天鹅</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-07 23:31:43 / Modified: 23:36:05" itemprop="dateCreated datePublished" datetime="2020-04-07T23:31:43-04:00">2020-04-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下是给红杉创始人和CEO们发来的一份说明，希望能给大家提供一些指导，让大家在应对冠状病毒蔓延带来的潜在业务后果的同时，也能保证企业的健康。</p>
<p>尊敬的创始人和CEO们</p>
<p>冠状病毒是2020年的黑天鹅。你们中的一些人（也是我们中的一些人）已经受到了病毒的亲身影响。我们知道你们所承受的压力，并在这里提供帮助。人命关天，我们希望条件尽快改善。在此期间，我们应该居安思危，对可能出现的情况要有心理准备。</p>
<p>在座的各位都收到了很多关于COVID-19附近的预防措施的建议，以保护您、您的员工和您的家人的健康和福利。和许多人一样，我们也研究了现有的信息，并很乐意分享我们的观点–如果您有兴趣，请告诉我们。本说明是关于其他方面的内容：确保您的企业健康，同时应对病毒传播的潜在商业后果。</p>
<p>不幸的是，由于红杉在全球许多地区都有分布，我们正在获得冠状病毒对全球业务影响的第一手资料。与所有危机一样，有一些企业可以从中受益。然而，许多一线国家的企业因病毒的爆发而面临着挑战，包括。</p>
<p>业务活动的下降。一些公司的增长率在12月至2月间急剧下降。随着病毒的影响波及范围的扩大，一些原本按部就班的公司现在有可能错过第一季度至2020年的计划。</p>
<p>供应链中断。中国前所未有的封锁，直接影响到了全球供应链。硬件企业、直销企业和零售企业可能需要寻找替代供应商。纯软件公司受供应链中断的影响较小，但由于级联经济影响，仍面临风险。</p>
<p>缩减旅行和取消会议。许多公司已经禁止所有的 “非必要 “旅行，有些公司已经禁止所有的国际旅行。虽然旅游公司受到直接影响，但所有依赖面谈会议进行销售、业务发展或合作讨论的公司都受到影响。</p>
<p>我们需要相当长的时间–也许需要几个季度–才能确信病毒已经被控制住。全球经济要想恢复健康，还需要更长的时间。你们中的一些人可能会经历需求疲软，一些人可能会面临供应方面的挑战。虽然美联储和其他央行可以降息，但货币政策可能是缓解全球健康危机对经济影响的钝器。</p>
<p>我们建议你质疑关于你的企业的每一个假设，包括。</p>
<p>现金跑路。你真的有你认为的那么多的跑道吗？如果经济不景气，你能承受几个糟糕的季度吗？你是否已经制定了应急计划？你在哪里可以在不从根本上损害业务的情况下削减开支？现在就问这些问题，避免未来可能带来的痛苦后果。</p>
<p>筹款。私人融资可能会大幅减弱，就像2001年和2009年发生的那样。如果在2020年和2021年以有吸引力的条件筹集资金证明很难，你会怎么做？你能不能把充满挑战的局面变成一个机会，让自己获得持久的成功？许多最具代表性的公司都是在困难时期锻造和塑造的。1987年黑色星期一后不久，我们就与思科公司合作。谷歌和PayPal在互联网公司的大萧条之后艰难地渡过了难关。最近，Airbnb、Square和Stripe都是在全球金融危机中成立的。约束力使人的思维集中，为创造力提供了沃土。</p>
<p>销售预测。即使你没有看到你的公司有任何直接或直接的曝光，也要预测你的客户可能会改变他们的消费习惯。看似已经确定的交易可能不会成交。关键是不要被动挨打。</p>
<p>营销。随着销售疲软，你可能会发现你的客户终生价值下降，这反过来表明你需要控制客户获取支出，以保持营销支出的稳定回报。随着经济和筹资的不确定性增加，你甚至可能需要考虑提高营销支出的投资回报率。<br>人头数。考虑到上述所有的财务压力点，现在可能是时候对你的财务进行批判性的评估了，你是否能以更少的投入做更多的事情，提高生产力。</p>
<p>资本支出。在你制定了财务独立的路线之前，请检查你的资本支出计划在更不确定的环境下是否合理。也许你没有理由改变计划，而且据你所知，环境的变化甚至可能会带来加速的机会。但这些都是应该深思熟虑的决定。</p>
<p>在经历了近五十年来的每一次商业衰退之后，我们学到了一个重要的教训–没有人会后悔根据环境的变化做出快速果断的调整。在经济不景气时，收入和现金水平的下降速度总是快于支出。在某些方面，商业反映了生物学。正如达尔文所推测的那样，生存下来的人 “不是最强壮的人，也不是最聪明的人，而是最能适应变化的人。”</p>
<p>经久不衰的公司的一个显著特点是他们的领导人对这样的时刻的反应方式。你的员工们都知道COVID-19，都在想你会有什么反应，对他们意味着什么。错误的乐观情绪很容易将你带入歧途，使你无法制定应急计划或采取大胆的行动。要避免这个陷阱，要以现实的态度对待，当情况发生变化时果断地采取行动。在这个紧张的时刻，展现出您的团队所需要的领导力。</p>
<p>以下是我们的合作伙伴Alfred Lin的一些观点，他作为一名运营主管，经历了另一个黑天鹅时刻。</p>
<blockquote>
<p>2008年金融危机爆发前，我是Zappos公司的首席运营官/首席财务官，当时我被传唤到红杉的办公室，参加著名的<a href="https://www.sequoiacap.com/article/rip-good-times" target="_blank" rel="noopener">R.I.P. Good Times演讲</a>。我们当时不知道，就像我们现在不知道，我们将面临多长时间或多尖锐或浅薄的经济衰退。我可以确认的是，这次演讲让我们的团队和业务变得更加强大。Zappos从金融危机中走出来，在我们的竞争对手被打得遍体鳞伤之后，我们已经做好了抓住机遇的准备。”</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/06/%E5%85%A5%E5%85%B3%E5%AD%A6%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/%E5%85%A5%E5%85%B3%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">入关学导论</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-06 22:43:46 / Modified: 22:45:33" itemprop="dateCreated datePublished" datetime="2020-04-06T22:43:46-04:00">2020-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当今知乎有无数的人从事或从事过键政学研究,号称是键政的文章和回答充满了专栏、热榜和各个回答。</p>
<p>与之相随,“蛮夷入关学”作为键政学学科体系下的一门具有独特魅力的分支，逐渐显露头角。目前世面上正在初步形成了以山高县语录为基础，以七十二贤冲塔言论为补充的理论体系，即“蛮夷入关学”（以下简称为入关学）。与之伴随的问题就是蛮夷入关学已经普及到只要学点皮毛就能研究的程度。以至于“入关，入关“的言论充斥了知乎。</p>
<p>我们提出的问题或许不合时宜,但面对目前知乎上各色各样的入关学研究,大多不以根本目的为导向和结构的入关学回答、文章、专栏时,我们不能不说,入关学若想继续发展。入关学需要明确研究什么、为什么研究。笔者在借鉴知乎显学六学的理论建设的基础上，对入关学进行了一次梳理总结：[1]。</p>
<h2 id="一、什么是入关学"><a href="#一、什么是入关学" class="headerlink" title="一、什么是入关学"></a>一、什么是入关学</h2><p>入关学（THE Science Of Enter The Gate），是一门研究山高县相关入关言论及其所代表的思想的新兴学科，其基础载体是山高县相关语录，以七十二贤冲塔言论为补充，以历史上的现实例子为渊源。从学科划分角度上来说，入关学是一门交叉学科，其覆盖领域包括政治学、军事学、地缘政治学、经济学、政治经济学、历史学等等，是一门相当前沿的综合性学科，并且还有很多发展的空间，值得研究者们去不断探索。 但随着近日入关学在人民群众中的普及，它也暴露出了许多问题：入关学的研究对象究竟是什么？入关学的使命是什么？入关学对人类社会有什么积极的意义？</p>
<p>入关学的研究对象和方法<br>目前知乎上的疑问主要是，入关学的研究对象到底是山高县的回答？还是评论区的精彩（献祭）言论？还是地缘政治学、军事学、经济学、明清易代史？ 笔者认为，其实三者一个密不可分的整体，缺少哪个都不能独立存活。山高县的回答基础来源于地缘政治学和军事学，为了使国人更清晰的理解而创造性地发明了将之粗略地投射到明清易代史的语境中，以此使得更多人方便理解学习。在入关学领域中，评论区的言论是山高县回答与键政研究者的结合体，经过知乎上各大学者（粉丝）的研究（冲塔），评论区的言论已经成为入关学丰富的增长点，是入关学理论知识在各个学者研究中不断突破、优化、细化的基础，被大批入关学学者应用于入关学研究中;然而，评论区言论在入关学教育中的应用尚浅，尚未得到应有的重视，但评论区言论对入关学领域的重要性决定了其在入关学教育中应用的必要，应用在入关学教育中是必然的。</p>
<p>入关学的主要内容<br>目前入关学的主要内容分3类：</p>
<p>（1）通过历史研究，以明亡清兴的历史教训论证了身为一个蛮子的正确自我认知[2]：</p>
<p>即入关的必要性 1.入关是女真团结的唯一途径，是女真求活的唯一选择，是女真崛起的唯一道路。 2. 扫帚不到，灰尘不会自己走掉。大明再烂，没有女真步步紧逼，一时半会儿也完不了。 3.蹲鹰和挖参固然能挣一些钱，然而改变不了摸鱼是绝大多数女真年轻人唯一出路的现实。 4. 摸鱼的命，不要操天朝的心。靠蹲鹰挖参和摸鱼，不仅买不来洪承畴，连范文程都买不来。 5.与其在关外吃敕书，不如到京城印敕书。 6.没了大明的敕书，女真也没饿死。 7. 靠同胞之情，同种之谊，既不可能让叶赫归顺，也不可能让朝鲜归降。 8. 在赫图阿拉再怎么读半吊子圣贤书，也改变不了摸鱼的现实。 9. 入关前不要搬着圣贤书胡思乱想，入关后自有正统儒学大师为我所用。</p>
<p>（2）通过对M国的研究，论证了M国治球不义不利，丧失人心、天道更易，而应有德之人居之：</p>
<p>具体又分为三方面论证：</p>
<p>1.M国崛起史、得球史寡廉鲜耻、不仁不义，实在人神共愤：</p>
<p>1.1</p>
<p>1845年，M国悍然吞并墨西哥领土德克萨斯后。仍不知足，得陇望蜀，竟恬不知耻的向墨西哥购买加利福尼亚和新墨西哥的广袤领土。[3]</p>
<p>1.2</p>
<p>英国在1807年就禁止贩奴，1833年就全面解放奴隶。而M国政权，直到1862年才解放奴隶，死不悔改、落后反动。[4]</p>
<p>1.3</p>
<p>M国是近现代极权迫害的极致，暴行不义，违反人权。</p>
<p>具体有以下方面：第一是政治迫害，比如独立战争时期，各个殖民地成立委员会，迫使每一个人宣誓效忠于合众国，胆敢不宣誓者，一律关进大牢，没收一切财产。第二是没收财产，比如1777年11月，国会建议各州没收变卖效忠派的财产。这个提议迅速得到支持。第三是人格侮辱，典型例子是托马斯布朗事件：乔治亚洲的著名效忠派托马斯·布朗，此人是一个富有的种植园主，1774年才来到殖民地。1775年一群独立派来到他家中，要求他向独立事业宣誓效忠的，他拒绝了，于是其他人打破了布朗头盖骨，剥下了他的部分头皮，并把他吊到他家门前的树上，又来了一出“涂沥青，粘羽毛”的戏码。而后他们又架上一堆火烤他，最终他的两个脚趾头被烧掉。第四则是互杀俘虏。[5]</p>
<p>爱国群众对效忠派M奸粘羽毛，涂沥青</p>
<p>由上诉例子可得结论：M国是近现代极权迫害的祖宗，违反人权，暴行不义。</p>
<p>（3）通过对M国治理全球方式的研究，论证了M国全球治理的不可持续性和必然衰亡性：</p>
<p>3.1 M国全球治理的不可持续性：</p>
<p>M国对世界经济的统治，宛如蒙古对中亚的统治。原本收税就行了，结果还是蒙古那一套——抢，没事就去抢劫自己治下的百姓来维持生活。例如索罗斯之流说白了就是蒙古抢劫大队长[6]。</p>
<p>而目前全世界最大的危机正是全球性的财政危机，连用货币政策和财政政策辗转腾挪的空间都很小的情况下，天降伟人特朗普还在全世界不停的火上浇油。俗话说国无完国，但会完蛋，饿虎不择食，蝼蚁且贪生。完蛋预期面前，这个世界要出多少幺蛾子，实难想象[7]。</p>
<p>3.2 M国全球治理的必然衰亡性：</p>
<p>M国是一个世界性的帝国，对一个世界性帝国来说，逆全球化四个字意味着什么？ 天子失德，诸侯离心，蛮夷崛起，四方扰攘之时。苏松二府的繁华，秦淮河畔的纸醉金迷，东林书院里的风声雨声读书声，又能代表什么呢？ 分析M国，要以其全球统治体系的运行状况为出发点，光盯着M国这个南直隶，是看不出什么的。[8]</p>
<p>但是全球化是其致命漏洞的，Dani Rodrik在2000年就指出，尽管全球化（在当时看来）势不可挡，但内在地蕴含着危机，根源在于全球经济一体化与全球政治上层建筑之间不可调和的矛盾。 Rodrik这篇文章[9]提出了一个“全球化三元悖论”，即经济一体化（或者说全球化）、民主政治和民族国家难以同时兼得，最多保证其二。</p>
<p>简而言之，经济全球化要求各国采取削减贸易壁垒，统一税制与监管，开放资本流动等一体化措施，这会对国家主权造成威胁；如果要在保证各国主权完整的情况下强行推进全球化，当国内部分群体利益受损时，只能牺牲这部分人的利益，而这又违背了民主原则；保证民主与主权完整必然会使全球化放缓[10]。</p>
<p>综上所述，M国的全球治理体系存在重大缺陷，必然走向衰亡。</p>
<p>入关学的历史渊源</p>
<p>许多研究者认为入关学是最近才出现的，这其实是不对的，因为通过文献研究，笔者发现，其实入关学的历史比一般意义上久远的多。广义上讲应该有两千余年的悠远历史。 理论依据：吾入关，秋毫不敢有所近，籍吏民，封府库，而待将军。(《史记·项羽本纪》)</p>
<p>根据史记的记载，刘邦其实才是入关学的第一位创始人、第一位研究者。刘项之争，刘弱项强，项羽分封刘邦于偏僻、资源贫瘠的蜀地（华夏文明当时的边缘地带），而自己占据华夏文明当时的中心地带，并挟制义帝作为大义，妄图通过资源封锁刘邦，通过占据道德的制高地谴责刘邦，通过占据文明的解释权将刘邦蛮夷化，这样的处境不能不说是很相似的阿！</p>
<p>在这样的困境面前，刘邦通过潜心研究入关学，采用张良、韩信的计策，暗度（入）陈仓（关），进入到肥沃、发达、人力资源丰富的关中平原，以此获得了和项羽争霸的资本，最终夺取天下。这正是刘邦研究入关学的证据和成果！</p>
<p>此外，入关学还经过了历代各位大家的不断补充，在不同的历史时期里，入关学的表现形式包括并展现为：北伐、南下、东征等。</p>
<p>例如：</p>
<p>前1046年：武王伐纣，入关学萌芽 前206年：刘邦暗度陈仓、还定三秦，诞生了第一为入关学家</p>
<p>227年：诸葛亮上出师表，被誉为千古奇文，这是入关学的第一次高峰</p>
<p>1644年，清军入关，这是入关学第一次进行朝代更替规模的应用</p>
<p>1941年12月，日军偷袭珍珠港，南下南洋，最终失败，昭（招）和（核）名副其实，这表明了入关学仍存在的缺陷，即如果研究不当、理解偏差，将一定灭亡</p>
<p>2019年，山高县于知乎开讲入关学，一时云从者众，成为知乎键政一大显学，与曹学等并列知乎键政奇学</p>
<h2 id="二、入关学的两大理论"><a href="#二、入关学的两大理论" class="headerlink" title="二、入关学的两大理论"></a>二、入关学的两大理论</h2><p>建州的发展与大明的治理的现状不可共存理论</p>
<p>海东青和高丽参确实是建州经济的支柱，007式的蹲鹰和挖参虽然苦，但在建州也是让绝大多数摸鱼诸申羡慕的好工作。然而蹲鹰和挖参，改变不了摸鱼是绝大多数女真年轻人唯一出路的现实。建州固然不可能靠摸鱼崛起，更不可能靠蹲海边抓海东青和钻长白山挖高丽参而崛起啊。[11]</p>
<p>所以，建州如果在现状下要想赢得尊重，只有一条路可走，就是——剃发易服。 蛮夷干什么都是错的，想解决挨骂问题，当然只能靠留头不留发，留发不留头（手动狗头）。 所以，从而明确了入关学研究的意义：即建州想解决尊重问题。首先，得入关，入关就是一切，一切为了入关，不入关，一切免谈。 你不入关，大M以抢劫治天下且有无数砖家穴者论述其合理性与合法性。在这种人类历史上空前无耻的舆论氛围面前，不入关消灭大M，绝其社稷，谈何赢得尊重？ 至于入关之后，山高认为应该做两件事（剃发易服笑笑就好）： 1：剿兵安民，彻底消灭与清算大M的金融铁骑及其走狗。 2：闯王来了不纳粮，不利用国际贸易与结算体系为自己牟利。 当昭告天下： ——今我华起义军，行天诛。非图一家一姓之荣华，实为五洲苍生之乞活![12]</p>
<p>从经济学角度讲，垄断资本主义规则下，自由资本主义是侵蚀垄断利润的规则破坏者（所谓发达国家粉碎机）。M国既然以垄断资本主义逻辑运行，那么它就必然要打击自由资本主义，以维持市场秩序。 而建州由于人口太多，发不起垄断资本主义阶段失业无产阶级的奶头乐，是很难向垄断资本主义转型的，除非有世界范畴内的垄断利润可吃（甚至哪怕入了关，也不过996变成986）。 所以说中国对M国而言，既是规则破坏者，又是地位挑战者。 所以M苏在经济上是可以共存的（M苏在没有核武器的时代也没有打热战），建州和M国之间则不一样。[13]</p>
<p>明确蛮夷的地位及入关是唯一的解决方法理论</p>
<p>入关学家逗比南波万 @逗比南波万 认为，当下我们面临的重要困惑是：</p>
<p>为何我们政治文化地位跟经济军事地位不符合？ 为何全世界都不待见建州人？ 为何舆论的高地我们没法占领？ 为何英M一张表单，能让我们投入千亿真金白银，再吸收一大群洋垃圾？ 为何？一句话，因为你是蛮夷。 华夏文明，如烈日当空，五千年来都是棋手，一直以天朝上国自居，何来蛮夷之说？因为现代化是英M开创，全世界的现代化都不可避免混入西化。你说现代化是你自己的，那是胡扯。你警察，西装咋回事？我们是天朝上国，划分出：南蛮、北狄、东夷、西戎。欧M是现代化正统，我们就是东夷。不想承认，也没办法。 综上，逗比南波万通过研究入关学理论，认为解决方案是： 入关！入关是让我们早饭M国。蛮夷灭了正统，自有衍圣公带头来跪。成了，我们就是真命天子，是罗马正统，是天道正义之剑。[14]</p>
<h2 id="三、入关学的具体应用"><a href="#三、入关学的具体应用" class="headerlink" title="三、入关学的具体应用"></a>三、入关学的具体应用</h2><p>键政一向被视作咸吃萝卜淡操心，甚至有观点认为键政是“地沟油的命，ZNH的心”，故很多人认为入关学也是如此。 笔者认为这有失偏颇。笔者经过总结发现，其实入关学理论能帮助我们正确认知世界，占领舆论高地和积极应对生活。从而帮助我们更积极、更向上、更正能量。</p>
<p>正确认知世界，占领舆论高地<br>入关学理论是山高县键政理论体系的基础，为学生认识和理解山高县键政理论体系提供渠道，训练并培养学生的键政思维，为培养键政方面人才提供了方法。入关学理论也是知乎键政体系扩展和发展的重要动力，通过重视入关学理论的研究，我们就可以借助入关学理论理解和认知当今世界体系的由来和发展，从思维和实践中培养更加优秀、专业的键政人才。只有认知世界正确了，我们才能形成良好的思维，将理论知识灵活运用于既定事实之中，占领舆论的高地、提升爱国主义教育。因此，入关学的研究可以更好培养出爱国主义正能量知乎键政体系的人才。</p>
<p>培养积极心态<br>作为当今重压之下浮躁内卷佛系的青年，入关学倡导的思想更能让人乐观向上、充满希望。 学习入关学后将明白面包会有的，楼上楼下，电灯电话也会有的。我们将在有生之年，用铁与火，在冲绳海沟，将日本人的舰队埋葬；在安达曼海与孟加拉湾，将印度人的舰队，变成一堆废铁；在北大西洋和南赤道，在密克罗尼西亚，在所罗门群岛，将美国人的所有航母舰队，变成一具又一具的海底铁棺材。</p>
<p>俗话说，白白胖胖，充满希望，人最怕的就是失去希望，变成一具行尸走肉，只要还有希望，就还拥有一切。</p>
<p>四、结论与展望 本文首次以理论的高度总结了入关学的定义、渊源及其应用，是对当今入关学发展的一次大一统性工作。不过限于作者水平，观点上难免会有疏漏，甚至存在争议，但态度是端正的，毕竟摸鱼是女真年轻人唯一的出路，可是谁不想念四书五经呢？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1436668936&auto=0&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">166</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
