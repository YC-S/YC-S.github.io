<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/22/%E4%B8%96%E7%95%8C%E6%98%AF%E5%90%A6%E8%BF%87%E5%BA%A6%E4%BE%9D%E8%B5%96%E4%B8%AD%E5%9B%BD%E5%88%B6%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/%E4%B8%96%E7%95%8C%E6%98%AF%E5%90%A6%E8%BF%87%E5%BA%A6%E4%BE%9D%E8%B5%96%E4%B8%AD%E5%9B%BD%E5%88%B6%E9%80%A0/" class="post-title-link" itemprop="url">世界是否过度依赖中国制造</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-22 19:30:24 / Modified: 19:31:10" itemprop="dateCreated datePublished" datetime="2020-03-22T19:30:24-04:00">2020-03-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>是。更是好事。</p>
<p>年初因为春节与疫情的双重空档，我们在全球化工产品上的供应出现了一个大断档，这导致美帝的制药业在生产上出现停摆，一些病人因为无药可买陷入困境。</p>
<p>可想而知，一系列美帝政客立马打了个旗号：“夺回供应链”，并要求政府支持。这个口号在3月初进入高潮，配合疫情的全球蔓延，很是抓了一把眼球。</p>
<p>当然，这就是来诳国会的定向补贴的，和美军整天向国会老爷嚷嚷解放军天顶星战斗力是一个套路。</p>
<p>共和党一边拿供应链问题向国会要钱，一边唱川皇的赞歌，证明川皇贸易战搞脱钩的英明神武。如果不是疫情在美帝那炸了，那么这个故事才是三月份美帝的原定剧本。</p>
<p>但我个人认为：让全球都深度依赖中国供应链，最符合我们的核心利益。</p>
<p>有些观点不管私信里多少人骂，我还是没变：</p>
<p>要孝子送终式的图穷匕见，而不是一放就软一抓就泄。急吼吼的那是雏，没经验，只会过早交货；老手要的是适应节奏均匀呼吸，陪跑到最后。</p>
<p>天天以自己是政治点数加满的古国自豪，一到键政口嗨就掉头昭和去了？</p>
<p>我相信从局座到政委到温老爷子他们反复强调的“战略定力”，不相信公众号们的大标题。情绪大家都有，但是情绪不能形成有效的战略。</p>
<p>当前局面，和过去的游牧农耕对抗没有根本变化，依然是各自生产方式所决定的结构性矛盾。</p>
<p>我们作为工业时代的制造国，本质就是这个时代里的农耕文明。我们采买、生产、销售，依靠的是成本效率优化与科技改良，并不掌握资源的定价权与市场准入许可。</p>
<p>而美帝作为工业时代的金融国，通过武力与科技确保了全球货币与资源定价权。这导致美帝能在我们每个环节上收取铸币税，减少我们整体的收益积累，并通过收益落差来吸纳我们艰难攒下的资金与人才，极大减缓我们自身科技研发与社会福利的增长速度。</p>
<p>所幸我们的体量与农村的牺牲，保证了基础积累的成功；教员留下来的遗产，保证了基本的独立性与自卫能力。所以我们虽然一直被收割，甚至还要送钱给外国人去消费本国产品，但好歹攒下来的那点，大头还是在自己手里。</p>
<p>亚洲很多制造国没有这些，就要承受一三五搬砖赚点存点，二四六匈奴南下抢一把再烧一遍，周日找只替罪羊宰了，下周再来一遍的历史周期循环。</p>
<p>这个从白登之围到封狼居胥的过程，最考验战略定力，因为你既要忍耐，又要发展。</p>
<p>八爷打航母，难道不是天子不能具钧驷将相或乘牛车？60分钟上的咄咄逼问，难道不是冒顿单于问娶吕后？换做当时，精汉（不对我是实汉）可以天天震怒，但怒就可以勒石燕然了？</p>
<p>不是没有人瞎怒过，仓皇北顾在史书里多了去了。</p>
<p>结构性矛盾就要用结构来解决。</p>
<p>匈奴是游牧民族的联盟，是一个概念，里面成分繁杂，白匈奴了解一下。这个概念能团结草原上的诸多民族，是因为这概念能让他们集体南下打草谷，抢来多多的财粮女人回家分。</p>
<p>所以只要一边让他们不能打，一边让他们分不够，这个联盟就会自然瓦解，强大的力量在内斗中耗尽，给农耕文明一波定局的机会。</p>
<p>身为制造国，供应链就是我们的结构优势，是我们在工业时代延续农耕防反专精的底牌：</p>
<p>全球越依赖我们的供应链，他们自身的产业空心化就会越严重。失业的蓝领会加大国家的福利成本，并且使得整个政府政策越发倾向保守；</p>
<p>本国年轻人在教育上也会更追求高收益的金融与文化产业，基础科研的脑力将越来越依赖外部；</p>
<p>虚拟经济会高度繁荣，在收益率上与实体经济拉开强烈落差，进一步削弱本国发展实体的欲望；</p>
<p>缺乏实体应用的高端技术最终会流失向有需要的他国实体，抑或因缺乏应用闲置太久，先发优势被他国的投入所追平甚至赶超；</p>
<p>虚弱的实体相关者——多数为普通民众与拥有强势行业的地方——与被虚拟收益所捆绑的精英及中央政府，会在认知上产生巨大鸿沟；</p>
<p>一旦中央政府无法继续维持虚拟的高收益，结构性矛盾爆发，匈奴这个联盟就会开始瓦解。</p>
<p>拥有强势工业的地方能够继续输出有竞争力的工业产品，会谋求与外部的和平，保证正常贸易；</p>
<p>捆绑虚拟收益的中央政府和金融精英会用一切手段维系高收益率，当往高抬抬不动时，就会去把别人的收益率砸低，这往往意味着对外冲突甚至战争；</p>
<p>被国家视为负担、徘徊在虚拟经济和强势工业之外的普通人，会陷入巨大的认知混乱，并被宗教、种族、传统等感性概念收割吸纳。</p>
<p>有的南附，有的西迁，剩下的力量不够打不了草谷，就要开始忍受白毛风。</p>
<p>陈平教授的很多观点在经济学上有巨大争议，不予置评。但是他认为美帝空心化再继续下去，united states可能会变成divided states，我赞成。</p>
<p>什么叫阳谋？这种结构性对抗就是阳谋。</p>
<p>所以这个过程极为难受，因为对方不傻，对方知道你要这么搞。</p>
<p>对美帝来说，就算明知制造业不能回流，那么能把中国的制造业打碎流到可控的第三国，也是胜利，因为第三国都可打草谷收割，保证能一直分到足够的钱粮女人。</p>
<p>中国的产业不是把成本效率优化得很好吗？那高端封锁，打击中国制造2025，降速；低端扶植东南亚，劳动密集性做来多low多不环保，转移出去吧，我有一堆金融机构手把手教你；中端上贸易战，全面拉高你的成本，让你大量工业门类要么自己关门，要么求助国家，增加你总体成本。</p>
<p>这就是为什么印度的污染不被骂、泰国的血汗工厂是发展象征、孟加拉的山寨不叫抄袭。多数，都是打击你成本效率优化的借口。</p>
<p>万一我们没顶住陷了，印度起来了，这些帽子会原封不动给印度再戴一遍。</p>
<p>其次，一手是全力打压实体，一手是大力鼓励你金融开放。来呀，靠产线做工来赚钱多累，房租贷要不要玩？二次衍生投资产品赚得多不多？你不会玩不要紧，打开门，我教你玩。</p>
<p>将美帝那套成熟的虚拟经济玩法引进给我们。我们在虚拟经济里赚了钱？没事，你人民币还是看着我美元发行的，你在虚拟经济中滚出来的数字越大，你对我美元的需求就越高，我全球货币的地位更加尊崇。</p>
<p>另外，你实体失血就好。你也成虚拟经济了，那么一旦你波动，资本还不是回到全球货币的大本营——美元这。</p>
<p>某种意义上，对方也是阳谋。</p>
<p>两边都是摆在台面上，美帝明说不许中国制造2025，我们也明说稳定全球供应链，这是正式进入拉锯的信号。</p>
<p>我们希望耗，耗到美帝决策理智又消减，虚拟收益又迷了眼，转头回去吸大烟，继续空心化。</p>
<p>美帝希望我们急，制造一个不是核战争但是能足以公开切断我们供应链对外流动的局面。</p>
<p>一般来说，东南小岛。</p>
<p>我们的回应是：别的骂阵我可以忍，这事我们当核战争来看。</p>
<p>美帝再回：那我可以表演一番让你拿走，但你全球供应链的地位我一定要趁机搞掉。</p>
<p>这是当下焦点。</p>
<p>东南小岛不是我们想不想的问题，就算我们不想现在动手，美帝也会怂恿小岛，逼着我们动手，因为美帝要这个机会切断我们与世界的联系。</p>
<p>所以干脆顺水推舟：既然你要拿小岛做借口，小岛又是我的合法性，干脆我先说，等你出牌。</p>
<p>问题是之后我们的全球供应链怎么办？</p>
<p>丧失外部市场和投资，巨大的过剩产能和资金断链会严重反噬我们自身，这是最最经典不过的经济危机。一旦发生，那就是真正的中国版中等收入陷阱。</p>
<p>所以要打通一条通往欧洲的路。</p>
<p>一带一路，海上多是以全球为目的，陆上基本是欧洲。和平时期海上的收益高于陆上，但万一海上通路被封锁了呢？</p>
<p>我们离芬兰就隔着一个俄罗斯。</p>
<p>全球供应链是我们的命门，这里故事太多，说不完。就当下而论，不厚道地讲：</p>
<p>欧洲疫情是机会。</p>
<p>是的，宏大叙事就是这么让人丧失人性。因为国际社会没有法则，也就没有多少善良的空间。</p>
<p>疫情加重了欧洲对我们供应链的依赖，为我们在特殊时期的产能输出再加一码。我们在特殊时期过剩产能的压力越小，美帝借东南小岛搞掉我们全球供应链的效果就越差。</p>
<p>最后在一个投入产出比的节点上，美帝退出拉锯，继续吸大烟。直到德克萨斯孤星国和加利福尼亚共和国不再是一个笑话的那一天，真正的机会才算到了。</p>
<p>在那一天之前，本质都是乖乖上贡的孝子。继续补贴海外消费者，继续开放金融管制，继续忍受美元的铸币税。</p>
<p>觉得难听？那就想办法上贡得少一点，引导美帝去多抢别人，然后多给他送点大烟。</p>
<p>那是肉食者谋了，某不敢多言。</p>
<p>当然，键政侠意淫一把国师，口嗨的画面往往很美好，往往不可能。</p>
<p>因为就算上面可忍，庞大的民意恐怕也过了愿意忍的阶段。日本当年又是和解苏联又是疯狂用贸易稳住美帝，不就是眼馋英法的亚洲势力范围么？</p>
<p>没忍住。</p>
<p>孝子没忍住怎么办？</p>
<p>只能入关了。</p>
<p>父慈子孝，不也恰如大明建州么？</p>
<p>没想到写着写着，又能为嵩学增加一点素材。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/%E7%9B%91%E5%AE%88%E8%87%AA%E7%9B%97%E5%BD%B1%E8%AF%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/%E7%9B%91%E5%AE%88%E8%87%AA%E7%9B%97%E5%BD%B1%E8%AF%84/" class="post-title-link" itemprop="url">监守自盗影评</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-21 23:16:05 / Modified: 23:16:30" itemprop="dateCreated datePublished" datetime="2020-03-21T23:16:05-04:00">2020-03-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这部电影很牛X。牛X的地方第一点是思路很清晰，虽然各位编导明显是选定了边站定了位，只是“论述自己的观点”的干活，但是人物采访数据分析，从华尔街，到政府，到经济学家，时不时地用胳膊肘捅观众一下，不太明显不是很故意，但效果毕竟是达到了。牛X的第二点是出场人物都很大牌，涉及美国高级行政人员，顶级银行家，金融分析师，大学教授，甚至新加坡，中国，法国的政府官员等等。从记录片，甚至可以说从discovery的角度，这都是一部很好的电影。对于有意研究金融的同学，有意研究危机的同学，有意研究金融危机的同学，甚至只是有意想要投资股市投资房产以抵抗通膨的同学，这都是一部深入浅出，信息丰富，分析明晰，概念清楚的资料/教学片。</p>
<p>说起美国这个国家，是个很神奇的国度，被很多人向往着，我则从来觉得“还好”，大约在经济发展之类的问题上我是个很保守又不思进取的人吧。但是常常有同学在我一番保守又不思进取的发言后面评论说“你看看人家美国”，言下之意美国是个绝好的榜样，只要我们在各方面照足美国那样做，十年之后不说赶英超美吧，把美国学到八九成像还是不成问题的。当然在这些同学的美好想像中，一旦我们变成美国的完整山寨版，他们必然不会是那些在底层社区挣扎温饱的 losers，统统都是在高级住宅区里牵着名贵小狗听着ipod享受阳光绿萌新鲜空气的成功人士。</p>
<p>暂且不去讨论谁在这些同学当中的脑海中扮演着那些loser的角色，但是这些同学美好的野望活生生的解释了一句话——greedy is good！当年《华尔街》当中的名台词鼓励无数美国的，中国的，法国的，日本的，天知道还有哪些国家的既不保守又很思进取的青年们学习金融经济最后投身于 “投资”行业，朝着“美国梦”或者“美国那样的梦”一步步迈进着。</p>
<p>我第一次见Luc的时候，他指着我的cv问“你有管理学的文凭为什么最后没有选择经管方面的工作”——这是多么的显而易见啊！我们做it业的民工而已，每天靠着点脑力赚血汗钱，怎么比得上经管行业，左手钱来右手钱去，转眼间兴许就发达了，你看看华尔街那些泡名模开名车住豪宅的。况且我是女生，编程神马的，跟一群穿老头衫夹脚拖鞋的宅男关在一个办公室里，连穿个名牌化个时髦妆容卖弄青春资本的机会都没有，划不来啊很划不来。因为太显而易见了，我都不晓得怎么回答这个问题。</p>
<p>once upon a time，我只身去远方旅行，家长拜托当地的友人照顾一下。友人很负责地百忙之中抽空领我四下游玩。当然生意人么，时间就是金钱，所以游玩间隙得到机会还是要百忙一下。于是在经过市中心的时候我们顺便进入当地最大的医院，直接找到该医院最牛X科系的主任。友人与主任一旁切切私语。我虽未成年，却不 innocent，诸如什么美国还没有通过临床检验期的抗xx病特效药，成本价多少，进价多少，开方价多少，给医生的回扣多少，等等等等，即使不是故意偷听也知道一二，自然晓得他们在聊什么。待友人谈毕了事情，主任送我们出来，拍着我的肩说“好好念书，只要你能进医学院，毕业了进xx医院肯定没问题”云云。只见候诊室里坐着千里迢迢不知从哪个乡下赶来看病的黑瘦农民，主楼门外停着医生们闪闪发亮的bmw。</p>
<p>后来我没进医学院，却报名了经管的双学位。我想知道，为什么有些人劳碌一生背朝天脚踏地提供人类最基本最需要的东西，末了搭上一生的积蓄却连一盒药都买不起，而有些人仗着好运或者好命就能在几个小时一桌饭上挥霍掉别人一年的生活费。虽然毕业之后我选择当民工——大部分时间跟代码纠缠是很痛苦的但在某些时候还会觉得“至少我是个创造者，一个小小的程序至少能改变一些人的生活”，不过这段过程还是挺有用的——至少想起来了自己还会记个账，也不至于被什么投资顾问坑骗。知识这个时候不仅是力量，也是金钱，我总觉得金融学之类的课程，在一个真正有道德的国家是应该免费的开放给所有国民，上山下乡，像大选宣传候选人那样硬塞也要塞给每个公民人的。</p>
<p>但是现实世界的国家，全都分成既得利益者和未得利益者。既得利益者制定掌握控制了游戏规则，以防止自己的利益被未得利益者窃取，未得利益者削尖了脑袋钻营这些游戏规则以求谋取别人的利益，而一旦他们得到了利益，他们就变成新的规则守护者。变的只是玩游戏双方的关系，游戏的规则从来未曾改变过。 greedy是人类的天性，人人都以为“只要我这样这样，那样那样，我也就可以变得和xxx一样一样”。于是掌握了规则的人，都不希望别人窥探到规则当中的奥秘，更不希望有人来打破这个规则。直到这个游戏崩坏为止，所以金融学校永远是最贵的学校。</p>
<p>问题是，永远没机会成为得利者的人问——什么会时候崩坏？既得利或者有可能得利者问——如果我们不想它崩坏，想继续这样玩下去，有没有阻止的办法？</p>
<p>进入二十一世纪后，几次金融危机好像大震前警告，预示着一场以美国这个掌握了全球最多资源的金融帝国为核心的大灾难的到来，于是所有处在这个金融圈里，利益间有瓜葛的都开始自危，都开始思考。这部电影应该跟Cleveland vs. Wall Street一起看，看两种文化两种经济制度两种社会体系——自我设定角色为“有可能得利者”和“永远没机会得利者”——的思考后结果。</p>
<p>本片以社会主义式的经济制度被破坏的结果入手，片中采访的几位国外官员，其中有象征着第三方崛起力量的中国，亚洲四小龙的新加坡，而充当欧洲发言人的并非好朋友英国，而是其历任（不包括现任）总统都被美国指为“对美国不友好，喜欢共产党”的法国的财政部长。这三个国家的发展路线，社会制度，司法体系各有不同，透露出本片编导对于国家干预经济，结束美国人向来标榜的“绝对自由市场”，这个路线的倾向性。</p>
<p>而另一厢边，在面对美国的钱力时，法国人恰恰也在想着改变自七八十年代开始搞起来的国家社会主义形式。</p>
<p>在这场追逐钱的游戏中，根据能量守恒，永远只能是一部分人压榨另一部分人的结果，每个个体所在乎的只是自己究竟处在被压榨一方还是压榨者一方。美国的社会结构以中产阶级为中坚力量，银行家和政客们也都不傻，不会太伸手去压榨这个主流社会，而主流社会想的也不过就是老婆孩子热炕头，这些都有保障之余，现行的社会体制还能给他们个“一朝致富爬入上流”的美国梦发发，那些低收入户是死是活有何相干。只要这一部分人的利益没有受到威胁，只要这一部分人还乐于盯着眼前的胡萝卜前进。那么这场游戏必将以现行的规则玩下去，直到崩盘的那一天。温水煮青蛙，向来如此。</p>
<p>电影这个载体，当不是以娱乐的姿态，而是以这种“我要摇醒你们”的形态出现在大众面前时，其威力究竟是否能达到艺术家们所期望的力量，也只能拭目以待了。毕竟greedy is good，如果眼前就有一块肥肉，谁能禁得住诱惑不立刻咬上去呢？我们真心所希望的，也只是——这块肥肉千万不要是从自己身上割出去的才好</p>
<p>PS：通货膨胀，房价飞涨，两极分化，教育昂贵，政经一体，权钱交融……大家觉得此情此景此等描述熟悉吗？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E9%A6%99%E6%B8%AF%E6%80%8E%E4%B9%88%E6%95%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E9%A6%99%E6%B8%AF%E6%80%8E%E4%B9%88%E6%95%91/" class="post-title-link" itemprop="url">香港怎么救</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-20 21:40:42 / Modified: 21:41:00" itemprop="dateCreated datePublished" datetime="2020-03-20T21:40:42-04:00">2020-03-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天我们跟风，讲一讲香港的问题。首先一句话概括一下香港问题的实质，那就是，香港内部的阶级矛盾，被恶意引导为陆港矛盾。</p>
<p>过去，我讲过一个“伊里奇陷阱”。也就是说，要学会换位思考。我们讲政治稳定理论，实际上就是把列宁主义的革命理论倒转过来，换个角度看问题。列宁讲革命的前提，讲的是“两个不能照旧”：一个是统治阶级不能照旧统治下去；另一个是被统治阶级不能照旧生活下去。</p>
<p>现在我们的分析更多侧重于第二个，也就是从民生角度，从经济角度去看问题。这是对的。比如说，我们讲香港，人均住房面积大概只有16平方米左右，相当于大陆的40%左右。在大陆的住房问题已经成为年轻人痛点的情况下，香港年轻人究竟有多不愿意照旧生活下去，是显而易见的。现有的分析也有很多，这里不班门弄斧。</p>
<p>但是，光分析民生问题是不够的。毕竟，香港无论如何，都是高度发达地区，香港的贫民，无论是从账面上还是从实质上看，也都属于相对贫穷。所以，香港这种相对贫穷，光是从民生角度看，并不必然导致政治和社会问题。还是要去找第一个原因，也就是为什么不能照旧统治下去。</p>
<p>对于正规的资本主义而言，私有制下的市场经济制造出的贫富差距，是依靠西方式的大众民主去平衡的。也就是说，贫民虽然在经济上没有钱，但在政治上，和富翁有着平等的一票。至少形式上如此。即使在许多不那么正规的资本主义国家和地区，尤其是在发展中国家或转型社会中，形式上的平等被实质上的贿选所操纵，但人家好歹还得花钱来买这个票。</p>
<p>对于正规的社会主义而言，具有比较完善的人民民主制度。很多人对东方式民主有误解。但事实上，东方式民主政治中，开会的过程和谐，是因为将很多工夫做在了会前，通过充分酝酿、科学分析、广泛征求意见，再将一个各方都能接受的议案付诸表决，从而使多数决议能够较好的体现各方面意志。</p>
<p>问题是，在香港，这两种形式上的民主都是不具备的。香港特区的行政长官由一个选举委员会选出。这个委员会包括了4个界别，共38组。第一组是工商业，包括17组资本家。第二组是专业人士，包括会计、建筑、教育等10组高知分子。第三组是渔农、劳工、宗教、社会福利、艺体出版等5组社会贤达。第四组是全国人大代表、政协委员，以及各级议员。从这个构成不难看出，香港政治并不是去设法弥补劳动群众由于私有制与市场经济所造成的被剥削地位，相反，更倾向于强化精英阶层，即剥削阶级在香港社会中的统治地位。这样一来，被剥削的大多数人的利益诉求势必在既有政治框架下很难有合法的实现途径。在这种情况下，单纯说什么法治与理性，实际上是十分空洞的。</p>
<p>当然，不民主的社会并非不能维持稳定。对于一个方圆近千余平方公里的小地区而言，极权政治没有存在的土壤，威权政治倒是可行的。然而，自古以来，要搞威权政治，首先要有威。而要有威，那么就必须有一个强大的统治集团。然而，这样一个集团在香港是不具备的。</p>
<p>如上所述，香港的政治体制塑造出一个人数占绝对少数的精英集团。在“港人治港”的大框架下，形成了与被治的港人相对立的、横亘在中央政府与香港人民之间的一个“治港港人”集团。他们代表人物，正如本号其他文章所说，当然是李先生们。从“一国两制”的初衷看，我们当然是希望这个“治港港人”集团能够切实担负起治港责任，维护好香港的繁荣稳定。如果做不到，至少维持稳定。</p>
<p>这里讲到了两个字：责任。问题是，这种责任感在“治港港人”集团中是不存在的。但凡实行威权政治，那就是以少数去治理多数，若是少数人无组织、不团结、没有决心，又如何治理得了呢？要说好的威权，新加坡就是典型，维持了繁荣稳定，但那是别人家的李先生们。差一点的威权，统治集团从齐奥塞斯库、卡扎菲等人血淋淋的教训中也不难看出，丢失政权就是死路一条，拼了命至少能维持个稳定，即使最后不一定做得到，出发点总是这样子的。</p>
<p>前几天我们讲，一个政府，可以腐败，但不能无能。今天要补充一句，无能就算了，好歹得负点责任。但事实上呢？这个“治港港人”集团所做的，是把香港的利益据为己有，10个最大的家族资产就占到香港GDP的35%，这种财富集中程度世所罕见。但与此同时，一是将资产逐步转移出香港，转移到大陆和西方，这样一来，就不再同香港的命运联系在一起，随时可以跳船。二就是把统治责任推给中央政府。</p>
<p>要使北京去背这口锅，很显然，就是要将“治港港人”与“被治港人”的港人内部矛盾，转化成了港人与大陆的矛盾。要让在香港几无立锥之地的穷屌觉得自己和李先生是一种人，却与深圳河对岸的大陆同胞不是一种人，很明显，就要强化“港人”的身份认同，而弱化“被治”的阶级认同。</p>
<p>于是，经济上的民生问题与政治上的民权问题就必然由建构“香港人”这样一个想象的共同体，而转变为民族问题。你要问“港独”是怎么来的，就是从回避不平等经济体制与不民主政治体制那里来的。有文章讲香港的年轻人“蠢”，这是不对的，从整体受教育程度看，香港年轻人比大陆还是要高的。当然，从政治上看，他们的政治表达方式与具体政治诉求确实相当不成熟，但是，我们要知道，这种不成熟并非先天愚钝，而是由不平等不民主的政治经济体制所塑造出来的，是由于他们没有生在红旗下、长在新时代。</p>
<p>只要我们知道，香港问题的症结一不是出在中央政府身上，二不是出在香港人民身上，而是出在横亘于这两者的“治港港人”集团身上，就应该知道，香港并不是没有救。</p>
<p>对维持香港繁荣稳定的共同愿望构成了中央政府与香港人民同呼吸共命运的基础。维持香港繁荣稳定，对于中央政府来说是必须的，因为无论风云如何变幻，香港就在那里，谁也带不走。对于香港人民来说也是必须的，因为无论风云如何变幻，他们就在那里，贫贱是不能移的。对于“治港港人”来说，不是必须的，他们在世界各地都有资产。</p>
<p>通过“治港港人”实现港人治港的这种间接统治的政治安排，本意是希望一个在香港既有既得利益，又有统治经验的集团去维持香港的繁荣稳定。因此，我们可以让渡给他们一定的经济利益。问题是，既然他们不仅做不到这一点，反而将他们获利所带来的社会矛盾转移到中央政府那里，我们就不禁要问，凭什么要许给这些麻烦制造者香港GDP的35%那么大的利益？</p>
<p>对于香港人民，尤其是香港年轻人来说，关键是必须看清自己诉求的实现路径。必须要让他们认识到，让他们买不起房子的，绝不是远在天边的中央政府。大陆的执政党及其领导的人民政府，是香港人民最可依赖的核心力量。除了大陆的党和政府，没有其他任何一个国家、任何一个组织能够帮助到他们。要看清楚，香港的繁荣稳定，符合双方的共同利益。</p>
<p>这样一来，路径就很清晰。站在“被治港人”的立场上，很显然，就是要把中央政府当做是对抗“治港港人”的依靠，要把意志统一到爱国爱港上面。他们应该认清，西方列强是靠不住的。无论谁给了何种承诺（更何况连公开的口头承诺都不敢给），都应该认清，同中央政府对抗没有出路，与中央政府合作前途远大。</p>
<p>这就意味着，给西方列强和本港大亨当枪使，将矛头对准大陆，不仅实现不了自身经济利益与政治诉求，反而会遂了“治港港人”的意——假如“被治港人”靠不住，那不就只能依靠“治港港人”了？相反，和中央政府、大陆人民站在一起，“治港港人”就成了可有可无、有不如无的群体，那么，为什么还要留着他们呢？</p>
<p>如果香港人民觉得这样好，那就这样办。如果觉得这样不好，那就算了。问题总归是要解决的。</p>
<p>最后是学习强国时间：</p>
<p>从1997年7月1日回归祖国那一刻起，香港的前途就已牢牢掌握在香港同胞手中，香港的命运就更加紧密地同祖国的命运联系在一起。有伟大祖国作坚强后盾，依靠香港特别行政区政府和社会各界人士共同团结奋斗，香港就一定能克服前进道路上的任何风险、困难和挑战，香港的明天必定会更加美好，香港市民生活必定会更加幸福，祖国的东方之珠必定会更加璀璨！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/19/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%98%E6%98%AF%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/19/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%98%E6%98%AF%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/" class="post-title-link" itemprop="url">Java工程师还是算法工程师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-19 23:53:25 / Modified: 23:55:34" itemprop="dateCreated datePublished" datetime="2020-03-19T23:53:25-04:00">2020-03-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>年轻人想太多了，以大部分人的技术水平，都谈不上选择技术方向，出去都是被社会艹的。</p>
<p>大部分人，能够选择一个价值观和你 match，给你机会发展的公司，已经是人生高光时刻了，做啥技术真的不重要。</p>
<p>打个蹭热点的比方，你要是憧憬生物学，去了武汉病毒所，除非你心黑，喜欢靠院士升职器当所长，这我无话可说，年轻人心不够脏的，你选择生物学方向，却屁颠颠去了这种机构，方向还重要吗？</p>
<p>像我们一些垃圾群里面</p>
<p>有人喜欢算法，刚进行业时候，觉得自己数学好所以放大算法的价值，恨不得未来都是算法，然后干两年，发现破烂公司觉得算法没用，做算法创新涨一点点，还不如写 ppt 做架构做产品的牛逼，技术又上不去，管理也做不好，团队都被削了，跳槽没人要，整天骂骂咧咧。</p>
<p>有人喜欢做开发，觉得自己特立独行，恨不得都劝退算法，过来搞开发，结果发现开发特别吃年龄，活也重的喘不过气，30 岁升不上管理或者架构师，就要退休了，自己爬不上，最终也是整天骂骂咧咧。</p>
<p>有人喜欢钱，拼命刷题，一开始 offer 多， 纠结个半天哪个岗位钱多，结果找一个号称技术积累深厚，天天沸腾，搞“牢疫结合”的公司，进去发现领导结果就是坨屎，2 年下来技术啥都没学，白闷一肚子火气。</p>
<p>结果，现在全都成了一堆骂骂咧咧的人。</p>
<p>然后其他人咋理解我们呢？一群针对互联网的黑公关狂欢！只有我们深知，绝对没有人能够跟上社会科技和商业的改变速度的，你奋斗还是躺平，都是一个人和 N 平方的群体博弈，保不济还有黑天鹅事件，你说统计上谁赢？</p>
<p><strong>大部分普通人与其纠结选择啥，还不如想着社会未来会是啥，增量是啥，你思考对了，躺在这个潮流里面都能笑傲江湖了。</strong></p>
<p>想靠 alpha 策略成为人赢，当你知道这个因子的时候，因子已经开始 decay 了。</p>
<p>你真的倔的不肯承认，活该被全球 quant 顺着网线过来打你。</p>
<p><strong>支撑一个人走下去的，从来不是你手头那点杂耍，而是你内心相信未来是啥，是信仰让你坚强，不是高空走钢丝赢来的廉价掌声。</strong></p>
<p>少年，你从现在开始，应该努力思考，我该如何做，才能更加接近未来互联网的新形态和新的渗透模式。</p>
<p>职业危机的本质是什么？本质是不需要那么多有经验的工程师，如何拿五个人的饭喂饱十个人？答案是，怎么分配都有人吃不饱。所以，这不是个人选择问题，而是市场问题、需求问题。比如一个老兵，会用迫击炮，会叫空中支援，懂无线电通讯，会火力压制，但是在岛主手下当兵，发一杆中正式，50发子弹，10个手榴弹，就这点东西，吃不饱饭还用绳子牵着防止逃跑去上战场跟穷凶极恶的鬼子拼命，那未必比得过战友那些文盲出身的士兵。因为，岛主的需求和市场和成本，不足以支撑美式老兵。难道，30多岁软工多年的老工程师，真的不如20多岁的新人？我30多岁写代码的能力比20多岁时不知道强了多少。关键在于就业市场和公司强调的，是什么竞争力。国内码工市场显然强调的是工作时间和耐劳易使。35岁的人其实技艺更精湛，但耐不住精力衰退，家庭分心，所以工作时间下降了不少；加上老油条好多时候想得多见得多，更不容易被情怀忽悠，滑得很。以前我觉得，这种跟西方的差别，是效率和技术水平导致的；现在又觉得，这也许是文化导致的，是思路不一样导致的。东方的思路本身就是强调人本身的能力，把“人”的潜力发挥到最大，是主观性的；西方的思路是强调“流程”，尽可能地消除“人”之间的差异，是客观性的。这是两种不同的思潮和习惯。测试职位回到正题，测试本身就是软件开发下的一个分支，既然软件开发都有市场带来的35岁危机，那么转测试并不能从根本上解决问题。当然，单分析测试和开发这两个方向的话，可以说测试更不乐观了。提到测试历史，必须说“陆奇改革”事件。长话短说，就是陆奇在微软时将自己部门SDET全部改为SDE，最后推广到全公司。这种带阵痛的改革非常成功，使得微软大大提高了开发效率。我先前听说一个SDET的Manager，在微软17年，从SDET1一路升上来，一行code没写过，是不是舒服得有些过分了？陆奇改革后，这人后来转成了SDE2，当然，人早就不差钱了。测试分为两种：手动测试的严格来说不算测试，跟Engineering不搭边，在如今的环境下，大公司基本上都是外包这种手动测试（中国和印度）；一般软工说的“测试”应该指的是“测试工程师”，是知道如何写code的人，写测试用例和框架。然而，测试工程师最大的问题就在于，他们的工作内容只是软件工程师的一个子集。这些code，完全可以交给软工来写，并且软工还更了解一个系统的弱点和细节。这就导致，测试工程师的职位，也被逐渐削减或是外包到更便宜的公司和国家去。我不是说测试框架在软工中不重要，而是说那种传统的微软式的开发、测试成双成对的做法，逐渐转变为全开发职位，部分人或是部分精力维护测试框架，偶尔一个部门下有一两个专精测试框架的专家（亚马逊这样做）即可。所以， 我个人认为，跟十几年前流行的工作方式比，其实对软工的要求更高了，活更重了，整个环节也更简单了。这就带来，软工职位不断增加，而测试、DBA等职位不断被削减，公司的效率和收益更高。从前，软工只是被认为是软件开发的一个环节，虽然也是最重要的；如今，软工的职责范围其实是扩大了。甚至，在很多快节奏，更现代化的大公司，软工还管项目进度和人员协调，以及项目报告等很多活，部分替代了PM/TPM/Manager的职责。有时候manager跑了、被开了，甚至还有“码工自治联盟”状态出现，没人管，几个码工自己商量做什么，也见过。这也部分解释了，软工需求大而且工资在过去10年间慢慢上涨的原因。很多公司之所以难面，不光是算法题的问题，还有承压、交流和设计等很多指标。要求高了，自然难招人，公司也不在乎钱多给点，因为巴不得进来的都是多面手。行业兴衰个人的努力虽然能够减缓、但是还是很难摆脱行业兴衰的。一个行业，享受它的福利，就必然承受它的规律和残酷。软工，无论国内外，最大的特征还是高强度的智力输出。而人的思维活跃和精力，无疑是一直随着时间而衰退的，有些衰退是因为要考虑的事情更多（比如身体状况，家庭等），哪怕30多岁更聪明了更努力了，也不行。此外，软工的行业跟总经济形式特别相关。你可以看出，各国的软工待遇，跟其GDP是非常相关的。中美IT之所以厉害，你当然可以吹说中美两国人聪明、能吃苦、自主研发，但说穿了还是因为两国GDP世界第一第二，有的是钱和市场，随便给点投资就雇得起码工去造东西，然后在本来已经非常巨大的市场上获得更多回报，良性循环。比如某些垃圾国家，饭都吃不饱，肉都不敢大口吃，穷得叮当乱响，你做外卖软件给谁用？在这种情况下，我倒是觉得，应该心平气和： 自己赚钱，是因为踏上行业的快车；自己失业，是因为行业或是经济下行。个人的能力和选择，倒没必要那么焦虑。</p>
<p>如果是技术类型管理的话，说几点：</p>
<p><strong>最重要的，明确组里在公司的地位，聪明地接活，合理的安排活</strong></p>
<p>业务过于琐碎和繁重会压垮组里成员，接着压垮你，要懂得抢做重要的活，为组里的整体绩效做精细化打算。</p>
<p>抢活能力是管理层自身修为的重要体现，无非两个方面，你的技术和人品都要好，技术好不必多说，技术不好连人家要做啥都不懂，谈何抢活。</p>
<p>这里强调人品不好的，就是对人特别狂的那种，这种人不适合当管理，很容易引起组和组之间的矛盾，这对整个组的影响力都是灾难性的打击。商业社会是利益的捆绑体，一个人再厉害，被人厌恶，也抵挡不住一堆人对你抵制。</p>
<p>当然，待人接物温文尔雅，这事情没这么理想，如果公司金字塔结构都被削成纺锤形了，中层管理哪怕学富五车，也一样极度内卷，谁也看不惯谁，互相倾轧抢活打架，这也是非常有可能的。</p>
<p>一般感受到这种纺锤形结构诞生以后，我觉得，中层管理赶紧跑路为好。</p>
<p><strong>保持打磨自己的技术，不求深，但一定要广</strong></p>
<p>管理以后技术是不可能变深的，管理如同挖战壕，你挖地过深会导致和其他人挖的连不到一块，反而还会形成一个巨坑，谁都爬不出来。此外，组里有人挖的深，有人挖的浅，管理要做的的是保证深浅不一的都能够串接起来。</p>
<p>所以，技术管理层技术广度必须够广，这里的广，不仅说你懂的知识多，而且，你还要知道各种 low 的解决方案，和各种高级的解决方案，雅俗共赏。不然各种乱七八糟的技术做出来，你半天整合不到一起，同事做的你不懂没法帮人家说话， low 的你看不惯打击人家，感情这饭你没法吃了。</p>
<p>但是，管理也有弊端，因为技术不深，导致跳槽经常性吃亏，一般国外的技术狂人都很不喜欢 manage people。只是国内风气不知为何，上年纪必须要考核你管理能力，实在是烦人。</p>
<p><strong>听组里同事吐槽和抱怨，并想办法制造条件给他们排忧解难，学会给组里同事挡子弹</strong></p>
<p>强调的是，管理不是奶妈或者坦克职业，管理也不是花掉你全部生命去做全职心理顾问，接受吐槽和挡子弹，只是一种最大化激励团队的措施，听取抱怨是防止有本事的同事频繁离职，增加你的招人成本，同时防止造成人才的死海效应。挡子弹是激发同事发挥更多自己主观能动性的措施，同时让他们觉得和你共事是有安全感的。</p>
<p>一般公司的管理层和干活的绩效是分开打的，所以同事干活开心产出高，管理层也有好的绩效，两者不是你死我活的关系，而是同生共辱的关系。</p>
<p>此外，国内对管理的理解还是掌握人事权这一点有点分歧，认为管理是统治阶级，抱有敌对态度。其实将心比心来说，互联网管理类岗位是很危险的职业，技术精进放慢，琐事增多，拿的工资未必比技术人员高(沸腾厂除外？？？)，离职跳槽非常困难，公司一个内斗或者业务不确定，人生被毁掉还不如一个写前端的小弟出去好找工作。</p>
<p>至于如何听取抱怨和吐槽，这和你听你家人唠叨和抱怨一个道理，很多抱怨都是你个人理性层面没法理解的，但是你也要听下去，所以，可以从家人入手，解决他们的唠叨，学会让他们宽心，这个训练如果做下去，往往非常见效。</p>
<p><strong>正确对待组里怠惰的同事</strong></p>
<p>有些同事可能对业务和前途没啥盼头，觉得业务做来做去都是一坨屎，陷入迷茫状态，这对管理人性话来说，很考验心性的。可能国内管理第一想法就是干掉人家，常见于脉脉里面骂街的针对对象，这是一种懒政思维，也是恶化团队关系，增加各种谣言的罪魁祸首。</p>
<p>对方不想做就候着，让他做自己喜欢做的，刷题考证都别理他，也别灌鸡汤忽悠人家或者苦口婆心劝对方，正确的方法是，组里潜意识灌输你不来给我们解决琐碎问题，我们组就要挂了的一种危机感，潜移默化让他觉得他是来救你的，不是来给你打工的，激发他的主人公意识。</p>
<p>至于如何让对方觉得做琐碎事还是救火呢，很简单也有点欺骗性质的，就是每周开周会的时候，让组里其它同时疯狂吐槽这东西不做，就没法干下去了，需要人来拯救，接着管理者适当抽象这种吐槽，变成目标明确的活，说谁能解决请谁吃饭，总之多来几轮这种形式的会议，怠惰的同事久了也不好意思一个人啥都不干，愣在那里摸鱼。</p>
<p>所以，有时候，可以巧妙地把一件事情拖到大家都觉得重要了才开始做，大家的战斗力都会巨大提升，deadline 是生产力，不是吗？</p>
<p>最后一点，不是最重要，但是却是一种神奇的力量，就是谈吐能力</p>
<p>谈吐能力无非几点，让人感到通情达理，幽默风趣，格局宏大，句句金句，都是好的谈吐。有空多多看看奇葩说一类的，看几本语言震撼的文学作品，多和脑洞大的有趣的人聊天，懂生活懂得玩，有共同话题。不求道理对不对，但求你的表达能力让人觉得耳目一新，听起来就是有趣的人。无论做啥事情，风趣的沟通能力都是好的印象分，如果实在受不了社会的虚假，你可以到网络匿名吐槽怼人也成(虽然我不是太赞同，不过有一些宣泄渠道很重要的)，总是，人前一定要学会高级别的谈吐，让人觉得你谈吐能力一流的人。</p>
<h2 id="中台和微服务有什么区别？"><a href="#中台和微服务有什么区别？" class="headerlink" title="中台和微服务有什么区别？"></a>中台和微服务有什么区别？</h2><p>你到高校去，导师承包一个项目，分给学生做，学生根据甲方需求，没日没夜做好一个项目，做完毕业，然后师弟过来接手，一看傻眼了，完全看不懂，推倒重做，接着毕业，接着让小小师弟接手，小小师弟接着崩溃，接着推倒重做。</p>
<p>组里唯一日益增长的，是导师的荷包，手下无数的横向项目ppt，还有组里某个学生才能看得懂的项目成果。这些拆分无比稀碎，功能又交叠极大的微型工程，只有做这个业务的学生看得懂，其它学生想用，费劲，没门。</p>
<p>导师一看，不成呀，每次招一个苦力过来，都要高年纪的学生带，越带越吃力，还重复造轮子，出活越来越慢，成本越来越高。</p>
<p>咋办呢，导师心里一横，把几个技术好的高年级博士叫过来，画了一个大饼，说你们前途无亮，让他们把整个组的项目都整和梳理一遍，把里面共同，且通用的东西都抽离出来，做了沉淀，让以后新来的师弟能够快速完成横向项目。</p>
<p>这几位博士不负众望，高质量地完成了导师的任务，让新来师弟调包溜得飞起，小小小师弟很快地解决了导师的横向项目，迅速毕业，走向人生巅峰。</p>
<p>而这几位博士，却因为没有直接完成导师的横向项目，被导师延期了。。。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E7%97%85%E6%AF%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/18/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E7%97%85%E6%AF%92/" class="post-title-link" itemprop="url">如何看待所谓中国病毒</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-18 13:07:58 / Modified: 14:08:51" itemprop="dateCreated datePublished" datetime="2020-03-18T13:07:58-04:00">2020-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>川皇这不是不合适，是不要脸。</p>
<p>美股三次熔断，按他老人家当年的言论，他是要装进大炮发射到月球上的。三次，地月之间三个来回都够了，人肉阿波罗。</p>
<p><strong>别人说得一点都没错，你莫乱发表言论好吗？多看的专业知识，把工作做好争取早点考个中高级职称，莫管闲事好吗</strong></p>
<p><strong>没上进心，整天混日子迟早会被淘汰的</strong></p>
<p>现在问题来了：人家不要脸，你咋办？</p>
<p>CGTN？</p>
<p>某性感主编在线叼盘？</p>
<p>观察者网国内整几个视频批判一下来波流量？</p>
<p>真特么内卷。</p>
<p>出门干啊！现在一通操作管下来，费拉不堪。忘了我们帝吧当年多么武德充沛么？</p>
<p>推特转发个几万条就全球热搜了，帝吧老哥分分钟能让你被骂上全球热搜，也能分分钟让你主动关闭评论区。</p>
<p>从当年红客留下来的口嗨传统，愣是给自我阉割了。现在川皇一口水洗脸，想起义和团了？</p>
<p>无事关闸，有事开闸？当人狗呢？连央行降准的闸都没整明白，指望你会在舆论的闸上开关自如？</p>
<p>疫情的舆论战争到底算不算人民战争？</p>
<p>川皇今日说中国病毒，明日就是中国造成的损失，后天欧洲一帮右翼党派喜滋滋点赞。</p>
<p>你之前的一切努力，近乎乌有。</p>
<p>b站一堆营销号可以艰难地在油管评论区找几句好听的，然后剪下来糊弄b站小孩，自欺欺人营造一种“我们好受欢迎鸭”的幻觉。</p>
<p>你不能这么干吧？</p>
<p>凭啥代表我们唾面自干？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/%E5%8D%B1%E6%9C%BA%E4%B8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/%E5%8D%B1%E6%9C%BA%E4%B8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%BA/" class="post-title-link" itemprop="url">危机下的四种人</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-17 16:34:18" itemprop="dateCreated datePublished" datetime="2020-03-17T16:34:18-04:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-18 09:17:00" itemprop="dateModified" datetime="2020-03-18T09:17:00-04:00">2020-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天讲一点点政治经济学。原理是重要的，特别是当你被市场经济搞的生活不能自理的时候。</p>
<p>第一个案例是小黄车。小黄车是什么问题呢？现象上的小黄车是一个遍地垃圾的问题，质量上的小黄车是一个刚好满足成本最低又不会骑着骑着就散架的二次函<br>数最大值的初中数学问题，政治经济学的小黄车是一个你在1929年就学会的资本<br>主义的生产过剩问题。</p>
<p>创业不是一个政治经济学概念，创业是一个文学概念，创业用政治经济学的说法叫资本主义再生产。是资本家的钱躺在账户里就相当于亏本，必须拿出来钱滚钱，小黄车只是钱滚钱的工具，而依附于这个工具上的一切美名其曰创业的活动都是对这个原理的修辞。</p>
<p>第二个案例叫做瑞幸咖啡。这个案例的修辞是据说要改变中国人的生活习惯。修辞背后的原理是一样的，我们决定讲一讲这个原理，即资本主义再生产的必然性是什么，即为什么资本家的钱不能躺在账户里。</p>
<p>因为资本主义从诞生开始就是冲着毁灭封建生产关系去的。封建生产关系是一种怎样的生产关系呢？是你知道你的土地是有限的，你知道人口涨到一定程度就必须战争，你知道君子之泽五世而斩，在有了这种稳定的预期之下诞生了一系列以宗教或者礼教为工具的社会生产约束。</p>
<p>然后资本主义来了，资本主义用创新和效率证明过去的约束条件统统不存在，我只要比你更快地生产，消费，投资，再生产，封建关系就会瓦解，你就要找我借钱。在这个游戏里，非但地主阶级抵抗不了这一套，小资产阶级和法西斯同样抵抗不了这一套，我只要比你快就好，冒险只要成功一次，就能覆盖之前的所有损失，这是资本主义出现后，西方资本家发现世界无限大后的本能反应。</p>
<p>当世界不再无限大的时候，就会发生帝国主义和帝国主义战争，如果核武器让帝国主义战争打不起来，帝国主义内部就会发生革命，资本家就会绞死自己，然后新一轮的科技创新，新一轮的速度游戏，历史周而复始。如果核武器让帝国主义战争打不起来，帝国主义内部就会发生革命，最后，革命未必会让你变得更好，说不定会让你变成俄罗斯和乌克兰。</p>
<p>明白了这一点，你才能理解为什么在中国的全要素生产率提升速度突然慢下来的时候，会出现小黄车和瑞幸咖啡这种东西。小黄车和瑞幸咖啡的投资者非但不是愚蠢的，反而是理性的。主要的创投扔出去的并不是自己的钱，但是没有项目投是不行的。自由市场发展到后期不但不会提升社会的生产率，反而会导致社会资源的浪费，因为浪费资本家的钱对职业经理人反而是有好处的，而资本家也必须允许这种浪费，你亲眼目睹了政治书里发生的一切。</p>
<p>那么怎么办呢？</p>
<p>接下来我们开始阅读新闻。</p>
<p>社科院蓝皮书：制造业就业需求萎缩，结构性失业和招工难并存。</p>
<p>这个新闻是什么意思呢？这个新闻是直接指向去年10月各个大企业内部开始压缩就业名额的措施的。具体讲，战略新兴产业人才不够，传统的就业大户现在不需要这么多人。</p>
<p>什么是传统的就业大户所不需要的人呢？我们再看下一个新闻。</p>
<p>京东坚决淘汰三类人。</p>
<p>某茶卸任重庆嫩绿茶艺董事。</p>
<p>显然，当然是互联网引发的服务业扩张所新容纳的就业人口。</p>
<p>这些人为什么要被挤出呢？因为你越要压低成本，你就越要996，你越996，你就越没有时间消费，你越没时间消费，就导致就必须进一步压低成本才能吸引你消费。循环几次你就可以自闭了。</p>
<p>这个现象和主题有什么关系呢？让我们回到政治经济学。</p>
<p>政治经济学明确了，生产过剩就是泡沫，泡沫就是生产危机（达里奥这种反复从经济周期中获益的大佬也直言不讳这一套对百分之八十的美国人毫无用处，因为他发现美国小孩的社会平均福利在不断下降，同样，我们讲过，09年信贷扩张之后中国小孩所享受到福利的质量问题），就在互联网服务业引发了巨大的创业泡沫的时候，工人阶级的先锋队当然是洞察了这一切，那么不好意思，只能以抬高上游企业生产成本的方式直接刺破泡沫，走好不送。</p>
<p>为了进一步巩固这件事的效果，下一步的思路自然是扫黑除恶，打掉高利贷分子的社会基础。至于你问我为什么先锋队为什么要这个时候刺破泡沫，我只能说这是历史的进程。</p>
<p>接下来会怎么样呢？我们回到社科院的报告提到的随着经济结构的调整所必然出<br>现的结构性失业问题。过度扩张的互联网服务业收缩时，最终挤出的人口要怎么<br>办呢？</p>
<p>以美国为例，苏联解体后，美国进一步将制造业转移到海外，国内傻的可爱高呼苏联解体万岁的白人工人阶级被这一套瓦解（搞垮苏东就是为了东欧世界的廉价劳动力啊哥哥，最后你不但当不了工人阶级，你连权贵的仆从都当不好，众所周知，美国人没有东欧人长得细腻），在不存在中产阶级这个阶级之后，他们应该怎么办呢？</p>
<p>最普遍的方式就不提了。有一句话说得好，no country for white men.</p>
<p>稍微好一点的方式是嗑药，滥交，环游世界，散步阴谋论，成立自己的右派网站，并且鼓动自己的粉丝给特朗普投票，宣称美国已经被犹太人篡夺。</p>
<p>进阶一点的方式是参军，改掉坏毛病，一边打工一边考上耶鲁大学法学院，却发现自己完全不知道怎么在有三把叉子和七个瓶瓶罐罐的餐馆吃饭，毕业后看着自己的同学飞黄腾达，一腔悲愤写出一本《乡下人的悲歌》。</p>
<p>高阶一点的方式是完全把自己与同样阶层的人隔绝开来，去图书馆猛看曾国藩传<br>和列宁全集，参加海军，去高盛搞清楚资本主义那一套，然后辞职，创办布莱巴<br>特网站，送特朗普进入白宫，再次辞职去欧洲发动群众，发誓干死索罗斯，深藏<br>功与名。</p>
<p>最后让我们阅读一份文件。</p>
<p>超大特大城市要立足城市功能定位、防止无序蔓延，合理疏解中心城区非核心功能，推动产业和人口向一小时交通圈地区扩散。大城市要提高精细化管理水平，增强要素集聚、高端服务和科技创新能力，发挥规模效应和辐射带动作用。中小城市发展要分类施策，都市圈内和潜力型中小城市要提高产业支撑能力、公共服务品质，促进人口就地就近城镇化；收缩型中小城市要瘦身强体，转变惯性的增量规划思维，严控增量、盘活存量，引导人口和公共资源向城区集中。</p>
<p>什么意思呢？很简单，结束了，回去吧。指望用市场经济去冲破一切，最终无非是一场梦呓。我还是那句话，关心你自己，关心你的过去，关心你身边的人。</p>
<p>我们将在下一期谈一谈如何预防黄马甲的问题。今天的任务就到这里。</p>
<p>现在是吐槽时间。</p>
<p>当生产过剩的时候，企业主采取裁员和关闭工厂的方式来躲避危机，把工厂看作是自己的一己之私，而不是社会大生产中不可或缺的一部分，自大革命开始，企业主就把这种残忍的生活方式当做了面对历史之神露出笑容时的唯一办法，他们总是有一种错觉，觉得自己已经是世界的主人了。这种错觉逼迫着他们种植一些因为假故事而昂贵起来的橙子，再卖给那些连一个工人都雇不起却非要感同身受的好孩子们。</p>
<p>比起这些，我还是更愿意听一听杜金同志的故事，起码他在意识到苏联续不上的时候没有选择背叛灵魂，而只是留起了胡须。但是更多的人毕竟是背叛了灵魂，并且宣称自己这样的背叛是有好处的，是为了国家，自己和父辈们好，希望他们的这种不正确的自我感觉良好能够在海南岛的医疗条件下逐渐康复。</p>
<p>第三个问题，就个人而言，围绕创新我们可以做些什么？我想借此机会对在座每一位毕业生同学谈谈对你们的希望，权当对你们的临行嘱托。</p>
<p>这里，我主要谈六个方面。</p>
<p>第一，养成并保持学习的能力。我在每一次开学典礼上都要谈一个话题：上大学是为了什么？我认为两件事情最为重要：一是掌握学习的能力，二是养成合作的习惯。掌握了学习的能力和拥有合作的习惯，才能事业顺利，缺一不成。</p>
<p>在我看来，学习的能力不是指掌握知识和技能，而是指认知世界、理解世界的能力。我们已经知道“知识越多越反动”这句话是错误的，我还要说培根的“知识就力量”这句话也是有时代局限的。在今天信息爆炸的时代，信息和技能永远在过时的道路上。人的一生只有不断掌握并增强自身的学习能力才能不落后于时代。这也是真正的大学教育的宗旨。</p>
<p>耶鲁大学的前校长理查德.莱文曾经说过一句话：如果一个学生从耶鲁大学毕业之后居然掌握了某种很专业的知识和技能，那是耶鲁教育的失败。学习的能力不仅仅来自阅读，更多的还有走出去看世界、观察世界、思考世界、品味世界，只有这样才能够拥有开阔的视野，体会、了解人类的诸多不同，这会使人更加宽容。宽容是人类最高的智慧之一，它会使人类增进幸福。</p>
<p>第二，独立思考的能力。没有独立思考的个人，不会产生创新性社会。我们都看过电影《阿凡达》，导演卡梅隆70多岁时拍了这部电影，我看后曾说过一句话：这是基于人类的想象达到了人类想象的边界。为什么他可以拍出这部片子？是由于他幼年时代的幻想、对世界的好奇心到了70多岁依然如故，没有被泯灭。</p>
<p>好奇心、想象力在今天的中国，在座各位还剩下多少？我真的不敢恭维。大家从幼儿园走到今天，基本上是做着标准答案走过来的。在毕业典礼上，本应对大家说些鼓励的话，但是我还是想严肃地跟大家说，在各位今后的生活当中，如果没有好奇心和想象力的话，将是人生的悲剧。好奇心和想象力塑造着一个人的偏好和喜好，没有自身喜好的人生或者说有自己的喜好却被父母和其他人强行改变的人生是非常恐怖的。这样的人多了，这样的人组成的社会也一定是恐怖的。所以，学习能力加上独立思考，是形成创新性社会的基本条件。</p>
<p>第三，自主选择的能力。经济学是一门研究资源稀缺条件下行为主体如何选择的学问。在计划经济条件下，我们基本上是不需要选择的。我上小学、中学的时候，感到自己没有什么选择，因为组织上已经替我选好了，不是上山下乡，就是到工厂接班。其实那时也没有什么痛苦，想起来很快乐。</p>
<p>今天，同学们的选择非常多。早晨起来你会选择是到A食堂还是B食堂或C食堂吃早餐，要选择上李老师的课、赵老师的课还是张老师的课。选择是有成本的，起码有机会成本，但不论怎样，市场经济条件下自主选择的成本再多也是必要的，市场经济就是由无数的选择组成的。</p>
<p>今天，在应试教育体制下大家还有多少自主选择能力？近几年经常遇到大学同学、朋友打来电话，说我孩子或者亲属今年要高考了，请你跟我说说哪个专业更好？我问他们孩子自己喜欢什么？经常的回答是“不知道”。在座的各位家长，你们可能更清楚是不是这样。这是很悲哀的一件事情。在我上课提问时，很多同学不敢正视我的眼睛，目光所到之处他们基本上都是放下眼帘，好像他不看我我就看不到他一样。没有问题意识，提不出问题，也自然缺乏自主选择能力，这是个恶性循环。具有学习能力的人，能够独立思考的人，也一定是拥有自主选择能力的人，自然是创新能力很强的人。</p>
<p>谈及自主选择能力，我想谈一点个人体会。现在大家都已基本上选择好了职业，未来还可能有许多新的选择，今天谈这些体会还不晚，也许对你们有参考。经济学强调发挥比较优势，但在做出人生选择的时候，应该注重自己的比较劣势。就是说，你要知道自己的缺点和不足。什么是理性？理性就是知道自己是无知的，或者说知道自己的不足。当你深入了解这些之后，比如在选择职业的时候，就要尽力回避因自身缺陷或不足难以胜任的领域。</p>
<p>这样做，不仅避开了自己的不足，实际上也是选择了你的比较优势，而且会使自己更加快乐、宽容。你不会见到某同学去金融机构做的很好，便产生凭啥我不能去金融机构、大学时我金融学成绩比他好之类的不正常心态。冷静地了解自己的比较劣势会让你有一个健康心态，你会认为那个同学成功是因为他确实很优秀，而在他很优秀的那个方面，我却是不足的。所以，了解自己的不足却不回避，一味地同他人比较，盲目跟风，无异于人生的铤而走险。</p>
<p>第四，审美能力。如果展开一幅世界经济地图，你会发现每个国家都有自己的比较优势，如美国出口的是金融服务，日本出口的是制造业技术，中国人出口的是劳动力，欧洲人出口的是古老的贵族文明积淀下来的审美，几乎所有的奢侈品都来自欧洲。</p>
<p>审美是一种历史积淀，前提是一个国家历史、文化的连续性。这个话题其实是很沉重的，在此我只想谈谈自己的体会。对个人而言，审美是一种品质和修养。一个审美能力低下的民族不仅素养、品格不高，道德水准也会有问题。迄今为止，大家的审美能力基本上都是从父母那里熏陶出来的，问题是在座的各位父母都是“文革”后的一代，这在很大程度上是问题所在。</p>
<p>我非常高兴地看到，在今天的毕业典礼上，大家都穿着皮鞋，穿着带领子的正装，我跟赵勇书记提出过毕业典礼上同学们的着装要求。为什么？看看我们的校园里，许多男同学穿着一条大短裤，露着带毛的双腿，穿一双拖鞋，身披庄严的毕业礼服满校园逛。你们觉得美吗？</p>
<p>今天，走在世界上任何地方，判断一个人是否是中国人的标准，基本上就是服饰与行为。针对个体，主要看服饰，相对于其他亚洲人，中国人的服装搭配比如衣裤、鞋帽、鞋袜等的搭配基本是不合体的，远远一看便知道是中国人，在亚洲人里韩国人喜欢穿着鲜艳，穿的素雅且搭配合理的多半是日本人。如果是团体，看到一个人在说，几乎所有人在听是日本人；一个人在讲，一半人在听，一半人乱乱哄哄的是韩国人；一个人在说，少数人在听，多数人各干各的，大多是中国人。</p>
<p>审美是一种尊严意识，是一种自我尊重也是对别人的尊重。在庄重的场合，一个没有仪式感的人、着装随意的人既是对自己的贬低，也是对他人的极大不敬。在更大意义上讲，审美可以让人知晓世界上的美好与丑恶，它告诉每一个人，人类的行为应当是有底线的，知道有些事情是绝对不可以去碰的、不可以去做的，而不是为达目的不择手段。这样，我们社会的道德水准才会有所提升。</p>
<p>第五，战胜困难的能力。人生中困难是常态，幸福是短暂的，海明威说“勇气就是优雅地面对压力”，人的一生中能成为优雅的人太难了，这也是我自己经常苦恼的问题。有时候，我跟同事说话时会忘乎所以，事后会反思自己的不优雅。但是优雅地面对压力真的是很难的一件事情，一个人在压力面前如果能做到优雅的话，这本身就说明你真的能够把困境作为常态。这一点对大家未来的人生、工作非常重要，会增进你的幸福感。</p>
<p>最后一点，要做一个具有使命感的人。我不想在这里空谈使命感，不要把它看作离我们很遥远的神圣之物。一个人做好自己每一个人生阶段中应该做好的事情，把自己喜欢做的事情尽可能地做到极致甚至像清教徒那样对待自己喜欢的职业并愿意为此努力一生，你就是一个具有使命感的人。所谓工匠精神，本质上与这种对职业的敬畏和使命感的理解与坚守密不可分。工匠精神与功利主义无缘。</p>
<p>在此我还想强调的是，今天的中国已经不是国土沦丧、家破人亡的民族危亡状态，而是处在快速崛起的进程当中，过去的“为中华崛起而读书”不应当是现在大家读书、学习的目标。</p>
<p>今天的中国面对着前所未有的经济全球化的大环境、面对着如何成为创新性国家的重任，只有我们每一个人、在座的每一位毕业生同学成为真正的人，即成为具有学习能力、独立思考能力、自主选择能力、审美能力、战胜困难能力和有使命感的人，你自己的一生才会幸福，我们这个社会才能不断进步，中华民族才真的有希望。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/16/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%8B%B1%E5%9B%BD%E7%9A%84%E7%96%AB%E6%83%85%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%8B%B1%E5%9B%BD%E7%9A%84%E7%96%AB%E6%83%85%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">如何看待英国的疫情操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 23:09:58" itemprop="dateCreated datePublished" datetime="2020-03-16T23:09:58-04:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-17 00:10:47" itemprop="dateModified" datetime="2020-03-17T00:10:47-04:00">2020-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天也在油管上看了Channel 4的这档新闻，印象最深的就是那哥们在强调herd immunity时，另外一个主张强力介入的嘉宾的表情。</p>
<p>当时我狂笑了快一分钟。</p>
<p>不过，我对腹黑的英国人充满不信任。美国和英国在阴谋诡计上对比，美国就是个弟弟。所以我有个不成熟的猜想：</p>
<p>英国同样想实施强力介入的措施，快一千例了，意大利啥样子都看到了。</p>
<p>打了两次世界大战又不是不懂什么叫战时体制，加上NHS又是英国特色社会主义的经典体现，有经验有工具干嘛不搞？</p>
<p>一是钱算谁的，二是要做的好看。</p>
<p>小特朗普鲍里斯为了上位，除了脱欧之外，还大力支持增加NHS的预算。所以他胜选后宣布的第一优先都不是脱欧，而是搞定NHS的预算。</p>
<p>这6600万人真是能花，我国基本医保总支出18年也就18000亿人民币。</p>
<p>强力介入必然要花大钱，这是当务之急。</p>
<p>所以怎么把花钱的事做的好听？</p>
<p>你传染一发生就大张旗鼓严格介入，直接的防疫费用不用说；伦敦以金融业旅游业交通业地产业为主，哪个行业不是严重依赖人的流动？这因防疫所导致的经济停转成本就吓死人。</p>
<p>老老实实按照WHO那套去隔离去封锁，控制不住鲍里斯死定了；就算控制住了，经济停转的亏空也足以让万年陪跑科尔宾在议院里轰上一年。</p>
<p>加上今年经济形势明显下滑，已经进入准危机状态，怕是防疫成功经济也没救。鲍里斯一直主张脱欧有助于经济，稍有不慎，疫情+经济下滑，普通民众和留欧派肯定会让科尔宾刷新战绩。</p>
<p>不行，肯定不行。</p>
<p>其次，英国一直暗搓搓地阻挠欧洲和中国的联手。英国自明确脱欧后，一直的战略思路是反对欧洲与中国直接走近，并引导中国选择英国，作为中国在欧洲整个大洲的利益支点。</p>
<p>这样，脱欧后的英国就能在传统英美关系下又获得与中国的特殊关系，反向加强自身在五眼联盟中的地位，平衡美帝独大的压力。</p>
<p>所以说老阴比嘛。</p>
<p>因此英国在对中国宣传上一直在夹私货，尝试用自己的影响力来缓阻欧洲的转向速度。这次疫情我们有好的一面，但烂的那面也不少，自然成为英国宣传战略里的绝佳素材。</p>
<p>现在开嘲讽开了快两个月，中国之前的一切被喷的手段突然要用到自己身上，不找个好点的借口，不仅英国民众要闹，欧洲回头也要炸锅。</p>
<p>所以要换过来，让民众觉得是他们自己要花钱。</p>
<p>怎么让民众心甘情愿掏钱？恐吓他们。</p>
<p>“中国那套玩法我们是搞不了的，体制不同，我们无法支付那样的成本，民众也不会同意”；</p>
<p>“出行自由我们是尊重的，税金的使用我们要严格根据法律规定来办，这是我国的价值观”；</p>
<p>“因此我们根据国民和国情，总结出一套资源内可行的方案，你们资辞不资辞呀”。</p>
<p>民众一看昏古去，醒过来骂声震天。</p>
<p>然后下周下议院一上班，科尔宾必然要开火：</p>
<p>听说你们要herd immunity，你们是不是打算置普通英国民众，特别是the old and the weak的生死于不顾！</p>
<p>表情一定要义正言辞。</p>
<p>鲍里斯一捋金发，怒目圆睁：</p>
<p>谁说的？没看到NHS和政府正在全力为英国人民对抗疫情吗？政府何时说要放弃民众？你你你你们工党不要听风是雨，天真简单！</p>
<p>然后抽一出一个本本：</p>
<p>我们现在正在竭尽全力，但是困难时刻需要我们英国人民的支持，这是临时增加的预算大家康康。</p>
<p>估计还会念几句丘吉尔。</p>
<p>科尔宾和鲍里斯几个来回互表对英国人民的忠心，夹杂在对英国人民坚韧性格的回顾和赞美声中，要多花钱这句话就过去了。然后是大英上下一心，共抗疫情，医护辛苦，巴拉巴拉。</p>
<p>这样就很漂亮。</p>
<p>第一，不是我们主动花钱抗疫、亏钱防疫，是应民众之呼唤，朝野之悲声，是救水火解倒悬的大义。</p>
<p>第二，万一钱花了效果还不行，你们骂中国去，丫的过度防疫引起恐慌欺骗他国混乱WHO，BBC出来干活啦。</p>
<p>你看，这样虽然英国本质上和美帝一样漠视疫情滞后反应，但是鲍里斯哪要像特朗普一样承担CNN7x24小时的反攻倒算？</p>
<p>疫情成为特朗普本来毫无悬念胜选的最大黑马事件，但操作得当，却会成为我鲍里斯继脱欧后的又一大功。脱欧与NHS，押宝全中，鲍中堂可列大英名相之位咯。</p>
<p>所以说美国人啊，真的是最年轻的帝国主义，太实诚。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%E5%8D%B1%E6%9C%BA%E9%83%BD%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%A7%E5%9F%BA%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%E5%8D%B1%E6%9C%BA%E9%83%BD%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%A7%E5%9F%BA%E5%BB%BA/" class="post-title-link" itemprop="url">为什么出现危机都要启动大基建</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 12:54:48 / Modified: 13:55:45" itemprop="dateCreated datePublished" datetime="2020-03-15T12:54:48-04:00">2020-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.本质上来说，凯恩斯主义的核心，就是通过财政扩张来解决经济周期问题，搞基建只是最常见的一种。但这里要提醒一下，旧凯恩斯主义已经失败被淘汰了（这里不展开了，有兴趣的人去看看当年的滞涨时期出现后，旧凯恩斯主义是如何因为无法解释这一原因导致整个学派崩溃的，至于几个高票答案，显然不知道这段历史）。</p>
<p>2.中国现在搞基建，边际收益还勉强是正的。对于其他发达国家来说，因为基建已经较为完备，再搞基建边际收益可能就是负数了。过一段时间以后中国也会是如此。这一轮之所以强调新基建，因为公路铁路这些旧基建的边际收益很可能已经是负数了。旧基建从业人员前景堪忧，以后可能只能去非洲中亚找饭吃（曹学上线）。</p>
<p>1，2是宏观经济学里最基本的常识。</p>
<p>说不好听一点，满嘴基建狂魔的人，见识档次欠佳。基建狂魔其实是发达国家上世纪和上上世纪玩剩下的。现在发达国家要是继续搞下去，只能和日本政府一样债台高筑了。</p>
<p>现在搞基建＝扶贫，以工代赈，顺便洗钱。这事你我知道就好，说出来很多人接受不了。</p>
<p>老板吃肉，下面才有汤</p>
<p>从《美国货币史》来看，新政的效果其实没有那么好。当时经济危机发生的原因也和中学教材说的完全不一样。彼时没有存款保险法，银行倒闭储户存款也会完蛋。所以危机出现后很快出现了遍及全美的银行挤兑。银行体系处于半瘫痪状态，这个过程里基础货币从银行体系搬家到了家庭床底下。引发了严重的通缩和危机。</p>
<p>本币债务能通过通胀消化，魏玛德国、德三帝国时期主要有大量的外币债务（一战失败的战争赔款），货币政策受到掣肘（蒙代尔不可能三角）。最终大概率铤而走险对外扩张，吞并法国直接消灭了对法外债。</p>
<p>我看网上有一个大佬写的。为什么相同的方法，瘸子被后世吹捧，元首被人唾骂。因为元首先憋不住了，决定改卖货为抢货。为什么呢？第一市场销售环境不同，美国在美洲基本没有竞争对手，产品销路稳定，在东亚，日本在上升期，消费胃口大，肯烧钱搞海军陆军，美国钢铁的销售行情一路看涨，德国不一样，它主要做中欧和巴尔干市场，这里都是小国，消费能力本就有限，而且面临法国的竞争，例如德国卖一批军火给保加利亚，小协约国，捷罗南之类马上会像巴黎下单。第二农业危机，纳粹本质是小农小业主的代表，既不像苏俄一样可以搞集体农奴制，也不像美国一样幅员辽阔，有搞农庄的基础，小农的底子不能触动，又要供应大工业城镇的市场需求，怎么办？于是西进是为了工商业者和英法争夺欧洲大陆的市场，东进是为了小农们的土地需求。</p>
<p>我的观点从来就没有变化：一切力量都可以为国家利益服务，从金融到军事。</p>
<p>这不是说有些人天生就爱杀人爱流血爱尸骸成堆，这是在阐述一个系统，一种万有引力：它的目的不受个人的意志而转移。</p>
<p>金融对美帝的重要性不用说了吧？外号就叫金融帝国主义，高度发达的虚拟经济，使得国民和政府的大量利益——从养老金到五角大楼——都由华尔街来交易、变现、流通。</p>
<p>不夸张地说，美帝这个国家已经证券化了。</p>
<p>所以千万不要用国内看A股洗脚婢的心态来看美股。A股从属于我朝，美帝从属于华尔街。不是华尔街的人真的吊到天天对总统耳提面命（其实是有的，例如高盛提携里根的那位），而是华尔街象征着一种系统，系统的意志高于它的零部件。</p>
<p>所以，当美帝的虚拟经济遭到承重压力，政府、国民、资本方的利益都被捆绑时，他们必然会寻找解决方案。不需要什么阴谋，不用像电影里奏起诡谲的BGM，他们会自发诞生答案，如同蜂群。</p>
<p>因此，思考的重点不在于美帝想做什么，而是他还能做什么。</p>
<p>虚拟经济收益畸高，必然会在一个拐点上开始回归实体经济。这个回归多数就是泡沫要炸了。</p>
<p>泡沫要炸了无外乎三种：</p>
<p>一是任你炸，躺平任艹。日本广场协议那波非常类似，但更经典的就是2933大危机。</p>
<p>任你炸的后果现在大家都知道了。恐慌无限放大人的非理性部分，市场严重震荡，资产价格跳崖，全行业现金流奔崩裂，国家直接动乱。</p>
<p>现在不是非洲那种捞一把就去迪拜巴黎养老的军阀，没有政府会在还有的选的时候来这个。</p>
<p>二是冻住不许走，时停系列。典型的就是我朝在几次房价要飙时的操作。</p>
<p>冻住不许走需要你有一套备用系统，可以在冻结泡沫的同时保证国家系统的基础运营。我们从来都是双轨制，所以但凡某个领域泡沫要炸，就用文件把泡沫冻住：</p>
<p>北上广深泡沫要炸，冻住之后成都武汉开始抢人了；成都武汉房价要炸，冻住之后还有高铁经济带；万一高铁经济带的房价也过了，还有鹤岗呢。</p>
<p>鹤岗的房子是谁建的？城投城建；城投城建是谁？是国开行。这就是两套系统。</p>
<p>冻住不许走除了我们，还有一个国家也很溜，就是大家平日口嗨的印度。（想不到吧.jpg）</p>
<p>印度还有一大批半封建半现代的小农自治体，这是印度每次在貌似要总崩盘的时候都能奇妙苟过来的重要底牌。不愧是把社会主义写入宪法的国家。</p>
<p>三是改变气压。</p>
<p>是不是突然以为在上物理课？</p>
<p>泡沫为什么炸？因为你吹了太多气在泡沫里，内部压力高于外部，就炸了。</p>
<p>那我要是把外部压力搞得比我内部压力还大，那泡沫不就不炸了嘛！</p>
<p>恭喜你，格林斯潘今晚请你吃饭！</p>
<p>美国所掌握的实体经济基本上只有军工复合体、能源、农业和航天芯片高尖精工业。而这些加一块都不足以满足虚拟经济的收益要求，美帝的虚拟收益和实体收益之间存在巨大落差。</p>
<p>资本一旦发现虚拟经济无法兑现许诺的畸高收益，就会重回有较稳定收益的实体；本国没有实体来承载，资本就必然外逃。</p>
<p>这个回归的过程犹如自由落体（巧了，今天推特上最多的词就是free fall）。那怎么阻止free fall？</p>
<p>美帝已经掌握了全球的铸币权，全球资源的总定价权在他手里，他牢牢占据虚拟经济的高地。</p>
<p>那剩下来要做的，就是确保全球范围内，没有比他更优的实体经济，没有只进不出的貔貅。</p>
<p>因为历史上就有一只貔貅，给他造成大麻烦。</p>
<p>大萧条时，美帝这边资产跳水、工人和技术人员失业，那边苏联咬着牙用集体农庄饿死乌克兰人的外汇疯狂买美帝的设备和人，实现工业化猪突猛进。</p>
<p>这导致了美帝当时居然出现了一定程度的去工业化，而苏联留下了一票美国人移民后裔。</p>
<p>这就是貔貅。苏联的体制决定了美帝在低价位时出售的东西，没法做个更低价让苏联吐出来。而技术、工业设备、研发人才的流失，是真正的失血，特别是当你没有掌握铸币权的时候。</p>
<p>万幸的是二战把欧洲打烂了，最后苏联解体时也把当年得到的加了百倍利息吐回来。从此，美帝就再也没有真正纠结过金融危机。</p>
<p>99年欧元正式发行，我就去揍一顿南联盟，给你出生庆礼；没想到你还整挺好，03年再打一顿伊拉克。</p>
<p>不是法德俄欧洲三大国一致反对吗？不是说中东是你们的利益范围吗？照打。资本需要暴力来保证交易的顺利执行，美帝能展现暴力的可靠，资本就会稳定在美帝一方。</p>
<p>“哎哎哎王蜀黍，为什么美帝不能让自己的实体经济变得更好，用竞争超过其他人呢？”</p>
<p>傻孩子，有美军在手，打就完事了。老老实实开工厂做研发做优化多累啊。没事，等你将来大学读自动化，出来就业就理解了。</p>
<p>我朝现在最尴尬的地方，就是我们是貔貅。</p>
<p>我们的实体收益高吗？</p>
<p>不算高，但比美帝高。而且本身的内需市场和产品所覆盖的全球市场加总，还是挺高的；</p>
<p>我们的资本可以随意流动吗？</p>
<p>不能，一般进来了就出不去，换个美元要凑几十个人的身份证，反洗钱中心都快把留学生逼疯了；</p>
<p>我们的暴力可靠吗？</p>
<p>跟美帝打遍全球不能比，但是家门口这一圈，还是能保证有来无回的。</p>
<p>那你不就是貔貅嘛。</p>
<p>一个有独立经济权力和武力保证的制造国，就是天然貔貅。</p>
<p>制造国、金融国、资源国三者里，制造国最容易维系工业体系的运转，因为金融国和资源国都需要制造国的产品；</p>
<p>制造国也能较好保证科技的迭代，因为制造会产生大量现实的市场需求，并为科研提供基础的成本；</p>
<p>一个制造国一旦拥有独立的经济权力，可以把握自己的货币政策和金融监管。那在工业社会里，他就是一个半闭环。</p>
<p>弱的如越南，强的如德国，都是这种半闭环，能成为区域内的稳态社会，并逐步吸纳区域内的资源。引进原材料，加工制造，同时形成基础研发乃至高端研发能力，保留利润，卖出去。</p>
<p>如果这种技术能力最后出现代差，资源国和金融国看制造国就跟看黑盒子一样。</p>
<p>所以占据优位的金融国，必须时不时打破这种半闭环，夺走利润，保证制造国长期处于技术下游。</p>
<p>金融收割是常态，必要时武力打击也可以。而且不需要直接打击，太难看了。破坏制造国的市场，让他资金无法回来就行，例如老欧洲的中东，例如俄罗斯最后的境外工业品市场乌克兰。</p>
<p>把多数国家锁在资源国身份，少数锁在低端制造业，金融和高端制造牢牢握在自己手里，进而形成科技与军事的代差优势，这是金融国最美的梦。</p>
<p>但是有只貔貅出现了。</p>
<p>按照美帝正常的剧本，我们在改开之初，就应该一直老老实实做玩具衣服；等到美帝做了新能源汽车，我们再去做小摩托；等到美帝做了火星飞船，我们再去做飞机。</p>
<p>但是庞大的人口、完备的工业门类、高素质廉价劳动力、公费高等教育（对，就是公费）、政府产业规划、独立主权，等等等等因素汇总，使得我们没有按照既定剧本走下去。</p>
<p>一边是低端产业逐渐爬升中端，玩具变机电；一边是科研投入与留学形成的中高端雏形；再加上严格的资本政策。</p>
<p>你慢慢变得更好，收益率逐步提高，同时能突然打断你收益率的手段在快速减少。</p>
<p>一个稳定的不可控的高收益地区对美帝，这个金融帝国主义，意味着什么？</p>
<p>血在外流，经脉逆行。</p>
<p>人有意识形态，资本没有。斯大林管理的卢布和胡佛管理的美元，虽然限定在不同的意识形态里，但是卢布和美元一样，需要实际价值做支撑，需要交换，需要收益和增殖。</p>
<p>如果美元没有收益而人民币有，那美元也会变成人民币。</p>
<p>这是美帝绝不允许的。</p>
<p>所以从崩溃论、威胁论、共治论、敌国论，各路帽子如大雪纷飞，应接不暇。手段也从常规的贸易战上升到科技战，并且开始在尝试进一步越界。</p>
<p>然后突然，美帝的金融，好像有点崩。</p>
<p>预示着什么？</p>
<p>不知道。</p>
<p>我只知道虚拟收益总是要向实体收益回归，小冰河期总是要来，等降水线总是要南移。</p>
<p>要么进了长城种田，要么长城内变成草原。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/React%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/React%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">React总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-14 14:38:17 / Modified: 16:10:53" itemprop="dateCreated datePublished" datetime="2020-03-14T14:38:17-04:00">2020-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、什么是react"><a href="#1、什么是react" class="headerlink" title="1、什么是react"></a>1、什么是react</h2><p>React.js 是一个帮助你构建页面 UI 的库。<br> React.js 将帮助我们将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，就成了我们的页面。<br> <strong>React.js 中一切皆组件，用 React.js 写的其实就是 React.js 组件。</strong><br> React.js 不是一个框架，它只是一个库。它只提供 UI （view）层面的解决方案。在实际的项目当中，它并不能解决我们所有的问题，需要结合其它的库，例如 Redux、React-router 等来协助提供完整的解决方法。</p>
<h2 id="2、理解JSX"><a href="#2、理解JSX" class="headerlink" title="2、理解JSX"></a>2、理解JSX</h2><p>React.js 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构。<br> <strong>所谓的 JSX 其实就是 JavaScript 对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     React.createElement(</span><br><span class="line">        <span class="string">"div"</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        React.createElement(</span><br><span class="line">          <span class="string">"h1"</span>,</span><br><span class="line">          &#123; <span class="attr">className</span>: <span class="string">'title'</span> &#125;,</span><br><span class="line">          <span class="string">"React 小书"</span></span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="../images/image-20200314143949254.png" alt="image-20200314143949254" style="zoom:200%;" />

<p>有些同学可能会问，为什么不直接从 JSX 直接渲染构造 DOM 结构，而是要经过中间这么一层呢？</p>
<p>第一个原因是，当我们拿到一个表示 UI 的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能把这个结构渲染到 canvas 上，或者是手机 App 上。所以这也是为什么会要把 react-dom 单独抽离出来的原因，可以想象有一个叫 react-canvas 可以帮我们把 UI 渲染到 canvas 上，或者是有一个叫 react-app 可以帮我们把它转换成原生的 App（实际上这玩意叫 ReactNative）。</p>
<p>第二个原因是，有了这样一个对象。当数据变化，需要更新组件的时候，就可以用比较快的算法操作这个 JavaScript 对象，而不用直接操作页面上的 DOM，这样可以尽量少的减少浏览器重排，极大地优化性能。这个在以后的章节中我们会提到。</p>
<p><strong>总结</strong></p>
<p>要记住几个点：</p>
<ul>
<li>JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML。</li>
<li>React.js 可以用 JSX 来描述你的组件长什么样的。</li>
<li>JSX 在编译的时候会变成相应的 JavaScript 对象描述。</li>
<li>react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上。</li>
</ul>
<h2 id="3、组件的组合、嵌套和组件树"><a href="#3、组件的组合、嵌套和组件树" class="headerlink" title="3、组件的组合、嵌套和组件树"></a>3、组件的组合、嵌套和组件树</h2><p>组件可以和组件组合在一起，组件内部可以使用别的组件。就像普通的 HTML 标签一样使用就可以。这样的组合嵌套，最后构成一个所谓的组件树，就正如上面的例子那样，Index 用了 Header、Main、Footer，Header 又使用了 Title 。这样用这样的树状结构表示它们之间的关系：</p>
<p><img src="../images/image-20200314144040294.png" alt="image-20200314144040294"></p>
<p>当页面结构复杂起来，有许多不同的组件嵌套组合的话，组件树会相当的复杂和庞大。<strong>理解组件树的概念对后面理解数据是如何在组件树内自上往下流动过程很重要。</strong></p>
<h2 id="4、事件监听"><a href="#4、事件监听" class="headerlink" title="4、事件监听"></a>4、事件监听</h2><p><strong>关于事件中的 this</strong><br> 一般在某个类的实例方法里面的 this 指的是这个实例本身。<br> 但是 React.js 调用你所传给它的方法的时候，并不是通过对象方法的方式调用（this.handleClickOnTitle），而是直接通过函数调用 （handleClickOnTitle），<strong>所以事件监听函数内并不能通过 this 获取到实例。</strong><br> 如果你想在事件函数当中使用当前的实例，你需要手动地将实例方法 bind 到当前实例上再传入给 React.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClickOnTitle (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1 onClick=&#123;<span class="keyword">this</span>.handleClickOnTitle.bind(<span class="keyword">this</span>)&#125;&gt;React 小书&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>为 React 的组件添加事件监听是很简单的事情，你只需要使用 React.js 提供了一系列的 on* 方法即可。</li>
<li>React.js 会给每个事件监听传入一个 event 对象，这个对象提供的功能和浏览器提供的功能一致，而且它是兼容所有浏览器的。</li>
<li>React.js 的事件监听方法需要手动 bind 到当前实例，这种模式在 React.js 中非常常用。</li>
</ul>
<h2 id="5、组件的-state-和-setState"><a href="#5、组件的-state-和-setState" class="headerlink" title="5、组件的 state 和 setState"></a>5、组件的 state 和 setState</h2><p>setState 接受函数参数:<br> 这里还有要注意的是，当你调用 setState 的时候，<strong>React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。</strong>这一点要好好注意。可以体会一下下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.isLiked)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    isLiked: !<span class="keyword">this</span>.state.isLiked</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.isLiked)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现两次打印的都是 false，即使我们中间已经 setState 过一次了。这并不是什么 bug，只是 React.js 的 setState 把你的传进来的状态缓存起来，稍后才会帮你更新到 state 上，所以你获取到的还是原来的 isLiked。</p>
<p>所以如果你想在 setState 之后使用新的 state 来做后续运算就做不到了，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) <span class="comment">// =&gt; this.state.count 还是 undefined</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;) <span class="comment">// =&gt; undefined + 1 = NaN</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">2</span>&#125;) <span class="comment">// =&gt; NaN + 2 = NaN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码的运行结果并不能达到我们的预期，我们希望 count 运行结果是 3 ，可是最后得到的是 NaN。但是这种后续操作依赖前一个 setState 的结果的情况并不罕见。</p>
<p>这里就自然地引出了<strong>setState 的第二种使用方式:可以接受一个函数作为参数</strong>，。React.js 会把上一个 setState 的结果传入这个函数，你就可以使用该结果进行运算、操作，然后返回一个对象作为更新 state 的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: prevState.count + <span class="number">1</span> &#125; <span class="comment">// 上一个 setState 的返回是 count 为 0，当前返回 1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: prevState.count + <span class="number">2</span> &#125; <span class="comment">// 上一个 setState 的返回是 count 为 1，当前返回 3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后的结果是 this.state.count 为 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以达到上述的利用上一次 setState 结果进行运算的效果。</p>
<hr>
<p><strong>setState 合并</strong><br> 上面我们进行了三次 setState，但是实际上组件只会重新渲染一次，而不是三次；这是因为在 React.js 内部会把 JavaScript 事件循环中的消息队列的同一个消息中的 setState 都进行合并以后再重新渲染组件。</p>
<p>深层的原理并不需要过多纠结，你只需要记住的是：在使用 React.js 的时候，并不需要担心多次进行 setState 会带来性能问题。</p>
<h2 id="6、配置组件的-props"><a href="#6、配置组件的-props" class="headerlink" title="6、配置组件的 props"></a>6、配置组件的 props</h2><p>在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为 props 对象的键值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClickOnLikeButton () &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> wordings = <span class="keyword">this</span>.props.wordings || &#123; <span class="comment">//获取props</span></span><br><span class="line">      likedText: <span class="string">'取消'</span>,</span><br><span class="line">      unlikedText: <span class="string">'点赞'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClickOnLikeButton.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isLiked ? wordings.likedText : wordings.unlikedText&#125; 👍</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">---------</span></span><br><span class="line"><span class="regexp">class Index extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;LikeButton likedText='已赞' unlikedText='赞' /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>props 不可变</strong><br>props 一旦传入进来就不能改变。修改上面的例子中的 handleClickOnLikeButton:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.likedText = <span class="string">'取消'</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    isLiked: !<span class="keyword">this</span>.state.isLiked</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们尝试在用户点击按钮的时候改变 <code>this.props.likedText</code> ，然后你会看到控制台报错了。<br> <strong>你不能改变一个组件被渲染的时候传进来的 props</strong>。React.js 希望一个组件在输入确定的 props 的时候，能够输出确定的 UI 显示形态。<strong>如果 props 渲染过程中可以被修改，那么就会导致这个组件显示形态和行为变得不可预测，这样会可能会给组件使用者带来困惑。</strong></p>
<p>但这并不意味着由 props 决定的显示形态不能被修改。<strong>组件的使用者可以主动地通过重新渲染的方式把新的 props 传入组件当中</strong>，这样这个组件中由 props 决定的显示形态也会得到相应的改变。</p>
<hr>
<p><strong>总结</strong></p>
<ul>
<li>为了使得组件的可定制性更强，在使用组件的时候，可以在标签上加属性来传入配置参数。</li>
<li>组件可以在内部通过 this.props 获取到配置参数，组件可以根据 props 的不同来确定自己的显示形态，达到可配置的效果。</li>
<li>可以通过给组件添加类属性 defaultProps 来配置默认参数。<br> props 一旦传入，你就不可以在组件内部对它进行修改。但是你可以通过父组件主动重新渲染的方式来传入新的 props，从而达到更新的效果。</li>
</ul>
<h2 id="7、state-vs-props"><a href="#7、state-vs-props" class="headerlink" title="7、state vs props"></a>7、state vs props</h2><p>我们来一个关于 state 和 props 的总结。</p>
<p><strong>state</strong>:主要作用是用于组件保存、控制、修改<strong>自己</strong>的可变状态。state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。state 中状态可以通过 this.setState 方法进行更新，setState 会导致组件的重新渲染。</p>
<p><strong>props</strong>: 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props，否则组件的 props 永远保持不变。</p>
<p>state 和 props 有着千丝万缕的关系。它们都可以决定组件的行为和显示形态。一个组件的 state 中的数据可以通过 props 传给子组件，一个组件可以使用外部传入的 props 来初始化自己的 state。但是它们的职责其实非常明晰分明：<strong>state 是让组件控制自己的状态，props 是让外部对组件自己进行配置。</strong></p>
<p><strong>如果你觉得还是搞不清 state 和 props 的使用场景，那么请记住一个简单的规则：尽量少地用 state，尽量多地用 props。</strong></p>
<p><strong>没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）</strong>。</p>
<blockquote>
<p>因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。前端应用状态管理是一个复杂的问题，我们后续会继续讨论。</p>
</blockquote>
<p>React.js 非常鼓励无状态组件，在 0.14 版本引入了函数式组件——一种定义不能使用 state 组件，例如一个原来这样写的组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi () &#123;</span><br><span class="line">    alert(<span class="string">'Hello World'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.sayHi.bind(<span class="keyword">this</span>)&#125;&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>用函数式组件的编写方式就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HelloWorld = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sayHi = <span class="function">(<span class="params">event</span>) =&gt;</span> alert(<span class="string">'Hello World'</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onClick=&#123;sayHi&#125;&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以前一个组件是通过继承 Component 来构建，一个子类就是一个组件。而用函数式的组件编写方式是一个函数就是一个组件，你可以和以前一样通过 <HellWorld /> 使用该组件。不同的是，函数式组件只能接受 props 而无法像跟类组件一样可以在 constructor 里面初始化 state。你可以理解函数式组件就是一种只能接受 props 和提供 render 方法的类组件。</p>
<h2 id="8、渲染列表数据"><a href="#8、渲染列表数据" class="headerlink" title="8、渲染列表数据"></a>8、渲染列表数据</h2><p>列表数据在前端非常常见，我们经常要处理这种类型的数据，例如文章列表、评论列表、用户列表…一个前端工程师几乎每天都需要跟列表数据打交道。</p>
<p>React.js 当然也允许我们处理列表数据，但在使用 React.js 处理列表数据的时候，需要掌握一些规则。我们这一节会专门讨论这方面的知识。</p>
<h3 id="渲染存放-JSX-元素的数组"><a href="#渲染存放-JSX-元素的数组" class="headerlink" title="渲染存放 JSX 元素的数组"></a>渲染存放 JSX 元素的数组</h3><p>假设现在我们有这么一个用户列表数据，存放在一个数组当中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Jerry'</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Tomy'</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lily'</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lucy'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果现在要把这个数组里面的数据渲染页面上要怎么做？开始之前要补充一个知识。之前说过 JSX 的表达式插入 <code>{}</code> 里面可以放任何数据，如果我们往 <code>{}</code> 里面放一个存放 JSX 元素的数组会怎么样？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;[</span><br><span class="line">          &lt;span&gt;React.js &lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">          &lt;span&gt;is &lt;/</span>span&gt;,</span><br><span class="line">          &lt;span&gt;good&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        ]&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们往 JSX 里面塞了一个数组，这个数组里面放了一些 JSX 元素（其实就是 JavaScript 对象）。</p>
<p>React.js 把插入表达式数组里面的每一个 JSX 元素一个个罗列下来，渲染到页面上。所以这里有个关键点：<em>如果你往 <code>{}</code> 放一个数组，React.js 会帮你把数组里面一个个元素罗列并且渲染出来</em>。</p>
<h3 id="使用-map-渲染列表数据"><a href="#使用-map-渲染列表数据" class="headerlink" title="使用 map 渲染列表数据"></a>使用 map 渲染列表数据</h3><p>知道这一点以后你就可以知道怎么用循环把元素渲染到页面上：循环上面用户数组里面的每一个用户，为每个用户数据构建一个 JSX，然后把 JSX 放到一个新的数组里面，再把新的数组插入 <code>render</code> 方法的 JSX 里面。看看代码怎么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Jerry'</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Tomy'</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lily'</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lucy'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> usersElements = [] <span class="comment">// 保存每个用户渲染以后 JSX 的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) &#123;</span><br><span class="line">      usersElements.push( <span class="comment">// 循环每个用户，构建 JSX，push 到数组中</span></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div&gt;姓名：&#123;user.username&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;年龄：&#123;user.age&#125;&lt;/</span>div&gt;</span><br><span class="line">          &lt;div&gt;性别：&#123;user.gender&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;hr /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;usersElements&#125;&lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里用了一个新的数组 <code>usersElements</code>，然后循环 <code>users</code> 数组，为每个 <code>user</code> 构建一个 JSX 结构，然后 push 到 <code>usersElements</code> 中。然后直接用表达式插入，把这个 <code>userElements</code> 插到 return 的 JSX 当中。因为 React.js 会自动化帮我们把数组当中的 JSX 罗列渲染出来，所以可以看到页面上显示：</p>
<img src="../images/image-20200314144503017.png" alt="image-20200314144503017" style="zoom:200%;" />

<p>但我们一般不会手动写循环来构建列表的 JSX 结构，可以直接用 ES6 自带的 <code>map</code>（不了解 <code>map</code> 函数的同学可以先了解相关的知识再来回顾这里），代码可以简化成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;div&gt;姓名：&#123;user.username&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;div&gt;年龄：&#123;user.age&#125;&lt;/</span>div&gt;</span><br><span class="line">              &lt;div&gt;性别：&#123;user.gender&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;hr /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          )</span></span><br><span class="line"><span class="regexp">        &#125;)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的模式在 JavaScript 中非常常见，一般来说，在 React.js 处理列表就是用 <code>map</code> 来处理、渲染的。现在进一步把渲染单独一个用户的结构抽离出来作为一个组件，继续优化代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Jerry'</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Tomy'</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lily'</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lucy'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; user &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;姓名：&#123;user.username&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;年龄：&#123;user.age&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;性别：&#123;user.gender&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Index extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;users.map((user) =&gt; &lt;User user=&#123;user&#125; /</span>&gt;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Index /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里把负责展示用户数据的 JSX 结构抽离成一个组件 <code>User</code> ，并且通过 <code>props</code> 把 <code>user</code> 数据作为组件的配置参数传进去；这样改写 <code>Index</code> 就非常清晰了，看一眼就知道负责渲染 <code>users</code> 列表，而用的组件是 <code>User</code>。</p>
<h3 id="key-key-key"><a href="#key-key-key" class="headerlink" title="key! key! key!"></a>key! key! key!</h3><p>现在代码运作正常，好像没什么问题。打开控制台看看：</p>
<img src="../images/image-20200314144605558.png" alt="image-20200314144605558" style="zoom:200%;" />

<p>React.js 报错了。如果需要详细解释这里报错的原因，估计要单独写半本书。但可以简单解释一下。</p>
<p>React.js 的是非常高效的，它高效依赖于所谓的 Virtual-DOM 策略。简单来说，能复用的话 React.js 就会尽量复用，没有必要的话绝对不碰 DOM。对于列表元素来说也是这样，但是处理列表元素的复用性会有一个问题：元素可能会在一个列表中改变位置。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;a&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;b&lt;/</span>div&gt;</span><br><span class="line">&lt;div&gt;c&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设页面上有这么3个列表元素，现在改变一下位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;a&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;c&lt;/</span>div&gt;</span><br><span class="line">&lt;div&gt;b&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>c</code> 和 <code>b</code> 的位置互换了。但其实 React.js 只需要交换一下 DOM 位置就行了，但是它并不知道其实我们只是改变了元素的位置，所以它会重新渲染后面两个元素（再执行 Virtual-DOM 策略），这样会大大增加 DOM 操作。但如果给每个元素加上唯一的标识，React.js 就可以知道这两个元素只是交换了位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div key=<span class="string">'a'</span>&gt;a&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div key='b'&gt;b&lt;/</span>div&gt;</span><br><span class="line">&lt;div key=<span class="string">'c'</span>&gt;c&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样 React.js 就简单的通过 <code>key</code> 来判断出来，这两个列表元素只是交换了位置，可以尽量复用元素内部的结构。</p>
<p>这里没听懂没有关系，后面有机会会继续讲解这部分内容。现在只需要记住一个简单的规则：<em>对于用表达式套数组罗列到页面上的元素，都要为每个元素加上 <code>key</code> 属性，这个 <code>key</code> 必须是每个元素唯一的标识</em>。一般来说，<code>key</code> 的值可以直接后台数据返回的 <code>id</code>，因为后台的 <code>id</code> 都是唯一的。</p>
<p>在上面的例子当中，每个 <code>user</code> 没有 <code>id</code> 可以用，可以直接用循环计数器 <code>i</code> 作为 <code>key</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map(<span class="function">(<span class="params">user, i</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">User</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span></span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">...</span></span><br></pre></td></tr></table></figure>

<p>再看看，控制台已经没有错误信息了。但这是不好的做法，这只是掩耳盗铃（具体原因大家可以自己思考一下）。记住一点：在实际项目当中，如果你的数据顺序可能发生变化，标准做法是最好是后台数据返回的 <code>id</code> 作为列表元素的 <code>key</code>。</p>
<h2 id="9、前端应用状态管理-——-状态提升"><a href="#9、前端应用状态管理-——-状态提升" class="headerlink" title="9、前端应用状态管理 —— 状态提升"></a>9、前端应用状态管理 —— 状态提升</h2><p>我们在讲解 JSX 的章节中提到，下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line"> &lt;Header /&gt;, </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>会编译成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Header, <span class="literal">null</span>), </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其实我们把 <code>Header</code> 组件传给了 <code>React.createElement</code> 函数，又把函数返回结果传给了 <code>ReactDOM.render</code>。我们可以简单猜想一下它们会干什么事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.createElement 中实例化一个 Header</span></span><br><span class="line"><span class="keyword">const</span> header = <span class="keyword">new</span> Header(props, children)</span><br><span class="line"><span class="comment">// React.createElement 中调用 header.render 方法渲染组件的内容</span></span><br><span class="line"><span class="keyword">const</span> headerJsxObject = header.render()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM 用渲染后的 JavaScript 对象来来构建真正的 DOM 元素</span></span><br><span class="line"><span class="keyword">const</span> headerDOM = createDOMFromObject(headerJsxObject)</span><br><span class="line"><span class="comment">// ReactDOM 把 DOM 元素塞到页面上</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>).appendChild(headerDOM)</span><br></pre></td></tr></table></figure>

<p>上面过程其实很简单，看代码就能理解。</p>
<p>我们把 <em>React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载</em>（这个定义请好好记住）。其实 React.js 内部对待每个组件都有这么一个过程，也就是初始化组件 -&gt; 挂载到页面上的过程。所以你可以理解一个组件的方法调用是这么一个过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="keyword">constructor</span>()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br></pre></td></tr></table></figure>

<p>这当然是很好理解的。React.js 为了让我们能够更好的掌控组件的挂载过程，往上面插入了两个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="keyword">constructor</span>()</span><br><span class="line">-&gt; componentWillMount()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br><span class="line">-&gt; componentDidMount()</span><br></pre></td></tr></table></figure>

<p><code>componentWillMount</code> 和 <code>componentDidMount</code> 都是可以像 <code>render</code> 方法一样自定义在组件的内部。挂载的时候，React.js 会在组件的 <code>render</code> 之前调用 <code>componentWillMount</code>，在 DOM 元素塞入页面以后调用 <code>componentDidMount</code>。</p>
<p>我们给 <code>Header</code> 组件加上这两个方法，并且打一些 Log：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'construct'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'component will mount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'component did mount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1 className=<span class="string">'title'</span>&gt;React 小书&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台你可以看到依次输出：</p>
<img src="../images/image-20200314145149375.png" alt="image-20200314145149375" style="zoom:200%;" />

<p>可以看到，React.js 确实按照我们上面所说的那样调用了定义的两个方法 <code>componentWillMount</code> 和 <code>componentDidMount</code>。</p>
<p>机灵的同学可以想到，一个组件可以插入页面，当然也可以从页面中删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="keyword">constructor</span>()</span><br><span class="line">-&gt; componentWillMount()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br><span class="line">-&gt; componentDidMount()</span><br><span class="line">// ...</span><br><span class="line">// 从页面中删除</span><br></pre></td></tr></table></figure>

<p>React.js 也控制了这个组件的删除过程。在组件删除之前 React.js 会调用组件定义的 <code>componentWillUnmount</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="keyword">constructor</span>()</span><br><span class="line">-&gt; componentWillMount()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br><span class="line">-&gt; componentDidMount()</span><br><span class="line">// ...</span><br><span class="line">// 即将从页面中删除</span><br><span class="line">-&gt; componentWillUnmount()</span><br><span class="line">// 从页面中删除</span><br></pre></td></tr></table></figure>

<p>看看什么情况下会把组件从页面中删除，继续使用上面例子的代码，我们再定义一个 <code>Index</code> 组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isShowHeader: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleShowOrHide () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isShowHeader: !<span class="keyword">this</span>.state.isShowHeader</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isShowHeader ? <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleShowOrHide.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">          显示或者隐藏标题</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>Index</code> 组件使用了 <code>Header</code> 组件，并且有一个按钮，可以控制 <code>Header</code> 的显示或者隐藏。下面这行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...a</span><br><span class="line">&#123;<span class="keyword">this</span>.state.isShowHeader ? <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>相当于 <code>state.isShowHeader</code> 为 <code>true</code> 的时候把 <code>Header</code> 插入页面，<code>false</code> 的时候把 <code>Header</code> 从页面上删除。这时候我们给 <code>Header</code> 添加 <code>componentWillUnmount</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'component will unmount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时候点击页面上的按钮，你会看到页面的标题隐藏了，并且控制台打印出来下图的最后一行，说明 <code>componentWillUnmount</code> 确实被 React.js 所调用了：</p>
<img src="../images/image-20200314145348052.png" alt="image-20200314145348052" style="zoom:200%;" />

<p>你可以多次点击按钮，随着按钮的显示和隐藏，上面的内容会按顺序重复地打印出来，可以体会一下这几个方法的调用过程和顺序。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载。这一节我们学习了 React.js 控制组件在页面上挂载和删除过程里面几个方法：</p>
<ul>
<li><code>componentWillMount</code>：组件挂载开始之前，也就是在组件调用 <code>render</code> 方法之前调用。</li>
<li><code>componentDidMount</code>：组件挂载完成以后，也就是 DOM 元素已经插入页面后调用。</li>
<li><code>componentWillUnmount</code>：组件对应的 DOM 元素从页面中删除之前调用。</li>
</ul>
<p>但这一节并没有讲这几个方法到底在实际项目当中有什么作用，下一节我们通过例子来讲解一下这几个方法的用途。</p>
<h2 id="10、挂载阶段的组件生命周期"><a href="#10、挂载阶段的组件生命周期" class="headerlink" title="10、挂载阶段的组件生命周期"></a>10、挂载阶段的组件生命周期</h2><p>这一节我们来讨论一下对于一个组件来说，<code>constructor</code> 、<code>componentWillMount</code>、<code>componentDidMount</code>、<code>componentWillUnmount</code> 这几个方法在一个组件的出生到死亡的过程里面起了什么样的作用。</p>
<p>一般来说，所有关于组件自身的状态的初始化工作都会放在 <code>constructor</code> 里面去做。你会发现本书所有组件的 <code>state</code> 的初始化工作都是放在 <code>constructor</code> 里面的。假设我们现在在做一个时钟应用：</p>
<img src="../images/image-20200314145413595.png" alt="image-20200314145413595" style="zoom:200%;" />

<p>我们会在 <code>constructor</code> 里面初始化 <code>state.date</code>，当然现在页面还是静态的，等下一会让时间动起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">          &lt;p&gt;现在的时间是&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.date.toLocaleTimeString()&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>h1&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>一些组件启动的动作，包括像 Ajax 数据的拉取操作、一些定时器的启动等，就可以放在 <code>componentWillMount</code> 里面进行，例如 Ajax：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    ajax.get(<span class="string">'http://json-api.com/user'</span>, (userData) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; userData &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然在我们这个例子里面是定时器的启动，我们给 <code>Clock</code> 启动定时器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>componentWillMount</code> 中用 <code>setInterval</code> 启动了一个定时器：每隔 1 秒更新中的 <code>state.date</code>，这样页面就可以动起来了。我们用一个 <code>Index</code> 把它用起来，并且插入页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Clock /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Index /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>像上一节那样，我们修改这个 <code>Index</code> 让这个时钟可以隐藏或者显示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isShowClock</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleShowOrHide () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isShowClock: !<span class="keyword">this</span>.state.isShowClock</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isShowClock ? <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span> : <span class="literal">null</span> &#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleShowOrHide.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">          显示或隐藏时钟</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在页面上有个按钮可以显示或者隐藏时钟。你试一下显示或者隐藏时钟，虽然页面上看起来功能都正常，在控制台你会发现报错了：</p>
<img src="../images/image-20200314145616845.png" alt="image-20200314145616845" style="zoom:200%;" />

<p>这是因为，<em>当时钟隐藏的时候，我们并没有清除定时器</em>。时钟隐藏的时候，定时器的回调函数还在不停地尝试 <code>setState</code>，由于 <code>setState</code> 只能在已经挂载或者正在挂载的组件上调用，所以 React.js 开始疯狂报错。</p>
<p>多次的隐藏和显示会让 React.js 重新构造和销毁 <code>Clock</code> 组件，每次构造都会重新构建一个定时器。而销毁组件的时候没有清除定时器，所以你看到报错会越来越多。而且因为 JavaScript 的闭包特性，这样会导致严重的内存泄漏。</p>
<p>这时候<code>componentWillUnmount</code> 就可以派上用场了，它的作用就是在组件销毁的时候，做这种清场的工作。例如清除该组件的定时器和其他的数据清理工作。我们给 <code>Clock</code>添加 <code>componentWillUnmount</code>，在组件销毁的时候清除该组件的定时器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时候就没有错误了。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>我们一般会把组件的 <code>state</code> 的初始化工作放在 <code>constructor</code> 里面去做；在 <code>componentWillMount</code> 进行组件的启动工作，例如 Ajax 数据拉取、定时器的启动；组件从页面上销毁的时候，有时候需要一些数据的清理，例如定时器的清理，就会放在 <code>componentWillUnmount</code> 里面去做。</p>
<p>说一下本节没有提到的 <code>componentDidMount</code> 。一般来说，有些组件的启动工作是依赖 DOM 的，例如动画的启动，而 <code>componentWillMount</code> 的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在 <code>componentDidMount</code> 当中。<code>componentDidMount</code> 的具体使用我们会在接下来的章节当中结合 DOM 来讲。</p>
<h2 id="11、更新阶段的组件生命周期"><a href="#11、更新阶段的组件生命周期" class="headerlink" title="11、更新阶段的组件生命周期"></a>11、更新阶段的组件生命周期</h2><p>从之前的章节我们了解到，组件的挂载指的是将组件渲染并且构造 DOM 元素然后插入页面的过程。<em>这是一个从无到有的过程</em>，React.js 提供一些生命周期函数可以给我们在这个过程中做一些操作。</p>
<p>除了挂载阶段，还有一种“更新阶段”。说白了就是 <code>setState</code> 导致 React.js 重新渲染组件并且把组件的变化应用到 DOM 元素上的过程，<em>这是一个组件的变化过程</em>。而 React.js 也提供了一系列的生命周期函数可以让我们在这个组件更新的过程执行一些操作。</p>
<p>这些生命周期在深入项目开发阶段是非常重要的。而要完全理解更新阶段的组件生命周期是一个需要经验和知识积累的过程，你需要对 Virtual-DOM 策略有比较深入理解才能完全掌握，但这超出了本书的目的。<em>本书的目的是为了让大家快速掌握 React.js 核心的概念，快速上手项目进行实战</em>。所以对于组件更新阶段的组件生命周期，我们简单提及并且提供一些资料给大家。</p>
<p>这里为了知识的完整，补充关于更新阶段的组件生命周期：</p>
<ol>
<li><code>shouldComponentUpdate(nextProps, nextState)</code>：你可以通过这个方法控制组件是否重新渲染。如果返回 <code>false</code> 组件就不会重新渲染。这个生命周期在 React.js 性能优化上非常有用。</li>
<li><code>componentWillReceiveProps(nextProps)</code>：组件从父组件接收到新的 <code>props</code> 之前调用。</li>
<li><code>componentWillUpdate()</code>：组件开始重新渲染之前调用。</li>
<li><code>componentDidUpdate()</code>：组件重新渲染并且把更改变更到真实的 DOM 以后调用。</li>
</ol>
<p>大家对这更新阶段的生命周期比较感兴趣的话可以查看<a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">官网文档</a>。</p>
<p><em>但这里建议大家可以先简单了解 React.js 组件是有更新阶段的，并且有这么几个更新阶段的生命周期即可</em>。然后在深入项目实战的时候逐渐地掌握理解他们，现在并不需要对他们放过多的精力。</p>
<h2 id="12、ref-和-React-js-中的-DOM-操作"><a href="#12、ref-和-React-js-中的-DOM-操作" class="headerlink" title="12、ref 和 React.js 中的 DOM 操作"></a>12、ref 和 React.js 中的 DOM 操作</h2><p>在 React.js 当中你基本不需要和 DOM 直接打交道。React.js 提供了一系列的 on* 方法帮助我们进行事件监听，所以 React.js 当中不需要直接调用 addEventListener 的 DOM API；以前我们通过手动 DOM 操作进行页面更新（例如借助 jQuery），而在 React.js 当中可以直接通过 setState 的方式重新渲染组件，渲染的时候可以把新的 props 传递给子组件，从而达到页面更新的效果。</p>
<p>React.js 这种重新渲染的机制帮助我们免除了绝大部分的 DOM 更新操作，也让类似于 jQuery 这种以封装 DOM 操作为主的第三方的库从我们的开发工具链中删除。</p>
<p>但是 React.js 并不能完全满足所有 DOM 操作需求，有些时候我们还是需要和 DOM 打交道。比如说你想进入页面以后自动 focus 到某个输入框，你需要调用 input.focus() 的 DOM API，比如说你想动态获取某个 DOM 元素的尺寸来做后续的动画，等等。</p>
<p>React.js 当中提供了 ref 属性来帮助我们获取已经挂载的元素的 DOM 节点，你可以给某个 JSX 元素加上 ref属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.input.focus()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;AutoFocusInput /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以看到我们给 input 元素加了一个 ref 属性，这个属性值是一个函数。当 input 元素在页面上挂载完成以后，React.js 就会调用这个函数，并且把这个挂载以后的 DOM 节点传给这个函数。在函数中我们把这个 DOM 元素设置为组件实例的一个属性，这样以后我们就可以通过 this.input 获取到这个 DOM 元素。</p>
<p>然后我们就可以在 componentDidMount 中使用这个 DOM 元素，并且调用 this.input.focus() 的 DOM API。整体就达到了页面加载完成就自动 focus 到输入框的功能（大家可以注意到我们用上了 componentDidMount 这个组件生命周期）。</p>
<p>我们可以给任意代表 HTML 元素标签加上 ref 从而获取到它 DOM 元素然后调用 DOM API。但是记住一个原则：能不用 ref 就不用。特别是要避免用 ref 来做 React.js 本来就可以帮助你做到的页面自动更新的操作和事件监听。多余的 DOM 操作其实是代码里面的“噪音”，不利于我们理解和维护。</p>
<p>顺带一提的是，其实可以给组件标签也加上 ref ，例如：</p>
<p>&lt;Clock ref={(clock) =&gt; this.clock = clock} /&gt;<br> 这样你获取到的是这个 Clock 组件在 React.js 内部初始化的实例。但这并不是什么常用的做法，而且也并不建议这么做，所以这里就简单提及，有兴趣的朋友可以自己学习探索。</p>
<h2 id="13、props-children-和容器类组件"><a href="#13、props-children-和容器类组件" class="headerlink" title="13、props.children 和容器类组件"></a>13、props.children 和容器类组件</h2><p>有一类组件，充当了容器的作用，它定义了一种外层结构形式，然后你可以往里面塞任意的内容。这种结构在实际当中非常常见，例如这种带卡片组件：</p>
<p>组件本身是一个不带任何内容的方形的容器，我可以在用这个组件的时候给它传入任意内容：</p>
<p>基于我们目前的知识储备，可以迅速写出这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'card'</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">'card-content'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.content&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Card content=&#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;React.js 小书&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div&gt;开源、免费、专业、简单&lt;/</span>div&gt;</span><br><span class="line">      订阅：&lt;input /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &#125; /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们通过给 <code>Card</code> 组件传入一个 <code>content</code> 属性，这个属性可以传入任意的 JSX 结构。然后在 <code>Card</code> 内部会通过 <code>{this.props.content}</code> 把内容渲染到页面上。</p>
<p>这样明显太丑了，如果 <code>Card</code> 除了 <code>content</code> 以外还能传入其他属性的话，那么这些 JSX 和其他属性就会混在一起。很不好维护，如果能像下面的代码那样使用 <code>Card</code> 那想必也是极好的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Card&gt;</span><br><span class="line">    &lt;h2&gt;React.js 小书&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;开源、免费、专业、简单&lt;/</span>div&gt;</span><br><span class="line">    订阅：&lt;input /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Card&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<p>如果组件标签也能像普通的 HTML 标签那样编写内嵌的结构，那么就方便很多了。实际上，React.js 默认就支持这种写法，所有嵌套在组件中的 JSX 结构都可以在组件内部通过 <code>props.children</code> 获取到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'card'</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">'card-content'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>props.children</code> 打印出来，你可以看到它其实是个数组：</p>
<img src="../images/image-20200314145828931.png" alt="image-20200314145828931" style="zoom:200%;" />

<p>React.js 就是把我们嵌套的 JSX 元素一个个都放到数组当中，然后通过 <code>props.children</code> 传给了 <code>Card</code>。</p>
<p>由于 JSX 会把插入表达式里面数组中的 JSX 一个个罗列下来显示。所以其实就相当于在 <code>Card</code> 中嵌套了什么 JSX 结构，都会显示在 <code>Card</code> 的类名为 <code>card-content</code> 的 <code>div</code> 元素当中。</p>
<p>这种嵌套的内容成为了 <code>props.children</code> 数组的机制使得我们编写组件变得非常的灵活，我们甚至可以在组件内部把数组中的 JSX 元素安置在不同的地方：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'two-cols-layout'</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">'sidebar'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children[<span class="number">0</span>]&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className='main'&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.props.children[1]&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这是一个两列布局组件，嵌套的 JSX 的第一个结构会成为侧边栏，第二个结构会成为内容栏，其余的结构都会被忽略。这样通过这个布局组件，就可以在各个地方高度复用我们的布局。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>使用自定义组件的时候，可以在其中嵌套 JSX 结构。嵌套的结构在组件内部都可以通过 <code>props.children</code> 获取到，这种组件编写方式在编写容器类型的组件当中非常有用。而在实际的 React.js 项目当中，我们几乎每天都需要用这种方式来编写组件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/google%E6%8A%80%E6%9C%AF%E5%86%99%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/google%E6%8A%80%E6%9C%AF%E5%86%99%E4%BD%9C/" class="post-title-link" itemprop="url">google技术写作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-14 10:57:18 / Modified: 15:27:43" itemprop="dateCreated datePublished" datetime="2020-03-14T10:57:18-04:00">2020-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Google 技术写作</p>
<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><table>
<thead>
<tr>
<th>词性</th>
<th>定义</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td>Noun 名词</td>
<td>人，地方，概念或事物</td>
<td><strong>Sam</strong> runs <strong>races</strong>. 山姆赛跑。</td>
</tr>
<tr>
<td>Pronoun 代词</td>
<td>替代另一个名词的名词</td>
<td>Sam runs races. <strong>He</strong> likes to compete. 山姆赛跑。他喜欢竞争。</td>
</tr>
<tr>
<td>Adjective 形容词</td>
<td>修饰名词的单词或短语</td>
<td>Sam wears <strong>blue</strong> shoes 山姆穿蓝色的鞋子。</td>
</tr>
<tr>
<td>Verb 动词</td>
<td>一个动作词或短语</td>
<td>Sam <strong>runs</strong> races.  山姆跑比赛。</td>
</tr>
<tr>
<td>Adverb 副词</td>
<td>修饰动词，形容词或其他副词的单词或短语</td>
<td>Sam runs <strong>slowly</strong>.  山姆跑得慢。</td>
</tr>
<tr>
<td>Preposition 介词</td>
<td>指定两个名词的位置关系的单词或短语</td>
<td>Sam’s sneakers are seldom <strong>on</strong> his shelf.  山姆的运动鞋很少在他的架子上。</td>
</tr>
<tr>
<td>Conjunction 连词</td>
<td>连接两个名词或短语的单词</td>
<td>Sam’s trophies <strong>and</strong> ribbons live only in his imagination.  山姆的奖杯和缎带只存在于他的想象中。</td>
</tr>
<tr>
<td>Transition 过渡</td>
<td>连接两个句子的单词或短语</td>
<td>Sam runs races weekly. <strong>However</strong>, he finishes races weakly. 山姆每周参加比赛。但是，他无力完成比赛。</td>
</tr>
</tbody></table>
<h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><p>名词代表人，地方或事物。<strong>朱迪（**</strong>Judy<strong>**）</strong>，<strong>南极洲（**</strong>Antarctica<strong>）和 <strong>锤子（</strong></strong>Hammer<strong>**）</strong>都是名词，无形的概念（例如<strong>健壮性</strong> <strong>robustness</strong> 和<strong>完美性</strong> <strong>perfection</strong> <strong>）</strong>也是如此。例如，我们在下面的示例中加粗了名词：</p>
<p>In the <strong>framework</strong>, an <strong>object</strong> must copy any underlying <strong>values</strong> that the <strong>object</strong> wants to change. The <strong>protos</strong> in the <strong>codebase</strong> are huge, so copying the <strong>protos</strong> is unacceptably expensive.</p>
<h3 id="代词"><a href="#代词" class="headerlink" title="代词"></a>代词</h3><p>代词是一个间接层，它指向或替代了其他名词或句子。例如：Janet writes great code. <strong>She</strong> is a senior staff engineer.  示例中，第一句话将Janet建立为名词。第二句用代词“ She”代替名词“Janet”。</p>
<p>在以下示例中，代词<strong>This</strong>代替了它前面的整个句子：</p>
<p>Most applications aren’t sufficiently tested. <strong>This</strong> is poor engineering.</p>
<h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><p>动词是一个动作词或短语。当您想要表示两个名词（一个行为者和一个目标）之间的关系时，该动词就起作用了。动词标识行为者对目标的作用。每个句子必须至少包含一个动词。例如，以下每个句子包含一个动词：</p>
<ul>
<li>Sakai <strong>prefers</strong> pasta.  酒井法子喜欢面食。</li>
<li>Rick <strong>likes</strong> the ocean.  瑞克喜欢大海。</li>
<li>Smurfs <strong>are</strong> blue.  蓝精灵是蓝色的。</li>
<li>Jess <strong>suffers</strong> from allergies.  杰西有过敏症。</li>
</ul>
<p>有些句子会包含多个动词，如：</p>
<ul>
<li>Nala <strong>suffers</strong> from allergies and <strong>sneezes</strong> constantly.<br> 娜娜过敏，经常打喷嚏。</li>
<li>Chung <strong>likes</strong> snacks <strong>to eat</strong> while <strong>riding</strong> the train.<br> Chung喜欢在火车上吃零食。</li>
</ul>
<p>根据时态和词缀变化，一个动词可以包含一个单词或多个单词。例如：</p>
<ul>
<li>Tina <strong>was eating</strong> breakfast a few hours ago.<br> 蒂娜几小时前正在吃早餐。</li>
<li>Tina <strong>is eating</strong> lunch right now.<br> 蒂娜现在在吃午餐。</li>
<li>Tina <strong>will eat</strong> dinner tonight at 7:00.<br> 蒂娜将在7点吃晚餐。</li>
</ul>
<h3 id="形容词和副词"><a href="#形容词和副词" class="headerlink" title="形容词和副词"></a>形容词和副词</h3><p>形容词修饰名词。例如，在下面的句子中，注意形容词如何修饰后面的名词：</p>
<p>Tom likes <strong>red</strong> balloons. He prepares <strong>delicious</strong> food. He fixed <strong>eight</strong> bugs at work.</p>
<p>大多数副词修饰动词。例如，注意下面句子中的副词是如何(有效地)修饰动词的：</p>
<p>Jane <strong>efficiently</strong> fixes bugs.</p>
<p>副词不一定紧挨着动词。例如，在下面的句子中，副词(effective)与动词(fixes)相距两个单词</p>
<p>Jane fixes bugs <strong>efficiently</strong>.</p>
<p>副词也可以修饰形容词或其他副词。</p>
<h3 id="连词和过渡"><a href="#连词和过渡" class="headerlink" title="连词和过渡"></a>连词和过渡</h3><p>连词连接句子中的短语或名词；过渡连接句子本身。最重要的连词如下：</p>
<ul>
<li>and</li>
<li>but</li>
<li>or</li>
</ul>
<p>例如，在下面的句子中，and连接了“code”和“documentation”，而but连接了句子的前半部分和后半部分。</p>
<p>Natasha writes great internal code <strong>and</strong> documentation <strong>but</strong> seldom works on open-source projects. </p>
<p>Natasha 编写了大量的内部代码和文档，但是很少在开源项目上工作。</p>
<p>技术写作中最重要的过度词如下：</p>
<ul>
<li>however</li>
<li>therefore</li>
<li>for example</li>
</ul>
<p>在下面的段落中，请注意过渡如何连接句子并使其上下文相关：</p>
<p>Juan is a wonderful coder. <strong>However</strong>, he rarely writes sufficient tests. <strong>For example</strong>, Juan coded a 5,000 line FFT package that contained only a single 10-line unit test.</p>
<p>Juan 是一个出色的程序员。然而，他很少编写足够的测试。例如，Juan编码了一个5000行的FFT包，却只包含一个10行的单元测试。</p>
<h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><h3 id="定义新术语或不熟悉的术语"><a href="#定义新术语或不熟悉的术语" class="headerlink" title="定义新术语或不熟悉的术语"></a>定义新术语或不熟悉的术语</h3><p>在写作或编辑时，识别那些目标受众可能不熟悉的术语。当您发现此类术语时，请采取以下两种策略之一：</p>
<ul>
<li>如果该术语已经存在，请链接到现有的具体解释。（不要重新发明轮子）</li>
<li>如果您的文档中引入了该术语，请定义该术语。如果您的文档引入了许多术语，请将定义收集到词汇表中。</li>
</ul>
<h3 id="始终使用术语"><a href="#始终使用术语" class="headerlink" title="始终使用术语"></a>始终使用术语</h3><p>如果在方法中途更改变量的名称，则代码将无法编译。同样，如果您在文档中间重命名术语，则您的想法将无法编译（在用户头脑中）。</p>
<p>修养：在整个文档中始终使用相同的明确词或术语。一旦你将某个组件命名为<strong>thingy</strong>之后，不要将其重命名为 <strong>thingamabob</strong>。例如，以下段落错误地将 <strong>Protocol Buffers</strong> 重命名为 <strong>protobufs</strong>：</p>
<p><strong>Protocol Buffer</strong> 提供了自己的定义语言。…………。这就是 <strong>protobufs</strong> 赢得如此众多县博览会的原因。</p>
<p>是的，技术写作是残酷和充满限制的，但是至少技术写作提供了一个很好的解决方法。即，当引入冗长的概念名称或产品名称时，您也可以指定该名称的缩写形式。然后，您可以在整个文档中使用该简称。例如，以下段落很好：</p>
<p><strong>Protocol Buffer</strong>（或简称 <strong>protobuf</strong>）提供了自己的定义语言。…… 这就是 <strong>protobuf</strong> 赢得如此众多县博览会的原因。</p>
<h3 id="正确使用首字母缩写词"><a href="#正确使用首字母缩写词" class="headerlink" title="正确使用首字母缩写词"></a>正确使用首字母缩写词</h3><p>在文档或章节中首次使用不熟悉的首字母缩写词时，请拼写完整的术语，然后将首字母缩写词放在括号中。拼写版本和首字母缩写用黑体字标出。例如：</p>
<p>本文档适用于<strong>远程触觉网络</strong> <strong>Telekinetic Tactile Network**</strong>（<strong><strong>TTN</strong></strong>）**的新手或需要了解如何通过手指运动订购TTN替换零件的工程师 。</p>
<p>然后可以使用首字母缩略词，如以下示例所示：</p>
<p>如果不存在缓存条目，则混合器将调用 <strong>OttoGroup Server</strong>（<strong>OGS</strong>）来为请求获取Ottos。OGS是一个存放所有可使用的Otto的存储库。OGS以逻辑树结构组织，具有一个根节点和两个级别的叶节点。OGS根将请求转发到叶子并收集响应。</p>
<p>另外，不要在同一文档中的首字母缩写词和扩展版本之间来回切换。</p>
<p>使用首字母缩写词还是完整术语？</p>
<p>当然，您可以正确地引入和使用首字母缩写词，但是您真的要使用首字母缩写词吗？好吧，首字母缩略词确实减少了句子的大小。例如，<em>TTN</em> 比<em>Telekinetic Tactile Network</em> 短很多。但是，首字母缩略词实际上只是抽象层。读者必须在头脑中将最近学到的首字母缩略词扩展到整个术语。例如，读者在脑海中将 <em>TTN</em> 转换为 <em>Telekinetic Tactile Network</em>，因此“较短”的首字母缩略词实际上要比整个术语花费更长的时间。</p>
<p>大量使用的首字母缩写词基本上会变成另外一个新词。在出现许多情况后，读者通常停止将首字母缩略词展开成具体的单词。例如，许多Web开发人员已经忘记了<em>HTML</em>这个术语展开后是什么。</p>
<p>这是首字母缩写词的准则：</p>
<ul>
<li><p>不要定义只会使用几次的首字母缩写词。</p>
</li>
<li><p>请定义同时满足以下两个条件的首字母缩写词：</p>
</li>
<li><ul>
<li>该首字母缩写词明显短于整个术语。</li>
<li>该首字母缩写词在文档中很多次出现。</li>
</ul>
</li>
</ul>
<h3 id="消除代词歧义"><a href="#消除代词歧义" class="headerlink" title="消除代词歧义"></a>消除代词歧义</h3><p>许多代词指向先前引入的名词。这种代词类似于编程中的指针。像编程中的指针一样，代词往往会引入错误。代词使用不当会就像程序中的 nullptr 空指针错误一样在读者的脑海中造成错误的认知 。在许多情况下，您应该简单地避免代词，而就直接重复使用该名词。但是，代词的效用有时会非常有用。</p>
<p>请考虑以下代词准则：</p>
<ul>
<li>引入名词后才使用代词；在介绍名词之前，切勿使用代词。</li>
<li>代词应尽可能靠近指称名词。根据经验，如果将名词与代词分隔开的单词超过五个，请考虑重复使用名词，而不要使用代词。</li>
<li>如果在名词和代词之间引入第二个名词，请重复使用名词，而不要使用代词。</li>
</ul>
<h4 id="it-和-they"><a href="#it-和-they" class="headerlink" title="it 和 they"></a>it 和 they</h4><p>以下代词在技术文档中引起最大的混乱：</p>
<ul>
<li>it</li>
<li>they，them 和 their</li>
</ul>
<p>例如，在下面的句子中，<strong>它</strong>是指Python还是C ++？</p>
<p>Python是解释型语言，而C ++是编译型语言。<strong>它</strong>具有几乎类似邪教的追随者。</p>
<p>再举一个例子，<strong>它们</strong> 在接下来的句子中指的是什么？</p>
<p>将 Frambus 或 Carambola 与 HoobyScooby 或 BoiseFram 一起使用时要小心，因为<strong>它们的</strong>核心可能会导致意外的大量脱机。</p>
<h4 id="this-和-that"><a href="#this-和-that" class="headerlink" title="this 和 that"></a>this 和 that</h4><p>考虑另外两个问题代词：</p>
<ul>
<li>this</li>
<li>that</li>
</ul>
<p>例如，在下面有歧义的句子中，“<strong>这**</strong>”** 可能是指Frambus，Foo或两者：</p>
<p>您可以使用 Frambus 或 Foo 来计算导数。<strong>这</strong> 不是最佳的。</p>
<p>使用以下的战术来消除歧义<strong>这个</strong>和<strong>那个</strong>：</p>
<ul>
<li>将 <strong>this</strong> 或 <strong>that</strong> 替换为相关的名词。</li>
<li>在 <strong>this</strong> 或 <strong>that</strong> 后马上使用那个名词。</li>
</ul>
<p>例如，以下两个句子中的任何一个都消除了前面的示例的歧义：</p>
<p><strong>Overlapping functionality</strong> is not optimal.</p>
<p><strong>This overlapping functionality</strong> is not optimal.</p>
<h3 id="主动语态与被动语态"><a href="#主动语态与被动语态" class="headerlink" title="主动语态与被动语态"></a>主动语态与被动语态</h3><p>技术写作中的绝大多数句子都应该是主动语态。本单元教您如何执行以下操作：</p>
<ul>
<li>区分被动语态和主动语态。</li>
<li>将被动语态转换为主动语态，因为主动语态通常更清晰。</li>
</ul>
<h4 id="用简单的句子区分主动语态和被动语态"><a href="#用简单的句子区分主动语态和被动语态" class="headerlink" title="用简单的句子区分主动语态和被动语态"></a>用简单的句子区分主动语态和被动语态</h4><p>在主动的语态句子中，主语作用于目标。也就是说，主动语态句子遵循以下公式：</p>
<p>主动语态句=主语+动词+目标</p>
<p>被动的语态句子则反过来。即，被动语态语句通常遵循以下公式：</p>
<p>被动语态句=目标+动词+主语</p>
<h5 id="主动语态示例"><a href="#主动语态示例" class="headerlink" title="主动语态示例"></a>主动语态示例</h5><p>例如，这是一个简短而主动语态句子：</p>
<p>The cat sat on the mat. 猫坐在垫子上。</p>
<ul>
<li>主语：The cat</li>
<li>动词：sat </li>
<li>目标：the mat</li>
</ul>
<h5 id="被动语态示例"><a href="#被动语态示例" class="headerlink" title="被动语态示例"></a>被动语态示例</h5><p>相比之下，这是被动语态中的同一句话：</p>
<p>The mat was sat on by the cat. 垫子被猫坐着。</p>
<ul>
<li>目标：The mat</li>
<li>被动动词：was sat</li>
<li>主语：the cat</li>
</ul>
<p>一些被动的语态句子省略了主语。例如：</p>
<p>The mat was sat on。</p>
<ul>
<li>主语：不明</li>
<li>被动动词：was sat</li>
<li>目标：the mat</li>
</ul>
<p>谁或什么坐在垫子上？一只猫？一只狗？霸王龙？读者只能猜测。技术文档中的好句子可以确定谁对谁做事。</p>
<h4 id="识别被动动词"><a href="#识别被动动词" class="headerlink" title="识别被动动词"></a>识别被动动词</h4><p>被动动词通常具有以下公式：</p>
<p>passive verb = be 的形式 + 动词过去分词</p>
<p>尽管上述公式令人生畏，但实际上非常简单：</p>
<ul>
<li><p><strong>be</strong> 在一个被动动词中通常是下列词语之一：</p>
</li>
<li><ul>
<li>is / are</li>
<li>was / were</li>
</ul>
</li>
<li><p><strong>past participle verb</strong> <strong>过去分词动词</strong> 通常是一个普通的动词加上过去式的后缀 ed。例如，以下是过去分词动词：</p>
</li>
<li><ul>
<li>interpreted</li>
<li>generated</li>
<li>formed</li>
</ul>
</li>
</ul>
<p>不幸的是，某些过去分词动词是不规则的；也就是说，过去分词形式不以后缀<em>ed</em>结尾。例如：</p>
<ul>
<li>sat</li>
<li>known</li>
<li>frozen</li>
</ul>
<p>将<em>be</em>和过去分词的形式放在一起会产生被动动词，例如：</p>
<ul>
<li>was interpreted</li>
<li>is generated</li>
<li>was formed</li>
<li>is frozen</li>
</ul>
<p>如果短语中包含一个主语，介词通常会跟在被动动词之后。(这个介词通常是帮助你辨别被动语态的关键线索)下面的例子结合了被动动词和介词：</p>
<ul>
<li>was interpreted as 被解释为</li>
<li>is generated by 由……生成</li>
<li>was formed by 由……形成</li>
<li>is frozen by 被……冻结</li>
</ul>
<h5 id="祈使动词通常是主动的"><a href="#祈使动词通常是主动的" class="headerlink" title="祈使动词通常是主动的"></a>祈使动词通常是主动的</h5><p>将祈使动词开头的句子很容易错误地归为被动。一个<strong>祈使动词</strong>是一个命令。编号列表中的许多项目都以祈使动词开头。例如，以下列表中的“ <em>Open”*和“ *Set</em> ”都是祈使动词：</p>
<ol>
<li>Open the configuration file.</li>
<li>Set the Frombus variable to False.</li>
</ol>
<p>以祈使动词开头的句子通常采用主动语态，即使它们没有明确提及主语。相反，以命令式动词开头的句子暗示一个主语。这个隐含的主语就是“<strong>你**</strong>”**。</p>
<h4 id="用更复杂的句子区分主动语态和被动语态"><a href="#用更复杂的句子区分主动语态和被动语态" class="headerlink" title="用更复杂的句子区分主动语态和被动语态"></a>用更复杂的句子区分主动语态和被动语态</h4><p>许多句子包含多个动词，其中有些是主动的，有些是被动的。例如，以下句子包含两个动词，两个动词均为被动语态：</p>
<img src="../images/image-20200314110029371.png" alt="image-20200314110029371" style="zoom:200%;" />

<p>完全转换为主动语态：</p>
<img src="../images/image-20200314110046383.png" alt="image-20200314110046383" style="zoom:200%;" />

<h4 id="首选主动语态而不是被动语态"><a href="#首选主动语态而不是被动语态" class="headerlink" title="首选主动语态而不是被动语态"></a>首选主动语态而不是被动语态</h4><p>大部分时间使用主动态。谨慎使用被动语态。主动语态具有以下优点：</p>
<ul>
<li>大多数读者会在心理上将被动语态转换为主动语态。为什么要使读者的处理时间更长？通过坚持主动语态，读者可以跳过预处理阶段，直接进入编译阶段。</li>
<li>被动语态会使您的想法模糊不清，使他们的句子变得无聊。被动语态间接报告操作。</li>
<li>一些被动语态的句子完全忽略了主语，这迫使读者猜测主语是谁。</li>
<li>主动语态通常比被动语态更短。</li>
</ul>
<p>Be bold—be active.</p>
<h3 id="清晰的句子"><a href="#清晰的句子" class="headerlink" title="清晰的句子"></a>清晰的句子</h3><p>喜剧作家寻求最有趣的结果，恐怖作家寻求最恐怖的结果，技术作家寻求最清晰的结果。在技术写作中，清晰度优先于所有其他规则。本单元提供了几种使句子清晰清晰的方法。</p>
<h4 id="选择强动词"><a href="#选择强动词" class="headerlink" title="选择强动词"></a>选择强动词</h4><p>许多技术写作者认为，动词是句子中最重要的部分。选择正确的动词，句子的其余部分都会顺理成章。不幸的是，有些写作者只重复使用了少量温和的动词，就像每天为客人提供千篇一律的饼干和生菜一样。选择正确的动词需要花费更多时间，但会产生更令人满意的结果。</p>
<p>为了吸引和教育读者，请选择精确，有力的特定动词。减少不精确，虚弱或通用的动词，例如：</p>
<ul>
<li><em>be</em>的形式：is，are，am，was，are等。</li>
<li>occur</li>
<li>happen</li>
</ul>
<p>例如，考虑以下句子中的弱动词如何增强有代入感的句子</p>
<table>
<thead>
<tr>
<th>弱动词</th>
<th>强动词</th>
</tr>
</thead>
<tbody><tr>
<td>The error <strong>occurs</strong> when clicking the Submit button.</td>
<td>Clicking the Submit button <strong>triggers</strong> the error.</td>
</tr>
<tr>
<td>This error message <strong>happens</strong> when…</td>
<td>The system <strong>generates</strong> this error message when…</td>
</tr>
<tr>
<td>We <strong>are</strong> very careful to ensure…</td>
<td>We carefully <strong>ensure</strong>…</td>
</tr>
</tbody></table>
<p>许多写作者都依赖于<em>be</em>的形式，好像它们是货架上唯一的香料。撒上不同的动词，能让自己的散文变得更开胃。也就是说，一种形式的<em>be</em>有时是动词的最佳选择，因此不必觉得您必须从写作中消除每种形式的<em>be</em>。</p>
<p>请注意，一般动词通常有病变的信号，例如：</p>
<ul>
<li>句子中不精确的主语或没有主语</li>
<li>被动语态句子</li>
</ul>
<p>示例一</p>
<p>When a variable declaration doesn’t have a data type, a compiler error happens.</p>
<p>被改写成下面的形式会更好：</p>
<ul>
<li>When a variable declaration doesn’t <strong>specify</strong> a data type, the compiler <strong>generates</strong> an error message.</li>
<li>If you <strong>declare</strong> a variable but don’t <strong>specify</strong> a data type, the compiler <strong>generates</strong> an error message.</li>
</ul>
<p>示例二</p>
<p>Compiler errors occur when you leave off a semicolon at the end of a statement.</p>
<p>被改成下面的形式会更好：</p>
<ul>
<li>Compilers <strong>issue</strong> errors when you <strong>omit</strong> a semicolon at the end of a statement.</li>
<li>A missing semicolon at the end of a statement <strong>triggers</strong> compiler errors.</li>
</ul>
<h4 id="减少使用-there-is-there-are"><a href="#减少使用-there-is-there-are" class="headerlink" title="减少使用 there is/there are"></a>减少使用 there is/there are</h4><p>以<strong>There is</strong> 或 <strong>There is</strong> 开头的句子将普通名词嫁接到普通动词上。这种乱点鸳鸯谱的方式会使读者感到厌烦。通过提供真实的主语和真实的动词来表达才是对读者的真爱。</p>
<p>在最佳情况下，您可以简单地删除“<strong>There is”</strong>或“<strong>There are”</strong> （以及句子后面的另一个单词或两个单词）。例如，考虑以下句子：</p>
<p>There is a variable called met_trick that stores the current accuracy.</p>
<p>删除 <strong>There is</strong> 用更好的主语替换通用主题。例如，以下任一句子比原始句子更清晰：</p>
<p>A variable named met_trick stores the current accuracy. </p>
<p>The met_trick variable stores the current accuracy.</p>
<h5 id="您有时可以通过将真实的主语和真实的动词从句子的末尾移到开头来修复-There-is或-There-are-句子。"><a href="#您有时可以通过将真实的主语和真实的动词从句子的末尾移到开头来修复-There-is或-There-are-句子。" class="headerlink" title="您有时可以通过将真实的主语和真实的动词从句子的末尾移到开头来修复 There is或 There are 句子。"></a>您有时可以通过将真实的主语和真实的动词从句子的末尾移到开头来修复 <strong>There is</strong>或 <strong>There are</strong> 句子。</h5><p>例如，请注意，<strong>You</strong> 的代词出现在以下句子的结尾：</p>
<p>There are two disturbing facts about Perl you should know.</p>
<p>用 You 替换 there is ：</p>
<p>You should know two disturbing facts about Perl.</p>
<p>在其他情况下，写作者以 <strong>There is</strong> 或 <strong>There are</strong> 开始句子，以避免创建真实的主语或动词的麻烦。如果不存在任何主题，请考虑创建一个。例如，以下 <strong>There is</strong> 句子不能识别接收实体：</p>
<p>There is no guarantee that the updates will be received in sequential order.</p>
<p>用有意义的主语（例如:<strong>client</strong>）代替“ There is”可以为读者带来更清晰的体验：</p>
<p>Clients might not receive the updates in sequential order.</p>
<p>练习</p>
<ol>
<li>There is a lot of overlap between X and Y.</li>
<li>There is no creator stack for the main thread.</li>
<li>There is a low-level, TensorFlow, Python interface to load a saved model.</li>
<li>There is a sharding function named distribute that assigns keys.</li>
</ol>
<p>可以改写为：</p>
<ol>
<li>X and Y overlap a lot.</li>
<li>The main thread does not provide a creator stack.</li>
<li>TensorFlow provides a low-level Python interface to load a saved model.</li>
<li>The distribute sharding function assigns keys.</li>
</ol>
<h4 id="最小化特定的形容词和副词（可选）"><a href="#最小化特定的形容词和副词（可选）" class="headerlink" title="最小化特定的形容词和副词（可选）"></a>最小化特定的形容词和副词（可选）</h4><p>形容词和副词在小说和诗歌中表现出色。由于形容词，普通的草能变成<strong>杂草</strong> <strong>prodigal</strong> 和<strong>葱绿</strong> <strong>verdant</strong>，而毫无生气的头发变换到的东西<strong>柔滑</strong> <strong>silky</strong> 和<strong>流动</strong> <strong>flowing</strong>。副词能让马跑地<strong>疯狂</strong> <strong>madly</strong>和<strong>自由</strong> <strong>freely</strong>，让狗叫得<strong>大声</strong> <strong>loudly</strong> 和<strong>凶猛</strong> <strong>ferociously</strong>。不幸的是，形容词和副词有时会加入很多噪音。那是因为形容词和副词的定义过于松散，对技术读者而言主观。更糟糕的是，形容词和副词会使技术文档听起来像营销材料一样危险。例如，请考虑以下技术文档中的内容：</p>
<p>Setting this flag makes the application run screamingly fast.</p>
<p>诚然，<strong>screamingly fast</strong> <strong>令人尖叫的速度</strong> 能引起了读者的注意，但不一定是一种很好的方式。向您的读者提供事实数据，而不是像市场营销人员讲话。将无定形副词和形容词重构为客观的数字信息。例如：</p>
<p>Setting this flag makes the application run 225-250% faster.</p>
<p>前面的更改是否会剥夺其某些魅力的句子？是的，有一点，但是修改后的句子获得了准确性和可信度。</p>
<h3 id="简短的句子"><a href="#简短的句子" class="headerlink" title="简短的句子"></a>简短的句子</h3><p>软件工程师通常愿意精简代码，主要出于以下原因：</p>
<ul>
<li>简短的代码更易于他人阅读。</li>
<li>简短的代码更易于维护。</li>
<li>多余的代码可能会引入潜在的故障。</li>
</ul>
<p>以上规则，同样适用于技术写作：</p>
<ul>
<li>简短的文档可读性更好。</li>
<li>简短的文档更易于维护。</li>
<li>多余的文档行会引入额外的问题。</li>
</ul>
<p>寻找最短的文档实现需要时间，但最终还是值得的。短句子比长句子更有效地进行交流，并且短句子通常比长句子更容易理解。</p>
<h4 id="一个句子只聚焦在一个想法"><a href="#一个句子只聚焦在一个想法" class="headerlink" title="一个句子只聚焦在一个想法"></a>一个句子只聚焦在一个想法</h4><p>将每句话聚焦在一个想法上思想或概念上。就像程序中的语句执行单个任务一样，句子也应该执行单个想法。例如，以下很长的句子包含多种想法：</p>
<p>The late 1950s was a key era for programming languages because IBM introduced FORTRAN in 1957 and John McCarthy introduced Lisp the following year, which gave programmers both an iterative way of solving problems and a recursive way.</p>
<p>1950年代后期是编程语言的关键时代，因为IBM于1957年推出了FORTRAN，而John McCarthy于次年推出了Lisp，这为程序员提供了解决问题的迭代方法和递归的方法。</p>
<p>将长句子分解为一连串的单意识句子会产生以下结果：</p>
<p>The late 1950s was a key era for programming languages. IBM introduced FORTRAN in 1957. John McCarthy invented Lisp the following year. Consequently, by the late 1950s, programmers could solve problems iteratively or recursively.</p>
<p>1950年代后期是编程语言的关键时代。IBM在1957年推出了FORTRAN。第二年，John McCarthy发明了Lisp。因此，到1950年代后期，程序员可以使用迭代或递归的方法来解决问题。</p>
<p>练习</p>
<p>将以下长句子转换为一系列短句子。不要修改太多；最后只剩下几句话而不是只有一句话。</p>
<p>In bash, use the if, then, and fi statements to implement a simple conditional branching block in which the if statement evaluates an expression, the then statement introduces a block of statements to run when the if an expression is true, and the fi statement marks the end of the conditional branching block.</p>
<p>可以改写成</p>
<p>In bash, use an if, then, and fi statement to implement a simple conditional branching block. The if statement evaluates an expression. The then statement introduces a block of statements to run when the if an expression is true. The fi statement marks the end of the conditional branching block.</p>
<h4 id="将长句子转换为列表"><a href="#将长句子转换为列表" class="headerlink" title="将长句子转换为列表"></a>将长句子转换为列表</h4><p>许多冗长的技术语句中，都有一个渴望摆脱困境的清单。例如，考虑以下句子：</p>
<p>To alter the usual flow of a loop, you may use either a <strong>break</strong> statement (which hops you out of the current loop) or a <strong>continue</strong> statement (which skips past the remainder of the current iteration of the current loop).</p>
<p>要更改循环的通常流程，可以使用<strong>break</strong>语句（使您跳出当前循环）或<strong>continue</strong>语句（跳过当前循环的当前迭代的其余部分）。</p>
<p>当您看到连词<strong>or</strong>长句子时，请考虑将该句子重构为项目符号列表。当您看到长句子中嵌入的项目或任务列表时，请考虑将该句子重构为项目符号或编号列表。例如，前面的示例包含连词<strong>或**</strong>or**，因此让我们将长句子转换为以下项目符号列表：</p>
<p>要更改循环的通常流程，请调用以下语句之一：</p>
<ul>
<li>break，使您跳出当前循环。</li>
<li>continue，跳过当前循环的当前迭代的其余部分。</li>
</ul>
<p>练习</p>
<p>将以下句子重构为更简短的内容。确保您的答案包含一个列表：</p>
<ol>
<li>To get started with the Frambus app, you must first find the app at a suitable store, pay for it using a valid credit or debit card, download it, configure it by assigning a value for the Foo variable in the /etc/Frambus file, and then run it by saying the magic word twice.</li>
<li>KornShell was invented by David Korn in 1983, then a computer scientist at Bell Labs, as a superset of features, enhancements, and improvements over the Bourne Shell (which it was backwards compatible with), which was invented by Stephen Bourne in 1977 who was also a computer scientist at Bell Labs.</li>
</ol>
<p>可以改写为</p>
<p>Take the following steps to get started with the Frambus app:</p>
<p>请按照以下步骤使用 Frambus 应用：</p>
<ol>
<li>Find the app at a suitable store.</li>
</ol>
<p>在应用商店搜索该应用。</p>
<ol>
<li>Pay for the app using a valid credit or debit card.</li>
</ol>
<p>使用有效的信用卡或借记卡购买该应用。</p>
<ol>
<li>Download the app.</li>
</ol>
<p>下载安装应用。</p>
<ol>
<li>Configure the app by assigning a value for the Foo variable in the /etc/Frambus file.</li>
</ol>
<p>在 /etc/Frambus 文件中，为 Foo 变量分配一个值来配置应用。</p>
<ol>
<li>Run the app by saying the magic word twice.</li>
</ol>
<p>The following two Bell Labs computer scientists invented popular shells:</p>
<ul>
<li>Stephen Bourne invented the Bourne Shell in 1977.</li>
<li>David Korn invented the KornShell in 1983.</li>
</ul>
<p>The KornShell’s features are a backwards-compatible superset of the Bourne Shell’s.</p>
<h4 id="消除或减少多余的单词"><a href="#消除或减少多余的单词" class="headerlink" title="消除或减少多余的单词"></a>消除或减少多余的单词</h4><p>许多句子都包含填充词，即文本的垃圾食品，它占用空间而不滋养读者。例如，看看是否可以在以下句子中找到不必要的单词：</p>
<p>An input value greater than 100 causes the triggering of logging.</p>
<p>替换<strong>causes the triggering of</strong> <strong>为</strong>动词 <strong>trigger</strong> 可以产生较短的句子：</p>
<p>An input value greater than 100 triggers logging.</p>
<p>通过练习，您会发现多余的单词，并享受删除他们的快乐。例如，考虑以下句子：</p>
<p>This design document provides a detailed description of Project Frambus.</p>
<p>句子 <strong>provides a detailed description of</strong> 可以缩减为动词 <strong>details</strong>，句子变为：</p>
<p>This design document details Project Frambus.</p>
<p>下表建议了一些常见的啰嗦的句子的替换：</p>
<table>
<thead>
<tr>
<th>啰嗦</th>
<th>简洁</th>
</tr>
</thead>
<tbody><tr>
<td>at this point in time</td>
<td>now</td>
</tr>
<tr>
<td>determine the location of</td>
<td>find</td>
</tr>
<tr>
<td>is able to</td>
<td>can</td>
</tr>
</tbody></table>
<h4 id="减少从句（可选）"><a href="#减少从句（可选）" class="headerlink" title="减少从句（可选）"></a>减少从句（可选）</h4><p>一个<strong>从句</strong>是一个句子中的独立逻辑片断，其中包含一个主语和动作。每个句子包含以下内容：</p>
<ul>
<li>一个主句</li>
<li>零个或多个从句</li>
</ul>
<p>从句在主从句中会修改了主要的意思。还会暗示着，从句比主句重要。例如，考虑以下句子：</p>
<p>Python是一种解释型编程语言，于1991年发明。</p>
<ul>
<li>主句：Python是一种解释型编程语言</li>
<li>从句：于1991年发明</li>
</ul>
<p>通常，您可以通过引入从句的词来识别它们。以下列表（绝不完整）显示了引入从句的常用词：</p>
<ul>
<li>which</li>
<li>that</li>
<li>because</li>
<li>whose</li>
<li>until</li>
<li>unless</li>
<li>since</li>
</ul>
<p>有些从句以逗号开头，有些则没有。例如，以下句子中突出显示的从属子句以单词“ <strong>因为**</strong>because”**开头，并且不包含逗号：</p>
<p>I prefer to code in C++ because I like strong data typing.</p>
<p>我更喜欢用C ++编写代码，因为我喜欢强大的数据类型。</p>
<p>编辑时，请仔细检查从属子句。记住one sentence = one idea 公式。句子中的从句是扩展单个概念还是将其分支成一个单独的概念？如果是后者，请考虑将有问题的从属子句分成单独的句子。</p>
<p>练习</p>
<p>判断哪些句子包含从句，这些从句应该被分支成独立的句子。(不要重写句子，只要找出需要重写的句子就可以了)</p>
<p>Python is an interpreted language, which means that the language can execute source code directly. </p>
<p>这个句子里的从句扩展了主句的意思，所以这个句子还可以。</p>
<p>Bash is a modern shell scripting language that takes many of its features from KornShell 88, which was developed at Bell Labs. </p>
<p>第一个从句扩展了主句的意思，而第二个从句则向另一个方向发展。把这个句子分成两部分。</p>
<p>Lisp is a programming language that relies on Polish prefix notation, which is one of the systems invented by the Polish logician Jan Łukasiewicz. </p>
<p>第一个从句扩展了主句的意思，而第二个从句则向另一个方向发展。把这个句子分成两部分。</p>
<p>I don’t want to say that Fortran is old, but only radiocarbon dating can determine its true age. </p>
<p>这个句子里的从句扩展了主句的意思，所以这个句子还可以。</p>
<h4 id="区分-that-和-which"><a href="#区分-that-和-which" class="headerlink" title="区分 that 和 which"></a>区分 that 和 which</h4><p><strong>that</strong> 和 <strong>which</strong> 都是用来引入了从句的。它们之间有什么区别？好吧，在某些国家，这两个词几乎可以互换。但是，不可避免的是，机智的美国读者会愤怒地宣布您再次混淆了这两个词。</p>
<p>在美国，使用 <strong>which</strong> 从句意味着从句是不必要的部分，而使用 <strong>that</strong> 则表明是一个重要的短语，句子不能没有。例如：</p>
<p>Python is an interpreted language, <strong>which</strong> means the processor runs the program directly.  </p>
<p>Python是一种解释性语言，这意味着处理器可以直接运行程序。</p>
<p>FORTRAN is perfect for mathematical calculations <strong>that</strong> don’t involve linear algebra. FORTRAN是完美的数学计算是不涉及线性代数。</p>
<p>这样的解释有用吗？可能不会。相反，请尝试以下操作：如果您大声朗读句子并听到从属子句之前的停顿，则使用<strong>which</strong>。如果你没有听到暂停，使用 <strong>that</strong>。返回并阅读两个例句。您听到第一句话中的停顿了吗？</p>
<p>在<strong>which</strong>前面放置逗号；在 <strong>that</strong> 之前不要使用逗号。</p>
<h3 id="列表和表格"><a href="#列表和表格" class="headerlink" title="列表和表格"></a>列表和表格</h3><p>读者通常喜欢列表，好的列表可以将混乱转变为有序。因此，在写作时，尽可能将散文转换为列表。</p>
<h4 id="选择正确的列表类型"><a href="#选择正确的列表类型" class="headerlink" title="选择正确的列表类型"></a>选择正确的列表类型</h4><p>以下列表在技术写作中占主导地位：</p>
<ul>
<li>无序列表 bullets lists</li>
<li>有序列表 numbered lists</li>
<li>嵌入式列表 embedded lists</li>
</ul>
<p>未排序的项目使用<strong>无序列表</strong>；排序的项目使用 <strong>有序列表</strong>。换一种说法：</p>
<ul>
<li>如果修改列表的顺序不会改变含义，则使用<strong>无序列表</strong>。</li>
<li>如果修改列表的顺序会改变含义，则使用<strong>有序列表</strong>。</li>
</ul>
<p>下面例子我们使用了<strong>无序列表</strong>，因为重新排列项目不会改变含义：</p>
<p>Bash提供以下字符串操作机制：</p>
<ul>
<li>子字符串会从字符串开头删除</li>
<li>将整个文件读入到一个字符串变量</li>
</ul>
<p>相比之下，下面例子使用有序列表，因为重新排列其项目会改变列表的含义：</p>
<p>请执行以下步骤来重新配置服务器：</p>
<ol>
<li>停止服务器。</li>
<li>编辑配置文件。</li>
<li>重新启动服务器。</li>
</ol>
<p><strong>嵌入式列表</strong>（有时称为 <strong>run-in</strong> 列表）包含在一个句子。例如，下面句子包含了四个项目的嵌入式列表。</p>
<p>llamacatcher API使调用者可以创建和查询美洲驼、分析羊驼、删除骆驼和跟踪单峰骆驼。</p>
<p>一般而言，嵌入式列表是展示信息较差的方法。尽量将<strong>嵌入式列表</strong>转换为无序列表或有序列表。</p>
<p>例如，上面的例子可以转化为无序列表：</p>
<p>llamacatcher API使调用者可以执行以下操作：</p>
<ul>
<li>创建和查询美洲驼。</li>
<li>分析羊驼。</li>
<li>删除骆驼。</li>
<li>跟踪单峰骆驼。</li>
</ul>
<p>将以下段落转换为列表形式：</p>
<p>今天，在工作中，我必须编写三个单元测试的代码，编写设计文档，并查看Janet的最新文档。下班后，我必须不用水洗车，然后不用毛巾擦干。</p>
<p>以下是列表的形式。</p>
<p>我今天工作必须执行以下操作：</p>
<ul>
<li>编码三个单元测试。</li>
<li>编写设计文档。</li>
<li>查看Janet的最新文档。</li>
</ul>
<p>下班后，我必须执行以下操作：</p>
<ol>
<li>不用水洗我的车。</li>
<li>不用毛巾擦干我的车。</li>
</ol>
<h4 id="保持清单项目平行"><a href="#保持清单项目平行" class="headerlink" title="保持清单项目平行"></a>保持清单项目平行</h4><p>如何区分好的列表和坏的列表？好的列表是平行的，坏的列表则相反。<strong>平行</strong>列表中的项目看起来属于一起。换句话说，平行列表中的所有项目都符合下面的参数：</p>
<ul>
<li>语法</li>
<li>逻辑类别</li>
<li>大小写</li>
<li>标点</li>
</ul>
<p>相反，<strong>非平行</strong>列表中的至少一项不符合上面参数。</p>
<p>例如，以下列表是平行的，因为所有项都是复数名词（语法），可食用（逻辑类别），小写（大小写），并且没有句点或逗号（标点符号）。</p>
<ul>
<li>carrots</li>
<li>potatoes</li>
<li>cabbages</li>
</ul>
<p>相比之下，以下列表在所有四个参数上都不是平行的：</p>
<ul>
<li>carrots</li>
<li>potatoes</li>
<li>The summer light obscures all memories of winter.</li>
</ul>
<p>以下列表是并行的，因为所有项目都是完整的句子，并带有完整的句子大写和标点符号：</p>
<ul>
<li>Carrots contain lots of Vitamin A. （胡萝卜含有大量的维生素A）</li>
<li>Potatoes taste delicious. （土豆味道鲜美）</li>
<li>Cabbages provide oodles of Vitamin K. (卷心菜提供大量的维生素K）</li>
</ul>
<p>列表中的第一项建立了读者的预期，后面项目反复强化这种预期。。</p>
<h4 id="列表项使用动词开头"><a href="#列表项使用动词开头" class="headerlink" title="列表项使用动词开头"></a>列表项使用动词开头</h4><p>推荐在有序列表中，项目使用动词开头，例如 <strong>打开**</strong>open** 或 <strong>启动</strong> <strong>start</strong>。下面是一些示例，请注意以下列表中所有的项目是如何以动词开头的：</p>
<ol>
<li>Download the Frambus app from Google Play or iTunes.</li>
</ol>
<p>下载 Frambus 应用（Google Play 或 iTunes）。</p>
<ol>
<li>Configure the Frambus app’s settings.</li>
</ol>
<p>配置 Frambus 应用的设置。</p>
<ol>
<li>Start the Frambus app.</li>
</ol>
<p>启动 Frambus 应用。</p>
<p>以下有序列表是不平行的，因为前两项以动词开头，而第三项则不是：</p>
<ol>
<li>Instantiate the Froobus class.</li>
</ol>
<p>实例化 Froobus 类。</p>
<ol>
<li>Invoke the Froobus.Salmonella() method.</li>
</ol>
<p>调用 Froobus.Salmonella() 方法。</p>
<ol>
<li>The process stalls.</li>
</ol>
<p>这个过程停滞不前。</p>
<h4 id="正确使用标点符号"><a href="#正确使用标点符号" class="headerlink" title="正确使用标点符号"></a>正确使用标点符号</h4><p>如果列表项是句子，请使用首字母大写并使用标点符号。否则，请勿使用句子大写和标点符号。例如，以下列表项是一个句子，因此使“ <strong>Most”</strong>中<strong>M</strong>大写， 并在句末加句号。</p>
<ul>
<li>Most carambolas have five ridges.</li>
</ul>
<p>但是，下面的列表项不是句子，所以使 <strong>the</strong> 中的 <strong>t</strong> 小写并不加标点。</p>
<ul>
<li>the color of lemons</li>
</ul>
<h4 id="创建有用的表格"><a href="#创建有用的表格" class="headerlink" title="创建有用的表格"></a>创建有用的表格</h4><p>分析型的头脑倾向于使用表格。如果一个页面上包含多个段落和一个表格，工程师往往将目光移向表格。</p>
<p>创建表格时，请遵循以下原则：</p>
<ul>
<li>用有意义的表头标记每列。不要让读者猜测每一列的内容。</li>
<li>避免在表格单元格中放入太多文本。如果一个表格单元格包含两个以上的句子，请问问自己该信息是否属于其他格式。</li>
<li>尽管不同的列可以保存不同类型的数据，但是要在各个列中尽可能的做到平行性。例如，特定表格列中的单元格不应是数字数据和著名的马戏团大象的混合。</li>
</ul>
<p><strong>注意：</strong>某些表格不能很好地呈现所有形式的信息。例如，在笔记本电脑上看起来不错的表格在手机上可能看起来很糟糕。</p>
<h4 id="介绍每个列表和表格"><a href="#介绍每个列表和表格" class="headerlink" title="介绍每个列表和表格"></a>介绍每个列表和表格</h4><p>我们建议在每个列表和表格前加上一句话，告诉读者该列表或表格代表什么。换句话说，给出列表或表格上下文：即使用冒号结束的介绍性句子。</p>
<p>尽管不是必需的，但我们建议将“ <strong>following</strong> ”一词放入介绍的句子中。参考如下例子：：</p>
<p>The following list identifies key performance parameters:</p>
<h5 id="以下列表确定了关键性能的参数"><a href="#以下列表确定了关键性能的参数" class="headerlink" title="以下列表确定了关键性能的参数:"></a>以下列表确定了关键性能的参数:</h5><p>Take the following steps to install the Frambus package:</p>
<h5 id="采取以下步骤安装-Frambus-软件包"><a href="#采取以下步骤安装-Frambus-软件包" class="headerlink" title="采取以下步骤安装 Frambus 软件包:"></a>采取以下步骤安装 Frambus 软件包:</h5><p>The following table summarizes our product’s features against our key competitors’ features:</p>
<p>下表总结了我们产品和主要竞争对手的特点：</p>
<p>练习</p>
<p>为下表写一个介绍性句子：</p>
<table>
<thead>
<tr>
<th>语言能力</th>
<th>发明者</th>
<th>推出年份</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td>Lisp</td>
<td>约翰·麦卡锡</td>
<td>1958年</td>
<td>递归</td>
</tr>
<tr>
<td>C++</td>
<td>比尼亚·斯特鲁斯特鲁普（Bjarne Stroustrup）</td>
<td>1979年</td>
<td>面向对象</td>
</tr>
<tr>
<td>Python</td>
<td>吉多·范·罗苏姆（Guido van Rossum）</td>
<td>1994年</td>
<td>简单</td>
</tr>
</tbody></table>
<p>The following table contains a few key facts about some popular programming languages:</p>
<p>下表展示了一些流行编程语言的关键信息：</p>
<p>The following table identifies the inventor, year of invention, and key feature of three popular programming languages: </p>
<p>下表列出了三种流行编程语言的发明者、发明年份和主要特征：</p>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>本节提供了一些构建内聚段落的指导原则。但是首先，先读一下下面的这段话：</p>
<p>写作的流程很简单：理清主题各部分之间的依赖关系，并以逻辑流的形式呈现这些部分，使读者能够理解您。</p>
<h4 id="写一个精彩的开头句"><a href="#写一个精彩的开头句" class="headerlink" title="写一个精彩的开头句"></a>写一个精彩的开头句</h4><p>开头句子是任何段落中最重要的句子。忙碌的读者只关注开头的句子，有时会跳过后面的句子。因此，将精力集中在开头句上。</p>
<p>好的开头句确立了段落的中心点。以下段落就是个好例子：</p>
<p>循环会多次运行同一代码块。例如，假设您编写了一段代码来检测输入行是否以句号结尾。要计算一百万条输入行，那请创建一个运行一百万次的循环。</p>
<p>前面的开头句将段落的主题确立为循环的简介。相比之下，以下开篇句子将读者引向错误的方向：</p>
<p>代码块是相同功能内的连续代码集。例如，假设您编写了一段代码来检测输入行是否以句点结尾。要评估一百万条输入行，请创建一个运行一百万次的循环。</p>
<p><strong>注意：</strong>有效的开头句可以采用多种形式。也就是说，并非所有出色的段落都以陈述主题的句子开头。例如，以反问开头的段落可以吸引读者。</p>
<h4 id="一个段落聚焦一个主题"><a href="#一个段落聚焦一个主题" class="headerlink" title="一个段落聚焦一个主题"></a>一个段落聚焦一个主题</h4><p>一个段落应代表一个独立的逻辑单元。将每个段落限制为当前主题。不要描述将来的话题会发生什么或过去的话题会发生什么。当我们要修改编辑时，一定要毫不犹豫地删除（或移至另一段）任何与当前主题无直接关联的句子。</p>
<p>下面例子中，假设开头句正确表达了段落的主题，你能找到其中不符合该主题的句子吗？</p>
<p>毕达哥拉斯定理指出，直角三角形的两条直角边的平方和等于斜边的平方。三角形的周长等于三个边的总和。您可以使用勾股定理来测量对角线距离。例如，如果您知道乒乓球桌的长度和宽度，则可以使用勾股定理确定对角线距离。要计算乒乓球桌的周长，请将长度和宽度相加，然后将其乘以2。</p>
<p>我们删去了第二和第五句话，得出了一个专门针对勾股定理的段落：</p>
<p>毕达哥拉斯定理指出，直角三角形的两条直角边的平方和等于斜边的平方。 三角形的周长等于三个边的总和。您可以使用勾股定理来测量对角线距离。例如，如果您知道乒乓球桌的长度和宽度，则可以使用勾股定理确定对角线距离。要计算乒乓球桌的周长，请将长度和宽度相加，然后将其乘以2。</p>
<h4 id="段落不要太长或太短"><a href="#段落不要太长或太短" class="headerlink" title="段落不要太长或太短"></a>段落不要太长或太短</h4><p>长段落在视觉上令人生畏。很长的段落构成了可怕的“文字墙”，读者会忽略。读者通常欢迎只有三到五个句子的段落，同时忽略超过七个句子的段落。修订时，请考虑将很长的段落分为两个单独的段落。</p>
<p>相反，段落也不要太短。如果您的文档包含大量的单句段落，则说明您语言组织不够。请设法将这些零散段落组合成连贯的段落，或者组合成列表形式。</p>
<h4 id="回答what，why-以及-how"><a href="#回答what，why-以及-how" class="headerlink" title="回答what，why 以及 how"></a>回答what，why 以及 how</h4><p>好的段落回答以下三个问题：</p>
<ol>
<li><strong>What -</strong> 告诉读者这是什么</li>
<li><strong>Why -</strong> 为什么让读者知道这一点很重要</li>
<li><strong>How -</strong> 读者应如何使用这些知识。或者，读者应该如何知道您的观点是正确的？</li>
</ol>
<p>下面例子就回答了 What，Why 以及 How：</p>
<p><strong>** 该 grap() 函数返回一个数据集的平均值和中位数之间的增量。**</strong> <strong>** 许多人毫不怀疑地相信，平均值之道总是真理。但是，平均值很容易受到几个非常大或非常小的数据点的影响。**</strong> <strong><strong>调用garp()可以帮助确定是否有几个非常大或非常小的数据点对均值的影响太大。相比较高的grap()值，较小的grap()值说明平均值更有意义。</strong></strong></p>
<h3 id="受众"><a href="#受众" class="headerlink" title="受众"></a>受众</h3><p>我们认为您应该喜欢数学。因此，本章节以一个公式开始：</p>
<p>好的文档 = 您的受众完成一项任务所需的知识和技能 - 您的受众当前的知识和技能</p>
<p>换句话说，请确保您的文档提供了受众所需的信息，而受众还没有这些信息。因此，本章节说明了如何执行以下操作：</p>
<ul>
<li>定义您的受众群体。</li>
<li>确定您的读者需要学习的内容。</li>
<li>提供合适您读者的文档。</li>
</ul>
<p>如以下视频所示，针对错误的受众可能会很混乱：<a href="https://youtu.be/eFtXIrmsMwI" target="_blank" rel="noopener">https://youtu.be/eFtXIrmsMwI</a></p>
<h4 id="定义您的受众"><a href="#定义您的受众" class="headerlink" title="定义您的受众"></a>定义您的受众</h4><p>认真的文档工作会花费了大量时间和精力来定义他们的受众。这些工作可能进行用户调查，用户体验研究，聚焦小组和文档测试。您可能没有那么多时间，所以本章节采用一种更简单的方法。</p>
<p>首先确定您的受众<strong>角色</strong>。示例角色包括：</p>
<ul>
<li>软件工程师</li>
<li>技术非工程师角色（例如技术项目经理）</li>
<li>科学家</li>
<li>科学领域的专业人员（例如医师）</li>
<li>工科本科生</li>
<li>工科研究生</li>
<li>非技术职位</li>
</ul>
<p>我们很高兴地认识到，许多非技术人员具有出色的技术和数学技能。但是，角色仍然是定义受众时必不可少的。具有相同角色的人通常对某些基本技能和知识有一定的共识。例如：</p>
<ul>
<li>大多数软件工程师都知道流行的排序算法，Big O 符号和至少一种编程语言。因此，您可以假定软件工程师了解O(n)的含义，但不能假定非技术角色也可以了解O(n)。</li>
<li>针对同一研究项目，医生的专业报告和普通受众的报纸文章应该看起来有很大的不同。</li>
<li>大学教授对研究生进行一种新型的机器学习方法的教学方法，会完全不同于对本科生的教学方法。</li>
</ul>
<p>如果处于同一角色的每个人都共享完全相同的知识，那么写作会容易得多。不幸的是，同一角色内的知识也会迅速产生分支。Amal是Python方面的专家，Sharon的专业知识是C++，Micah的专业知识是Java。Kara喜欢Linux，但是David只知道iOS。</p>
<p>角色本身不足以定义受众。也就是说，您还必须考虑受众对知识的接近程度。Project Frombus的软件工程师对相关的Project Dingus有所了解，但对无关的Carambola项目一无所知。普通的心脏病专家比普通的软件工程师对耳朵问题的了解要多，但比听觉专家要少得多。</p>
<p>时间也会造成差距。例如，几乎所有软件工程师都学过微积分。但是，大多数软件工程师在工作中并不使用微积分，因此他们对微积分的了解逐渐消失。相反，与同一项目的新工程师相比，经验丰富的工程师通常对当前项目的了解要多得多。</p>
<h5 id="样本受众分析"><a href="#样本受众分析" class="headerlink" title="样本受众分析"></a>样本受众分析</h5><p>以下是虚拟Zylmon项目的样本受众分析：</p>
<p>Zylmon项目的目标受众包括以下角色：</p>
<ul>
<li>软件工程师</li>
<li>技术产品经理</li>
</ul>
<p>目标受众在以下方面有相近的知识：</p>
<ul>
<li>我的目标受众已经知道Zyljeune API，它们与Zylmon API有点相似。</li>
<li>我的目标读者知道C ++，但通常没有在新的Winged Victory开发环境中构建C ++程序。</li>
<li>我的目标受众是大学里的线性代数，但团队的许多成员都需要复习矩阵乘法。</li>
</ul>
<h4 id="确定受众可以学到什么"><a href="#确定受众可以学到什么" class="headerlink" title="确定受众可以学到什么"></a>确定受众可以学到什么</h4><p>写下目标受众学习以实现目标所需的一切清单。在某些情况下，列表应包含目标受众需要执行的任务。例如：</p>
<p>阅读文档之后，受众将知道如何执行以下任务：</p>
<ul>
<li>使用Zylmon API按价格列出酒店。</li>
<li>使用Zylmon API可以按位置列出酒店。</li>
<li>使用Zylmon API通过用户评分列出酒店。</li>
</ul>
<p>请注意，您的受众有时必须按一定顺序完成任务。例如，您的受众可能需要在学习如何编写特定类型的程序之前，先学习如何在新的开发环境中构建和执行程序。</p>
<p>如果您正在编写设计规范，那么您的列表应该关注目标受众应该学习的信息，而不是精通特定任务：例如：</p>
<p>阅读设计规范后，受众将学到以下内容：</p>
<ul>
<li>Zylmon胜过Zyljeune的三个原因。</li>
<li>Zylmon花了5.25个工程年来开发的五个原因。</li>
</ul>
<h4 id="使文档适合受众"><a href="#使文档适合受众" class="headerlink" title="使文档适合受众"></a>使文档适合受众</h4><p>满足受众需求的写作需要无私的同理心。您必须创建满足受众好奇心而不是您自己的解释。为了使文档适合受众，您如何跳出自己的脚步？不幸的是，我们无法提供简单的答案。但是，我们可以提供一些要重点关注的参数。</p>
<h5 id="词汇和概念"><a href="#词汇和概念" class="headerlink" title="词汇和概念"></a>词汇和概念</h5><p>使您的词汇与受众匹配。请参阅<a href="https://docs.google.com/document/d/16aoMrMGHPIR1i_eUNRvksdDdwcDG6KiOJN6Vfh-n8-s/edit#heading=h.j6q144iyxgk4" target="_blank" rel="noopener">单词</a>以获取帮助。</p>
<p>注意亲近。您团队中的人员可能理解您团队的缩写，但是，其他团队中的人员是否也理解相同的缩写？随着目标受众的扩大，假设您必须进行更多说明。</p>
<p>同样，软件团队中经验丰富的人员可能了解团队项目的实施细节和数据结构，但几乎其他所有人（包括团队的新成员）都不了解。除非您是专门为团队中其他经验丰富的成员撰写的，否则通常您必须解释的内容超出了您的预期。</p>
<h5 id="知识的魔咒"><a href="#知识的魔咒" class="headerlink" title="知识的魔咒"></a>知识的魔咒</h5><p>专家经常遭受知识的魔咒，也就是说，他们对主题的专业理解破坏了对新手的解释。作为专家，很容易忘记新手不知道您已经知道的知识。新手可能不理解解释，而这些解释需要专家们不停地用和各种引用以及更深的知识来进行各种解释。</p>
<p>从新手的角度来看，知识的磨咒就好是由于模块尚未编译而导致的“找不到文件”链接器错误。</p>
<h5 id="简单的话"><a href="#简单的话" class="headerlink" title="简单的话"></a>简单的话</h5><p>英语已经成为全球技术交流的主要语言。但是，英语并不是大多数技术读者的母语。因此，更喜欢简单的单词而不是复杂的单词。避免使用奥术，过时或过于复杂的英语单词； <a href="https://www.google.com/search?q=sesquipedalian" target="_blank" rel="noopener">倍半数</a> 和稀有词会排斥大多数读者。</p>
<h5 id="文化中立和成语"><a href="#文化中立和成语" class="headerlink" title="文化中立和成语"></a>文化中立和成语</h5><p>使您的作品保持文化中立。不需要读者了解NASCAR，板球或相扑的复杂性，以了解某个软件的工作原理。例如，下面的句子（加上像苹果派一样的美国人的棒球比喻）可能会使某些巴黎读者感到困惑：</p>
<p>If Frambus 5.0 was a solid single, Frambus 6.0 is a stand-up double.</p>
<p><strong>习惯用语</strong>是短语，其整体含义不同于该短语中各个单词的字面含义。例如，以下短语是成语：</p>
<ul>
<li>a piece of cake</li>
<li>Bob’s your uncle</li>
</ul>
<p>蛋糕？鲍勃？大多数美国读者都认可第一个习惯用法。大多数英国读者都认可第二种成语。如果您是专门为英国观众写的书，那么 鲍勃的叔叔 就可以了。但是，如果您要为国际读者写作，那么用此任务替换该惯用法很容易。</p>
<p>习语在我们的演讲中根深蒂固，以至于习语的特殊非文字含义对我们来说是不可见的。也就是说，习语或成语是知识魔咒的另一种形式。</p>
<p>请注意，受众中的某些人使用翻译软件来阅读您的文档。比起简单朴素的英语，翻译软件往往在文化参考和习语方面很无力。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>你可以写句子。您可以编写段落。但是，您可以将所有这些段落组织到一个连贯的文档中吗？</p>
<h4 id="说明文件范围"><a href="#说明文件范围" class="headerlink" title="说明文件范围"></a>说明文件范围</h4><p>一个好的文档首先要定义其范围。例如：</p>
<p>本文档描述了Project Frambus的总体设计。</p>
<p>更好的文档还定义了未覆盖的范围，即目标读者可能希望文档涵盖但是文档并没有未涵盖主题。例如：</p>
<p>本文档未介绍相关技术Froobus项目的设计。</p>
<p>这些作用域和非作用域语句不仅使读者受益，而且使作者（您）受益。在编写时，如果文档的内容偏离范围声明，则必须重新调整文档的范围或修改范围声明。在查看初稿时，请删除（或分支到另一个文档）任何不利于满足范围说明的部分。</p>
<h4 id="陈述你的受众"><a href="#陈述你的受众" class="headerlink" title="陈述你的受众"></a>陈述你的受众</h4><p>好的文档明确指定了它的受众。例如：</p>
<p>我为支持Project Frambus的测试工程师编写了此文档。</p>
<p>除了受众的角色之外，良好的受众声明还可以指定任何必备的知识或经验。例如：</p>
<p>本文档假定您了解矩阵乘法以及如何冲泡一杯真正好的茶。</p>
<p>在某些情况下，受众声明还必须指定先决条件文件。例如：</p>
<p>在阅读本文档之前，您必须阅读“ Project Froobus：A New Hope”。</p>
<h4 id="预先建立关键观点"><a href="#预先建立关键观点" class="headerlink" title="预先建立关键观点"></a>预先建立关键观点</h4><p>工程师和科学家们很忙，他们不一定会阅读您全部76页的设计文档。想象一下，您的同龄人可能只会阅读第一页的第一段。在查看文档时，请确保文档的开头回答了读者的基本问题。</p>
<p>专业作家将大量精力放在第一页上，以增加读者进入第二页的几率。但是，任何长文档的第一页都是最难写的页面。因此，准备好多次修改页面。</p>
<p>始终为长的工程文档写一份总结性摘要（TL; DR）。尽管这个摘要必须非常简短，但是应该花很多时间来编写它。无聊或令人困惑的执行摘要是一个危险信号，会让你的读者直接你的文档丢到垃圾桶。</p>
<h4 id="为受众写作"><a href="#为受众写作" class="headerlink" title="为受众写作"></a>为受众写作</h4><p>本课程反复强调定义受众的重要性。在本节中，我们将重点放在受众定义上，以将其组织为文档。</p>
<h5 id="定义受众"><a href="#定义受众" class="headerlink" title="定义受众"></a>定义受众</h5><p>回答以下问题有助于您确定文档应包含的内容：</p>
<ul>
<li>谁是您的目标受众？</li>
<li>您的读者在阅读文档之前已经知道什么？</li>
<li>您的读者在阅读您的文档后应该知道或能够做什么？</li>
</ul>
<p>例如，假设您已经发明了一种新的排序算法。以下列表包含对以上问题的一些潜在答案：</p>
<ul>
<li><p>我的目标受众是组织中的所有软件工程师。</p>
</li>
<li><p>我的大多数目标受众在学校期间都学习了排序算法。但是，多年以来，大约有25％的目标受众尚未实现或评估排序算法。</p>
</li>
<li><p>阅读此文档后：</p>
</li>
<li><ol>
<li>读者知道该算法如何工作。</li>
<li>读者可以用所需的语言来实现算法。</li>
<li>读者知道在什么情况下该算法要优于流行的快速排序算法。</li>
<li>读者了解某些情况下的性能下降。</li>
</ol>
</li>
</ul>
<h5 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h5><p>定义受众之后，整理文档以提供读者在阅读文档后应该知道或能够做的事情。例如，文档的大纲可能如下所示：</p>
<ol>
<li><p>算法概述</p>
</li>
<li><ol>
<li>Big O 复杂度</li>
<li>用伪代码实现</li>
</ol>
</li>
<li><p>用C语言实现的示例</p>
</li>
<li><ol>
<li>使用其他语言实现的提示</li>
</ol>
</li>
<li><p>更深入的算法分析</p>
</li>
<li><ol>
<li>最佳数据集</li>
<li>边界案例问题</li>
</ol>
</li>
</ol>
<p>此外，使用受众群体定义可帮助您选择编写文档的正确方法。例如，目标受众研究了排序算法，但是大约四分之一的受众可能不记得不同算法的细节。因此，您的文档可能应该插入指向 quicksort 的现有教程的链接，而不是试图解释 quicksort。</p>
<h4 id="将主题分为几个部分"><a href="#将主题分为几个部分" class="headerlink" title="将主题分为几个部分"></a>将主题分为几个部分</h4><p>您将代码模块化为文件，类和方法。模块化代码更易于阅读，理解，维护和重用。使您的文档模块化可为您带来相同的好处。您可能对代码中的功能模块化有很强的直觉，但是如何将这些原理应用于您的写作中？</p>
<p>想象一下，您有一个空罐子，需要把一大堆岩石，粗砂砾和沙子打包。您将如何打包它们以确保可以将所有物料放入罐子中？当然，您需要先放置大石头，然后倒入砾石中，然后用沙子填充剩余的空气空间。如果尝试以相反的顺序执行此操作，则将失败。</p>
<p>读者的头很像一个空罐子，您的信息通常分为三种大小：岩石，砾石和沙子。断面是岩石。您需要用石头来构造读者的罐头内部的空间，以接受其余信息。</p>
<p>但是，您如何确定什么是大石头而不是砾石？一种策略是在短时间内（可能只有2到5分钟）记录自己谈论或随意写的话题。是的，这需要一定的纪律。以测试您会产生了什么内存。你做了以下的事了吗？</p>
<ul>
<li>用模糊不清的方式描述概念？</li>
<li>列出您的受众需要完成的步骤才能达到目标？</li>
<li>描述系统可以表达的属性的排列？</li>
</ul>
<p>您所指的未指定内容可能是构成主题的大型概念。如果您的演讲没有做到这一点，请返回并尝试这种结构。</p>
<h3 id="标点（可选）"><a href="#标点（可选）" class="headerlink" title="标点（可选）"></a>标点（可选）</h3><h4 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h4><p>编程语言强制执行有关标点的明确规则。相反，在英语中，有关逗号的规则有些模糊。作为指导，在读者自然会在句子中某处停顿的地方插入逗号。用音乐上来做类比，如果句号是整个音符的休止符，那么逗号可能是半音符或四分音符的休止符。换句话说，逗号的暂停要短于一段时间。例如，如果您大声阅读以下句子，则可能会在单词 <em>just</em> 之前短暂停留：</p>
<p>C behaves as a mid-level language, just a couple of steps up in abstraction from assembly language.</p>
<p>有些情况下需要逗号。例如，使用逗号分隔嵌入式列表中的项目，如下所示：</p>
<p>我们公司使用C++，Python，Java和JavaScript。</p>
<p>您可能想知道列表的最终逗号，该逗号插入在项目N-1和N之间。该逗号（称为<strong>串行逗号</strong>或<strong>牛津逗号）是</strong>有争议的。我们建议仅提供最后一个逗号，因为技术写作需要选择最不明确的解决方案。也就是说，我们实际上更喜欢通过将嵌入列表转换为项目符号列表来规避争议。</p>
<p>在表达条件的句子中，在条件和结果之间放置逗号。例如，以下两个句子在正确的位置提供逗号：</p>
<p>If the program runs slowly, try the –perf flag.</p>
<p>If the program runs slowly, then try the –perf flag.</p>
<p>您还可以在一对逗号之间进行快速定义或离题，如以下示例所示：</p>
<p>Python, an easy-to-use language, has gained significant momentum in recent years.</p>
<p>最后，避免使用逗号将两个独立的想法粘贴在一起。例如，以下句子中的逗号是被称为<strong>逗号拼接</strong>的标点重罪：</p>
<p>萨曼莎（Samantha）是一位出色的编码员，她编写了大量测试。</p>
<p>使用句号而不是逗号来分隔两个独立的思想。例如：</p>
<p>萨曼莎（Samantha）是一位出色的编码员。她写了大量的测试。</p>
<h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>一个时期将不同的思想分开；分号统一了高度相关的思想。例如，请注意以下句子中的分号如何结合了第一和第二个想法：</p>
<p>更新配置文件后，重新运行Frambus；更新现有源代码后，请勿重新运行Frambus。</p>
<p>分号之前和之后的思想必须全部是语法完整的句子。例如，以下分号是错误的，因为分号后面的段落不是完整的句子：</p>
<p>Rerun Frambus after updating your configuration file; not after updating existing source code.</p>
<p>在使用分号之前，请先问问自己，如果您将思想转到分号的相对两侧，该句子是否仍然有意义。例如，反转前面的示例仍会产生一个有效的句子：</p>
<p>Don’t rerun Frambus after updating existing source code; rerun Frambus after updating your configuration file.</p>
<p>您几乎应该始终使用逗号（而不是分号）来分隔嵌入列表中的项目。例如，以下分号的使用是不正确的：</p>
<p>Style guides are bigger than the moon; more essential than oxygen; and completely inscrutable.</p>
<p>许多句子在分号后立即放置过渡词或短语。在这种情况下，请在转换后放置逗号。请注意以下两个示例中过渡后的逗号：</p>
<p>Frambus provides no official open source package for string manipulation; however<strong>,</strong> subsets of string manipulation packages are available from other open source projects.</p>
<p>Even seemingly trivial code changes can cause bugs; therefore<strong>,</strong> write abundant unit tests.</p>
<h4 id="破折号"><a href="#破折号" class="headerlink" title="破折号"></a>破折号</h4><p>破折号是引人注目的标点符号，具有丰富的标点符号可能性。破折号比逗号表示更长的暂停（更大的中断）。如果逗号是四分音符休止符，则破折号是半音符休止符。例如：</p>
<p>C++ is a rich language—one requiring extensive experience to master.</p>
<p>编写者有时使用一对破折号来阻止题外话，如以下示例所示：</p>
<p><strong>Protocol Buffers</strong>—often nicknamed <strong>protobufs</strong>—encode structured data in an efficient yet extensible format.</p>
<p>我们可以在前面的示例中使用逗号而不是破折号吗？当然。为什么我们选择破折号而不是逗号？感觉。艺术。经验。请记住，英语的标点符号是糊状且具有延展性的。</p>
<h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>使用括号可以保留次要点和题外话。括号告诉读者，所附文字并不重要。</p>
<p>有关句号和括号的规则使许多写作者大跌眼镜。以下是标准：</p>
<ul>
<li>如果一对圆括号包含整个句子，则句号在右圆括号内。</li>
<li>如果一对括号使一个句子结尾但不包含整个句子，则句点就在右括号之外。</li>
</ul>
<p>例如：</p>
<p>(Incidentally, Protocol Buffers make great birthday gifts.)</p>
<p>Binary mode relies on the more compact native form (described later in this document).</p>
<h3 id="Markdown-（可选）"><a href="#Markdown-（可选）" class="headerlink" title="Markdown （可选）"></a>Markdown （可选）</h3><p><strong>Markdown</strong>是一种轻量级的标记语言，许多技术专业人员使用它来创建和编辑技术文档。使用Markdown，您可以在纯文本编辑器(如vi或Emacs)中编写文本，插入特殊字符来创建标题、加粗、项目符号等。例如，下面的示例显示了一个用Markdown格式化的简单技术文档</p>
<p>## bash and ksh</p>
<p><strong>bash</strong> closely resembles an older shell named <strong>ksh</strong>. The key</p>
<p><em>practical</em> difference between the two shells is as follows:</p>
<p>* More people know bash than ksh, so it is easier to get help for bash problems than ksh problems.</p>
<p>上述的文档会被渲染成如下的样子：</p>
<p><strong>bash and ksh</strong> <strong>bash</strong> closely resembles an older shell named <strong>ksh</strong>. The key <em>practical</em> difference between the two shells is as follows: More people know bash than ksh, so it is easier to get help for bash problems than ksh problems.</p>
<p>Markdown解析器将Markdown文件转换成HTML。然后，浏览器可以将生成的HTML显示给读者。我们建议您通过学习下面的教程来熟悉Markdown</p>
<ul>
<li><a href="https://www.markdowntutorial.com/" target="_blank" rel="noopener">www.markdowntutorial.com</a></li>
<li><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">Mastering Markdown</a></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>始终使用术语。</li>
<li>避免模棱两可的代词。</li>
<li>首选主动语态而不是被动语态。</li>
<li>选择强动词。</li>
<li>选择具体的动词而不是模糊的动词。</li>
<li>将每个句子聚焦在一个事上。</li>
<li>将一些长句子转换为列表。</li>
<li>消除不必要的单词。</li>
<li>如果次序重要，请使用编号列表；与次序无关，则使用项目符号列表。</li>
<li>保持列表项的平行属行。</li>
<li>用祈使性单词开始编号的列表项。</li>
<li>正确地介绍列表和表格。</li>
<li>创建漂亮的开头句，以建立本段落的中心思想。</li>
<li>将每个段落集中在一个主题上。</li>
<li>确定您的受众需要学习的内容和目标。</li>
<li>让文档贴近您的受众。</li>
<li>在文档开头处说明文档的主要观点。</li>
</ul>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="自我编辑"><a href="#自我编辑" class="headerlink" title="自我编辑"></a>自我编辑</h2><p>想象一下，您刚刚编写了文档的初稿。您如何做得更好？在大多数情况下，达到可最终发布的文档是一个反复迭代的过程。从零开始形成初稿通常是最困难的步骤。编写完初稿后，还要确保能留出大量时间来完善文档。</p>
<p>本章节中的编辑技巧可以帮助您将初稿转换为文档，从而更清晰地传达您的受众所需的信息。你可以使用其中的一个小或全部的技巧；但重要的是找到适合您的策略，然后将该策略作为写作日常的一部分。</p>
<p><strong>注意：</strong>本章节的技巧以技术写作一的基本写作和编辑技能为基础。本单元总结了该课程中有用的编辑技术。有关更详细的复习，请访问技术写作的第一部分 <a href="https://docs.google.com/document/d/16aoMrMGHPIR1i_eUNRvksdDdwcDG6KiOJN6Vfh-n8-s/edit#heading=h.zrd92of27j0" target="_blank" rel="noopener">自学单元</a>。</p>
<h3 id="采用样式指南"><a href="#采用样式指南" class="headerlink" title="采用样式指南"></a>采用样式指南</h3><p>公司，组织和大型开源项目经常采用已有的风格样式。<a href="https://developers.google.com/" target="_blank" rel="noopener">Google Developers</a>网站上的许多文档项目都遵循《 <a href="https://developers.google.com/style" target="_blank" rel="noopener">Google Developer文档样式指南》</a>。如果您以前从未使用过样式指南，那么乍一看，《 Google Developer文档样式指南》可能看起来有点吓人，它提供了有关语法，标点符号，格式设置和计算机接口文档等主题的详细指南。所以，您可能更喜欢从 《<a href="https://developers.google.com/style/highlights" target="_blank" rel="noopener">样式指南精要</a>》 开始。</p>
<p><strong>注意：</strong>对于较小的项目，例如团队文档或小型开源项目，《样式指南精要》已经够你用了。</p>
<p>精要内容中列出的一些准则在第一部分中有介绍。您应该可以回想起一些：</p>
<ul>
<li>使用<a href="https://developers.google.com/tech-writing/one/active-voice" target="_blank" rel="noopener">主动语态</a>来明确谁在执行操作。</li>
<li>将顺序步骤格式化为 <a href="https://developers.google.com/tech-writing/one/lists-and-tables" target="_blank" rel="noopener">编号列表</a>。</li>
<li>将其他列表格式化为项目符号列表。</li>
</ul>
<p>精要还介绍了许多其他技术，这些技术在编写技术文档时可能会有用，例如：</p>
<ul>
<li><a href="https://developers.google.com/style/person" target="_blank" rel="noopener">写第二人称</a>。将您的受众称为“您”而不是“我们”。</li>
<li><a href="https://developers.google.com/style/clause-order" target="_blank" rel="noopener">将条件子句放在指令之前</a>，而不是之后。</li>
<li>为与代码相关的文本格式设置<a href="https://developers.google.com/style/code-in-text" target="_blank" rel="noopener">代码字体</a>。</li>
</ul>
<h3 id="像受众一样思考"><a href="#像受众一样思考" class="headerlink" title="像受众一样思考"></a>像受众一样思考</h3><p>你的受众是谁？退后一步，尝试从他们的角度阅读草稿。确保文档的目的明确，并为读者可能不熟悉的任何术语或概念提供定义和解释。</p>
<p>给你的受众设置一个“人设”可能会对写作有所帮助。其中可以包含以下任何属性：</p>
<ul>
<li><p>角色，例如：系统工程师 或 <em>QA</em>测试人员。</p>
</li>
<li><p>最终目标，例如：还原数据库。</p>
</li>
<li><p>知识和经验的一组假设。例如，您可能假设您的“人设”是：</p>
</li>
<li><ul>
<li>熟悉Python。</li>
<li>运行Linux操作系统。</li>
<li>平时在命令行的环境工作。</li>
</ul>
</li>
</ul>
<p>然后，您可以模拟他们来阅读初稿。告诉受众您所做的任何假设可能特别有用。您还可以提供指向资源的链接，如果他们需要复习特定主题，他们可以在其中了解更多信息。</p>
<p>请注意，过分依赖角色（或两个角色）可能会导致文档过于狭窄而无法对大多数读者有用。</p>
<p>有关技术写作一的复习和更多信息，请参阅<a href="https://docs.google.com/document/d/16aoMrMGHPIR1i_eUNRvksdDdwcDG6KiOJN6Vfh-n8-s/edit#heading=h.lxllsbersc8a" target="_blank" rel="noopener">受众</a>自学单元。</p>
<h3 id="大声朗读"><a href="#大声朗读" class="headerlink" title="大声朗读"></a>大声朗读</h3><p>不同的上下文或写作风格可能会疏远、吸引甚至打扰你的受众。给定文档设定什么样的样式在一定程度上取决于受众。例如，旨在招募新志愿者的开放源项目贡献者指南可能采用更非正式和对话的风格，而商业企业应用程序的开发者指南则更可能采用更正式的风格。</p>
<p>要检查您的写作是否有对话性，请大声朗读。识别尴尬的措词，太长的句子或其他不自然的内容。另外，您也可以尝试请其他人为您朗读您的草稿。</p>
<p>有关调整写作风格以适合受众的更多信息，请参阅<a href="https://developers.google.com/style/tone" target="_blank" rel="noopener">样式和作者语气</a>。</p>
<h3 id="稍后再回来"><a href="#稍后再回来" class="headerlink" title="稍后再回来"></a>稍后再回来</h3><p>在您编写了第一稿（或第二稿或第三稿）之后，请将其放在一边。一小时（或两到三个）后再回来阅读，这样在阅读时会有新鲜感。于是，您几乎总是会注意到一些可以改进的地方。</p>
<h3 id="改变场景"><a href="#改变场景" class="headerlink" title="改变场景"></a>改变场景</h3><p>一些写作者喜欢打印他们的文档，并且手里拿着一支红色铅笔，查看纸质的文档副本。这种换一种场景来审阅自己的作品时，可以帮助您找到需要改进的地方。如果要使这个经典技巧更富现代感，你可将文稿复制到其他文档中并更改字体，大小和颜色。</p>
<h3 id="寻找同伴编辑"><a href="#寻找同伴编辑" class="headerlink" title="寻找同伴编辑"></a>寻找同伴编辑</h3><p>就像工程师需要同伴人审查他们的代码一样，写作者也需要其他编辑者来向他们提供有关文档的反馈。请他人来审阅您的文档，并给您具体的建设性意见。您的同伴编辑者不必是文档技术主题的主题专家，但他们确实需要熟悉您遵循的样式指南。</p>
<h2 id="组织大型文档"><a href="#组织大型文档" class="headerlink" title="组织大型文档"></a>组织大型文档</h2><p>您如何将大量信息归并到一整个文档或网站中？或者说，您如何将现有的混乱文档或网站重组为平易近人且有用的工具？以下策略可以帮助您：</p>
<ul>
<li>整理组织文档</li>
<li>添加导航</li>
<li>逐步展开信息</li>
</ul>
<h3 id="什么时候写大文档"><a href="#什么时候写大文档" class="headerlink" title="什么时候写大文档"></a>什么时候写大文档</h3><p>您可以将一组信息组织成较长的单一文档或一组较短的相关文档。一组较短的相互关联的文档通常以网站，Wiki或类似结构化格式发布。</p>
<p>有些读者比其他人来说更喜欢长文档。对此，对于这两类的读者，他们会有如下的搜索行为：</p>
<ul>
<li>Hong发现阅读长文件很困难并且迷失方向。他更喜欢使用站点搜索来找到问题的答案。</li>
<li>Rose更喜欢单一的长文档。她经常使用Web浏览器中的内置页面搜索功能在当前页面上找到有用的信息。</li>
</ul>
<p>那么，您应该将材料组织成一个文档还是网站中的一组文档？请考虑以下准则：</p>
<ul>
<li>当针对刚接触该主题的读者时，How-to操作指南，入门介绍性的概述和概念指南通常以较短的文档出现时，会更好地发挥作用。例如，对于您的主题完全陌生的读者可能很难记住很多新的术语，概念和事实。请记住，您的受众阅读您的文档的目的可能是想以最快的速度来全面地了解该主题。</li>
<li>深入的教程，最佳实践指南和命令行参考页可以以长文档的方式出现，尤其是针对那些已经对工具和主题有一定经验的读者。</li>
<li>出色的教程一般可以依靠叙述的方式来引导读者完成较长文档中的一系列相关任务。但是，即使是大型教程，很多时候分割成较小的部分会更好。</li>
<li>许多较长的文档并非连续阅读。例如，用户通常浏览参考页面以搜索某个命令的参数或标志的说明。</li>
</ul>
<p>本章节的其余部分介绍了可用于编写较长文档的技术，例如教程和一些概念性指南。</p>
<h3 id="整理文件"><a href="#整理文件" class="headerlink" title="整理文件"></a>整理文件</h3><p>本节提出了一些准备写长文档的技术，包括创建大纲和起草引言。在完成文档的初稿之后，可以根据您的概述和简介对其进行复审，以确保您没有错过任何本来打算涵盖的内容。</p>
<h4 id="文档大纲"><a href="#文档大纲" class="headerlink" title="文档大纲"></a>文档大纲</h4><p>从结构化的高层级的大纲开始，可以帮助您对相关的主题进行分组并确定哪里需要更多详细信息。大纲可帮助您在开始写作之前就先讨论主题。</p>
<p>您可能会发现将大纲视为文档的叙述很有用。这世上还没有一个编写大纲的标准方法，但是以下准则提供的实用技巧可能会对您有帮助：</p>
<ul>
<li><p>在要求读者执行任务之前，请向他们解释为什么要执行任务。例如，以下要点说明了本教程中有关审核和改善网页可访问性的部分大纲：</p>
</li>
<li><ul>
<li>介绍浏览器插件；说明我们将使用审计报告的结果来修复一些错误。</li>
<li>列出运行插件和审计网页可访问性的步骤。</li>
</ul>
</li>
<li><p>将大纲的每个步骤限制为，描述概念或完成特定任务。</p>
</li>
<li><p>结构化大纲，以便文档在与读者最相关的时候才引入相关的信息。例如，当您的读者刚开始使用基础知识时，他们可能不需要在文档的简介部分中了解（或想要了解）项目的历史。如果您觉得项目的历史记录很有用，请在文档末尾添加指向此类信息的链接。</p>
</li>
<li><p>在概念性信息和实际步骤之间交替的文档可能是一种特别吸引人的学习方式。考虑解释一个概念，然后说明读者如何将其应用于示例项目或自己的工作中。</p>
</li>
<li><p>如果您要与将要审阅和测试文档的贡献者团队合作，则提纲特别有用。在开始写文档之前，请与您的撰稿人分享您的大纲，看看他们是否有任何建议。</p>
</li>
</ul>
<h4 id="大纲练习"><a href="#大纲练习" class="headerlink" title="大纲练习"></a>大纲练习</h4><p>对于本练习，请查看并更新以下长篇教程简介的高层级大纲。您可以重新排列，添加和删除主题。</p>
<p>##项目的历史</p>
<p>描述该项目的发展历史。</p>
<p>##先决条件</p>
<p>列出读者在开始之前应熟悉的概念，以及任何软件或硬件要求。</p>
<p>##系统设计</p>
<p>描述系统如何工作。</p>
<p>##受众</p>
<p>描述本教程的目标对象。</p>
<p>##设置教程</p>
<p>解释如何配置环境以跟进本教程。</p>
<p>## 故障排除</p>
<p>说明在实践本教时如何诊断并解决在以下情况下可能发生的潜在问题。</p>
<p>##有用的术语</p>
<p>列出读者需要遵循的术语定义教程。</p>
<p>以下是一种可能的解决方案：</p>
<p>##观众</p>
<p>描述了本教程的目标读者。</p>
<p>##先决条件</p>
<p>列出了读者在开始之前应熟悉的概念以及</p>
<p>所有软件或硬件要求。</p>
<p>##设置本教程</p>
<p>介绍如何配置您的环境以遵循本教程。</p>
<p>##有用的术语</p>
<p>列出了读者阅读本</p>
<p>教程需要了解的术语定义。</p>
<h4 id="介绍文档"><a href="#介绍文档" class="headerlink" title="介绍文档"></a>介绍文档</h4><p>如果文档的读者找不到与该主题相关的内容，则他们基本上会忽略这个文档。要为您的用户设置基本规则，建议您提供一个包含以下信息的简介：</p>
<ul>
<li>文档涵盖的内容。</li>
<li>您希望读者具备哪些先验知识。</li>
<li>该文件未涵盖的内容。</li>
</ul>
<p>请记住，您想使文档易于维护，因此请勿尝试介绍中的所有内容。</p>
<p>下面的段落演示了前面列表中的思想，作为一个名为Froobus的假设文档发布平台的概述：</p>
<p>本文档说明了如何使用Froobus系统发布Markdown文件。</p>
<p>Froobus是一个运行在Linux服务器上的将Markdown文件转成HTML页面的发布系统。</p>
<p>本文档适用于熟悉Markdown语法。要了解语法，请参阅 Markdown 参考。您还需要了解在</p>
<p>Linux终端下的一些命令。</p>
<p>本文档不包含有关安装或配置Froobus发布系统的内容。有关Froobus的安装，请参阅使用入门手册。</p>
<p>完成初稿后，请对照概述中设置的期望检查整个文档。您的简介是否提供您所涵盖主题的准确概述？您可能会发现把这种审核认为是文档的质量保证（QA）是很有效的。</p>
<h4 id="介绍练习"><a href="#介绍练习" class="headerlink" title="介绍练习"></a>介绍练习</h4><p>对于本练习，请查看并修订以下介绍，以获取一种称为F@的假设编程语言的最佳实践指南。删除您认为与此无关的任何信息，并添加您认为丢失的任何信息。</p>
<p>本指南列出了使用F@编程语言的最佳实践。</p>
<p>F@是在2011年开发的一个开源社区项目。本指南提供了F@的代码风格指南。除了本指南中的最佳实践之外，确保您已安装并运行F@命令行Linter。该编程语言在健康行业中被广泛采用。</p>
<p>如果你有有关最佳做法列表的补充建议，请到F@的github上给我们开issue。</p>
<p>​    以下是一种可能的修改：</p>
<p>本指南列出了使用F@编程语言的最佳实践。</p>
<p>在阅读本指南之前，请先完成F@开发人员的入门教程。本指南提供了F@代码风格指南。除了</p>
<p>本指南中的最佳实践之外，确保您已安装并运行F@命令行Linter。</p>
<p>如果你有有关最佳做法列表的补充建议，请到F@的github上给我们开issue。</p>
<h3 id="添加导航"><a href="#添加导航" class="headerlink" title="添加导航"></a>添加导航</h3><p>为读者提供导航和路标，可确保他们能够找到所需的内容以及不需要的信息。</p>
<p>清晰的导航包括：</p>
<ul>
<li>简介和摘要部分</li>
<li>一个清晰有逻辑的主题</li>
<li>有助于用户理解主题的标题和副标题</li>
<li>介绍该工具的概述</li>
<li>目录菜单，向用户显示他们在文档中的位置</li>
<li>链接到相关资源或更深入的信息</li>
<li>链接到下一步学习</li>
</ul>
<p>以下各节中的技巧可以帮助您写出不错文档标题。</p>
<h4 id="首选基于任务的标题"><a href="#首选基于任务的标题" class="headerlink" title="首选基于任务的标题"></a>首选基于任务的标题</h4><p>选择描述您的读者正在从事的任务的标题。避免使用不熟悉的术语或工具的标题。例如，假设您正在写创建新网站的过程。要创建站点，读者必须初始化Froobus框架。要初始化Froobus框架，必须运行 carambola 命令行工具。乍一看，在说明中添加以下任一标题似乎合乎逻辑：</p>
<ul>
<li>运行carambola命令</li>
<li>初始化Froobus框架</li>
</ul>
<p>除非您的读者已经非常熟悉该主题的术语和概念，否则最好使用更熟悉的标题，例如“ 创建站点<em>”</em>。</p>
<h4 id="在每个标题下提供文字"><a href="#在每个标题下提供文字" class="headerlink" title="在每个标题下提供文字"></a>在每个标题下提供文字</h4><p>大多数读者至少喜欢在每个标题下进行简短介绍以提供一些背景信息。避免在第二级标题之后放置三级标题，如以下示例所示：</p>
<p>##创建网站</p>
<p>###运行carambola命令</p>
<p>在此示例中，简要介绍可以帮助读者确定方向：</p>
<p>##创建网站</p>
<p>要创建站点，请运行<code>carambola</code>命令行工具。该命令会显示一系列提示，以帮助您配置站点。</p>
<p>###运行carambola命令</p>
<h4 id="标题练习"><a href="#标题练习" class="headerlink" title="标题练习"></a>标题练习</h4><p>帮助读者浏览您的文档可帮助他们找到成功使用您的工具所需的信息。通常，清晰，井井有条的目录或大纲就像地图一样，可以帮助用户导航工具的功能。</p>
<p>对于本练习，请改进以下大纲。您可以重新排列，添加和删除主题，也可以创建辅助条目。</p>
<p>关于本教程</p>
<p>进阶主题</p>
<p>建立资产导航树</p>
<p>定义资源路径</p>
<p>定义和建设项目</p>
<p>启动开发环境</p>
<p>定义和建设资源</p>
<p>下一步是什么</p>
<p>定义图像资源</p>
<p>受众</p>
<p>参考</p>
<p>建立图像资源</p>
<p>定义图像项目</p>
<p>建立影像专案</p>
<p>设置教程</p>
<p>选择教程资产根</p>
<p>关于本指南</p>
<p>以下是一种可能的修改：</p>
<p>##关于本教程</p>
<p>###受众</p>
<p>###关于本指南</p>
<p>###高级主题</p>
<p>##设置本教程</p>
<p>###选择本教程根目录</p>
<p>###启动开发环境</p>
<p>###构建资产导航树</p>
<p>###定义资源路径</p>
<p>##定义和构建资源</p>
<p>###定义图像资源</p>
<p>###构建图像资源</p>
<p>##定义和构建项目</p>
<p>###定义图像项目</p>
<p>###构建图像项目</p>
<p>##定义和构建数据库</p>
<p>###定义数据库</p>
<p>###建立数据库</p>
<p>##推送，发布和查看数据库</p>
<p>###推送数据库</p>
<p>###发布数据库</p>
<p>###查看数据库</p>
<p>##配置“点数据”的显示规则</p>
<p>###定义，配置和构建矢量数据</p>
<p>##另请参阅</p>
<p>###示例数据文件</p>
<p>##下一步做什么</p>
<h3 id="循序递近"><a href="#循序递近" class="headerlink" title="循序递近"></a>循序递近</h3><p>对于许多乐于按自己的节奏阅读文档的读者而言，学习新的概念，想法和技术是一个有益的体验。但是，过快地面对太多新概念和说明可能会令人不知所措。读者很可能会接受较长的文档的形是，文档会逐步地在需要的时候层层递近。以下技术可以帮助您写出这样的层层递进的文档：</p>
<ul>
<li>尽可能地，在需要用到的地方引入新的术语和概念。</li>
<li>分解大块文字。为了避免在一个页面上出现多个较大的段落，请在适当的地方引入表格，图表，列表和标题。</li>
<li>分解大量步骤。如果您的复杂步骤列表特别长，请尝试将它们重新排列为较短的列表，以解释如何完成子任务。</li>
<li>从简单的示例和说明开始，然后逐步添加更多有趣和复杂的技术。例如，在创建表单的教程中，首先说明如何处理文本响应，然后介绍其他技术来处理多个选择，图像和其他响应类型。</li>
</ul>
<h2 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h2><p>还记得老师给您分配的阅读篇章吗？您翻阅了教科书的指定部分，非常希望…是的，图片！查看插图比阅读文本有趣得多。实际上，在阅读技术资料时，绝大多数成年人还是小孩，他们仍然渴望图片而不是文字。</p>
<p><img src="../images/jE6R_7ISrWtAcm5rnEX7JgrrX-YzwtIqsSWqcFRr9P6raZxlIdkYNlRDwKoU0-i-LIafqfR_Se1pq__H-81I3C4gEMNcOgNoZ1m6S9bGlhMEen2lhOMORpJUae2tdt8LaoXJgxfo-20200314140000135.jpeg" alt="三个孩子指着这些图片时读了一本书。"></p>
<p><strong>图**</strong>1.<strong>**良好的图片以文本无法不可比拟的方式吸引读者。</strong></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Nepalese_Children.JPG" target="_blank" rel="noopener">Nirmal Dulal [CC BY-SA 4.0（https://creativecommons.org/licenses/by-sa/4.0）]</a></p>
<p>根据<a href="https://www.sciencedirect.com/science/article/pii/S0747563212000921" target="_blank" rel="noopener">Sung和Mayer（2012）的研究</a>，提供任何图片（无论好坏）都会使读者更喜欢该文档。但是，只有教育性的 图片才能帮助读者学习。本章节提供了几种方法来帮助您创建真正胜过千言的图示。</p>
<h3 id="首先写标题"><a href="#首先写标题" class="headerlink" title="首先写标题"></a>首先写标题</h3><p>通常，在创建插图之前写标题会很有帮助。然后，创建最能说明标题的插图。此过程可帮助您检查插图是否符合目标。</p>
<p>好的标题具有以下特征：</p>
<ul>
<li>他们很<strong>简短</strong>。通常，标题只是几个单词。</li>
<li>他们解释了<strong>要点</strong>。查看此图形后，读者应该记住什么？</li>
<li>他们<strong>聚焦</strong>读者的注意力。当照片或图表包含很多细节时，聚焦尤其重要。</li>
</ul>
<p>示例：</p>
<p>目标受众：CS本科生参加“数据结构入门”课程。</p>
<p>考虑以下三个图形，每个图形使用相同的标题。</p>
<p><img src="../images/n2VrvJB3FR75g6ZAy8tYZQLwRdU4IXSo5kVAiYEupjAz3750NR8Fpgk9s6aKGB2bmiS2mls4mRQIYsf-B51dO3dfuM1RANyADpjALmHeH94GC0lh-XzDjmXrTbsrPqfyWEl1h76J-20200314135944582.png" alt="img"></p>
<p><strong>标题**</strong>A<strong>**。单向链表包含内容和指向下一个节点的指针。</strong></p>
<p><img src="../images/D6dcerQce7rgaGRG_YafpEK8gH1CAWTiY91CunUMVHiB_D3YWT4cHM7QqQD-Oi0XKTEbmVYW3AtavR_jh6bgUqTe_08phRnvnR2Zy_dxTEj-vmbjKeC-WxEhvGWIztIrx-6-tFd_-20200314140016480.png" alt="用三个箭头连接的四个盒子"></p>
<p><strong>标题**</strong>B<strong>**。单向链表包含内容和指向下一个节点的指针。</strong></p>
<p><img src="../images/O8QRqho8LjEXTIF5hbiK31kBDFwQpeTMvyAwFcVxUoRrVjY3n6KQl4wNY25H6As1M9YvuaP0_jGHlD1Z8ELWIDGRTw1ZtJ03_bYuad-yRyPq5ifK91kCjP_AXqPyLox9zj1tD3xi-20200314140024181.png" alt="img"></p>
<p><strong>标题**</strong>C<strong>**。单向链表包含内容和指向下一个节点的指针。</strong></p>
<p>前三个图中的哪一个最能说明其标题？</p>
<ul>
<li>图A很糟糕。链条很漂亮，但是没有信息。链还错误地暗示了一个单链表同时指向向后和向前。</li>
<li>图B是可以的。这个插图帮助学生认识到第一项指向第二项，第二项指向第三项，以此类推。但是，虽然标题同时引用了<strong><em>内容</em></strong>和<strong><em>指针</em></strong>，但是插图显示的是指针，而不是内容。</li>
<li>图C是最好的、最有启发意义的选择。插图清楚地描述了每个节点的内容部分和指针部分。</li>
</ul>
<h3 id="限制单个图片中的信息量"><a href="#限制单个图片中的信息量" class="headerlink" title="限制单个图片中的信息量"></a>限制单个图片中的信息量</h3><p>很少的智力工作可以像学习一幅精美的画作一样有收获，它逐渐揭示了洞察力和意义。人们为在世界艺术博物馆中做到这一点付出了很多钱。</p>
<p><img src="../images/yaRvvgA5PXE6Ew63bb-wgKN2_65DgQL-scySq9rdBLEa8489yPhaY6hagxfP6VnIanEEX-1zSkwZhO3hq82t7qeZPHJAK43TmCqoSCBHVAqoNpg1i-qhKQRLzMDFnBJyrjv-MBNw-20200314140036522.jpeg" alt="Pere Tanguy的画像，作者Vincent van Gogh-罗丹博物馆，公共领域，https：//commons.wikimedia.org/w/index.php？curid = 119599"></p>
<p><strong>图**</strong>2.<strong>**您会很高兴研究梵高的这幅画。</strong></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Van_Gogh_-_Portrait_of_Pere_Tanguy_1887-8.JPG" target="_blank" rel="noopener">Pere Tanguy的画像，文森特·梵高-罗丹博物馆[公共领域]</a></p>
<p>相比之下，如下所示的高度复杂的技术插图往往会阻止大多数读者：</p>
<p><img src="../images/48v7yt9pVjD6rlZzFOjMML79V7Bx5xLvZG94Q35d375Nyp_Gjc4nVUWxnmITLDPpKM5cmrpN1_Tj-ui6Gl7E8BMZt3Ei-At6VRjl3P9OYDAkuzySTagGqNcXuPNrMAlsayQCFmMQ-20200314140049461.png" alt="img"></p>
<p><strong>图**</strong>3.<strong>**复杂的框图使读者不知所措。</strong></p>
<p>就像您避免过长的句子一样，也要努力避免视觉冲击。根据以往经验，不要在一个图表中放置超过一个段落的信息。（另一种经验法则是避免插图需要五个以上的无序列表来解释。）我听到您说：“但是，现实生活中的技术系统可能比图3所示的系统复杂得多。” 您是对的，但是您可能不会觉得要在单个段落中解释这个复杂的系统。</p>
<p>将视觉混乱变成连贯且有用的东西的诀窍是将复杂的系统组织成子系统，如下图所示：</p>
<p><img src="../images/Yeyo20lvR4xle9wsHUuSRWJR_Xdh3Ig_bWvBkvFub6-2jHAs-Jg9e6CNQIf73mIVNHB8GQBP7s_t1JyB8D1qJOjq1NqjgGucfukUGfuR6tGmNq-0B80Gtm9iqpAs1dXCofsUDZo9-20200314140059131.png" alt="img"></p>
<p><strong>图**</strong>4.<strong>**分为三个子系统的复杂系统。</strong></p>
<p>显示“大图”之后，分别提供每个子系统的图示。</p>
<p><img src="../images/zeC0klriuJFNa_-cSgpsD8qZuYDOIBjT7SCwd3AZdhsyPoCJFdHLT7MeWr3k1rfRieIrTr_2JaVkmOz3eJdgI0vo6gpO-D9AHliITi8L8L0CQ91sBM8M3UnntuONbPxaIlwkklPp-20200314140107828.png" alt="img"></p>
<p><strong>图**</strong>5.<strong>**复杂系统的一个子系统的扩展细节。</strong></p>
<p>另外，可以从简单的“大图片”开始，然后在每个后续插图中逐步扩展细节。</p>
<h3 id="吸引读者的注意力"><a href="#吸引读者的注意力" class="headerlink" title="吸引读者的注意力"></a>吸引读者的注意力</h3><p>面对如下复杂的屏幕截图时，读者难以确定相关内容：</p>
<p><img src="../images/HajIj_VeHCkeZ97hmSxff8WcRnTFKXax3YkBFCMsZXrztnv3rjoXkS-a8BIynrjnEgsDBSMSdsa996evyJdAY7kLlMcDP9nlDpewVcXgE5dRPiwey2ZR-xmsMeCIjS86AOPnWhV8-20200314140117466.png" alt="三个块，每个块都有一个简单的标签"></p>
<p><strong>图**</strong>6.<strong>**读者不知道该关注什么。</strong></p>
<p>添加视觉提示，例如下图中的红色椭圆，可以帮助读者专注于屏幕截图的相关部分：</p>
<p><img src="../images/175ofZpKAWCFWKeFBTzgETTftuYjG8lIjLa0JG60njiuDciLbZFyzX7peMb_sWG-hqk1rA8NJN7jh6mwhU0w7gdqGP7g0M3DhH4PSkYMFIhhZ6rfd0RaFYVnHWni15-cC_PTxMnv-20200314140124914.png" alt="相同的屏幕截图，但其中一个菜单项用红色圈出"></p>
<p><strong>图**</strong>7.<strong>**读者会关注于破坏图案的形状。</strong></p>
<p><strong>标注</strong>提供了另一种吸引读者注意力的方法。对于图片和艺术线条，标注可以帮助我们的眼睛找到合适的落地位置。图片中的标注通常比图片的段落说明更好，因为标注将读者的注意力集中在图片的最重要的地方。然后，在您的解释中，您可以直接关注图表的相关部分，而不必花费时间描述您所讨论的图像的哪个部分。</p>
<p>在示例图像中，标注和箭头快速将读者引导至目标。</p>
<p><img src="../images/283dqnnnKtWlKVb68D3je8av_MxYUVZY1BDTTRXrrSU4gKoWUPAfoyGcx_BButTMCUu_CTSnuTzF1XFil_oi5zLzvTeK-D_WpLY8GgLB9neNR3xgUvr_yTRr3twRp5Q78SnN4LCK-20200314140141013.png" alt="img"></p>
<p><strong>图**</strong>8.<strong>**标注引导读者的视线。</strong></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Phobos_colour_2008.jpg" target="_blank" rel="noopener">NASA / JPL-Caltech /亚利桑那大学[公共领域]</a></p>
<h3 id="插图重构"><a href="#插图重构" class="headerlink" title="插图重构"></a>插图重构</h3><p>与写作一样，插图的初稿也不够好。修改插图以澄清内容。修改时，请问自己以下问题：</p>
<ul>
<li>如何简化图示？</li>
<li>我应该将此插图分为两个或更多个简单的插图吗？</li>
<li>插图中的文字是否易于阅读？文字与背景是否有足够的对比？</li>
<li>什么是重点？</li>
</ul>
<p>例如，考虑<a href="https://wikipedia.org/wiki/Tube_map#History" target="_blank" rel="noopener">伦敦地铁地图</a>的 <a href="https://wikipedia.org/wiki/Tube_map#History" target="_blank" rel="noopener">演变</a>。在1931年之前，绘制了地铁地图，并按比例绘制了地上道路和像轨道一样弯曲的地铁线。</p>
<p><img src="../images/euP3eyeWX-VG131ipdWv9a77kx4mqw5L_1KCDpmHY20evqxkr1ZT1jWbeA-gThj5Ojvh3E3QDW2tR7t7RtR7jM-VCtSDoYSOyYeTJrRQOm_O5SxOEFu8a9tzBmyN-7einM3mEZd_-20200314140152285.jpeg" alt="1908年伦敦地铁的复杂地图，包括地上道路"></p>
<p><strong>图**</strong>9. 1908<strong>**年的按地面街道绘制的伦敦地铁地图</strong></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Tube_map_1908.jpg" target="_blank" rel="noopener">[公共区域]</a></p>
<p>1931年，哈里·贝克（Harry Beck）革新了一种新型的公共交通地图，通过取消地上标记和比例尺来简化旧地图。相反，他的设计专注于使用地图的人们真正关心的是：从A站到B站。即使1931年的地图取得了成功，但贝克仍然多年对地图进行反复的简化和并使用清晰易读。现在考虑一下<a href="https://www.google.com/search?tbm=isch&q=london+tube+map" target="_blank" rel="noopener">现代的地铁图</a>，尽管出现了新的线路和车站，但它们仍然与贝克的设计保持接近。</p>
<img src="../images/5jC-OPwHxr6Mj-fuKPtgUX0XfCoVMUlmjm7siCMKz6AXsXDLP_QjJtDPunYBXKPpP3-zmhjyTXxJ9HPTN8ApVgomXgg4kkKLx2shmxKnSLRr443FHY9grmrM-_8Lrk6J0htz9Ovn-20200314140207008.png" alt="img" style="zoom:200%;" />

<p>考虑以下原始插图：</p>
<p><img src="../images/xnR8SI5KCSPzQ6Dg0m5UTwHS_V5Vm5dAXjTV_--_8pokF63WyiUM-8ZXVnL3uuiDEZqfZpMK1hh15EvW5gxgo5w8vf3fv6cucArmYHaauvhEQx7pW4D7iU_Yx3AXO93IrsD9Wuru-20200314140221061.png" alt="img"></p>
<p><strong>图**</strong>10.<strong>**复杂图。</strong></p>
<p>上图的内容应该是：</p>
<p>对于递归函数，在return语句中调用函数本身，直到获得基本解为止。</p>
<p>考虑这个图表的复杂性是以什么方式隐藏了要点？您将如何解决这些问题？</p>
<p>该图中可能存在的一些问题包括：</p>
<ul>
<li><strong>问题</strong>：鲜艳的色彩使读者的注意力从图片的其他部分移开。<br> <strong>解决方案</strong>：仔细选择颜色，以免它们压倒图片。</li>
<li><strong>问题</strong>：图片的色彩对比度不足。这使得某些视力较弱或某些类型的色盲的人无法访问该图。<br> <strong>解决方案</strong>：消除不必要的颜色使用，并确保颜色 <a href="https://material.io/design/color/text-legibility.html#legibility-standards" target="_blank" rel="noopener">符合标准的颜色对比建议</a>。</li>
<li><strong>问题</strong>：当前箭头指向两个方向，这使得该图的流程变得不清楚。<br> <strong>解决方案</strong>：将箭头分为两部分，其中一组说明调用功能，另一组说明从功能返回。</li>
</ul>
<p>当然，图中还有其他未在这里指出的问题。</p>
<p>这是一个改进的图示：</p>
<p><img src="../images/8bngRBIGBzJEejHZ_ekuvFCKyTEG0rfQx7ZLF21yPSKzzCiB3KxmnUh5xocI00rR5zfU1AxBQfk8wLu1RNTulzbJ8w7kVlQCcyN5snEHZlvHY3sT9u1PEkldFGK2j-3yj3WKS8fs-20200314140231439.png" alt="img"></p>
<p><strong>图**</strong>11.<strong>**上图的简化版本。</strong></p>
<p>您在改进的插图中看到哪些缺陷？</p>
<p>这是两个仍然存在的缺陷：</p>
<ul>
<li>该图仍然太复杂。要解释此插图，需要的不仅仅是段落。考虑删除多余的信息或添加说明标签如何简化解释。</li>
<li>当函数之间相互调用或返回数据时，分开显示箭头有助于显示，但返回箭头可能会受益于告诉读者返回值是什么的标签。</li>
</ul>
<h3 id="插图工具"><a href="#插图工具" class="headerlink" title="插图工具"></a>插图工具</h3><p>有许多工具可用于创建图表。这里推荐三个免费的作图工具：</p>
<ul>
<li><a href="https://drawings.google.com/" target="_blank" rel="noopener">Google Drawings</a></li>
<li>Draw.<a href="https://draw.io/" target="_blank" rel="noopener">IO</a></li>
<li>LucidChart</li>
</ul>
<p>从这些工具导出图表供文档使用时，通常最好将文件导出为SVG或<a href="https://wikipedia.org/wiki/Scalable_Vector_Graphics" target="_blank" rel="noopener">可缩放矢量图形</a>。可伸缩矢量图形可以轻松地根据空间限制来缩放图表，因此无论大小如何，您最终都可以得到高质量的图像。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>好的示例代码通常是最好的文档。即使您的段落和列表像水一样清澈，程序员仍然更喜欢好的示例代码。毕竟，文本是与代码不同的语言，并且它是读者最终关心的代码。尝试用文本描述代码就像尝试用英语解释一首意大利诗。</p>
<p>好的样本是<strong>正确</strong>，<strong>简洁的</strong>代码，您的读者可以 <strong>快速理解它们，</strong>并以<strong>最小的副作用轻松地重用它们</strong>。</p>
<h3 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h3><p>示例代码应满足以下条件：</p>
<ul>
<li>构建没有错误。</li>
<li>执行它要执行的任务。</li>
<li>尽可能是可以上生产的代码。例如，该代码不应包含任何安全漏洞。</li>
<li>遵循特定于语言的约定。</li>
</ul>
<p>示例代码是直接影响用户编写代码的方式。因此，示例代码应示例最佳的编码方法。如果编码的方法不止一种，请以您的团队认为最好的方式对其进行编码。如果您的团队尚未考虑每种方法的利弊，请花一些时间去对比一下各种方式的好坏和优缺。</p>
<p>始终测试您的示例代码。随着时间的流逝，系统会发生变化，示例代码可能会出错。与其他任何代码一样，测试并维护您的示例代码。</p>
<p>许多团队将其单元测试用作示例程序，这有时是个坏主意。因为，单元测试的主要目标是测试，而示例程序的唯一目的是教育。</p>
<p>一个<strong>程序**</strong>片断**是示例程序的一个碎片，可能只有一行或几行长。这种程序片段繁多的文档通常会随着时间的推移而降级，因为团队倾向于不像完整的示例程序那样严格地测试程序片段。</p>
<h3 id="运行示例代码"><a href="#运行示例代码" class="headerlink" title="运行示例代码"></a>运行示例代码</h3><p>好的文档说明了如何运行示例代码。例如，在运行示例之前，您的文档可能需要告知用户执行以下活动：</p>
<ul>
<li>安装某个库。</li>
<li>配置某些环境变量的值。</li>
<li>配置集成开发环境（IDE）。</li>
</ul>
<p>用户并不总是正确执行上述活动。在某些情况下，用户喜欢直接在文档中运行或（使用）示例代码。（如：“单击此处运行此代码。”）</p>
<p>编写者应考虑描述示例代码的预期输出或结果，尤其是对于难以运行的示例代码。</p>
<h3 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h3><p>示例代码应该简短，仅包括基本组件。当C语言新手想学习如何调用该malloc函数时，请给该程序员一个简短的代码片段，而不是整个Linux源代码树。不相关的代码可能会使您的受众分散注意力并使他们困惑。也就是说，切勿使用错误的做法来缩短代码；总是喜欢正确而不是简洁。</p>
<h3 id="易理解"><a href="#易理解" class="headerlink" title="易理解"></a>易理解</h3><p>请遵循以下建议来创建清晰的示例代码：</p>
<ul>
<li>选择自描述性的类，方法和变量名。</li>
<li>避免读者难以理解的编程技巧。</li>
<li>避免深层嵌套的代码。</li>
<li>可选：使用粗体或彩色字体将读者的注意力吸引到示例代码的特定部分。但是，明智地使用突出显示——太多的突出显示意味着读者不会特别关注任何内容。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下哪个示例示例程序中的代码行会更有帮助？假设目标受众由go.soAPI的新软件工程师组成。</p>
<ol>
<li>MyLevel = go.so.Level(5, 28, 48)</li>
<li>MyLevel = go.so.Level(rank=5, 28, 48)</li>
<li>MyLevel = go.so.Level(rank=5, dimension=28, opacity=48)</li>
</ol>
<p>答案<strong>3</strong>是这里的最佳选择。尽管试图使示例代码尽可能短，但省略参数名称会使新手学习起来更加困难。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>遵循以下示例代码注释的建议：</p>
<ul>
<li>保持简短，但易懂清楚始终高于简洁。</li>
<li>避免编写明显 代码的注释，但也要记住，对您（专家）而言显而易见的东西可能对新手而言并不明显。</li>
<li>将您的评论精力集中在任何非直觉的代码上。</li>
<li>当你的读者非常有技术有经验，不解释 什么<em>what</em> <em>——</em>代码是什么，解释为什么 <em>why ——</em>代码为什么这么干。</li>
</ul>
<p>您应该将代码的描述放在代码注释中还是在示例代码之外的文本（段落或列表）中？请注意，复制并粘贴代码的读者不仅会拷走代码，还会拷走其中的注释。因此，将代码的说明放入代码注释中以便一同复制粘贴。相比之下，当您必须解释冗长或难以解释的概念时，通常应将注释文本放在示例程序之前。</p>
<p><strong>注意：</strong>如果必须牺牲能上生产环境质量的代码，以便使代码更短且更易于理解，请在注释中解释您的决定。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>您在以下代码片段的注释中看到什么问题？假设代码针对的是不熟悉brAPI但对流的概念有一定经验的程序员：</p>
<p>/ *从文本文件创建路径为 /tmp/myfile 的流 */</p>
<p>mystream = br.openstream(pathname=“/tmp/myfile” ，mode= “z” )</p>
<p>注释包含以下缺陷：</p>
<ul>
<li>该注释只是说明了代码中相当明显的部分。</li>
<li>该代码段未解释的不直觉的部分。即，mode参数是什么，z 值是什么意思？</li>
</ul>
<h3 id="可重用"><a href="#可重用" class="headerlink" title="可重用"></a>可重用</h3><p>为了使读者轻松地重用示例代码，请提供以下内容：</p>
<ul>
<li>运行示例代码所需的所有信息，包括所有依赖关系和设置。</li>
<li>可以以有用的方式扩展或自定义的代码。</li>
</ul>
<p>拥有简洁明了且易于理解的示例代码是一个很好的开始。但是，如果毁了读者的应用程序，他们将不会高兴。因此，在编写示例代码时，请考虑由于将代码集成到另一个程序中而引起的任何潜在副作用。没有人想要不安全或效率很低的代码。</p>
<h3 id="正反示例"><a href="#正反示例" class="headerlink" title="正反示例"></a>正反示例</h3><p>除了告诉读者 要做什么，有时还要明智的向读者展示了什么不该做。例如，许多编程语言都允许程序员在等号的两侧放置空格。现在，假设您正在使用某种语言（例如bash）编写教程，该语言不允许在等号的两边使用空格。在这种情况下，同时展示好例子和反例子将使读者受益。例如：</p>
<p>正确的示例</p>
<p>＃有效的字符串分配。</p>
<p>s=“The Rain in Maine.”</p>
<p>错误的示例</p>
<p>＃由于在字符串的两边都有空格，因此字符串分配无效</p>
<p>＃等于符号。</p>
<p>s = “The Rain in Maine.”</p>
<h3 id="并列示列"><a href="#并列示列" class="headerlink" title="并列示列"></a>并列示列</h3><p>一个好的示例代码集展示了<strong>一系列**</strong>的<strong><strong>复杂</strong></strong>度**。</p>
<p>完全不了解某种技术的读者通常渴望获得一些简单的示例来上手。示例代码集中的第一个也是最基本的示例通常称为 <a href="https://wikipedia.org/wiki/" target="_blank" rel="noopener"Hello,_World!"_program">Hello World程序</a>。掌握了基础知识之后，工程师们需要更复杂的程序。一组好的示例代码提供了一系列简单，适当和复杂的示例程序。</p>
<p>以下哪一项是一组好的函数示例，以向新手介绍编程函数概念的教程？</p>
<ol>
<li><p>以下是一组函数：</p>
</li>
<li><ol>
<li>一个不带参数且不返回任何东西的函数。</li>
<li>一个带有一个参数但不返回任何东西的函数。</li>
<li>一个具有一个参数并返回一个值的函数。</li>
<li>具有三个参数并返回一个值的函数。</li>
</ol>
</li>
<li><p>以下是一组函数：</p>
</li>
<li><ol>
<li>具有三个参数并返回一个值的函数。</li>
</ol>
</li>
<li><p>以下是一组函数：</p>
</li>
<li><ol>
<li>一个具有一个参数并返回一个值的函数。</li>
<li>具有三个参数并返回一个值的函数。</li>
</ol>
</li>
</ol>
<p>最好的答案是<strong>1</strong>。提供涵盖一系列复杂性的样本通常是最明智的选择，尤其是对于新来者。抵制诱惑，匆匆走向非常复杂的示例程序，绕过新人渴望的初级和中级示例程序。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>技术写作两个涵盖了以下技术写作中级课程：</p>
<ul>
<li>采用统一的样式。</li>
<li>换位思考。</li>
<li>大声朗读文档（对自己）。</li>
<li>编写初稿后，离开一会儿再回来查看文档。</li>
<li>寻找一个好的同伴编辑。</li>
<li>文档大纲。或是先写下类别，这后再组织起来。</li>
<li>介绍文档的范围和所有先决条件。</li>
<li>首选基于任务的标题。</li>
<li>循序渐进地写作（在某些情况下）。</li>
<li>在创建插图之前，请考虑写标题。</li>
<li>将信息量限制在一个图示中。</li>
<li>通过标注来集中读者的注意力。</li>
<li>创建简单易懂的示例代码。</li>
<li>保持代码注释简短，但更推崇清楚而不是简洁。</li>
<li>避免编写显而易见 的代码注释。</li>
<li>将您的注释集中在任何非直觉的代码上。</li>
<li>不仅提供示例，还提供反例。</li>
<li>提供一系列复杂度的代码示例。</li>
<li>有连续修订记录的版本管理。</li>
<li>为不同类别的用户提供不同的文档类型。</li>
<li>与读者已经熟悉的东西进行比较和对比。</li>
<li>在教程中，通过示例来增强概念。</li>
<li>在教程中，指出危险之处。</li>
</ul>
<h1 id="技术写作资源"><a href="#技术写作资源" class="headerlink" title="技术写作资源"></a>技术写作资源</h1><p>这里总结了其他技术写作资源。</p>
<h2 id="编辑风格指南"><a href="#编辑风格指南" class="headerlink" title="编辑风格指南"></a>编辑风格指南</h2><p>一个<strong>编辑风格指南</strong>规定了编辑团队的指导方针。例如，您的组织应采用以下哪个规则作为标题？</p>
<ul>
<li>标题用 sentence case（仅将每个标题的首字母大写）</li>
<li>标题用 title case （将每个标题中的单词首字母大写）</li>
</ul>
<img src="../images/oRi1oFcErhRddvpYrB-UMIJxoa1RaPboq8KmdxiPUa3ud5b0z_WFgtHFx320fqQe5eHcoKpY0Aj94DV9Qw3xZjFbwvJwdZXzrTeD2UpJpGP1occ81ITmXfURNp6-bX_xPMVwzd_h-20200314140248427.png" alt="img" style="zoom:200%;" />
 （译者注：左边中是Title Case，右边是 Sentence case）

<p>不要浪费时间和精力争论这类问题。而是要求您的组织采用统一的编辑风格指南。一个<strong>编辑风格指南</strong>提供了写作的一种约定。是 Sentence case 还是Title case 并不重要。整个团队采用统一的编辑风格指南才很重要。</p>
<p>嗯，但是要用哪个编辑风格指南呢？您可能已经熟悉通用的编辑样式指南（例如《<a href="https://www.chicagomanualofstyle.org/home.html" target="_blank" rel="noopener">芝加哥样式手册》</a>或《 [牛津大学样式指南》](<a href="https://www.ox.ac.uk/sites/files/oxford/media_wysiwyg/University" target="_blank" rel="noopener">https://www.ox.ac.uk/sites/files/oxford/media_wysiwyg/University</a> of Oxford Style Guide.pdf)）。但是，您的工程团队应使用专门从事技术写作的编辑风格指南。所以，我们建议选择以下选项之一：</p>
<ul>
<li>在<a href="https://developers.google.com/style" target="_blank" rel="noopener">谷歌的开发者文档风格指南</a>规定了谷歌有关的项目，任何人书写的开发者文档的编辑准则。</li>
<li>《<a href="https://docs.microsoft.com/en-us/style-guide/welcome/" target="_blank" rel="noopener">Microsoft写作风格指南》</a>为编写技术文档的任何人提供了指南。</li>
</ul>
<p>不要编写自己的编辑风格指南。创建和维护编辑风格指南需要大量资源，并且会引起巨大冲突。就是说，有团队创造了新术语，而现有的编辑风格指南中没有出现。发生这种情况时，组织可以执行以下任一操作：</p>
<ul>
<li>要求编辑风格指南的维护者添加新术语。</li>
<li>创建并维护您自己的<strong>用法指南</strong>或<strong>样式表</strong>，以将团队的专业词汇的拼写和单词用法编入规章。</li>
</ul>
<h2 id="开源文档的机会"><a href="#开源文档的机会" class="headerlink" title="开源文档的机会"></a>开源文档的机会</h2><p>Google的<a href="https://developers.google.com/season-of-docs/" target="_blank" rel="noopener">“Season of Docs”</a> 计划旨在促进开源项目与技术作家之间的协作。对于从事开源项目的人们来说，这是一个提高他们的技术写作技能的好机会。</p>
<p>文档季节每年运行一次。要随时了解2020年计划，您可以加入邮件列表或Slack工作区，如有关<a href="https://developers.google.com/season-of-docs/docs/discussion" target="_blank" rel="noopener">讨论频道</a>的页面中所述。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=432430716&auto=1&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">89</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
