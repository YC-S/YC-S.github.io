<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E8%B0%81%E5%9C%A8%E5%AF%BC%E6%BC%94%E4%B8%96%E7%95%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E8%B0%81%E5%9C%A8%E5%AF%BC%E6%BC%94%E4%B8%96%E7%95%8C/" class="post-title-link" itemprop="url">谁在导演世界</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-09 19:03:41 / Modified: 20:22:31" itemprop="dateCreated datePublished" datetime="2020-03-09T19:03:41-04:00">2020-03-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>讽刺什么的，一点都不重要。可怕的<strong>是傲慢、隔阂、抹黑、对立、仇恨、和让人绝望的偏见。</strong></p>
<p>重要的是西方民众除非亲自来一趟，<strong>否则已经失去了了解中国真相的渠道</strong>。我们看一段文字，出自边芹的<strong>《谁在导演世界》</strong></p>
<p>话语的流向是一场精准谋划的战争。引一位法国汉学家的话说：中国在这场图谋已久的战争中至今处在不设防状态。</p>
<p>在这里，解构对手的“话语平台”与自建平台是双管齐下的，操纵舆论的力量不在于往自己脸上抹金，而在于往对手头上扣屎盆子！</p>
<p><strong>西方世界对“话语平台”的控制有一张严密的网</strong>，从文化到体育无所不包，没有一个环节是疏忽的。就说体育，掌控“话语”基本做法是不播放中国人有优势的体育比赛；不传播中国自己组办赛事；在各类国际比赛中封锁中国人参赛的事实。比如环法自行车比赛是法国媒体暑期大炒的项目，组委会邀请了中国自行车选手，但这种事不让法国民众知道。为什么？因为请中国选手参赛不像挑选大陆电影界名人参加电影节，艺术不是目的，政治才是由头，不管大陆艺人感觉脸上多么风光，在法国这头就是为负面话语配料、送料的；<strong>而大陆自行车选手参赛则难变成这个性质，既然属于正面话语的范畴，就必须阻止其流入。邀中国人来，是为了中国媒体替法国旅游做宣传，也就是只让话语流出去</strong>。所以没有任何一家电视台或报纸提供哪怕一张中国人参赛的画面，媒介从业人员的广泛“自觉”让人不得不佩服这个民族自觉的权力意识以及不与外人谋的“内忠”。直到赛后数月法国媒体报道西班牙冠军有服用兴奋剂嫌疑，顺带提到有一位中国自行车选手也被怀疑，中国人参赛才透过一则负面新闻泄露出来。这些针对中国人负面话语，经年累月，视利益需要时收时放。其实法国民众对世界是两眼一抹黑，“新闻自由”更多是操纵自由。<strong>比如嫦娥二号升天新闻是封锁的；法国人也不知中国高铁比法国快；不知中国有退休制度（法国媒体声称中国人连退休二字为何物都不知道）；不知中国妇女与男人同工同酬（法国妇女工资比男人少30%）</strong>。不知中国能用高科技织布、炼铁、造汽车<strong>（至今多数民众认定中国人连织布技术都要偷法国的）</strong>；不知朝鲜战争美国人是打不过才谈判的；不知从制瓷、造纸到印刷均传自中国；不知鸦片战争是英国人强迫中国人吸毒；不知法国参与了第二次鸦片战争，烧了圆明园……</p>
<p>如果说这些还只是造谣和限流这么简单，那么奥运会的事情简直是可怕。</p>
<p><strong>边芹：同一个世界同一个梦想有多遥远</strong></p>
<p>这些“画面阴谋家”从一百年前电影出现的那天起，就开始琢磨影像操纵和诈骗，精巧地操纵画面，足以将现实的力量打垮，足以抹去真实，篡改历史，虚构出另一种可以随他们摆布的世界秩序。</p>
<p>客居法国的我，有时看一场体育转播，都有“锤子”砸下，好像生怕你忘掉“一个世界，一个梦想”有多遥远。有一个问题摆在那里：我们可以包容世界，世界(西方)能否容纳我们？我是从一些事例看到这个问题的可能结论的。不敢说是最后的结论，但至少让人心寒。但愿只是我的“误解”……</p>
<h3 id="转播中看不到中国人"><a href="#转播中看不到中国人" class="headerlink" title="转播中看不到中国人"></a>转播中看不到中国人</h3><p>2009年罗马游泳世锦赛期间，我几乎每天观看法国国家电视二台的直播。当然我也早有心理准备，如果一场比赛中国队占绝对优势，就别梦想在法国看到转播，像乒乓球、羽毛球世锦赛，不要说看转播，连体育新闻都不报，好像世界上不存在这两项运动。所以本届游泳世锦赛，跳水部分是被割掉的，一般法国民众可能因此而以为罗马世锦赛只有游泳。如果只是因为法国在某些项目上弱，电视台不转播，我倒也能理解；问题是它还跟美、英、澳等国进一个“战壕”，中国人什么运动强，就封什么。</p>
<p>就算只有游泳吧，但即使在他们强势项目中，依然没有一点点大度。在所有游泳比赛中尽量不给中国运动员画面，不得不给时，比如上场介绍时避不开，不能明显地在一组参赛运动员中单单不让中国人露面，在这种时候你仔细看，一给中国人画面的时间最短；二只给中景或远景不给特写；三挑不好的角度。凡中国队取得金牌，不得不照惯例给一个特写时，在欧美运动员脸上可以停很久的镜头，对中国人则转瞬即逝，观者眼睛不盯着，马上就错过了。按惯例金牌得主不管哪国都有几个或长或短接受媒体采访的画面，自然法国人时间最长，尽管一块金牌未得，但这可以理解；美国人也很长，拍强权马屁嘛！其余画面长短按意识形态和种族分配，盟国或走卒根据富裕和战略重要程度依次递减；种族也有个排列：西方人(这种时候不分黑白)、黑人(非西方国家的)、阿拉伯人、东亚黄种人。想不到吧，黄种人是排在最后的，日、韩也未逃掉，只不过中国人又在日韩之后。</p>
<p>这样排纯属偶然，还是精心算计？由于将一眼能看到的种族主义模糊掉了，不深解西方近现代史，是很难看透玄机的。我这样一个有心人都费时颇多才看出门道，未解西方那些藏而不露历史的人，怎么可能看穿这天方夜谭般的算计？我若转到中国电视台想弥补在法国电视台看不到的中国运动员身影，结果有时也是同样的，因为部分国内传媒以西媒马首是瞻。所以我时常落入绝望中，这么聪明的统治者控制世界的那一天不会遥远。至于为什么在这种时候放黑人一码，东亚黄种人又为什么被排在最后，以后有机会再谈。</p>
<p>我从头至尾细看了，日本人得金后也没有西方记者采访的画面，但至少还留给他几个本国媒体采访的镜头；中国人则连日、韩都不如，没有一秒钟的采访画面。没法像乒乓球和羽毛球那样将整场运动会抹掉，就在画面上做手脚。<strong>这些“画面操纵手”对人的心理有透彻研究，反复炒作的消息和重复的画面，才能收进每个观者个人的心理影像史，通过巧妙诱导的个人视角，又能返回去操纵历史甚至改写历史。即刻的真实是无足轻重的，留下来的会轻而易举地取代它，变成真实。</strong>这就是为什么法国各大电视台的剪辑权是握在极少几个核心人员手里的。此大权绝不旁落，莫非把“新闻”当作武器，视“舆论”为战争乎？否则何必权力如此集中？如果承认传媒是能量堪与政权媲美的权力，如此集中的控制，是不是也是一种形式的“极权”？所以在这里，大财团只要暗暗控制总编、主持人和剪辑师等寥寥数人，根本不需要再出面干涉什么。</p>
<p>由此你若在比赛冲刺前有事离开几分钟，假如金牌又恰恰被中国人拿了，折回后就很难知道金牌花落谁家。凡中国人得金牌，盯着看才可能看到，一旦错过你就无法获悉了，因为他们连“新闻回顾”时都有意绕开，这叫“后消除法”。这种手法你若追究，他可以狡辩：我没有封锁新闻。<strong>但这样暗做手脚，且长此以往，绝无例外，就是一种极其有效的新闻封锁，让你存而不在。赛后，我连问了好几个法国人，无一人知道中国拿过金牌，遑论得悉中国无论是金牌数还是奖牌总数都与美国一样。在这后一点上，法国媒体连暗搞都放弃了，直接撒了一个谎，说美国第一，德国第二，但为了谎不被识破，不公布具体奖牌榜。</strong>堂堂国家电视台！对金牌尚且如此，得银牌、铜牌的中国人就更不用说了，他们根本就不存在，银、铜牌得主只要是中国人，观众不仔细去查该赛排行榜，就不知道二、三名被什么人得了。</p>
<h3 id="恶意点评中国"><a href="#恶意点评中国" class="headerlink" title="恶意点评中国"></a>恶意点评中国</h3><p>再就是主持人，如果法国队在争奖牌，他们会叫得惊天动地，一点不夸张，如果是美国人冲向终点，他们也会叫得声嘶力竭，世界霸主嘛！小资是最看强权眼色调配热度的。余下的，用什么音频、取多少热情则与上述分配画面长短一样，也是随西方利益圈的辐射一层层向外递减，不知他们脑袋里装了架什么机器，可以如此精确地调节感情。轮到中国人率先冲向终点时，音频则降到了最低点，时常到最后几秒是沉默，问题是哪怕不是与法国人对阵，按理应该有起码的中立了，不！照样好像被偷了金子似的，有时甚至大叫着希望诸如摩洛哥或非洲某个国家赢，以我“狭隘”的观感，不知是否因为那曾经是他们的殖民地？<strong>最后看到中国运动员胜得无可争议、遥遥领先，就酸酸地开始翻旧账了。比如女子4×100米混合接力中国女队战胜美国队后，主持人就开始暗示，说多少年前中国女队也得过此项冠军，但是服用了兴奋剂。我想象力再丰富，也无法逆料其肚里水这么浅！</strong></p>
<p>整个罗马世锦赛期间，我在法国的电视转播中，没有看到一个中国运动员领奖的画面，更不要说听到一声中国国歌，看到一次升旗了。柏林田径世锦赛时，最后一天直播，由于重头戏是女子马拉松，中国女孩奔跑的身影绕不过，但她冲向终点前我因事走开片刻，回来那镜头就看不到了，只听见全场掌声，镜头里却不见冠军身影，民众还是好人多，而且他们讲究集体风度，只要有一部分人鼓掌，余下的人必跟。大概这样一场大赛，如此有天赋的冠军，再不给一个画面太过分，镜头又转回冠军，但只有几秒，女孩与队友拥抱，接过五星红旗，正要展开，画面马上就被剪掉了，再也没有转回来。整个下午到晚上乃至第二天的田径赛总回顾，<strong>你可以想象，一切就像没有发生过。</strong></p>
<p>再说奖牌数。早在北京奥运，法国电视台一开始转播中每天挂奖牌榜，后来中国金牌越来越多，超过美国时，奖牌榜就被撤掉了。而且不是自己玩不过就不玩了，而是美国玩不过中国，法国体育迷们就连知情权都被剥夺了，他们不知道谁拿的金牌最多，甚至奖牌在全球的分布也无权知情，因为体育记者们受不了中国拿得多决定不玩奖牌竞争了。也是从中国奖牌大增那一天起，媒体开始朝与原来相反的方向引导舆论。起先以为西方尤其是美国肯定是赢家，他们对奖牌非常在乎，转播中天天清点一番牌落谁家，后来情势逆转，奖牌榜便不见了，舆论的调子也随之逆转。</p>
<p>奥运直播每天有一段点评，由对中国极端恶意的电视明星加尔利耶主持，这个节目实际是给体育节目定政治调子，不让体育越“政治不正确”的红线。如开幕式很好看，<strong>加尔利耶就出来消毒，说那么漂亮是虚假的；如中国运动员表现出色，加尔利耶又出来敲打敲打被迷住的观众，说那都是不人道的“冠军工厂”炮制出来的，好像法美顶尖运动员不是靠吃苦练就的；中国金牌多了，加尔利耶就又出来做反向引导，说体育比赛重在参与，奖牌不重要，为此还有意为放弃比赛、令法国观众大失所望的游泳女将马努杜唱赞歌，说在“逃兵”的失败中看到了美，那三寸不烂之舌，硬可以讲歪理，把得金牌说成了一件坏事。</strong></p>
<p>如果一视同仁倒也罢了，全世界取消比赛和金牌，我也赞成。但自己人拿金牌是英雄，中国人得金牌，就连金牌都成了过错？！罗马世锦赛也一样，中国因金牌拿得多，反倒令他们三缄其口，甚至编出德国金牌第二的谎言。等到柏林田径赛，中国只得一枚金牌，嘴上的封条就撕掉了，主持人在中国女子马拉松取得金牌后，讥讽地说：“中国在奥运会拿那么多，这回才拿了一枚。”法国民众到这时方得知中国在奥运会拿了很多金牌，可惜是体育记者为了挖苦中国人才漏出来的。在这里搞的又是模糊细节、偷换概念的游戏，中国的奥运金牌并不是靠田径得来的，把两个不可比的事物进行比较，目的不是知会民众，而是抓住任何机会、甚至不惜变相骗人，误导法国民众。</p>
<p>看到这一切我还能总结出什么别的逻辑吗？只得一枚金牌时，法国人就有权知道确切数字了；拿了十枚，真实数字就消失了；等到金牌超过美国，则奖牌榜整个被抹去了，这时候人们听到了从未在西方听过的“理念”——比赛是为了“交流”！全世界只有中国人提过比赛是为了友谊，但中国人是在打败对方怕精神上伤害对方才提出的；西方人是在打不过时，为了贬低对方的胜利，才祭出这面旗帜。两个文明之间的鸿沟只在这一个细节里，便已经惊心动魄！</p>
<h3 id="影像中的“消毒”"><a href="#影像中的“消毒”" class="headerlink" title="影像中的“消毒”"></a>影像中的“消毒”</h3><p>你读了上文再回头看2008年奥运会前发生的那些“离奇”事，大概就不再需要解释了。先是奥运开幕前声势浩大的舆论战，一块破布只要能拿来抹黑中国都可以硬说成是锦缎，到处展示。巴黎火炬受阻已有很多报道，我在此省略。媒体怎么对待火炬剩下的传递，我说出来，中国人大概都难以相信。伦敦、巴黎、旧金山这筹划好的“百慕大三角”过去之后，法国媒体几乎成了一座“灾难守望塔”，没有别的任务，就是盼火炬再“出事”。那种不加掩饰的幸灾乐祸，简直就像小孩盼望鞭炮爆炸或水漫车翻一样可笑。最先寄望于阿根廷，然后又把希望挪到日本、印度、澳大利亚，估计什么地方会闹，就把特派记者早早送去等着。直到火炬传入东南亚，知道没戏了，火炬便在法国媒体上消失了。</p>
<p>“藏独”、阻挠火炬、呼吁抵制均未成功，接下来便打环境污染牌，注意这几乎是所有恶搞的最后杀手锏，因为最时髦、最道德、最受普遍认同。奥运开幕前那一个多月，特派北京的记者简直就像身负使命的“特工”，钻到北京甚至京郊最肮脏的角落(真要找巴黎难道没有吗？不往远去，市中心圣米歇尔地铁站楼梯上的尿迹和臭味难道还少吗？但中国记者觉得专挑人家这种事不地道！)，或者找最穷的人，要不就是最激烈的异议人士，或挑最阴云密布的一天，连篇累牍报回空气怎么坏、城市怎么丑陋、百姓怎么穷、筹办怎么虚假……目的也很明确：一让法国公众对如此重要的体育盛会事先产生恶感，进而失去兴趣**，这叫打“预防针”，他们有一整套拴牢百姓的谋略，法国国家足球队教练甚至在《世界报》上呼吁民众连电视转播都不要看；二是天罗地网地撒“消毒水”，避免开幕后任何正面的东西反渗过来；三不用公开号召，暗地恐吓百姓，让其望而却步，使北京宾馆饭店赚不到钱，拖垮你，这叫正面进攻不成，从后面进攻。</p>
<p>开幕式绕不过，但准备了“消毒”工具。电视二台主持人比拉利安那晚的任务傻瓜都能看明白，简直就是“政治铺导员”，时不时地敲打观众别光顾了好看忘了那是什么国家。就好比假如奥运会在美国举办，开幕式两个多小时的直播中，中国主持人时刻不忘提醒观众：“别忘小布什发动了对伊拉克的入侵或关塔那摩还关着囚犯”；又或“别看黑人运动员这么风光，美国监狱里可多半关的是黑人……”人们又会作何感想。那晚的解说做得之过分，让不少想好好欣赏表演的观众实在受不了，往电视二台的网页上发信：住嘴吧，比拉利安！坐在主持人边上是一位华裔老先生，他的角色是解释表演的文化内涵，虽然插话机会不多，但他也忍不住为中国辩了几句。事后他私下对我们说，我与他(指这位主持人)结识多年，但有什么用，他在下面又踢又掐不让我说！</p>
<p>尽管做了一切“消毒”工作，但也许开幕式和闭幕式太好看，挡不住百姓喜爱，若再“开放”下去，便有“危险”，因此到了残奥会，干脆开、闭幕式都不转播，而其实转播权是一并购买的。很多法国残疾人都没有料到，开幕那天他们等在电视前，不少人以为自己弄错了时间。那天专业体育台都一片沉默，我拨过去看，在转播汽车赛。有个体育新闻台更绝，那天根本提都未提残奥会开幕。有聪明者绕到西班牙、英国台才看到开幕式。其后每天的比赛转播缩减到不足10分钟，如果没有法国残疾运动员在那边，恐怕整个运动会就不存在了。这次“新闻封锁”在民间引起不满，因为损害了残疾人的利益，对残疾运动员也不公，如果不是损害到自己人的利益，只对中国人不公，无论何种“封锁”民间其实是普遍接受的。但由于媒体对不满情绪如墙一般封得严严实实，政权也装聋作哑，再加上这个民族可能颇识“大体”，很快就没有下文了。</p>
<p>政权与媒体在残奥转播问题上是不是串通好的？永远不会水落石出。人们只能从一个事实推测：转播的台是国家电视台，国家电视台的总裁由“视听传媒最高委员会”任命，而该委员会的负责人由政府任命，这圈绕的！有一北非裔女残疾运动员夺了金牌，面对镜头说出媒体冷落，电视台马上封她，请来另一位坐轮椅的金牌得主，此人深解媒体要听什么，不光配合媒体数落主办国(中国人为各国残疾运动员做了多少好事，有点良心的都不该这么做！)，还解释批评法国电视的女运动员说那种话是“得金后头脑发热”。<strong>法国游泳冠军贝尔纳也是这种“识时务”的人，知道要上电视必须配合，而经常上电视就意味着广告和财源，他从鸟巢返回次日，便在晚间新闻中表示，自己很想为“藏独”效力，但一时缺乏“勇气”。自这番“勇敢表态”后，他就成了传媒宠儿。</strong></p>
<p>北京奥运千培万训挑出的美女颁奖员，在法国的转播中几乎看不到。每次颁奖，画面有时切割到失衡的程度，就是为了不让中国颁奖美女与得奖运动员在同一画面里出现，如果因为某种角度实在切不掉，就把镜头拉远，让人看不清她们，因为特写画面穿透力是很大的，尤其是好看的形象。我花了好多年才证实法国电影界也是朝这个方向努力的，凡大众电影里的华人形象，必是脸呆或丑、动作可笑的，我起先以为找不到面孔周正一点的，毕竟华人在这里人数不算太多，后来看到电影圈放进一越南裔美女(两个因素：对昔日殖民地，不管其政体如何，一般手下留情；越南非竞争对手)，才证实对华人是故意找丑的，而且专找有几分“卑琐”相的。这些“画面阴谋家”从一百年前电影出现的那天起，就开始琢磨影像操纵和诈骗，精巧地操纵画面，足以将现实的力量打垮，足以抹去真实，篡改历史，虚构出另一种可以随他们摆布的世界秩序。</p>
<p>法国民众不知道北京奥运的象征物是什么样儿，“福娃”和奥运口号“同一个世界，同一个梦想”就没有在法国媒体上出现一次，连体现奥运精神的这样一句话都容纳不了，雨果的故土今天到底是怎么了。</p>
<p>这还是法国，美国更不用说了，就连报道中国的好，比如nasa夸赞中国绿化，也得把印度也算进去。而稍微愿意查真相的人就知道，印度的绿化只有百分之二是植树，大部分是破坏环境的不可持续开垦，把这些破坏环境的行为放在一起是侮辱那些在戈壁奉献一生的英雄。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/08/guiding-principles-for-20-years-of-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/guiding-principles-for-20-years-of-programming/" class="post-title-link" itemprop="url">guiding_principles_for_20_years_of_programming</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-08 19:47:48 / Modified: 20:51:38" itemprop="dateCreated datePublished" datetime="2020-03-08T19:47:48-04:00">2020-03-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>Don’t fight the tools: libraries, language, platform, etc. Use as much native constructs as possible. Don’t <a href="https://medium.com/free-code-camp" target="_blank" rel="noopener">bend</a> the technology, but don’t bend the problem either. Pick the <strong>right tool</strong> for the job or you’ll have to find the right job for the tool you got.</li>
<li>You don’t write the code for the machines, you write it for your colleagues and your <strong>future self</strong> (unless it’s a throw away project or you’re writing assembly). Write it for the junior ones as a reference.</li>
<li>Any significant and rewarding piece of software is the result of collaboration. Communicate effectively and collaborate openly. Trust others and earn their trust. Respect people more than code. Lead by example. Convert your followers to leaders.</li>
<li>Divide and conquer. Write isolated modules with separate concerns which are loosely coupled. Test each part separately and together. Keep the tests close to reality but test the edge cases too.</li>
<li>Deprecate yourself. Don’t be the go-to person for the code. Optimize it for people to find their way fixing bugs and adding features to the code. Free yourself to move on to the next project/company. Don’t own the code or you’ll never grow beyond that.</li>
<li>Security comes in layers: each layer needs to be assessed individually but also in relation to the whole. Risk is a business decision and has direct relation to vulnerability and probability. Each product/organization has a different risk appetite (the risk they are willing to take for a bigger win). Often these 3 concerns fight with each other: UX, Security, Performance.</li>
<li>Realize that every code has a life cycle and will die. Sometimes it dies in its infancy before seeing the light of production. Be OK with letting go. Know the difference between 3 categories of features:<br><strong>Core:</strong> like an engine in a car. The product is meaningless without it.<br><strong>Necessary:</strong> like a car’s spare will. It’s rarely used but when needed, its function decides the success of the system.<br><strong>Added value:</strong> like a car’s cup-holder. It’s nice to have but the product is perfectly usable without it.</li>
<li>Don’t attach your identity to your code. Don’t attach anyone’s identity to their code. Realize that people are separate from the artifacts they produce. Don’t take code criticism personally but be very careful when criticizing others’ code.</li>
<li>Tech debt is like fast food. Occasionally it’s acceptable but if you get used to it, it’ll kill the product faster than you think (and in a painful way).</li>
<li>When making decisions about the solution all things equal, go for this priority:<br><strong>Security</strong> &gt; <strong>Usability (Accessibility &amp; UX)</strong> &gt; <strong>Maintainability</strong> &gt; <strong>Simplicity (Developer experience/DX)</strong> &gt; <strong>Brevity (code length)</strong> &gt; *<em>Performance<br>*</em>But don’t follow that blindly because it is dependent on the nature of the product. Like any career, the more experience you earn, the more you can find the right balance for each given situation. For example, when designing a game engine, performance has the highest priority, but when creating a banking app, security is the most important factor.</li>
<li>Bugs’ genitals are called <strong>copy &amp; paste</strong>. That’s how they reproduce. Always read what you copy, always audit what you import. Bugs take shelter in <strong>complexity</strong>. “Magic” is fine in my dependency but not in my code.</li>
<li>Don’t only write code for the happy scenario. Write <a href="https://medium.com/hackernoon/what-makes-a-good-error-710d02682a68" target="_blank" rel="noopener">good errors</a> that answer why it happened, how it was detected and what can be done to resolve it. Validate all system input (including user input): fail early but recover from errors whenever possible. Assume the user hold a gun: put enough effort into your errors to <strong>convince</strong> them to shoot something other than your head!</li>
<li>Don’t use <strong>dependencies</strong> unless the cost of importing, maintaining, dealing with their edge cases/bugs and refactoring when they don’t satisfy the needs is significantly less than the code that you own.</li>
<li>Stay clear from <a href="https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22" target="_blank" rel="noopener"><strong>hype-driven development</strong></a>. But learn all you can. Always have <strong>pet projects</strong>.</li>
<li>Get out of your comfort zone. Learn every day. <strong>Teach</strong> what you learn. If you’re the master, you’re not learning. Expose yourself to other languages, technologies, culture and stay curious.</li>
<li>Good code doesn’t need documentation, great code is <strong>well documented</strong> so that anyone who hasn’t been part of the evolution, trial &amp; error process and requirements that led to the current status can be productive with it. An undocumented feature is a non-existing feature. A non-existing feature shouldn’t have code.</li>
<li>Avoid overriding, inheritance and implicit smartness as much as possible. Write pure functions. They are easier to test and reason about. Any function that’s not pure should be a class. Any code construct that has a different function, should have a different name.</li>
<li>Never start coding (making a solution) unless you fully understand the <strong>problem</strong>. It’s very normal to spend more time listening and reading than typing code. Understand the domain before starting to code. A problem is like a maze. You need to progressively go through the code-test-improve cycle and explore the problem space till you reach the end.</li>
<li>Don’t solve a problem that doesn’t exist. Don’t do <strong>speculative programming</strong>. Only make the code extensible if it is a validated assumption that it’ll be extended. Chances are by the time it gets extended, the problem definition looks different from when you wrote the code.</li>
<li>Software is more fun when it’s made together. Build a sustainable <strong>community</strong>. Listen. Inspire. Learn. Share.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/07/20-Things-to-know-before-you-start-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/07/20-Things-to-know-before-you-start-programming/" class="post-title-link" itemprop="url">20_Things_to_know_before_you_start_programming</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-07 14:25:45 / Modified: 15:36:15" itemprop="dateCreated datePublished" datetime="2020-03-07T14:25:45-05:00">2020-03-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Everyone who started coding started out pretty much in the same seat as you. It can be <em>extremely frustrating.</em> A lot of people tend to give up when they start teaching themselves to code. It can be overwhelming, and not bearable at times. That’s why the CTO and Co-found of TheFireHouseProject.com were nice enough to tell us 20 things to know before you start programming.</p>
<p>Here are the top things to know before you start programming:</p>
<ul>
<li>You learn by doing</li>
<li>Programming is not like studying for a test</li>
<li>Cheating is very well acceptable</li>
<li>Letting problems pile up is a poor strategy</li>
<li>You do not need 5 monitors</li>
<li>Pair programming as much as possible</li>
<li>There’s a right way to ask for help</li>
<li>Always celebrate small wins</li>
<li>Never stop learning</li>
</ul>
<p><img src="../images/What-subject-do-students-like-a-lot.png" alt="What subject do students like a lot?" style="zoom:200%;" />What subject do students like a lot?</p>
<h4 id="Memorizing-does-not-apply-on-programming"><a href="#Memorizing-does-not-apply-on-programming" class="headerlink" title="Memorizing does not apply on programming"></a>Memorizing does not apply on programming</h4><p><strong>You learn by doing</strong> is on the first place of “20 Things to know before you start programming” list for a reason. The only way to get better at programming is to actually code. Do not let paralysis prevent you from starting. Ever.</p>
<p><strong>Programming is not like studying for a test</strong> by a mile. When you study, you memorize things in order to get a better grade. This does not apply to programming, at all. It doesn’t matter at all if you forget how to do a <strong>switch case,</strong> or an <strong>if/else</strong> statement for that matter. As long as you know that <em>something does that,</em> you’re golden.</p>
<p><strong>Cheating is completely acceptable.</strong> Hell, it’s even encouraged. The top programmers I’ve had to deal with use Google on a regular basis. This way, you’ll save tremendously much time on trying to fix something yourself. This doesn’t mean that you shouldn’t write any piece of code on yourself. But, if you’re stuck Google is your friend.</p>
<p><img src="../images/The-top-programming-languages-of-2019.jpeg" alt="The top programming languages of 2019">The top programming languages of 2019</p>
<p><strong>Letting problems pile up is the poorest strategy there is.</strong> I used to make countless changes on my code and expected it to work right away with no errors. The problem with this path is that it stacks problems one over another. It <strong>will</strong> become difficult to deal with them because you will not know where the problem is. So take them one by one.</p>
<p><strong>Learning by yourself is very tough.</strong> The majority of people started off programming by trying to learn by themselves. It’s not that bad of a choice, but it’s very time-consuming. I remember when I didn’t know how the <strong>map</strong> function worked on JavaScript. I spent all weekend trying to figure it out, and I didn’t get very far. Then, on Monday a friend of mine explained it for 5 minutes and I got it completely.</p>
<h4 id="Your-ego-doesn’t-have-a-place-while-you’re-learning-to-code"><a href="#Your-ego-doesn’t-have-a-place-while-you’re-learning-to-code" class="headerlink" title="Your ego doesn’t have a place while you’re learning to code"></a>Your ego doesn’t have a place while you’re learning to code</h4><p><strong>Let go of your emotions</strong>. You’re going to see errors on your journey to programming a lot. A lot lot. You’ll even get familiarized with them. When screwing up is such a big part of the process, you have to be okay with the mistakes you made. Don’t hold grudges, as you’ll only lose time and patience.</p>
<p><strong>You don’t need 5 monitors</strong>. Can’t stress that enough. Despite what Hollywood shows on movies, you never need an insane external monitor to be a programmer. The computer you’re on right now is probably good enough for you to start programming. Don’t waste money on something that might not be useful. I’ve been using 2 monitors for the past 15 years and I’m pretty okay.</p>
<p><strong>Capitalization matters</strong>. It took me a while to understand this. There’s a subtle difference between similar symbols, and it can be pretty frustrating until you get used to it. I remember pointing out to the computer “Hey, here’s the variable I declared. Are you blind?”</p>
<p><img src="../images/SDK-usage-shows-the-most-popular-programming-language.png" alt="SDK usage shows the most popular programming language">SDK usage shows the most popular programming language</p>
<p><strong>Trying to understand everything is a lost cause.</strong> In the beginning, you’re full of energy. You chase down the “why” of every single problem you encounter. This is not necessary by a mile. Computers are so complex and there is a sea full of things to learn. And you’re never going to know everything. And that’s really okay.</p>
<p><strong>Pair the program as much as possible</strong>. There’s no faster way until to this day to learn how to code. Pair program as much as you can, and you’ll be amazed at the results.</p>
<h4 id="Ask-for-help-without-feeling-embarrassed"><a href="#Ask-for-help-without-feeling-embarrassed" class="headerlink" title="Ask for help without feeling embarrassed"></a>Ask for help without feeling embarrassed</h4><p><strong>Changing code is a huge part of the process</strong>. I used to think back in my young days that every piece of code I wrote had to be perfect. But making improvements to your code is normal. Hell, it’s essential. You’re not writing a book that can’t be changed once it’s published. So if you feel like your code might run faster another way, do it.</p>
<p><strong>There’s a right way to ask for help.</strong> Everybody has to ask for help at some point in their career. And when you do, remember these four things:</p>
<ol>
<li>Overcommunicate details that you see</li>
<li>Explain just what’s happening, nothing more</li>
<li>Explain what should be happening</li>
<li>State why you think it has to be working differently</li>
</ol>
<p>Go through this process, and you’ll often come across a solution <strong>without having to ask for help.</strong> It makes you think about your problem in a holistic way.</p>
<p><strong>You don’t have to be a math genius.</strong> If you’re not a math person, or into math at all, it doesn’t mean that you won’t succeed in programming. It’s a huge advantage if you do, but if not, it’s not an indicator that you will fail programming. I know someone who doesn’t know how to multiply numbers without a calculator and he excels in Python.</p>
<p><strong>Always celebrate small wins.</strong> Building stuff with code is extremely cool. I would’ve never arrived where I’m at if I hadn’t celebrated every win. It’s amazing to see how well your code runs once you optimize it. And it’s a very powerful tool to pat yourself in the back if no one is doing it for you.</p>
<p><img src="../images/Pair-programming-is-similar-to-having-a-navigator-while-you-drive.jpeg" alt="Pair programming is similar to having a navigator while you drive">Pair programming is similar to having a navigator while you drive</p>
<p><strong>Meet-ups are extremely valuable.</strong> In the beginning, I found it pretty intimidating to get myself to the point where I found myself comfortable enough to attend these. But once I did, I realized that there were a lot of programmers just like me. And you will be amazed by how many people are going through the same things as you.</p>
<h4 id="It’s-okay-to-make-big-mistakes"><a href="#It’s-okay-to-make-big-mistakes" class="headerlink" title="It’s okay to make big mistakes"></a>It’s okay to make big mistakes</h4><p><strong>Avoid merge conflicts and you’ll be happy.</strong> Merge conflicts are probably the most annoying thing that can happen. Especially on a Friday. When I realized that I could sneak a feature in before a teammate so that he has to deal with it instead of me, I was super excited. This isn’t the most morally advise I give, but it helps.</p>
<p><strong>It’s okay to admit what you don’t know.</strong> When you land your first programming job, you might stick to the “fake it till you make it” agenda. Don’t. Nobody expects you to know everything right away. And the truth will get you farther than a lie ever will. Don’t expect people to believe you know everything on your first job. Having the ability to know it’s okay is crucial to the “20 Things to know before you start programming” list.</p>
<p><strong>It doesn’t take 10,000 hours to land a good job.</strong> There’s a saying “you need 10,000 hours of work to be good at something”. This doesn’t apply to programming at all. In reality, you need to be good enough to know how to self-correct and get back on track when some problem arises. And, this goes without saying, that it takes less than 10,000 hours.</p>
<p><strong>You’re going to wake up thinking about code.</strong> And when it happens, it’s amazing. You’ll find out that you love what you’re doing. In fact, you’re loving it so much that it’s the first thing you think about when you wake up.</p>
<p><strong>It’s okay to make big mistakes.</strong> I once made a mistake so big that it cost my company 10,000. And in the process, I realized the most important lesson of my programming language: it’s okay to make mistakes. Through this mistake, I realized what I shouldn’t do. Ever. And I passed this lesson further below and we never had to pay ​10,000 again.</p>
<p><img src="../images/Big-mistakes-can-lead-to-a-more-sustainable-future.jpeg" alt="Big mistakes can lead to a more sustainable future">Big mistakes can lead to a more sustainable future </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/06/1971%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%81%A2%E5%A4%8D%E8%81%94%E5%90%88%E5%9B%BD%E5%B8%AD%E4%BD%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/06/1971%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%81%A2%E5%A4%8D%E8%81%94%E5%90%88%E5%9B%BD%E5%B8%AD%E4%BD%8D/" class="post-title-link" itemprop="url">1971年中国恢复联合国席位</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-06 19:27:52 / Modified: 20:28:44" itemprop="dateCreated datePublished" datetime="2020-03-06T19:27:52-05:00">2020-03-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最值钱的席位是安理会常任理事国，这也是当时拉锯的核心价值，否则多一张普通票意义不大。</p>
<p>本质是：为什么欧洲和加拿大们都认为彼时的我朝，有资格坐安理会常任理事国这把交椅？</p>
<p>安理会常任理事国，意味着对全球有影响力。对全球没有影响力，强大也不过是圈地自萌。</p>
<p>文绉绉一点的说法：就是不仅要有力量，而且要有能力把这些力量投射到全球范围。</p>
<p>这里其实就常常让有一定历史知识的朋友陷入迷茫：我朝彼时是有力量的，但是是纯纯的陆权力量，投射范围到朝鲜半岛和中南半岛就是极限了，全球范围肯定不对。</p>
<p>如果力量处于高度被封锁的状态，资本主义阵营是没有必要让你参与到全球治理中的，封锁你就好。</p>
<p>没有出海口的俄罗斯再强大，在全球利益划分上也不如荷兰，这也是为什么斯拉夫人到现在看到出海口都会手抖，ptsd了。</p>
<p>那为什么？</p>
<p>全球嘛…其实我们还真有。</p>
<p>我一直讲，在某段时间里，马来亚革命之声广播电台在哪里？在湖南益阳；东南亚共产主义训练营在哪里？在云南昆明。</p>
<p>印尼苏加诺的1965年、老挝对泰国的“解放区”、新加坡人跑到公海上看《决裂》、菲律宾现总统杜特尔特的导师何塞西松、印度的那夏里特运动；</p>
<p>不仅仅是南亚东南亚这么热闹，秘鲁古兹曼68年在北京的岁月、72年墨西哥与我朝建交时的尴尬、罗德西亚津巴布韦民族联盟、阿曼游击队…</p>
<p>你打开世界地区，看看上面提到的几处地点在哪里。</p>
<p>单非洲，2万多人受训。</p>
<p>这也是全球力量投射。</p>
<p>有个观点说烂了：二战台面上是法西斯阵营与反法西斯阵营之间的斗争，台面下暗含了美苏两大阵营对英法荷比欧洲殖民主义阵营的斗争。</p>
<p>二战结束后，第一个十年是美苏两大阵营对殖民主义阵营的彻底瓦解；第二个十年是美苏两大阵营对峙的同时，在殖民主义阵营的遗产上划分势力范围。</p>
<p>所以不要老觉得丘吉尔还没等盟军攻入柏林就挑唆美帝去打苏联很脑残，不得已而为之。英法与美之间的矛盾，仅是次于英法与德的矛盾。德国的威胁消失，那就必须迅速寻找新威胁，来继续巩固老欧洲和美国的合作关系。否则美国一空下手，第一个揍的就是欧洲。</p>
<p>可惜，美帝不傻，一边听着丘吉尔的铁幕演讲看着凯南报告，一边和苏联一起，在苏伊士运河事件上一巴掌呼在英法脸上。</p>
<p>美帝表示：我都要。全球霸权就是要有全球影响力，一边反苏一边把表面盟友的家拆了，没毛病。</p>
<p>我们常说六七十年代是亚非拉民族解放运动的风起云涌之时，没错，但不全面。</p>
<p>因为如果真的按民族自决来解放，为什么亚非拉那么多国家依然继承了殖民时代的国境线？那么多不相干的民族被强行划分在同一个国境内，直接导致了亚非大地在20世纪后半段漫无止境的流血漂杵。</p>
<p>捷克和斯洛伐克还知道划清楚，奥匈帝国拆的时候拆得那么“民族自决”，怎么到殖民地解放的时候，就连经纬线都那么清晰了？非洲民族是天然带着卫星视野来建国的？</p>
<p>因为这还是披着民族解放的皮，干划分势力范围的勾当。不否认第三世界国家的自我努力，但是政治是讲现实力量对比的，没有外力扶植，他们自己做不到。</p>
<p>美苏就这么一边对喷，一边愉快地分起了老欧洲的遗产。苏联美帝愉快地分家，老欧洲不停地出卖集体主权，换取一点援助，抢救一点非洲和中东的残余资产。很像两头老虎打架，几头受伤的老狼瑟瑟发抖，偶尔趁着老虎不注意，把本属于自己的猎物咬一口扯一块回来。</p>
<p>这个画面，本来和我们没什么关系的。</p>
<p>直到两头老虎打着打着，突然发现猎物动了。</p>
<p>wdnmd我柜子动了我不玩了。</p>
<p>美苏划分势力范围的方式很有意思。东欧中亚肯定是苏联的，南美洲西欧和日本肯定是美帝的，有意思的就在亚非地区。</p>
<p>某第三世界国家：殖民者走了，我们组了个政府，独立咯！</p>
<p>美帝：为了自由世界，小盆友来我这，蜀黍有钱。</p>
<p>好，我们就是要钱！来咯！</p>
<p>苏联：为了民主世界，小盆友来我这，蜀黍钱不多，但有枪。</p>
<p>某第三世界国家：我裂开了。</p>
<p>A：跟美帝，要钱。</p>
<p>B：跟苏联，要枪，然后抢钱。</p>
<p>得，开打。</p>
<p>六七十年代，上一秒民族解放建国，下一秒开打，这是常态。本身就是人为造出来的国家，内部板块完全不统一，美苏在外面一发力，新国家立刻内战。</p>
<p>打，打完哪派站上风就算跟了哪个阵营。当然，之后还有墙头切换阵营的，那是后话，按下不表。</p>
<p>建国，内战，站队，拉锯。周而复始，势力范围的划分就在原殖民地国家这么循环往复。</p>
<p>那到底跟我朝有啥关系？</p>
<p>哦，是这样的，某一天美苏发现，除了A和B，还来了个C。</p>
<p>A：美帝，自由。</p>
<p>B：苏联，民主。</p>
<p>C：你们都是人民的敌人，死ね！</p>
<p>A &amp; B &amp; 美帝 &amp; 苏联 &amp; 只能看着的老欧洲：</p>
<p>我靠你哪位？</p>
<p>全乱了，整个晋西北乱成了一锅粥。</p>
<p>从玻利维亚到秘鲁，从坦桑尼亚到喀麦隆，从阿曼到印度，从菲律宾到老挝。</p>
<p>成群结队的第三势力出现，不认美也不认苏。装备虽然落后，但是意志坚定，游击战术又能够以低成本产生高代价，划分势力范围的成本突然被拔高。</p>
<p>而且不仅仅是亚非拉有穷人，欧美日也有穷人。这一思潮对相同的阶级产生一样的震撼和鼓舞，亚非拉人民端起枪钻入丛林，塌进深山；欧美日人民走上街头，冲向警察。</p>
<p>全世界点起了一把火，一把我们如今完全无法想象的燎原野火。不仅让你即将咽下去的卡在喉咙里，也能让你已经吃下去的在肚子里发疼。</p>
<p>这就是我朝当时，以极低成本实现的全球力量投射。效果之佳，以致苏联跑过来抗议，认为我们太革命了。</p>
<p>阻碍，也是一种力量。</p>
<p>教员说：是非洲兄弟把我们抬进去的。</p>
<p>很多人一翻当年的投票记录：不对呀，非洲一堆反对票，没抬咱们呀。</p>
<p>这就是看事只看一层。</p>
<p>是非洲兄弟抬进去的，不过不是投票的那些政府代表，而是端着枪讲农村包围城市的游击队员。</p>
<p>他们展现给美苏老欧洲一个结论：不让我朝参与全球治理，那么全球治理的成本就会越来越高。高到某个阶段，桌子都给你扬咯。</p>
<p>有人翻了投票结果：哎呀欧洲票最多，你看人家多讲规矩。</p>
<p>人家老欧洲看到你的表现，觉得你是在这场美苏分他家遗产大赛里，唯一有实力缓阻他俩的潜在盟友，才愿意舔着脸来把渎圣联盟，资本主义与共产主义又睡一块去了。</p>
<p>你要是乖乖在自己一亩三分地里蹲着，你看老欧洲理不理你。</p>
<p>这才会出现70年代，美苏势均力敌愉快对喷时，老欧洲突然对遥远的东方那么感兴趣。</p>
<p>戴高乐的声望是有道理的，你看人家反应多快。</p>
<p>这就是教员谋断的精妙之处。</p>
<p>种子在延安时期就种下了，起手式在抗美援朝后亮出来，六十年代初轻轻一手把印度还没坐热的“第三世界领袖”交椅夺了过来，等到六十年代中期，老欧洲的遗产争夺战进入高潮时：</p>
<p>爷来辣。</p>
<p>我穷，但是我是丐帮帮主，武林大会能上主席台么？</p>
<p>被打残的五岳剑派代表赶忙上前：有的有的。</p>
<p>没有这些，没那么快的。</p>
<p>可惜这套玩法是自有安理会常任理事国席位以来，第一次有人这么玩。没有前例，无法对比，所以乍一眼看不出精妙之处。</p>
<p>只有在特殊时刻，我们才会抖一抖这张牌。</p>
<p>墨西哥的三不言论就是不经意抖了一下。</p>
<p>拿回这把交椅后，还有5年就76年了。</p>
<p>教员千古。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/Concurrency-vs-Parallelism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/Concurrency-vs-Parallelism/" class="post-title-link" itemprop="url">Concurrency_vs_Parallelism</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-05 23:27:55" itemprop="dateCreated datePublished" datetime="2020-03-05T23:27:55-05:00">2020-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-06 00:28:57" itemprop="dateModified" datetime="2020-03-06T00:28:57-05:00">2020-03-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Concurrency</strong> means multiple tasks which start, run, and complete in overlapping time periods, in no specific order. <strong>Parallelism</strong> is when multiple tasks OR several part of a unique task literally run at the same time, e.g. on a multi-core processor. Remember that Concurrency and parallelism are NOT the same thing.</p>
<p>Let’s understand more in detail that what I mean when I say <strong>Concurrency vs. Parallelism</strong>.</p>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><p>Concurrency is essentially applicable when we talk about minimum two tasks or more. When an application is capable of executing two tasks virtually at same time, we call it concurrent application. Though here tasks run looks like simultaneously, but essentially they MAY not. They take advantage of <strong>CPU time-slicing</strong> feature of operating system where each task run part of its task and then go to waiting state. When first task is in waiting state, CPU is assigned to second task to complete it’s part of task.</p>
<p>Operating system based on priority of tasks, thus, assigns CPU and other computing resources e.g. memory; turn by turn to all tasks and give them chance to complete. To end user, it seems that all tasks are running in parallel. This is called concurrency.</p>
<h2 id="Parallelism"><a href="#Parallelism" class="headerlink" title="Parallelism"></a>Parallelism</h2><p>Parallelism does not require two tasks to exist. It literally physically run parts of tasks OR multiple tasks, at the same time using multi-core infrastructure of CPU, by assigning one core to each task or sub-task.</p>
<p>Parallelism requires hardware with multiple processing units, essentially. In single core CPU, you may get concurrency but NOT parallelism.</p>
<h2 id="Differences-between-concurrency-vs-parallelism"><a href="#Differences-between-concurrency-vs-parallelism" class="headerlink" title="Differences between concurrency vs. parallelism"></a>Differences between concurrency vs. parallelism</h2><p>Now let’s list down remarkable differences between concurrency and parallelism.</p>
<p>Concurrency is when two tasks can start, run, and complete in overlapping time periods. Parallelism is when tasks literally run at the same time, eg. on a multi-core processor.</p>
<p>Concurrency is the composition of independently executing processes, while parallelism is the simultaneous execution of (possibly related) computations.</p>
<p>Concurrency is about <strong>dealing with lots of things</strong> at once. Parallelism is about <strong>doing lots of things</strong> at once.</p>
<p>An application can be concurrent – but not parallel, which means that it processes more than one task at the same time, but no two tasks are executing at same time instant.</p>
<p>An application can be parallel – but not concurrent, which means that it processes multiple sub-tasks of a task in multi-core CPU at same time.</p>
<p>An application can be neither parallel – nor concurrent, which means that it processes all tasks one at a time, sequentially.</p>
<p>An application can be both parallel – and concurrent, which means that it processes multiple tasks concurrently in multi-core CPU at same time .</p>
<p>That’s all about <strong>Concurrency vs. Parallelism</strong>, a very important concept in java multi-threading concepts.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/04/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/04/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" class="post-title-link" itemprop="url">自学计算机科学</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-04 10:46:09 / Modified: 11:47:03" itemprop="dateCreated datePublished" datetime="2020-03-04T10:46:09-05:00">2020-03-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果你是一个自学成才的工程师，或者从编程培训班毕业，那么你很有必要学习计算机科学。幸运的是，不必为此花上数年光阴和不菲费用去攻读一个学位：仅仅依靠自己，你就可以获得世界一流水平的教育💸。</p>
<p>互联网上，到处都有许多的学习资源，然而精华与糟粕并存。你所需要的，不是一个诸如“200+免费在线课程”的清单，而是以下问题的答案：</p>
<ul>
<li>你应当学习<strong>哪些科目</strong>，为什么？</li>
<li>对于这些科目，<strong>最好的书籍或者视频课程</strong>是什么？</li>
</ul>
<p>在这份指引中，我们尝试对这些问题做出确定的回答。</p>
<h2 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h2><p>大致按照列出的顺序，借助我们所建议的教材或者视频课程（但是最好二者兼用），学习如下的九门科目。目标是先花100到200个小时学习完每一个科目，然后在你职业生涯中，不时温习其中的精髓🚀。</p>
<table>
<thead>
<tr>
<th>科目</th>
<th>为何要学？</th>
<th>最佳书籍</th>
<th>最佳视频</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#编程" target="_blank" rel="noopener">编程</a></strong></td>
<td>不要做一个“永远没彻底搞懂”诸如递归等概念的程序员。</td>
<td><em><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">《计算机程序的构造和解释》</a></em></td>
<td>Brian Harvey’s Berkeley CS 61A</td>
</tr>
<tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#计算机架构" target="_blank" rel="noopener">计算机架构</a></strong></td>
<td>如果你对于计算机如何工作没有具体的概念，那么你所做出的所有高级抽象都是空中楼阁。</td>
<td><em><a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">《计算机组成与设计》</a></em></td>
<td>Berkeley CS 61C</td>
</tr>
<tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#算法和数据结构" target="_blank" rel="noopener">算法与数据结构</a></strong></td>
<td>如果你不懂得如何使用栈、队列、树、图等常见数据结构，遇到有难度的问题时，你将束手无策。</td>
<td><em><a href="https://book.douban.com/subject/4048566/" target="_blank" rel="noopener">《算法设计手册》</a></em></td>
<td>Steven Skiena’s lectures</td>
</tr>
<tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#数学知识" target="_blank" rel="noopener">数学知识</a></strong></td>
<td>计算机科学基本上是应用数学的一个“失控的”分支，因此学习数学将会给你带来竞争优势。</td>
<td><em><a href="https://book.douban.com/subject/33396340/" target="_blank" rel="noopener">《计算机科学中的数学》</a></em></td>
<td>Tom Leighton’s MIT 6.042J</td>
</tr>
<tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#操作系统" target="_blank" rel="noopener">操作系统</a></strong></td>
<td>你所写的代码，基本上都由操作系统来运行，因此你应当了解其运作的原理。</td>
<td><em><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">《操作系统导论》</a></em></td>
<td>Berkeley CS 162</td>
</tr>
<tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#计算机网络" target="_blank" rel="noopener">计算机网络</a></strong></td>
<td>互联网已然势不可挡：理解工作原理才能解锁全部潜力。</td>
<td><em><a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener">《计算机网络：自顶向下方法》</a></em></td>
<td>Stanford CS 144</td>
</tr>
<tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#数据库" target="_blank" rel="noopener">数据库</a></strong></td>
<td>对于多数重要程序，数据是其核心，然而很少人理解数据库系统的工作原理。</td>
<td><em><a href="https://book.douban.com/subject/2256069/" target="_blank" rel="noopener">《Readings in Database Systems》</a> （暂无中译本）</em></td>
<td>Joe Hellerstein’s Berkeley CS 186</td>
</tr>
<tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#编程语言与编译器" target="_blank" rel="noopener">编程语言与编译器</a></strong></td>
<td>若你懂得编程语言和编译器如何工作，你就能写出更好的代码，更轻松地学习新的编程语言。</td>
<td><em><a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener">《编译原理》</a></em></td>
<td>Alex Aiken’s course on Lagunita</td>
</tr>
<tr>
<td><strong><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#分布式系统" target="_blank" rel="noopener">分布式系统</a></strong></td>
<td>如今，<em>多数</em> 系统都是分布式的。</td>
<td><em>《分布式系统原理与范型》（<a href="https://book.douban.com/subject/3108801/" target="_blank" rel="noopener">中文第二版</a>，<a href="https://book.douban.com/subject/26979326/" target="_blank" rel="noopener">英文第三版</a>）</em></td>
<td>🤷‍</td>
</tr>
</tbody></table>
<h2 id="为什么要学习计算机科学？"><a href="#为什么要学习计算机科学？" class="headerlink" title="为什么要学习计算机科学？"></a>为什么要学习计算机科学？</h2><p>软件工程师分为两种：一种充分理解了计算机科学，从而有能力应对充满挑战的创造性工作；另一种仅仅凭着对一些高级工具的熟悉而勉强应付。</p>
<p>这两种人都自称软件工程师，都能在职业生涯早期挣到差不多的工资。然而，随着时间流逝，第一种工程师不断成长，所做的事情将会越来越有意义且更为高薪，不论是有价值的商业工作、突破性的开源项目、技术上的领导力或者高质量的个人贡献。</p>
<blockquote>
<p>全球短信系统每日收发约200亿条信息，而仅仅靠57名工程师，现在的 WhatsApp 每日收发420亿条。</p>
<p>— Benedict Evans (@BenedictEvans) <a href="https://twitter.com/BenedictEvans/status/694342874729545729" target="_blank" rel="noopener">2016年2月2日</a></p>
</blockquote>
<p>第一种工程师总是寻求深入学习计算机科学的方法，或是通过传统的方法学习，或是在职业生涯中永无止息地学习；第二种工程师 通常浮于表面，只学习某些特定的工具和技术，而不研究其底层的基本原理，仅仅在技术潮流的风向改变时学习新的技能。</p>
<p>如今，涌入计算机行业的人数激增，然而计算机专业的毕业生数量基本上未曾改变。第二种工程师的供过于求正在开始减少他们的工作机会，使他们无法涉足行业内更加有意义的工作。对你而言，不论正在努力成为第一种工程师，还是只想让自己的职业生涯更加安全，学习计算机科学是唯一可靠的途径。</p>
<blockquote>
<p>23333 然而他们… <a href="https://t.co/XVNYlXAHar" target="_blank" rel="noopener">pic.twitter.com/XVNYlXAHar</a></p>
<p>— Jenna Bilotta (@jenna) <a href="https://twitter.com/jenna/status/838161631662092289" target="_blank" rel="noopener">2017年3月4日</a></p>
</blockquote>
<h2 id="分科目指引"><a href="#分科目指引" class="headerlink" title="分科目指引"></a>分科目指引</h2><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>大多数计算机专业本科教学以程序设计“导论”作为开始。这类课程的最佳版本不仅能满足初学者的需要，还适用于那些在初学编程阶段遗漏了某些有益的概念和程序设计模式的人。</p>
<p>对于这部分内容，我们的标准推荐是这部经典著作：<a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">《计算机程序的构造和解释》</a>。在网络上，这本书既可供<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html" target="_blank" rel="noopener">免费阅读（英文版）</a>，也作为<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/" target="_blank" rel="noopener">MIT的免费视频课程</a>。不过尽管这些视频课程很不错，我们对于视频课程的推荐实际上是<a href="https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter" target="_blank" rel="noopener">Brian Harvey 开设的 SICP 课程</a>（即 Berkeley 的 61A 课程）。比起MIT的课程，它更加完善，更适用于初学者。</p>
<p>我们建议至少学完SICP的前三章，并完成配套的习题。如果需要额外的练习，可以去解决一些小的程序设计问题，比如<a href="http://exercism.io/" target="_blank" rel="noopener">exercism</a>。</p>
<blockquote>
<p><strong>中文翻译新增：</strong></p>
<ul>
<li>关于SICP国内视频观看地址<ul>
<li><a href="https://www.bilibili.com/video/av8515129/" target="_blank" rel="noopener">MIT的免费视频课程（中英字幕）</a></li>
<li><a href="https://www.bilibili.com/video/av40460492/" target="_blank" rel="noopener">Brian Harvey 开设的 SICP 课程（英文字幕）</a></li>
</ul>
</li>
<li>Scheme 学习的相关资源参见：<a href="https://github.com/DeathKing/Learning-SICP" target="_blank" rel="noopener">https://github.com/DeathKing/Learning-SICP</a></li>
<li>更详细的补充说明：<a href="https://github.com/keithnull/TeachYourselfCS-CN/issues/3" target="_blank" rel="noopener">#3</a></li>
</ul>
</blockquote>
<p>如果你觉得SICP过于难，那我们推荐 <em>《程序设计方法》（<a href="https://book.douban.com/subject/1140942/" target="_blank" rel="noopener">中文版</a>，<a href="http://www.htdp.org/" target="_blank" rel="noopener">英文版</a>）</em> ；如果你觉得SICP过于简单，那我们推荐 <em><a href="https://book.douban.com/subject/1782316/" target="_blank" rel="noopener">《Concepts, Techniques, and Models of Computer Programming》</a></em> 。</p>
<p><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener"><img src="../images/66758473-ef7bff80-eed0-11e9-944a-15ae5c8542ca.jpg" alt="计算机程序的构造和解释"></a></p>
<h3 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h3><p>计算机架构——有时候又被称为“计算机系统”或者“计算机组成”——是了解软件底层的的重要视角。根据我们的经验，这是自学的软件工程师最容易忽视的领域。</p>
<p>*<a href="https://book.douban.com/subject/1998341/" target="_blank" rel="noopener">《计算机系统要素》</a>*，又名“从与非门到俄罗斯方块”（“Nand2Tetris”），这本书规模宏大，让读者对计算机内的所有部分如何协同工作有完全的认识。这本书的每一章节对应如何构建计算机整体系统中的一小部分，从用HDL（硬件描述语言）写基本的逻辑门电路出发，途经CPU和汇编，最终抵达诸如俄罗斯方块这般规模的应用程序。</p>
<p>我们推荐把此书的前六章读完，并完成对应的项目练习。这么做，你将更加深入地理解，计算机架构和运行其上的软件之间的关系。</p>
<p>这本书的前半部分（包括所有对应的项目）均可从<a href="http://www.nand2tetris.org/" target="_blank" rel="noopener">Nand2Tetris的网站上</a>免费获得。同时，在Coursera上，这是一门<a href="https://www.coursera.org/learn/build-a-computer" target="_blank" rel="noopener">视频课程</a>。</p>
<p>为了追求简洁和紧凑，这本书牺牲了内容上的深度。尤其值得注意的是，流水线和存储层次结构是现代计算机架构中极其重要的两个概念，然而这本书对此几乎毫无涉及。</p>
<p>当你掌握了Nand2Tetris的内容后，我们接下来推荐Patterson和Hennessy二人所著的 *<a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">《计算机组成与设计》</a>*，一本优秀的经典著作。这本书中的不同章节重要程度不一，因此我们建议根据Berkeley的<a href="http://inst.eecs.berkeley.edu/~cs61c/sp15/" target="_blank" rel="noopener">CS61C课程</a> “计算机架构中的伟大思想”来着重阅读一些章节。这门课的笔记和实验在网络上可以免费获得，并且在<a href="https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_" target="_blank" rel="noopener">互联网档案</a>中有这门课程的过往资料。</p>
<p><a href="http://www.nand2tetris.org/" target="_blank" rel="noopener"><img src="../images/66758695-60231c00-eed1-11e9-8422-a4acfb10a390.jpg" alt="计算机系统要素"></a> <a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener"><img src="../images/66758887-bf812c00-eed1-11e9-87cf-9255a4815d04.jpg" alt="计算机组成与设计"></a></p>
<blockquote>
<p>硬件是平台。</p>
<p>— Mike Acton, Engine Director at Insomniac Games (<a href="https://www.youtube.com/watch?v=rX0ItVEVjHc" target="_blank" rel="noopener">观看他在CppCon上的演说</a>)</p>
</blockquote>
<h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>正如几十年来的共识，我们认为，计算机科学教育所赋予人们的最大能量在于对常见算法和数据结构的熟悉。此外，这也可以训练一个人对于各种问题的解决能力，有助于其他领域的学习。</p>
<p>关于算法与数据结构，有成百上千的书可供使用，但是我们的最爱是Steven Skiena编写的 <em><a href="https://book.douban.com/subject/4048566/" target="_blank" rel="noopener">《算法设计手册》</a>*。显而易见，他对此充满热爱，迫不及待地想要帮助其他人理解。在我们看来，这本书给人一种焕然一新的体验，完全不同于那些更加经常被推荐的书（比如Cormen，Leiserson，Rivest 和 Stein，或者 Sedgewick的书，后两者充斥着过多的证明，不适合以 *解决问题</em> 为导向的学习）。</p>
<p>如果你更喜欢视频课程，<a href="https://www.youtube.com/watch?v=A2bFN3MyNDA&list=PLOtl7M3yp-DX32N0fVIyvn7ipWKNGmwpp" target="_blank" rel="noopener">Skiena慷慨地提供了他的课程</a>。此外，Tim Roughgarden的课程也很不错， 在Stanford的MOOC平台Lagunita，或者<a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener">Coursera</a>上均可获得。Skiena和Roughgarden的这两门课程没有优劣之分，选择何者取决于个人品味。</p>
<p>至于练习，我们推荐学生在<a href="https://leetcode.com/" target="_blank" rel="noopener">Leetcode</a>上解决问题。Leetcode上的问题往往有趣且带有良好的解法和讨论。此外，在竞争日益激烈的软件行业，这些问题可以帮助你评估自己应对技术面试中常见问题的能力。我们建议解决大约100道随机挑选的Leetcode问题，作为学习的一部分。</p>
<p>最后，我们强烈推荐 *<a href="https://book.douban.com/subject/2124114/" target="_blank" rel="noopener">《怎样解题》</a>*。这本书极为优秀且独特，指导人们解决广义上的问题，因而一如其适用于数学，它适用于计算机科学。</p>
<p><a href="https://book.douban.com/subject/4048566/" target="_blank" rel="noopener"><img src="../images/66759121-361e2980-eed2-11e9-913c-8fc48c67122a.jpg" alt="算法设计手册"></a> <a href="https://book.douban.com/subject/2124114/" target="_blank" rel="noopener"><img src="../images/66759282-8e552b80-eed2-11e9-89de-16b1f8d82e78.jpg" alt="怎样解题"></a></p>
<blockquote>
<p>我可以广泛推荐的方法只有一个： 写之前先思考。</p>
<p>— Richard Hamming</p>
</blockquote>
<h3 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h3><p>从某个角度说，计算机科学是应用数学的一个“发育过度”的分支。尽管许多软件工程师试图——并且在不同程度上成功做到——忽视这一点，我们鼓励你用学习来拥抱数学。如若成功，比起那些没有掌握数学的人，你将获得巨大的竞争优势。</p>
<p>对于计算机科学，数学中最相关的领域是“离散数学”，其中的“离散”与“连续”相对立，大致上指的是应用数学中那些有趣的主题，而不是微积分之类的。由于定义比较含糊，试图掌握离散数学的全部内容是没有意义的。较为现实的学习目标是，了解逻辑、排列组合、概率论、集合论、图论以及密码学相关的一些数论知识。考虑到线性代数在计算机图形学和机器学习中的重要性，该领域同样值得学习。</p>
<p>学习离散数学，我们建议从<a href="http://www.cs.elte.hu/~lovasz/dmbook.ps" target="_blank" rel="noopener">László Lovász的课程笔记</a>开始。Lovász教授成功地让这些内容浅显易懂且符合直觉，因此，比起正式的教材，这更适合初学者。</p>
<p>对于更加高阶的学习，我们推荐 *<a href="https://book.douban.com/subject/33396340/" target="_blank" rel="noopener">《计算机科学中的数学》</a>*，MIT同名课程的课程笔记，篇幅与书籍相当（事实上，现已出版）。这门课程的视频同样<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/" target="_blank" rel="noopener">可免费获得</a>，是我们所推荐的学习视频。</p>
<p>对于线性代数，我们建议从<a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab" target="_blank" rel="noopener">Essence of linear algebra</a>系列视频开始，然后再去学习Gilbert Strang的<a href="https://book.douban.com/subject/34820335/" target="_blank" rel="noopener">《线性代数导论》</a>和<a href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/" target="_blank" rel="noopener">视频课程</a>。</p>
<p><a href="https://book.douban.com/subject/33396340/" target="_blank" rel="noopener"><img src="../images/66759673-4387e380-eed3-11e9-8469-3e677d108e91.jpg" alt="计算机科学中的数学"></a></p>
<blockquote>
<p>如果人们不相信数学是简单的，那么只能是因为他们没有意识到生活有多么复杂。</p>
<p>— John von Neumann</p>
</blockquote>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><em><a href="https://book.douban.com/subject/30297919/" target="_blank" rel="noopener">《操作系统概念》</a></em> （“恐龙书”）和 <em><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">《现代操作系统》</a></em> 是操作系统领域的经典书籍。二者都因为写作风格，长达1000页的篇幅以及每隔几年就增加内容来鼓励人们购买“最新版本”招致了一些批评。</p>
<p><em><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">《操作系统导论》（Operating Systems: Three Easy Pieces）</a></em> 是一个不错的替代品，并且<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">可在网上免费获得（英文版）</a>。我们格外喜欢这本书的结构，并且认为这本书的习题很值得一做。</p>
<p>在读完《操作系统导论》后，我们鼓励你探索特定操作系统的设计。可以借助“{OS name} Internals”风格的书籍，比如 *<a href="https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/" target="_blank" rel="noopener">Lion’s commentary on Unix</a><em>， *<a href="https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/" target="_blank" rel="noopener">The Design and Implementation of the FreeBSD Operating System</a></em>，以及 *<a href="https://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542/" target="_blank" rel="noopener">Mac OS X Internals</a>*。</p>
<p>为了巩固对操作系统的理解，阅读小型系统内核的代码并且为其增加特性是一个很不错的方法。比如，<a href="https://pdos.csail.mit.edu/6.828/2016/xv6.html" target="_blank" rel="noopener">xv6</a>，由MIT的一门课程所维护的从Unix V6到ANSI C和x86的移植，就是一个很棒的选择。《操作系统导论》有一个附录，记载了一些可能的<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/lab-projects-xv6.pdf" target="_blank" rel="noopener">xv6实验项目</a>，其中充满了关于潜在项目的很棒想法。</p>
<p><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener"><img src="../images/66759780-78943600-eed3-11e9-8eb5-6472c318c265.jpg" alt="操作系统导论"></a></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>鉴于有那么多关于网络服务端和客户端的软件工程，计算机网络是计算机科学中价值最为“立竿见影”的领域之一。我们的学生，系统性地学习了计算机网络，最终能够理解那些曾困扰他们多年的术语、概念和协议。</p>
<p>在这一主题上，我们最爱的书籍是 *<a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener">《计算机网络：自顶向下方法》</a>*。书中的小项目和习题相当值得练习，尤其是其中的“Wireshark labs”（<a href="http://www-net.cs.umass.edu/wireshark-labs/" target="_blank" rel="noopener">这部分在网上可以获得</a>）。</p>
<p>如果更喜欢视频课程，我们推荐Stanford的<a href="https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/about" target="_blank" rel="noopener"><em>Introduction to Computer Networking</em></a>，可在他们的MOOC平台Lagunita上免费观看。</p>
<p>对于计算机网络的学习，做项目比完成小的习题更有益。一些可能的项目有：HTTP服务器，基于UDP的聊天APP，<a href="http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/" target="_blank" rel="noopener">迷你TCP栈</a>，代理，负载均衡器，或者分布式哈希表。</p>
<p><a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener"><img src="../images/66760004-d9bc0980-eed3-11e9-9b3f-74bf54b9571f.jpg" alt="《计算机网络：自顶向下方法》"></a></p>
<blockquote>
<p>你无法盯着水晶球预见未来，未来的互联网何去何从取决于社会。</p>
<p>— Bob Kahn</p>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>比起其他主题，自学数据库系统需要更多的付出。这是一个相对年轻的研究领域，并且出于很强的商业动机，研究者把想法藏在紧闭的门后。此外，许多原本有潜力写出优秀教材的作者反而选择了加入或创立公司。</p>
<p>鉴于如上情况，我们鼓励自学者大体上抛弃教材，而是从<a href="https://archive.org/details/UCBerkeley_Course_Computer_Science_186" target="_blank" rel="noopener">2015年春季学期的CS 186课程</a>（Joe Hellerstein在Berkeley的数据库课程）开始，然后前往阅读论文。</p>
<p>对于初学者，有一篇格外值得提及的论文：“<a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf" target="_blank" rel="noopener">Architecture of a Database System</a>”。这篇论文提供了独特的对关系型数据库管理系统（RDBMS）如何工作的高层次观点，是后续学习的实用梗概。</p>
<p>*<a href="https://book.douban.com/subject/2256069/" target="_blank" rel="noopener">《Readings in Database Systems》</a>*，或者以<a href="http://www.redbook.io/" target="_blank" rel="noopener">数据库“红书”</a>更为人知，是由Peter Bailis，Joe Hellerstein和Michael Stonebraker编纂的论文合集。对于那些想要在CS 186课程的水平更进一步的学习者，“红书”应当是下一步。</p>
<p>如果你坚持一定要一本导论教材，那我们推荐Ramakrishnan和Gehrke所著的 <em><a href="https://book.douban.com/subject/1155934/" target="_blank" rel="noopener">《数据库管理系统：原理与设计》</a>*。如需更深一步，Jim Gray的经典著作 *<a href="https://book.douban.com/subject/2586390/" target="_blank" rel="noopener">《Transaction Processing: Concepts and Techniques》</a></em> 值得一读，不过我们不建议把这本书当作首要资源。</p>
<p>如果没有编写足够数量的代码，很难巩固数据库理论。CS 186课程的学生给Spark添加特性，倒是不错的项目，不过我们仅仅建议从零实现一个简单的关系型数据库管理系统。自然，它将不会有太多的特性，但是即便只实现典型的关系型数据库管理系统每个方面最基础的功能，也是相当有启发的。</p>
<p>最后，数据模型往往是数据库中一个被忽视的、教学不充分的方面。关于这个主题，我们推荐的书籍是 *<a href="https://book.douban.com/subject/17915870/" target="_blank" rel="noopener">Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World</a>*。</p>
<p><a href="https://book.douban.com/subject/2256069/" target="_blank" rel="noopener"><img src="../images/66760126-08d27b00-eed4-11e9-82c6-46c571036aa1.jpg" alt="Readings in Database Systems"></a> <a href="https://book.douban.com/subject/1155934/" target="_blank" rel="noopener"><img src="../images/66760358-85655980-eed4-11e9-9130-66d2ecea5700.jpg" alt="数据库管理系统：原理与设计"></a></p>
<h3 id="编程语言与编译器"><a href="#编程语言与编译器" class="headerlink" title="编程语言与编译器"></a>编程语言与编译器</h3><p>多数程序员学习编程语言的知识，而多数计算机科学家学习编程语言 <em>相关</em> 的知识。这使得计算机科学家比起程序员拥有显著的优势，即便在编程领域！因为他们的知识可以推而广之：相较只学习过特定编程语言的人，他们可以更深入更快速地理解新的编程语言。</p>
<p>权威的导论书籍是 *<a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener">《编译原理》</a>*，通常称为“龙书”。不幸的是，这本书不是为自学者而设计的，而是供教师从中挑选一些主题用于1-2学期的教学。因此十分重要的是，你需要从中甄选主题，而且最好是在导师的帮助下。</p>
<p>如果你选择使用龙书进行自学，我们建议依据某个视频课程来设定学习的结构，然后按需从龙书中获取深入的内容。我们推荐的在线课程是<a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about" target="_blank" rel="noopener">Alex Aiken在Stanford的MOOC平台Lagunita所开设的</a>。</p>
<p>我们所推荐的龙书替代品是Terence Parr所著的 *<a href="https://book.douban.com/subject/10482195/" target="_blank" rel="noopener">《编程语言实现模式》</a>*。这本书更加直接地面向那些想要着手于诸如DSL的小型编程语言项目的软件工程师，因此从你的角度来看可能会更加实用。当然，这样做牺牲了一些有价值的理论内容。</p>
<p>对于项目练习，我们建议为诸如COOL的简单教学语言或者你所感兴趣的某个语言的一个子集写一个编译器。如果感觉这样的项目让人生畏，可以先从<a href="https://github.com/kanaka/mal" target="_blank" rel="noopener">Make a Lisp</a>开始，在一步步的指引下完成项目。</p>
<p><a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener"><img src="../images/66760486-ca898b80-eed4-11e9-80ba-df298ac8d5da.jpg" alt="编译原理"></a><a href="https://book.douban.com/subject/10482195/" target="_blank" rel="noopener"><img src="../images/66760488-cb222200-eed4-11e9-846e-e4c6fa0d75d2.jpg" alt="编程语言实现模式"></a></p>
<blockquote>
<p>不要做一个只写样板代码的程序员。相反，给用户和其他程序员创造工具。从纺织工业和钢铁工业中学习历史教训：你想制造机器和工具，还是操作这些机器？</p>
<p>— Ras Bodik 在他的编译器课程伊始</p>
</blockquote>
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>随着计算机在数量上的增加，计算机同样开始 <em>分散</em>。尽管商业公司过去愿意购买越来越大的大型机，现在的典型情况是，甚至很小的应用程序都同时在多台机器上运行。思考这样做的利弊权衡，即是分布式系统的研究所在，也是越来越重要的一项技能。</p>
<p>对于自学者，我们推荐的教材是Maarten van Steen和Andrew Tanenbaum所著的 <em>《分布式系统原理与范型》（<a href="https://book.douban.com/subject/3108801/" target="_blank" rel="noopener">中文第二版</a>，<a href="https://book.douban.com/subject/26979326/" target="_blank" rel="noopener">英文第三版</a>）</em>。相较之前的版本，第三版有巨大的改进，并且多亏了其作者的慷慨，这本书在网上可以免费获得。考虑到分布式系统是一个迅速变化的领域，没有教材可以完全作为路标指引，不过就我们所见，这本书是基础扎实的最佳总览。</p>
<p><a href="https://www.youtube.com/watch?v=hBWfjkGKRas&list=PLkcQbKbegkMqiWf7nF8apfMRL4P4sw8UL" target="_blank" rel="noopener">MIT的6.824</a>（研究生课程）是一门在网络有部分视频的优秀课程，不过不幸的是，录像中的声音质量很差，并且不确定这些录像是否经过许可。</p>
<p>不管选择怎样的教材或者其他辅助资料，学习分布式系统必然要求阅读论文。<a href="http://dsrg.pdos.csail.mit.edu/papers/" target="_blank" rel="noopener">这里</a>有一个不错的论文清单，而且我们强烈建议你出席你当地的<a href="http://paperswelove.org/" target="_blank" rel="noopener">Papers We Love</a>（仅限美国）。</p>
<p><a href="https://book.douban.com/subject/3108801/" target="_blank" rel="noopener"><img src="../images/66760565-f73da300-eed4-11e9-90e9-85c0498de233.jpg" alt="分布式系统原理与范型"></a></p>
<h2 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h2><h3 id="人工智能-计算机图形学-XX主题怎么样？"><a href="#人工智能-计算机图形学-XX主题怎么样？" class="headerlink" title="人工智能/计算机图形学/XX主题怎么样？"></a>人工智能/计算机图形学/XX主题怎么样？</h3><p>我们试图把计算机科学主题清单限制到那些我们认为 <em>每一个软件工程师</em> 都应该了解的内容，不限于专业或行业。拥有了这些基础，你将能更加轻松地挑选教材或论文，然而无需指引地学习核心概念。在这里，我们给出一些其他常见主题的自学起点：</p>
<ul>
<li>人工智能：通过观看视频并完成Pacman项目来学习<a href="http://ai.berkeley.edu/" target="_blank" rel="noopener">Berkeley的AI课程</a>。至于教材，使用Russell和Norvig编写的 *<a href="https://book.douban.com/subject/25796281/" target="_blank" rel="noopener">《人工智能：一种现代方法》</a>*。</li>
<li>机器学习：学习吴恩达在Coursera上的课程。耐心学习，先确保理解了基础概念再奔向类如深度学习的诱人新主题。</li>
<li>计算机图形学：学习<a href="http://inst.eecs.berkeley.edu/~cs184/fa12/onlinelectures.html" target="_blank" rel="noopener">Berkeley CS 184课程</a>的材料，使用<a href="https://book.douban.com/subject/30402778/" target="_blank" rel="noopener">《计算机图形学：原理及实践》</a>作为教材。</li>
</ul>
<h3 id="一定要严格遵守推荐的学习次序吗？"><a href="#一定要严格遵守推荐的学习次序吗？" class="headerlink" title="一定要严格遵守推荐的学习次序吗？"></a>一定要严格遵守推荐的学习次序吗？</h3><p>事实上，所有主题之间都有一定程度的重叠，彼此循环引用。以离散数学和算法的关系为例：先学习数学可以帮助你更深入地分析和理解算法，然而先学习算法可以为学习离散数学提供更大的动力和应用背景。理想情况下，你将在你的职业生涯多次重温二者。</p>
<p>因此，我们所推荐的次序主要是为了帮助你 <em>起步</em>……如果你出于某种强烈的原因而倾向以不同的顺序学习，那也没有关系，勇敢开始吧！不过在我们看来，最重要的“先决条件”是：先学计算机架构再学操作系统或数据库，先学计算机网络和操作系统再学分布式系统。</p>
<h3 id="这份指引的目标受众是？"><a href="#这份指引的目标受众是？" class="headerlink" title="这份指引的目标受众是？"></a>这份指引的目标受众是？</h3><p>我们面向自学的软件工程师、培训班学生、“早熟的”高中生或者想要通过自学补充正式教育的大学生。关于何时开启这段自学旅程，完全取决于个人，不过多数人在有一定的职业经历后深入学习计算机科学理论会获益匪浅。比如，我们注意到，如果学生在工作中曾经使用过数据库，他们会 <em>喜爱</em> 学习数据库系统课程；如果学生从事过一两个Web项目，他们会 <em>喜爱</em> 学习计算机网络。</p>
<h3 id="和Open-Source-Society、freeCodeCamp-curricula等比起来，这份指引"><a href="#和Open-Source-Society、freeCodeCamp-curricula等比起来，这份指引" class="headerlink" title="和Open Source Society、freeCodeCamp curricula等比起来，这份指引?"></a>和Open Source Society、freeCodeCamp curricula等比起来，这份指引?</h3><p><a href="https://github.com/open-source-society/computer-science" target="_blank" rel="noopener">OSS指引</a>涵盖太多主题，在许多主题中推荐劣质资源，没有就特定课程哪些方面有价值提供原因或指引。我们努力对这份指引中的课程加以限制，仅仅包括那些你作为软件工程师 <em>确实需要了解的</em>，不论你的专业方向，并且对每门课程为何必要做出了解释以帮助你理解。</p>
<p>FreeCodeCamp主要关注编程，而不是计算机科学。至于你为什么要学习计算机科学，参见<a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#为什么要学习计算机科学" target="_blank" rel="noopener">上文</a>。</p>
<h3 id="XX编程语言怎么样"><a href="#XX编程语言怎么样" class="headerlink" title="XX编程语言怎么样?"></a>XX编程语言怎么样?</h3><p>学习一门特定的编程语言和学习计算机科学的一个领域完全不在一个维度——相比之下，学习语言 <em>容易</em> 且 <em>缺乏价值</em>。如果你已经了解了一些语言，我们强烈建议遵照我们的指引，然后在学习的空当中习得语言，或者暂且不管以后再说。如果你已经把编程学得不错了（比如学完了 <em>《计算机程序的构造和解释》</em>），尤其是如果你学习过编译器，那么面对一门新的语言，你只需要花一个周末稍多的时间即可基本掌握。</p>
<h3 id="XX流行技术怎么样"><a href="#XX流行技术怎么样" class="headerlink" title="XX流行技术怎么样?"></a>XX流行技术怎么样?</h3><p>没有任何一种技术的重要程度可以达到学习其使用足以成为计算机科学教学的核心部分。不过，你对学习那门技术充满热情，这很不错。诀窍是先从特定的技术回退到基本的领域或概念，判断这门流行技术在技术的宏观大局中位于何处，然后才深入学习这门技术。</p>
<h3 id="为什么你们还在推荐龙书"><a href="#为什么你们还在推荐龙书" class="headerlink" title="为什么你们还在推荐龙书?"></a>为什么你们还在推荐龙书?</h3><p>龙书依旧是内容最为完整的编译器单本书籍。由于过分强调一些如今不够时新的主题的细节，比如解析，这本书招致了恶评。然而事实上，这本书从未打算供人一页一页的学习，而仅仅是为了给教师准备一门课程提供足够的材料。类似地，自学者可以从书中量身按需挑选主题，或者最好依照公开课授课教师在课程大纲中的建议。</p>
<h3 id="如何便宜获取教材"><a href="#如何便宜获取教材" class="headerlink" title="如何便宜获取教材?"></a>如何便宜获取教材?</h3><p>我们所建议的许多教材在网上都可以免费获得，这多亏了作者们的慷慨。对于那些不免费的书籍，我们建议购买旧版本的二手书籍。广而言之，如果一本教材有多个版本，旧版本大概率是完全足够使用的。即便新版本的价格是旧版本的10倍，新版本也绝不可能比旧版本好10倍！</p>
<p><strong>中文翻译新增：</strong> 事实上，比起美国，在国内购买技术书籍可以说是相当“廉价”了。如果仍旧寻求更加便宜的购买渠道，可以参考这篇V2EX上的<a href="https://www.v2ex.com/t/578615" target="_blank" rel="noopener">讨论帖子</a>，其中提到了一些不错的购买渠道。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9F%9F%E9%BB%91%E6%80%BB%E6%8A%93%E7%9D%80%E6%B2%B3%E5%8D%97%E5%92%8C%E4%B8%9C%E5%8C%97%E4%B8%8D%E6%94%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9F%9F%E9%BB%91%E6%80%BB%E6%8A%93%E7%9D%80%E6%B2%B3%E5%8D%97%E5%92%8C%E4%B8%9C%E5%8C%97%E4%B8%8D%E6%94%BE/" class="post-title-link" itemprop="url">为什么中国地域黑总抓着河南和东北不放</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-03 23:14:43" itemprop="dateCreated datePublished" datetime="2020-03-03T23:14:43-05:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-04 00:16:08" itemprop="dateModified" datetime="2020-03-04T00:16:08-05:00">2020-03-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>东北比较好理解，引爆点就是当年的下岗。</p>
<p>当年九五年后家里在南方涉及点娱乐买卖的朋友应该有印象，声色场所里，门口站着的多是东北的爷们，里面躺着的多是东北的姑娘。一直到现在，这都是很多小店的常态。</p>
<p>很多东北朋友非常耻于提起这些现象，但我觉得忘记就是背叛。这是一场国家级的背叛，数千万根据国家意志已经结构化的产业工人，被国家以各种冠冕堂皇的词汇剥夺了被许诺的隐形资产权力，然后弃之如敝履，扔到他们非常不适应的市场上自生自灭。</p>
<p>多少跳楼，多少围堵政府大楼，多少举家煤气自杀，多少捡菜叶子过活。说实话，没有酿成更严重的事件，已经是某种意义上东北人对国家的谅解。最后逼得相当数量共和国昔日的产业工人去涉黄涉黑，责任在谁头上，大家自己清楚。</p>
<p>东北人那段时间在黑黄一路上从业者比例急升，自然会引起普通人的歧视。只是悲哀的是，普通人不去问谁是这一现象的制造者，却去指责这件事的受害者，弱者抽刀，确实是向更弱者。</p>
<p>但更悲哀的是，从大量的反馈上来看，东北人似乎没有因为这次被国家的背叛而丧失对国家的信任。官僚主义、对体制的推崇、对市场经济的不信任，东北地区都是全国范围内的屈指可数。跟其他某些较推崇体制的省份不同，考虑到东北工人群体一直都遭到比较严重的利益损害，我有些难以理解。</p>
<p>或许历史的反作用力，需要时间。</p>
<hr>
<p>而河南的问题，则可以说是歧视农民工的一个典型代表。</p>
<p>河南很不幸地满足了三个比较罕有的特征：</p>
<p>人口大省；<br>劳务输出大省；<br>覆盖全国多种日常行业。</p>
<p>这就意味着，各地的普通人，日常都有着大量机会遇到从事低端产业的河南农民工。</p>
<p>例如，安徽也是高比例的劳务输出大省，但是北方地区对安徽人的歧视明显比东部少，因为安徽的劳务人口东部就可以消化；</p>
<p>四川也是劳务输出大省，人口也足够多，但是早期四川是以建筑行业为主，集中居住集中管理，与当地居民互动较少。所以即使四川人建了中国一半以上的楼，很多本地普通人对四川人这个概念依然感知淡薄；</p>
<p>最后像湖北输出农民工，凭借九省通衢的地理位置和重商的传统，虽然遍布全国也渗透至多种日常行业，但是体量摊到全国来说不算大，所以也没有成为被歧视的重灾区。</p>
<p>河南三点都满足，唉。</p>
<p>农民工的教育水平、收入水平、福利水平摆在那里，形象和素质是可以预判的，犯罪率是算的出来的。加上农民工必然和当地的劳务人员抢夺就业机会，最后产生的不满是肯定的。</p>
<p>也就是说，这不涉及到道德判断也不涉及到地域区别，这就是一道数学题。你把这些条件给任何一个省份，他们最后遭到的舆论结果都是一样的。</p>
<p>而在这个过程中，我们在城乡二元制这个系统上，随着开左灯往右转，诞生了一批有能力建构话语体系的城市小资阶级。他们在面临每日大资本和体制的剥削下，需要明确一个能够在他们之下的阶层，他们也是要向下获取资源的，资本上，权力上，舆论上。</p>
<p>河南，就决定是你了！</p>
<hr>
<p>我祖上山东。后来清末黄河改道，举家迁到河南洛阳，住了几十年。到我爷爷那辈跟着红军打过了长江，在南昌复员。我父母那辈广东改革开放缺老师，俩语文老师就这么带着我去了佛山。最后浦东新区开发，老爸在浦东买了房。</p>
<p>曾有个北京认识的“长辈”语重心长地对我说：别说你是河南人，名声不好；也别说你是广东人，北方人对广东人有很多偏见；说江西人嘛没什么印象（不愧是阿卡林省！）；上海人也不行，男的会被笑。就说你是山东人吧！</p>
<p>我现在走南闯北已经十年了，愈发理解到何为“人是环境的动物”：农业时代，有险可守的平原是帝王之资；工业时代，靠海的矿山工厂可以获利全球；海权时代，深水良港是必争之地；陆权时代，十字路口是膏腴之地。</p>
<p>人？人只是那些无数因素集合的一个界面。知乎喜欢强调个人的奋斗，但是当我们看到成千上万在挣扎时，为什么不思考一下背后历史的进程？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/%E6%97%A5%E9%9F%A9%E7%9A%84%E5%89%8D%E9%80%94%E5%B7%B2%E8%A2%AB%E4%B8%AD%E7%BE%8E%E9%94%81%E4%BD%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/%E6%97%A5%E9%9F%A9%E7%9A%84%E5%89%8D%E9%80%94%E5%B7%B2%E8%A2%AB%E4%B8%AD%E7%BE%8E%E9%94%81%E4%BD%8F/" class="post-title-link" itemprop="url">日韩的前途已被中美锁死</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-03 23:12:43" itemprop="dateCreated datePublished" datetime="2020-03-03T23:12:43-05:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-04 00:14:23" itemprop="dateModified" datetime="2020-03-04T00:14:23-05:00">2020-03-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>日韩的前途已被中美锁住，但还没彻底锁死。什么时候“世界人民大团结万岁”不见了，那就是彻底锁死了。</p>
<p>上头已经讲了新兴大国和守成大国的故事，也直接点明了修昔理德陷阱，意见应该是已经统一了：闷声大发财的时代早已结束，大家都是资深玩家，现在到了放在台面上讲的时候。还打哈哈，既没有效果，又侮辱人智商。</p>
<p>过去你是逍遥派，群众基础不错，也不闹事，就那么点家伙什，书记看你那个吊样也就睁一只眼闭一只眼；</p>
<p>现在你翅膀硬了，轻则单干重则造反，你让老书记心里怎么想？</p>
<p>所以第一点：老大要搞你。这是肯定的，不管互访多少次编多少名词绑定多少利益，老大就是要搞你。这一点上可以说“放弃幻想，准备战斗”。</p>
<p>第二点就很简单，大家都有DuangDuangDuang，只能文斗不能武斗。所以软刀子、低烈度、长期拉锯、多种姿势，成为当下大国撕逼的主流特征；</p>
<p>第三点最微妙：除了少数地缘躲无可躲的国家，多数国家也想搞死你，但是他们搞死你的热情程度是有差距的。</p>
<p>有的是巴不得踏上一万只脚叫你永不翻身；</p>
<p>有的希望你安静地去死；</p>
<p>有的希望你别死那么快，先顶一会；</p>
<p>有的觉得你不死不活挺好。</p>
<p>看清楚以上三点，我们再翻一翻历史，这个节点上做人老二有两种路径：</p>
<p>路径A：皇帝轮流做今年到我家，兄弟们并肩子上啊！</p>
<p>这个版本很决绝，要么天命要么德日苏。虽然这是对修昔理德陷阱最干脆的回答，但是这操作太好被预测，又没什么余地，非常不中国，我们也远没有达到这个力量对比转折点；</p>
<p>一旦失败，我们就会沦为现有国际秩序的祭品与肥料，一面滋养他们，一面做京观；</p>
<p>路径B：周天下三分有其二，犹能事殷；</p>
<p>不冲突不对抗已经说到美国人都会背了，考虑到我们不是像昭和日本一样无耻欺诈的国家，这个应该是表里一致的调子。从这个调子来看，我们是要搞“唾面自干、养老送终”型互动方式。</p>
<p>这种方式最大的好处就是，我和现有国际秩序是一体的，也就是我尊王攘夷。时间没到，我是负责任的孙子你不好动我；时间到了，三劝三让，为天下苍生辛苦一下也是可以的。</p>
<p>也就是“嘴上笑嘻嘻，手上掐鸡鸡。再干五十年，你看谁傻逼”。再直白一点就是岳不群道路，看着左冷禅浪，支持左冷禅浪，创造机会让他浪死。</p>
<p>可惜这个世界没有令狐冲…</p>
<p>那扯这么多中美的爱恨情仇是为了什么捏？因为中美关系是全球核心关系，也是日韩首先要梳理的关系。</p>
<p>日韩必然是中美关系的角力场，双方政治力量在该地的持续拉锯必然会造成国家的撕裂与混乱，这是夹缝国家的常态。</p>
<p>但是日韩在这种持续低烈度的拉锯下，既不会走向内部统合乃至彻底站队，也不会走向全面撕裂对抗清算。我在出租屋里吃着方便面看着欣慰联播听着房东砸门催房租的声音，给日韩的未来起了个动听的名字：</p>
<p>异化国家的国家异化。</p>
<p>你看民科起的名字都霸气。</p>
<p>异化国家好理解，就是国家主权、特别是军事主权的不能自主。日韩在建国初，因为历史原因，把自己的核心国家主权，军事主权，交易掉了。</p>
<p>军事主权是一个国家的核心主权，一个国家捍卫自己与威胁他国的力量不能够自主，就会对该国在外交乃至国内政治上产生极大的异化压力，其国家决策能力就会存在极大的摇摆性。</p>
<p>谈判的基础是筹码的真实与稳定，筹码不可信则谈判不可信。上面这些相信大家是有共识的，也被中日韩之间多个无疾而终的整合动作所证实。</p>
<p>下面就是我和一些比较乐观的朋友有分歧的地方：</p>
<p>因为军事主权被交易掉了，而且实际来说，低烈度的收回主权方式几乎不存在，遏制美国掌握军事主权后对其他国家主权渗透的方式也几乎不存在。所以面临中国持续的经济辐射与逐步成型的军事压力，日韩有可能选择妥协，但也可能选择国家异化。</p>
<p>我认为这种国家异化，是指自身存在无法交易的他国力量，为了使该力量的存在合理化，无视、扭曲本国自身利益，异化本国政治社会环境，选择对抗冲突，进而形成对抗的合理性，补偿和平所能获得的利益。</p>
<p>好比身体脏器长了个结石，你又没办法做手术取出来，脏器就会产生各种千奇百怪而且非常痛苦的代偿异化。</p>
<p>日韩固然有很多人明白与中国共存共生的重要性与必然性，很多人也为此不懈努力。然而军事主权的傀儡化会让一切努力都面临极大不确定性。于是乎从实际角度出发，选择与美国坚定一路的人也越来越多。</p>
<p>要注意，在中国将起未起时，日韩对美斗争其实是很激烈的，他们很多人还寄望借助中国的力量来杠杆回自己的国家主权。结果吊诡的是，中国崛起后，依附美国的声音反而前所未有地大了起来。</p>
<p>日韩的国家异化正在发生。</p>
<p>面临日韩美国仆从国的政权本质，中国的策略也必然会从谈判转向全面威慑；</p>
<p>而对日韩的全面威慑并不是真正对美国的威慑，所以美国并不会为中国对日韩的威慑而做出国际政治利益的实质让步；</p>
<p>而遭受中国威慑的日韩并不能做出合理合逻辑的反馈，于是内部压力与混乱升级；</p>
<p>还好，在中国现有的经济辐射下，这类恶性反馈链条还没有跑起来。我想这也是为什么上头说要让大家都来搭便车。</p>
<p>但是如果中国经济发展不好，或者好到威胁日韩的核心产业…像日本的精工啊材料啊韩国的半导体啊电子供应链啊…</p>
<p>所以说啊同志们，自立自主是很重要滴！</p>
<p>土地就那么多，不分，人就要饿死；分，过个几十年，人就牢牢地长在土地里，其他人慢慢饿死。等到饿死的人足够多了，没饿死的人就会用刀把土地再分一次。</p>
<p>我们总是为加足马力开工的工厂感到高兴，那是繁荣的象征。可是当工厂生产出来的罐头没人买怎么办？不要紧，生产子弹，子弹一定有人买的。</p>
<p>世界每一次大融合的巅峰，就是大战争的前夜。当人们为国际间的交流欢呼时，足以流干几千万人血的仇恨就开始蔓延。</p>
<p>第二名最惨：第一名防着他，第三名追赶他。而且比起第二名联合其他人打倒第一名，第一名联合其他人打倒第二名要容易的多。</p>
<p>每一块大陆最终只有一个文明，但每一个小岛都是一个王国。他们窥探大陆，学习大陆，但永远是独立的。</p>
<p>处于战争与饥荒的人，不用一年就会感到麻木，对死亡习以为常；而在太平盛世中成长的人，文字与画面的阅读不会留下什么印象。那些昔日的错误随着时间而日渐陌生，历史必将重演，只是时间问题。</p>
<p>精英对底层民众既有不屑也有同情，不屑可能是他们在经验上的优势，但同情绝对是他们的护身符。不同情底层民众的精英已经绝种了。</p>
<p>文化真正要扩张，只能是DNA的扩张。没有DNA做载体的文化扩张就和“神圣罗马帝国”这六个字一样可笑。</p>
<p>曾经有人想垄断钢锻造技术，还有人想垄断马克沁机枪技术，还有人想垄断坦克技术。我们知道他们都失败了，可我们今天相信能垄断核技术。</p>
<p>血脉认同是一个很有意思的概念，这基本是人的一种生物性反馈。当它强大的时候，它能弥合许多现实利益冲突，但是当它瓦解时，那些冲突会以十倍的代价反噬。</p>
<p>总有一个艰难创业的开始，总有一个卧薪尝胆的发展，总有一个扬眉吐气的抬头，总有一个得意忘形的失败，总有一个无可奈何的崩溃。愚蠢的人试图逆转，聪明的人努力把下限控制在可接受范围。</p>
<p>我翻了好久的书，从来没有在历史里发现平等二字。我只看到了有钱的、有枪的、有笔的人要求赋予自己对应的地位。</p>
<p>有些英雄人物的诞生，是多个变量的合力结果。有的变量属于人民，有的变量属于自然，有的变量属于英雄自己。</p>
<p>人的性命与道德从来都有明确的价码，他们是多个交易上最常见的交易品。另一端的交易品往往是货币和领土，交易方式基本为战争。</p>
<p>成立一个国家很像开一家公司，人的血就是注册资金。如果你开公司的时候没有把注册费用交够，公司日常运行效率会大打折扣。</p>
<p>历史中唯一存在的平等，大概就是死亡：他不在乎男女老少贫富贵贱，迟早会到来。感谢死亡，多少人命与金钱无法解决的辩论因你终结。</p>
<p>我不知道正义与邪恶是何物，我看到的只有秩序与混乱的永恒斗争。他们相杀，他们相生，像一对阴阳鱼，在历史里形成了一道道惊艳的曲线。</p>
<p>历史可能是个近视眼，他经常没办法把报应放到个人身上，而是常常投射到那一整个群体。所以他的清单经常漏掉一些人，不过你从整个数量上来看，还是很严谨的。</p>
<p>圣人看着历史的车轮说：我知道你要开向哪；神人挡着历史的车轮说：有我在，你就无法开过去。这种人确实存在。</p>
<p>科技是历史的第一推动力，不管繁荣还是战争。至于怎么把故事说完，这个任务由意识形态完成。</p>
<p>但科技不是一直推动历史发展，他是一波一波推动的。在这个中间，分配的重要程度压过了科技。他还有个名字，叫政治。</p>
<p>我不是历史学者，我充其量就是个历史爱好者。福山先生说历史有终结，尽管读完他的史料与推导，我依然无法认同。历史没有唯一解，历史是在不断的偏差与修正中产生多个精彩的文明。如果什么时候人类面临着真正的历史唯一解，我想，那就是人类的灭亡。</p>
<p>历史里有许多足以改变进程的小细节：一条山脉、一种可驯养的马匹、一种高淀粉作物、一种高强度材料，甚至战场上一次狠不下心的宽恕，都能给历史带来意想不到的改变。</p>
<p><strong>如果宗教是鸦片，那么历史就是海洛因。喜欢历史的人很难对宗教提起兴趣，刺激的量级差太大了。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%8C%91%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%8C%91%E6%88%98/" class="post-title-link" itemprop="url">分布式系统相关挑战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-02 22:23:50 / Modified: 23:24:43" itemprop="dateCreated datePublished" datetime="2020-03-02T22:23:50-05:00">2020-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从我们添加第二台服务器的那一刻起，分布式系统就已融入 Amazon。1999 年，我初到 Amazon 之时，服务器非常少，少到我们甚至可以给部分服务器命名（如“fishy”或“online-01”），以便于识别它们。然而，即便是在 1999 年，分布式计算也并非易事。与现在一样，分布式系统同样面临着诸多挑战，包括延迟、扩展、理解网络 API、数据编组和解组以及 Paxos 等算法的复杂性。随着系统的不断快速扩展和分布程度的不断提高，理论上的边缘情况成为了常态。</p>
<p>开发分布式实用程序计算服务（例如可靠的长途电话网络或 Amazon Web Services (AWS) 服务）比较困难。与其他形式的计算相比，分布式计算也<em>更古怪</em>，而且<em>不够直观</em>，因为它存在两个相互关联的问题。在分布式系统中，造成最大问题的是<strong>故障独立性</strong>和<a href="https://sampa.cs.washington.edu/new/papers/asplos021-hunt.pdf" target="_blank" rel="noopener">不确定性</a>。在分布式系统中，除了大多数工程师习以为常的计算故障外，故障还会以许多其他方式出现。更糟糕的是，不可能时刻知晓某事项是否发生了故障。</p>
<p>在整个 Amazon 构建者库中，我们介绍了 AWS 如何处理分布式系统产生的复杂的开发和运营问题。在探讨其他文章对于这些技术的详细介绍之前，我们有必要先来了解一下为什么分布式计算如此古怪。首先，我们来了解一下分布式系统的类型。</p>
<h2 id="分布式系统的类型"><a href="#分布式系统的类型" class="headerlink" title="分布式系统的类型"></a>分布式系统的类型</h2><p>实际上，分布式系统在实施过程中是存在难易差异的。一方面，我们有 <em>离线</em>分布式系统。其中包括批处理系统、大数据分析集群、电影场景渲染农场、蛋白质折叠集群等。虽然离线分布式系统实现起来并不容易，但它却几乎囊括了分布式计算的所有优点（可扩展性和容错能力），而且几乎没有缺点（复杂的故障模式和不确定性）。</p>
<p>另一方面，我们有 <em>软实时</em>分布式系统。这些是必须不断产生或更新结果的重要系统，但是它们有一个相对充裕的时间窗口来执行这些操作。此类系统包括部分搜索索引生成器、搜寻受损服务器的系统、Elastic Compute Cloud (Amazon EC2) 的角色等等。搜索索引器可能会有 10 分钟到数小时的时间（具体取决于应用程序）处于离线状态，但不会对客户造成不当影响。Amazon EC2 的角色必须将更新的凭证推送到（基本上）每个 EC2 实例，但是它有几个小时的时间来执行此操作，因为旧凭证在一段时间过后才会过期。</p>
<p>最后一方面，我们有 <em>硬实时</em>分布式系统，这也是最难实现的分布式系统。我们通常将其称之为请求/回复服务。在 Amazon，当我们考虑构建分布式系统时，首先想到的类型是硬实时系统。然而，硬实时分布式系统是最难实现的。难以实现的原因是，无法预计请求的到达但又必须迅速对其做出响应（例如，客户正在热切等待响应）。示例包括前端 Web 服务器、订单管道、信用卡交易、每个 AWS API、电话通讯等。本文将重点介绍硬实时分布式系统。</p>
<h2 id="硬实时系统非常古怪"><a href="#硬实时系统非常古怪" class="headerlink" title="硬实时系统非常古怪"></a>硬实时系统非常古怪</h2><p>在《超人》漫画中有这样一个故事情节：超人遇到了名叫 <em>Bizarro</em> 的另一个自我，Bizarro 生活在一个规则相反的行星 (<em>Bizarro World</em>) 上。Bizarro <em>外表</em>与超人相似，但他实际上是个反派人物。硬实时分布式系统亦是如此。它们表面上酷似常规计算，但实际上并不相同；坦率地说，有点“邪恶”。</p>
<p>硬实时分布式系统的开发之所以奇怪是因为：请求/回复网络。我们并<em>不</em>是指 TCP/IP、DNS、套接字或其他此类协议的具体细节。这些主题可能难以理解，但与计算中的其他难题相似。</p>
<p>硬实时分布式系统的难点在于网络允许将消息从一个<em>容错域</em>发送到另一个容错域。发送消息似乎没有什么危害。但事实上，发送消息是一切变得比正常情况更加复杂的源头。</p>
<p>举一个简单的例子，我们来看一下 Pac-Man 实施中的以下代码段。它只在单台计算机上运行，不通过任何网络发送任何消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">board.move(pacman, user.joystickDirection())</span><br><span class="line">ghosts = board.findAll(":ghost")</span><br><span class="line">for (ghost in ghosts)</span><br><span class="line">  if board.overlaps(pacman, ghost)</span><br><span class="line">    user.slayBy(":ghost")</span><br><span class="line">    board.remove(pacman)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>

<p>现在，我们假设要开发此代码的联网版本，在一个单独的服务器上维护 board 对象的状态。对 board 对象（例如 findAll()）的每次调用都会导致在两台服务器之间发送和接收消息。</p>
<p>每当在两台服务器之间发送请求/回复消息时，<em>从始至终</em>一定会至少发生同样的一组八个步骤。要了解联网的 Pac-Man 代码，我们先来了解请求/回复消息收发的基础知识。 </p>
<h2 id="通过网络进行请求-回复消息收发"><a href="#通过网络进行请求-回复消息收发" class="headerlink" title="通过网络进行请求/回复消息收发"></a>通过网络进行请求/回复消息收发</h2><p>一个请求/回复往返操作始终需要执行相同的步骤。如下图所示，客户端计算机 CLIENT 通过网络 NETWORK 向服务器计算机 SERVER 发送请求 MESSAGE，SERVER 也通过网络 NETWORK 回复消息 REPLY。</p>
<p><img src="../images/reply-messaging-across-network.e70d2f48b08da1b3b4b234fee7f4ee6f335a8373.png" alt="reply-messaging-across-network"></p>
<p>在一切正常的情况下，会执行以下步骤：</p>
<p>1.<strong>POST REQUEST</strong>：CLIENT 将请求 MESSAGE 放到 NETWORK 上。<br>2.<strong>DELIVER REQUEST</strong>：NETWORK 将 MESSAGE 传送到 SERVER。<br>3.<strong>VALIDATE REQUEST</strong>：SERVER 验证 MESSAGE。<br>4.<strong>UPDATE SERVER STATE</strong>：如有必要，SERVER 根据 MESSAGE 更新其状态。<br>5.<strong>POST REPLY</strong>：SERVER 将回复 REPLY 放到 NETWORK 上。<br>6.<strong>DELIVER REPLY</strong>：NETWORK 将 REPLY 传送到 CLIENT。<br>7.<strong>VALIDATE REPLY</strong>：CLIENT 验证 REPLY。<br>8.<strong>UPDATE CLIENT STATE</strong>：如有必要，CLIENT 根据 REPLY 更新其状态。</p>
<p>这只是往返一次就发生的诸多步骤！ 然而，这些步骤就是通过网络请求/回复通信的<em>定义</em>，无法跳过它们之中的任何一个步骤。例如，不可能跳过步骤 1。客户端必须以某种方式将 MESSAGE 放到网络 NETWORK 上。从物理角度讲，这意味着要通过网络适配器发送数据包，这会导致电子信号通过一系列路由器（构成 CLIENT 和 SERVER 之间的网络）在电线上传输。这与步骤 2 是分开的，因为步骤 2 可能由于自主原因出现问题，例如 SERVER 突然断电并且无法接受传入的数据包。这一逻辑同样适用于其余步骤。</p>
<p>因此，通过网络的单个请求/回复会将<em>一件</em>事（调用方法）分解为<em>八件</em>事。更糟糕的是，如上所述，CLIENT、SERVER 和 NETWORK 可能会彼此<em>独立地</em>发生故障。工程师的代码必须处理上文提及的<em>任何</em>步骤发生的故障。典型的工程设计中很少会这样做。要想知晓原因，我们先来了解一下单机版代码中的以下表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board.find("pacman")</span><br></pre></td></tr></table></figure>

<p>从技术角度讲，即使 board.find 的实施本身没有错误，这段代码在运行时也会以一些古怪的方式发生故障。例如，CPU 可能在运行时自发过热。计算机的电源也可能自发地出现故障。内核可能出现恐慌。内存可能已满，无法创建 board.find 想要创建的某些对象。或者，它正在运行的计算机上的磁盘可能已满，board.find 无法更新某些统计文件，然后返回错误（即使可能不应该这样做）。伽马射线可能击中了服务器并剐蹭到 RAM。但是，在大多数情况下，工程师们并不担心这些问题。例如，单元测试永远不会涵盖“如果 CPU 发生故障”的情况，同时也很少涉及内存不足的情况。</p>
<p>在常见的工程设计中，这些类型的故障发生在一台计算机上；即一个<em>容错域</em>。例如，如果 board.find 方法由于 CPU 自发过热而发生故障，则可以肯定地说，整个计算机都处于故障状态。即使是从概念上也不可能处理该错误。可以对上文列出的其他类型的错误做出类似的假设。您可以尝试为其中一些情况编写测试，但是对于典型的工程设计来说，这毫无意义。如果确实发生了这些故障，可以肯定所有其他项也会发生故障。从技术角度讲，我们称他们<em>共担命运</em>。命运共担可极大地减少工程师必须处理的不同故障模式。</p>
<h2 id="硬实时分布式系统中的故障处理模式"><a href="#硬实时分布式系统中的故障处理模式" class="headerlink" title="硬实时分布式系统中的故障处理模式"></a>硬实时分布式系统中的故障处理模式</h2><p>硬实时分布式系统工程师必须对网络故障的所有方面都进行测试，因为服务器和网络<em>不会</em>共担命运。与单台计算机的情况不同，如果网络出现故障，客户端计算机将继续工作。如果远程计算机出现故障，客户端计算机将继续工作，如此等等。</p>
<p>为了详尽测试上文所述的请求/回复步骤的故障情况，工程师必须假定每个步骤都可能发生故障。而且，他们必须确保客户端和服务器上的代码始终能够针对这些故障正确运行。<br>让我们看一下出现问题的请求/回复的一次往返操作：</p>
<p>1.<strong>POST REQUEST 失败</strong>：NETWORK 无法传送消息（例如，中间路由器恰好不合时宜地崩溃），或者 SERVER 明确拒绝了该消息。<br>2.<strong>DELIVER REQUEST</strong> <strong>失败</strong>：NETWORK 已成功将 MESSAGE 传送到 SERVER，但是 SERVER 收到 MESSAGE 后立即崩溃。<br>\3. <strong>VALIDATE REQUEST 失败</strong>：SERVER 判定 MESSAGE 无效。原因可能无所不有。例如，数据包损坏、软件版本不兼容，或者客户端或服务器出现错误。<br>4.<strong>UPDATE SERVER STATE</strong> <strong>失败</strong>：SERVER 尝试更新其状态，但无法更新。<br>5.<strong>POST REPLY 失败</strong>：无论尝试回复成功还是失败，SERVER 都可能无法发布回复。例如，它的网卡可能恰好不合时宜地过热。<br>6.<strong>DELIVER REPLY 失败</strong>：即使 NETWORK 在上文的步骤中可以正常运行，NETWORK 仍可能无法像上文描述的那样将 REPLY 传送给 CLIENT。<br>7.<strong>VALIDATE REPLY 失败</strong>：CLIENT 判定 REPLY 无效。<br>8.<strong>UPDATE CLIENT STATE 失败</strong>：CLIENT 可能会收到消息 REPLY，但是无法更新其自身的状态、无法理解消息（由于不兼容）或由于其他原因而失败。</p>
<p>正是这些故障模式使得分布式计算变得困难重重。我将其称之为<em>天启的八种故障模式</em>。鉴于这些故障模式，让我们再次从 Pac-Man 代码中查看该表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board.find("pacman")</span><br></pre></td></tr></table></figure>

<p>该表达式扩展为以下客户端活动：</p>
<p>1.在网络上发布一条消息（例如 {action: “find”, name: “pacman”, userId: “8765309”}），该网络寻址到 Board 计算机。<br>2.如果网络不可用，或者显式拒绝了与 Board 计算机的连接，则会引发错误。这种情况有些特殊，因为客户端确切地知道服务器计算机可能未收到该请求。<br>3.等待回复。<br>4.如果从未收到回复，则超时。在此步骤中，超时意味着请求的结果为 UNKNOWN。它可能发生过也可能没发生过。客户端必须正确处理 UNKNOWN。<br>5.如果收到回复，则确定是成功回复、错误回复还是回复难以理解/发生损坏。<br>6.如果不是错误，则解组响应并将其转换为代码可以理解的对象。<br>7.如果是错误或无法理解的回复，则会引发异常。<br>8.无论如何处理异常，都必须确定应<em>重试</em>该请求还是放弃并停止操作。</p>
<p>该表达式还会启动以下服务器端活动：</p>
<p>1.收到请求（这可能根本不会发生）。<br>2.验证请求。<br>3.查找用户以查看该用户是否还处于活动状态。（服务器可能已经放弃该用户，因为它很长时间没有收到来自用户的任何消息。）<br>4.更新用户的保持活动表，以便服务器知道他们（可能）仍然还在。<br>5.查找用户的位置。<br>6.发布包含类似 {xPos: 23, yPos: 92, clock: 23481984134} 的响应。<br>7.任何其他服务器逻辑都必须正确处理客户端的后续影响。例如，无法接收消息、接收消息但不理解消息、接收消息但消息崩溃或成功处理消息。</p>
<p>总之，普通代码中的<em>一个表达式</em>在硬实时分布式系统代码中变成了<em>十五个</em>额外的步骤。发生这种扩展的原因是客户端和服务器之间的每次往返通信在八个不同的点都有可能发生故障。任何表示网络往返的表达式（例如 board.find(“pacman”)），都会产生以下结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(error, reply) = network.send(remote, actionData)</span><br><span class="line">switch error</span><br><span class="line">  case POST_FAILED:</span><br><span class="line">    // handle case where you know server didn't get it</span><br><span class="line">  case RETRYABLE:</span><br><span class="line">    // handle case where server got it but reported transient failure</span><br><span class="line">  case FATAL:</span><br><span class="line">    // handle case where server got it and definitely doesn't like it</span><br><span class="line">  case UNKNOWN: // i.e., time out</span><br><span class="line">    // handle case where the *only* thing you know is that the server received</span><br><span class="line">    // the message; it may have been trying to report SUCCESS, FATAL, or RETRYABLE</span><br><span class="line">  case SUCCESS:</span><br><span class="line">    if validate(reply)</span><br><span class="line">      // do something with reply object</span><br><span class="line">    else</span><br><span class="line">      // handle case where reply is corrupt/incompatible</span><br></pre></td></tr></table></figure>

<p>这种复杂性是难以避免的。如果代码无法正确处理所有情况，则该服务最终将以奇怪的方式发生故障。想象一下，若尝试为客户端/服务器系统（例如 Pac-Man 示例）可能遇到的所有故障模式编写测试，难度何其之大！</p>
<h2 id="测试硬实时分布式系统"><a href="#测试硬实时分布式系统" class="headerlink" title="测试硬实时分布式系统"></a>测试硬实时分布式系统</h2><p>测试单机版本的 Pac-Man 代码段相对比较简单。创建一些不同的 Board 对象，将它们置于不同的状态，创建一些不同状态的 User 对象，如此等等。工程师会特别认真地考虑边缘条件，可能会使用生成式测试或模糊测试。</p>
<p>在 Pac-Man 代码中，有四个地方使用 board 对象。在分布式 Pac-Man 中，该代码中有四个点具有五种不同的可能结果，如上文所示（POST_FAILED、RETRYABLE、FATAL、UNKNOWN 或 SUCCESS）。这极大地增加了测试的状态空间。例如，硬实时分布式系统的工程师必须处理许多排列。假设对 board.find() 调用失败，并显示 POST_FAILED。那么，您必须测试当它失败并显示 RETRYABLE 时会发生什么，然后必须测试当它失败并显示 FATAL 时会发生什么，如此等等。</p>
<p>但即使这样，测试也是不够的。在常规代码中，工程师可能会认为，如果 board.find() 有效，那么对 board 的下一个调用 board.move() 也将有效。在硬实时分布式系统工程中，没有这样的保证。服务器计算机随时都有可能发生独立故障。最终，工程师每次调用 board 时都必须针对所有五种情况编写测试。假设工程师提出了 10 种可以在单机版 Pac-Man 中进行测试的情况。但是，在分布式系统版本中，他们必须针对每种情况测试 <em>20</em> 次。这意味着测试矩阵会从 10 膨胀到 200！</p>
<p>但是等等，情况不止如此。工程师<em>也</em>可能拥有<em>服务器</em>代码。无论客户端、网络和服务器端出现怎样的错误组合，工程师都必须进行测试，以便客户端和服务器最终不会处于损坏状态。服务器代码可能如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">handleFind(channel, message)</span><br><span class="line">  if !validate(message)</span><br><span class="line">    channel.send(INVALID_MESSAGE)</span><br><span class="line">    return</span><br><span class="line">  if !userThrottle.ok(message.user())</span><br><span class="line">    channel.send(RETRYABLE_ERROR)</span><br><span class="line">    return</span><br><span class="line">  location = database.lookup(message.user())</span><br><span class="line">  if location.error()</span><br><span class="line">    channel.send(USER_NOT_FOUND)</span><br><span class="line">    return</span><br><span class="line">  else</span><br><span class="line">    channel.send(SUCCESS, location)</span><br><span class="line"></span><br><span class="line">handleMove(...)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">handleFindAll(...)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">handleRemove(...)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>需要测试四个服务器端函数。假设一台计算机上的每个函数都需进行五次测试，那么就需要进行 20 次测试。由于客户端将多条消息发送到同一服务器，因此测试应模拟不同请求的序列，以确保服务器保持稳健运行。请求的示例包括 find、move、remove 和 findAll。</p>
<p>假设一个构造有 10 种不同的场景，每种场景平均有 3 个调用，那么就需要进行超过 30 次测试。此外，一个场景还需要测试故障案例。对于每一个测试，您都需要模拟以下情况：如果客户端收到四种失败类型（POST_FAILED、RETRYABLE、FATAL 和 UNKNOWN）中的任何一种，然后使用无效请求再次调用服务器，将会发生什么情况。例如，客户端可能成功调用了 find，但是在调用 move 时，有时会收到 UNKNOWN。然后出于某种原因，它可能会再次调用 find。服务器是否可以正确处理这种情况？ 也许可以处理。但是如果不进行测试，您就无从知晓。因此，与客户端代码一样，服务器端测试矩阵的复杂性也会呈爆炸式增长。</p>
<h2 id="处理未知的未知情况"><a href="#处理未知的未知情况" class="headerlink" title="处理未知的未知情况"></a>处理未知的未知情况</h2><p>如果要考虑分布式系统可能会遇到的所有故障排列，尤其是在有多个请求时，这简直难以想象。我们发现处理分布式工程设计的一种方法是不信任<em>任何事物</em>。除非不会引发网络不通信，否则每一行代码都可能无法达到预期的效果。</p>
<p>也许最难处理的是上一节中所述的 UNKNOWN 错误类型。客户端无法时时知晓请求是否成功。也许它<em>确实</em>移动了 Pac-Man（或者在银行服务中，从用户的银行账户中提款），或者也许<em>没有</em>。工程师应该如何处理此类情形？ 这很难处理，因为工程师是人，而人往往要在真正的不确定性中挣扎。人类习惯于像下面这样查看代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool isEven(number)</span><br><span class="line">  switch number % 2</span><br><span class="line">    case 0</span><br><span class="line">      return true</span><br><span class="line">    case 1</span><br><span class="line">      return false</span><br></pre></td></tr></table></figure>

<p>人类理解此代码，是因为它执行了它<em>应该</em>执行的操作。分布式版本的代码让人类苦不堪言，它会将一些工作分配给服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool distributedIsEven(number)</span><br><span class="line">  switch mathServer.mod(number, 2)</span><br><span class="line">    case 0</span><br><span class="line">      return true</span><br><span class="line">    case 1</span><br><span class="line">      return false</span><br><span class="line">    case UNKNOWN</span><br><span class="line">      return WHAT_THE_FARG?</span><br></pre></td></tr></table></figure>

<p>人类几乎不可能弄清楚如何正确处理 UNKNOWN。UNKNOWN 的真正含义为何？ 是否应重试代码？ 如果应该，要重试多少次？ 重试之间应等待多长时间？ 当代码有副作用时，情况甚至会更糟。在单台计算机上运行的预算应用程序内部，从账户中提取资金非常容易，如以下示例所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Teller</span><br><span class="line">  bool doWithdraw(account, amount)</span><br><span class="line">    switch account.withdraw(amount)</span><br><span class="line">      case SUCCESS</span><br><span class="line">        return true</span><br><span class="line">      case INSUFFICIENT_FUNDS</span><br><span class="line">        return false</span><br></pre></td></tr></table></figure>

<p>但是，由于出现 UNKNOWN，该应用程序的分布式版本很古怪。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DistributedTeller</span><br><span class="line">  bool doWithdraw(account, amount)</span><br><span class="line">    switch this.accountService.withdraw(account, amount)</span><br><span class="line">      case SUCCESS</span><br><span class="line">        return true</span><br><span class="line">      case INSUFFICIENT_FUNDS</span><br><span class="line">        return false</span><br><span class="line">      case UNKNOWN</span><br><span class="line">        return WHAT_THE_FARG?</span><br></pre></td></tr></table></figure>

<p>在分布式工程设计中，要想知道为什么<em>事情并非总如表现的那样</em>，就需要弄清楚如何处理 UNKNOWN 错误类型。</p>
<h2 id="硬实时分布式系统群"><a href="#硬实时分布式系统群" class="headerlink" title="硬实时分布式系统群"></a>硬实时分布式系统群</h2><p>天启的八种故障模式可以发生在分布式系统中的任何抽象层。上文的示例仅限于一台客户端计算机、一个网络和一台服务器计算机。即使在这种简单的场景中，故障状态矩阵的复杂性也会呈爆炸式增长。与单台客户端计算机示例相比，实时分布式系统具有更复杂的故障状态矩阵。实时分布式系统由多台计算机组成，可以在多个抽象层上进行查看：</p>
<p>1.个别计算机<br>2.计算机组<br>3.计算机组群<br>4.其他（潜在）</p>
<p>例如，在 AWS 上构建的服务可能会将专用于处理特定可用区资源的计算机分成一组。可能还会有另外两组用于处理另外两个可用区的计算机。然后，可以将这些组划分到一个 AWS 区域组。而且，该区域组（逻辑上）可与其他区域组进行通信。然而，即使在这一更高、更合乎逻辑的抽象层，<em>仍然会出现所有相同的问题。</em></p>
<p>假设服务已将某些服务器划分到一个逻辑组 GROUP1。GROUP1 组有时可能会将消息发送到另一组服务器 GROUP2。这是<em>递归分布式工程设计</em>的一个示例。上文所述的所有相同的网络故障模式在此都适用。假设 GROUP1 想要向 GROUP2 发送请求。如下图所示，两台计算机的请求/回复交互就像上文所述的单台计算机一样。</p>
<p><img src="../images/two-machine-request-reply.1e17ff385870b005b8d260d809e34a2e78c7ea95.png" alt="two-machine-request-reply"></p>
<p>无论如何，GROUP1 中的某些计算机必须在（逻辑上）寻址到 GROUP2 的网络 NETWORK 上放置一条消息。GROUP2 中的某些计算机必须处理该请求等等。GROUP1 和 GROUP2 是由计算机组组成的这一事实并未改变基本原则。GROUP1、GROUP2 和 NETWORK 仍然可以彼此独立发生故障。</p>
<p>然而，这只是组级视图。每个组中还存在计算机到计算机级别的交互。例如，GROUP2 的结构可能如下图所示。</p>
<p><img src="../images/group-2-load-balancer.8ca4bed7e09adb925f696172f61b858a50cb1770.png" alt="group-2-load-balancer"></p>
<p>首先，通过负载均衡器将发送到 GROUP2 的消息发送到组中的一台计算机（可能是 S20）。系统设计人员知道 S20 在 UPDATE STATE 阶段可能会发生故障。因此，S20 可能需要将该消息传递给至少一台其他计算机，要么是同组的计算机，要么是其他组的计算机。S20 实际上是如何做到的？ 通过发送请求/回复消息，比如发送给 S25，如下图所示。</p>
<p><img src="../images/send-request.reply-message.ee869a6e7bfeded543dd25150a22f8a562457547.png" alt="send-request.reply-message"></p>
<p>因此，S20 正在递归地执行联网。同样的八个故障可能会再次各自独立地发生。分布式工程设计发生两次，而不是一次。在逻辑层级上，从 GROUP1 传递到 GROUP2 的消息可能会以所有八种方式发生故障。该消息会导致另一条消息（可能自己发生故障）以上文所述的所有八种方式独立发生故障。测试此场景至少涉及以下方面：</p>
<p>• 针对 GROUP1 到 GROUP2 组级消息传递的所有八种方式的测试均可能失败。<br>• 针对 S20 到 S25 服务器级消息传递的所有八种方式的测试均可能失败。</p>
<p>这个请求/回复消息传递示例告诉我们为什么即使在使用分布式系统 20 多年后，测试分布式系统仍然是一个特别棘手的问题。由于存在大量的边缘情况，因此测试颇具挑战性，但它在此类系统中特别重要。部署系统后，错误可能需要很长时间才能浮出水面。而且，错误可能会对系统及相邻系统产生难以预料的广泛影响。</p>
<h2 id="分布式错误通常是潜在的"><a href="#分布式错误通常是潜在的" class="headerlink" title="分布式错误通常是潜在的"></a>分布式错误通常是潜在的</h2><p>如果故障终究要发生，人们普遍认为越早越好。例如，最好找出服务中的扩展问题，这将需要六个月的时间来解决，<em>至少</em>在六个月后，服务才能达到如此规模。同样，最好在错误影响生产之前就找到它们。如果错误确实影响了生产，则最好快速找到它们，以免影响诸多客户或产生其他不利影响。</p>
<p>分布式错误，即那些由于无法处理天启的八个故障模式的所有排列而导致的错误，通常非常严重。随着时间的推移，从电信系统到核心 Internet 系统，大型分布式系统的例子比比皆是。这些故障不仅普遍而且成本高昂，而且几个月前部署到生产中的错误也可能引发这些故障。然后需要一段时间来触发实际导致这些错误发生（并蔓延到整个系统）的场景的组合。</p>
<h2 id="分布式错误的病毒式传播"><a href="#分布式错误的病毒式传播" class="headerlink" title="分布式错误的病毒式传播"></a>分布式错误的病毒式传播</h2><p>我来介绍另一个对于分布式错误至关重要的问题：</p>
<p>1.分布式错误必定涉及网络的使用。<br>2.因此，分布式错误更有可能传播到其他计算机（或计算机组），因为按照定义，它们<em>已经涉及将计算机链接到一起的唯一事项。</em></p>
<p>Amazon 也经历过这些分布式错误。这是一个时间久远但切题的示例，那就是 <a href="http://www.amazon.com" target="_blank" rel="noopener">www.amazon.com</a> 发生全站故障。该故障是由远程目录服务中的一个服务器在其磁盘被填满时出现故障引起的。</p>
<p>由于对该错误状况处理不当，远程目录服务器开始对收到的每个请求返回空响应。此外，它还开始非常快速地返回它们，因为不返回任何东西都比返回东西要快得多（至少在这种情况下如此）。同时，网站和远程目录服务之间的负载均衡器没有注意到所有响应的长度均为零。但是，它<em>确实</em>注意到它们比所有其他远程目录服务器快得多。因此，它从 <a href="http://www.amazon.com" target="_blank" rel="noopener">www.amazon.com</a> 向磁盘已满的一台远程目录服务器发送了大量流量。事实上，整个网站都瘫痪了，因为一台远程服务器无法显示任何产品信息。</p>
<p>我们迅速找到了故障服务器，并将其从服务中移除，恢复了网站。然后，我们遵循常规流程来确定根本原因并找到问题，以防止情况再次发生。我们在 Amazon 上分享了这些经验教训，以帮助预防其他系统出现相同的问题。除了学习有关此故障模式的特定经验教训之外，此事件还很好地说明了故障模式如何在分布式系统中快速且不可预测地传播。</p>
<h2 id="分布式系统中的问题总结"><a href="#分布式系统中的问题总结" class="headerlink" title="分布式系统中的问题总结"></a>分布式系统中的问题总结</h2><p>简而言之，为分布式系统进行工程设计很困难，因为：</p>
<p>• 工程师无法对错误状况进行组合。相反，他们必须考虑许多故障排列。大多数错误可以随时发生，与任何其他错误状况无关（因此，可能会与其他错误状况相结合）。<br>• 任何网络操作的结果都可能是 UNKNOWN，在这种情况下，请求可能已成功、失败或已接收但未处理。<br>• 分布式问题发生在分布式系统的所有逻辑层级，而不仅仅是低层级的物理计算机。<br>• 由于递归，分布式问题在更高层级的系统上会变得更加严重。<br>• 分布式错误通常会在部署到系统后很长时间才出现。<br>• 分布式错误可能会蔓延到整个系统。<br>• 上述许多问题都源自联网的物理定律，无法更改。</p>
<p>这仅仅是因为分布式计算既困难又古怪，但并不意味着没有办法解决这些问题。在整个 Amazon 创建者库中，我们深入研究了 AWS 如何管理分布式系统。希望您在为客户构建时能够利用我们所学到的一些知识，发挥它们的价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/Developer-RoadMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/Developer-RoadMap/" class="post-title-link" itemprop="url">Developer_RoadMap</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-02 22:05:12 / Modified: 23:07:16" itemprop="dateCreated datePublished" datetime="2020-03-02T22:05:12-05:00">2020-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Front-End-RoadMap"><a href="#Front-End-RoadMap" class="headerlink" title="Front-End RoadMap"></a>Front-End RoadMap</h1><p><img src="../images/frontend-3208362.png" alt="frontend"></p>
<h1 id="Back-End-RoadMap"><a href="#Back-End-RoadMap" class="headerlink" title="Back-End RoadMap"></a>Back-End RoadMap</h1><p><img src="../images/backend-3208384.png" alt="backend"></p>
<h1 id="DevOps-RoadMap"><a href="#DevOps-RoadMap" class="headerlink" title="DevOps RoadMap"></a>DevOps RoadMap</h1><p><img src="../images/devops.png" alt="devops"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=432430716&auto=1&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
