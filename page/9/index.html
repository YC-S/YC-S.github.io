<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9F%9F%E9%BB%91%E6%80%BB%E6%8A%93%E7%9D%80%E6%B2%B3%E5%8D%97%E5%92%8C%E4%B8%9C%E5%8C%97%E4%B8%8D%E6%94%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9F%9F%E9%BB%91%E6%80%BB%E6%8A%93%E7%9D%80%E6%B2%B3%E5%8D%97%E5%92%8C%E4%B8%9C%E5%8C%97%E4%B8%8D%E6%94%BE/" class="post-title-link" itemprop="url">为什么中国地域黑总抓着河南和东北不放</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-03 23:14:43" itemprop="dateCreated datePublished" datetime="2020-03-03T23:14:43-05:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-04 00:16:08" itemprop="dateModified" datetime="2020-03-04T00:16:08-05:00">2020-03-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>东北比较好理解，引爆点就是当年的下岗。</p>
<p>当年九五年后家里在南方涉及点娱乐买卖的朋友应该有印象，声色场所里，门口站着的多是东北的爷们，里面躺着的多是东北的姑娘。一直到现在，这都是很多小店的常态。</p>
<p>很多东北朋友非常耻于提起这些现象，但我觉得忘记就是背叛。这是一场国家级的背叛，数千万根据国家意志已经结构化的产业工人，被国家以各种冠冕堂皇的词汇剥夺了被许诺的隐形资产权力，然后弃之如敝履，扔到他们非常不适应的市场上自生自灭。</p>
<p>多少跳楼，多少围堵政府大楼，多少举家煤气自杀，多少捡菜叶子过活。说实话，没有酿成更严重的事件，已经是某种意义上东北人对国家的谅解。最后逼得相当数量共和国昔日的产业工人去涉黄涉黑，责任在谁头上，大家自己清楚。</p>
<p>东北人那段时间在黑黄一路上从业者比例急升，自然会引起普通人的歧视。只是悲哀的是，普通人不去问谁是这一现象的制造者，却去指责这件事的受害者，弱者抽刀，确实是向更弱者。</p>
<p>但更悲哀的是，从大量的反馈上来看，东北人似乎没有因为这次被国家的背叛而丧失对国家的信任。官僚主义、对体制的推崇、对市场经济的不信任，东北地区都是全国范围内的屈指可数。跟其他某些较推崇体制的省份不同，考虑到东北工人群体一直都遭到比较严重的利益损害，我有些难以理解。</p>
<p>或许历史的反作用力，需要时间。</p>
<hr>
<p>而河南的问题，则可以说是歧视农民工的一个典型代表。</p>
<p>河南很不幸地满足了三个比较罕有的特征：</p>
<p>人口大省；<br>劳务输出大省；<br>覆盖全国多种日常行业。</p>
<p>这就意味着，各地的普通人，日常都有着大量机会遇到从事低端产业的河南农民工。</p>
<p>例如，安徽也是高比例的劳务输出大省，但是北方地区对安徽人的歧视明显比东部少，因为安徽的劳务人口东部就可以消化；</p>
<p>四川也是劳务输出大省，人口也足够多，但是早期四川是以建筑行业为主，集中居住集中管理，与当地居民互动较少。所以即使四川人建了中国一半以上的楼，很多本地普通人对四川人这个概念依然感知淡薄；</p>
<p>最后像湖北输出农民工，凭借九省通衢的地理位置和重商的传统，虽然遍布全国也渗透至多种日常行业，但是体量摊到全国来说不算大，所以也没有成为被歧视的重灾区。</p>
<p>河南三点都满足，唉。</p>
<p>农民工的教育水平、收入水平、福利水平摆在那里，形象和素质是可以预判的，犯罪率是算的出来的。加上农民工必然和当地的劳务人员抢夺就业机会，最后产生的不满是肯定的。</p>
<p>也就是说，这不涉及到道德判断也不涉及到地域区别，这就是一道数学题。你把这些条件给任何一个省份，他们最后遭到的舆论结果都是一样的。</p>
<p>而在这个过程中，我们在城乡二元制这个系统上，随着开左灯往右转，诞生了一批有能力建构话语体系的城市小资阶级。他们在面临每日大资本和体制的剥削下，需要明确一个能够在他们之下的阶层，他们也是要向下获取资源的，资本上，权力上，舆论上。</p>
<p>河南，就决定是你了！</p>
<hr>
<p>我祖上山东。后来清末黄河改道，举家迁到河南洛阳，住了几十年。到我爷爷那辈跟着红军打过了长江，在南昌复员。我父母那辈广东改革开放缺老师，俩语文老师就这么带着我去了佛山。最后浦东新区开发，老爸在浦东买了房。</p>
<p>曾有个北京认识的“长辈”语重心长地对我说：别说你是河南人，名声不好；也别说你是广东人，北方人对广东人有很多偏见；说江西人嘛没什么印象（不愧是阿卡林省！）；上海人也不行，男的会被笑。就说你是山东人吧！</p>
<p>我现在走南闯北已经十年了，愈发理解到何为“人是环境的动物”：农业时代，有险可守的平原是帝王之资；工业时代，靠海的矿山工厂可以获利全球；海权时代，深水良港是必争之地；陆权时代，十字路口是膏腴之地。</p>
<p>人？人只是那些无数因素集合的一个界面。知乎喜欢强调个人的奋斗，但是当我们看到成千上万在挣扎时，为什么不思考一下背后历史的进程？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/%E6%97%A5%E9%9F%A9%E7%9A%84%E5%89%8D%E9%80%94%E5%B7%B2%E8%A2%AB%E4%B8%AD%E7%BE%8E%E9%94%81%E4%BD%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/%E6%97%A5%E9%9F%A9%E7%9A%84%E5%89%8D%E9%80%94%E5%B7%B2%E8%A2%AB%E4%B8%AD%E7%BE%8E%E9%94%81%E4%BD%8F/" class="post-title-link" itemprop="url">日韩的前途已被中美锁死</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-03 23:12:43" itemprop="dateCreated datePublished" datetime="2020-03-03T23:12:43-05:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-04 00:14:23" itemprop="dateModified" datetime="2020-03-04T00:14:23-05:00">2020-03-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>日韩的前途已被中美锁住，但还没彻底锁死。什么时候“世界人民大团结万岁”不见了，那就是彻底锁死了。</p>
<p>上头已经讲了新兴大国和守成大国的故事，也直接点明了修昔理德陷阱，意见应该是已经统一了：闷声大发财的时代早已结束，大家都是资深玩家，现在到了放在台面上讲的时候。还打哈哈，既没有效果，又侮辱人智商。</p>
<p>过去你是逍遥派，群众基础不错，也不闹事，就那么点家伙什，书记看你那个吊样也就睁一只眼闭一只眼；</p>
<p>现在你翅膀硬了，轻则单干重则造反，你让老书记心里怎么想？</p>
<p>所以第一点：老大要搞你。这是肯定的，不管互访多少次编多少名词绑定多少利益，老大就是要搞你。这一点上可以说“放弃幻想，准备战斗”。</p>
<p>第二点就很简单，大家都有DuangDuangDuang，只能文斗不能武斗。所以软刀子、低烈度、长期拉锯、多种姿势，成为当下大国撕逼的主流特征；</p>
<p>第三点最微妙：除了少数地缘躲无可躲的国家，多数国家也想搞死你，但是他们搞死你的热情程度是有差距的。</p>
<p>有的是巴不得踏上一万只脚叫你永不翻身；</p>
<p>有的希望你安静地去死；</p>
<p>有的希望你别死那么快，先顶一会；</p>
<p>有的觉得你不死不活挺好。</p>
<p>看清楚以上三点，我们再翻一翻历史，这个节点上做人老二有两种路径：</p>
<p>路径A：皇帝轮流做今年到我家，兄弟们并肩子上啊！</p>
<p>这个版本很决绝，要么天命要么德日苏。虽然这是对修昔理德陷阱最干脆的回答，但是这操作太好被预测，又没什么余地，非常不中国，我们也远没有达到这个力量对比转折点；</p>
<p>一旦失败，我们就会沦为现有国际秩序的祭品与肥料，一面滋养他们，一面做京观；</p>
<p>路径B：周天下三分有其二，犹能事殷；</p>
<p>不冲突不对抗已经说到美国人都会背了，考虑到我们不是像昭和日本一样无耻欺诈的国家，这个应该是表里一致的调子。从这个调子来看，我们是要搞“唾面自干、养老送终”型互动方式。</p>
<p>这种方式最大的好处就是，我和现有国际秩序是一体的，也就是我尊王攘夷。时间没到，我是负责任的孙子你不好动我；时间到了，三劝三让，为天下苍生辛苦一下也是可以的。</p>
<p>也就是“嘴上笑嘻嘻，手上掐鸡鸡。再干五十年，你看谁傻逼”。再直白一点就是岳不群道路，看着左冷禅浪，支持左冷禅浪，创造机会让他浪死。</p>
<p>可惜这个世界没有令狐冲…</p>
<p>那扯这么多中美的爱恨情仇是为了什么捏？因为中美关系是全球核心关系，也是日韩首先要梳理的关系。</p>
<p>日韩必然是中美关系的角力场，双方政治力量在该地的持续拉锯必然会造成国家的撕裂与混乱，这是夹缝国家的常态。</p>
<p>但是日韩在这种持续低烈度的拉锯下，既不会走向内部统合乃至彻底站队，也不会走向全面撕裂对抗清算。我在出租屋里吃着方便面看着欣慰联播听着房东砸门催房租的声音，给日韩的未来起了个动听的名字：</p>
<p>异化国家的国家异化。</p>
<p>你看民科起的名字都霸气。</p>
<p>异化国家好理解，就是国家主权、特别是军事主权的不能自主。日韩在建国初，因为历史原因，把自己的核心国家主权，军事主权，交易掉了。</p>
<p>军事主权是一个国家的核心主权，一个国家捍卫自己与威胁他国的力量不能够自主，就会对该国在外交乃至国内政治上产生极大的异化压力，其国家决策能力就会存在极大的摇摆性。</p>
<p>谈判的基础是筹码的真实与稳定，筹码不可信则谈判不可信。上面这些相信大家是有共识的，也被中日韩之间多个无疾而终的整合动作所证实。</p>
<p>下面就是我和一些比较乐观的朋友有分歧的地方：</p>
<p>因为军事主权被交易掉了，而且实际来说，低烈度的收回主权方式几乎不存在，遏制美国掌握军事主权后对其他国家主权渗透的方式也几乎不存在。所以面临中国持续的经济辐射与逐步成型的军事压力，日韩有可能选择妥协，但也可能选择国家异化。</p>
<p>我认为这种国家异化，是指自身存在无法交易的他国力量，为了使该力量的存在合理化，无视、扭曲本国自身利益，异化本国政治社会环境，选择对抗冲突，进而形成对抗的合理性，补偿和平所能获得的利益。</p>
<p>好比身体脏器长了个结石，你又没办法做手术取出来，脏器就会产生各种千奇百怪而且非常痛苦的代偿异化。</p>
<p>日韩固然有很多人明白与中国共存共生的重要性与必然性，很多人也为此不懈努力。然而军事主权的傀儡化会让一切努力都面临极大不确定性。于是乎从实际角度出发，选择与美国坚定一路的人也越来越多。</p>
<p>要注意，在中国将起未起时，日韩对美斗争其实是很激烈的，他们很多人还寄望借助中国的力量来杠杆回自己的国家主权。结果吊诡的是，中国崛起后，依附美国的声音反而前所未有地大了起来。</p>
<p>日韩的国家异化正在发生。</p>
<p>面临日韩美国仆从国的政权本质，中国的策略也必然会从谈判转向全面威慑；</p>
<p>而对日韩的全面威慑并不是真正对美国的威慑，所以美国并不会为中国对日韩的威慑而做出国际政治利益的实质让步；</p>
<p>而遭受中国威慑的日韩并不能做出合理合逻辑的反馈，于是内部压力与混乱升级；</p>
<p>还好，在中国现有的经济辐射下，这类恶性反馈链条还没有跑起来。我想这也是为什么上头说要让大家都来搭便车。</p>
<p>但是如果中国经济发展不好，或者好到威胁日韩的核心产业…像日本的精工啊材料啊韩国的半导体啊电子供应链啊…</p>
<p>所以说啊同志们，自立自主是很重要滴！</p>
<p>土地就那么多，不分，人就要饿死；分，过个几十年，人就牢牢地长在土地里，其他人慢慢饿死。等到饿死的人足够多了，没饿死的人就会用刀把土地再分一次。</p>
<p>我们总是为加足马力开工的工厂感到高兴，那是繁荣的象征。可是当工厂生产出来的罐头没人买怎么办？不要紧，生产子弹，子弹一定有人买的。</p>
<p>世界每一次大融合的巅峰，就是大战争的前夜。当人们为国际间的交流欢呼时，足以流干几千万人血的仇恨就开始蔓延。</p>
<p>第二名最惨：第一名防着他，第三名追赶他。而且比起第二名联合其他人打倒第一名，第一名联合其他人打倒第二名要容易的多。</p>
<p>每一块大陆最终只有一个文明，但每一个小岛都是一个王国。他们窥探大陆，学习大陆，但永远是独立的。</p>
<p>处于战争与饥荒的人，不用一年就会感到麻木，对死亡习以为常；而在太平盛世中成长的人，文字与画面的阅读不会留下什么印象。那些昔日的错误随着时间而日渐陌生，历史必将重演，只是时间问题。</p>
<p>精英对底层民众既有不屑也有同情，不屑可能是他们在经验上的优势，但同情绝对是他们的护身符。不同情底层民众的精英已经绝种了。</p>
<p>文化真正要扩张，只能是DNA的扩张。没有DNA做载体的文化扩张就和“神圣罗马帝国”这六个字一样可笑。</p>
<p>曾经有人想垄断钢锻造技术，还有人想垄断马克沁机枪技术，还有人想垄断坦克技术。我们知道他们都失败了，可我们今天相信能垄断核技术。</p>
<p>血脉认同是一个很有意思的概念，这基本是人的一种生物性反馈。当它强大的时候，它能弥合许多现实利益冲突，但是当它瓦解时，那些冲突会以十倍的代价反噬。</p>
<p>总有一个艰难创业的开始，总有一个卧薪尝胆的发展，总有一个扬眉吐气的抬头，总有一个得意忘形的失败，总有一个无可奈何的崩溃。愚蠢的人试图逆转，聪明的人努力把下限控制在可接受范围。</p>
<p>我翻了好久的书，从来没有在历史里发现平等二字。我只看到了有钱的、有枪的、有笔的人要求赋予自己对应的地位。</p>
<p>有些英雄人物的诞生，是多个变量的合力结果。有的变量属于人民，有的变量属于自然，有的变量属于英雄自己。</p>
<p>人的性命与道德从来都有明确的价码，他们是多个交易上最常见的交易品。另一端的交易品往往是货币和领土，交易方式基本为战争。</p>
<p>成立一个国家很像开一家公司，人的血就是注册资金。如果你开公司的时候没有把注册费用交够，公司日常运行效率会大打折扣。</p>
<p>历史中唯一存在的平等，大概就是死亡：他不在乎男女老少贫富贵贱，迟早会到来。感谢死亡，多少人命与金钱无法解决的辩论因你终结。</p>
<p>我不知道正义与邪恶是何物，我看到的只有秩序与混乱的永恒斗争。他们相杀，他们相生，像一对阴阳鱼，在历史里形成了一道道惊艳的曲线。</p>
<p>历史可能是个近视眼，他经常没办法把报应放到个人身上，而是常常投射到那一整个群体。所以他的清单经常漏掉一些人，不过你从整个数量上来看，还是很严谨的。</p>
<p>圣人看着历史的车轮说：我知道你要开向哪；神人挡着历史的车轮说：有我在，你就无法开过去。这种人确实存在。</p>
<p>科技是历史的第一推动力，不管繁荣还是战争。至于怎么把故事说完，这个任务由意识形态完成。</p>
<p>但科技不是一直推动历史发展，他是一波一波推动的。在这个中间，分配的重要程度压过了科技。他还有个名字，叫政治。</p>
<p>我不是历史学者，我充其量就是个历史爱好者。福山先生说历史有终结，尽管读完他的史料与推导，我依然无法认同。历史没有唯一解，历史是在不断的偏差与修正中产生多个精彩的文明。如果什么时候人类面临着真正的历史唯一解，我想，那就是人类的灭亡。</p>
<p>历史里有许多足以改变进程的小细节：一条山脉、一种可驯养的马匹、一种高淀粉作物、一种高强度材料，甚至战场上一次狠不下心的宽恕，都能给历史带来意想不到的改变。</p>
<p><strong>如果宗教是鸦片，那么历史就是海洛因。喜欢历史的人很难对宗教提起兴趣，刺激的量级差太大了。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%8C%91%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%8C%91%E6%88%98/" class="post-title-link" itemprop="url">分布式系统相关挑战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-02 22:23:50 / Modified: 23:24:43" itemprop="dateCreated datePublished" datetime="2020-03-02T22:23:50-05:00">2020-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从我们添加第二台服务器的那一刻起，分布式系统就已融入 Amazon。1999 年，我初到 Amazon 之时，服务器非常少，少到我们甚至可以给部分服务器命名（如“fishy”或“online-01”），以便于识别它们。然而，即便是在 1999 年，分布式计算也并非易事。与现在一样，分布式系统同样面临着诸多挑战，包括延迟、扩展、理解网络 API、数据编组和解组以及 Paxos 等算法的复杂性。随着系统的不断快速扩展和分布程度的不断提高，理论上的边缘情况成为了常态。</p>
<p>开发分布式实用程序计算服务（例如可靠的长途电话网络或 Amazon Web Services (AWS) 服务）比较困难。与其他形式的计算相比，分布式计算也<em>更古怪</em>，而且<em>不够直观</em>，因为它存在两个相互关联的问题。在分布式系统中，造成最大问题的是<strong>故障独立性</strong>和<a href="https://sampa.cs.washington.edu/new/papers/asplos021-hunt.pdf" target="_blank" rel="noopener">不确定性</a>。在分布式系统中，除了大多数工程师习以为常的计算故障外，故障还会以许多其他方式出现。更糟糕的是，不可能时刻知晓某事项是否发生了故障。</p>
<p>在整个 Amazon 构建者库中，我们介绍了 AWS 如何处理分布式系统产生的复杂的开发和运营问题。在探讨其他文章对于这些技术的详细介绍之前，我们有必要先来了解一下为什么分布式计算如此古怪。首先，我们来了解一下分布式系统的类型。</p>
<h2 id="分布式系统的类型"><a href="#分布式系统的类型" class="headerlink" title="分布式系统的类型"></a>分布式系统的类型</h2><p>实际上，分布式系统在实施过程中是存在难易差异的。一方面，我们有 <em>离线</em>分布式系统。其中包括批处理系统、大数据分析集群、电影场景渲染农场、蛋白质折叠集群等。虽然离线分布式系统实现起来并不容易，但它却几乎囊括了分布式计算的所有优点（可扩展性和容错能力），而且几乎没有缺点（复杂的故障模式和不确定性）。</p>
<p>另一方面，我们有 <em>软实时</em>分布式系统。这些是必须不断产生或更新结果的重要系统，但是它们有一个相对充裕的时间窗口来执行这些操作。此类系统包括部分搜索索引生成器、搜寻受损服务器的系统、Elastic Compute Cloud (Amazon EC2) 的角色等等。搜索索引器可能会有 10 分钟到数小时的时间（具体取决于应用程序）处于离线状态，但不会对客户造成不当影响。Amazon EC2 的角色必须将更新的凭证推送到（基本上）每个 EC2 实例，但是它有几个小时的时间来执行此操作，因为旧凭证在一段时间过后才会过期。</p>
<p>最后一方面，我们有 <em>硬实时</em>分布式系统，这也是最难实现的分布式系统。我们通常将其称之为请求/回复服务。在 Amazon，当我们考虑构建分布式系统时，首先想到的类型是硬实时系统。然而，硬实时分布式系统是最难实现的。难以实现的原因是，无法预计请求的到达但又必须迅速对其做出响应（例如，客户正在热切等待响应）。示例包括前端 Web 服务器、订单管道、信用卡交易、每个 AWS API、电话通讯等。本文将重点介绍硬实时分布式系统。</p>
<h2 id="硬实时系统非常古怪"><a href="#硬实时系统非常古怪" class="headerlink" title="硬实时系统非常古怪"></a>硬实时系统非常古怪</h2><p>在《超人》漫画中有这样一个故事情节：超人遇到了名叫 <em>Bizarro</em> 的另一个自我，Bizarro 生活在一个规则相反的行星 (<em>Bizarro World</em>) 上。Bizarro <em>外表</em>与超人相似，但他实际上是个反派人物。硬实时分布式系统亦是如此。它们表面上酷似常规计算，但实际上并不相同；坦率地说，有点“邪恶”。</p>
<p>硬实时分布式系统的开发之所以奇怪是因为：请求/回复网络。我们并<em>不</em>是指 TCP/IP、DNS、套接字或其他此类协议的具体细节。这些主题可能难以理解，但与计算中的其他难题相似。</p>
<p>硬实时分布式系统的难点在于网络允许将消息从一个<em>容错域</em>发送到另一个容错域。发送消息似乎没有什么危害。但事实上，发送消息是一切变得比正常情况更加复杂的源头。</p>
<p>举一个简单的例子，我们来看一下 Pac-Man 实施中的以下代码段。它只在单台计算机上运行，不通过任何网络发送任何消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">board.move(pacman, user.joystickDirection())</span><br><span class="line">ghosts = board.findAll(":ghost")</span><br><span class="line">for (ghost in ghosts)</span><br><span class="line">  if board.overlaps(pacman, ghost)</span><br><span class="line">    user.slayBy(":ghost")</span><br><span class="line">    board.remove(pacman)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>

<p>现在，我们假设要开发此代码的联网版本，在一个单独的服务器上维护 board 对象的状态。对 board 对象（例如 findAll()）的每次调用都会导致在两台服务器之间发送和接收消息。</p>
<p>每当在两台服务器之间发送请求/回复消息时，<em>从始至终</em>一定会至少发生同样的一组八个步骤。要了解联网的 Pac-Man 代码，我们先来了解请求/回复消息收发的基础知识。 </p>
<h2 id="通过网络进行请求-回复消息收发"><a href="#通过网络进行请求-回复消息收发" class="headerlink" title="通过网络进行请求/回复消息收发"></a>通过网络进行请求/回复消息收发</h2><p>一个请求/回复往返操作始终需要执行相同的步骤。如下图所示，客户端计算机 CLIENT 通过网络 NETWORK 向服务器计算机 SERVER 发送请求 MESSAGE，SERVER 也通过网络 NETWORK 回复消息 REPLY。</p>
<p><img src="../images/reply-messaging-across-network.e70d2f48b08da1b3b4b234fee7f4ee6f335a8373.png" alt="reply-messaging-across-network"></p>
<p>在一切正常的情况下，会执行以下步骤：</p>
<p>1.<strong>POST REQUEST</strong>：CLIENT 将请求 MESSAGE 放到 NETWORK 上。<br>2.<strong>DELIVER REQUEST</strong>：NETWORK 将 MESSAGE 传送到 SERVER。<br>3.<strong>VALIDATE REQUEST</strong>：SERVER 验证 MESSAGE。<br>4.<strong>UPDATE SERVER STATE</strong>：如有必要，SERVER 根据 MESSAGE 更新其状态。<br>5.<strong>POST REPLY</strong>：SERVER 将回复 REPLY 放到 NETWORK 上。<br>6.<strong>DELIVER REPLY</strong>：NETWORK 将 REPLY 传送到 CLIENT。<br>7.<strong>VALIDATE REPLY</strong>：CLIENT 验证 REPLY。<br>8.<strong>UPDATE CLIENT STATE</strong>：如有必要，CLIENT 根据 REPLY 更新其状态。</p>
<p>这只是往返一次就发生的诸多步骤！ 然而，这些步骤就是通过网络请求/回复通信的<em>定义</em>，无法跳过它们之中的任何一个步骤。例如，不可能跳过步骤 1。客户端必须以某种方式将 MESSAGE 放到网络 NETWORK 上。从物理角度讲，这意味着要通过网络适配器发送数据包，这会导致电子信号通过一系列路由器（构成 CLIENT 和 SERVER 之间的网络）在电线上传输。这与步骤 2 是分开的，因为步骤 2 可能由于自主原因出现问题，例如 SERVER 突然断电并且无法接受传入的数据包。这一逻辑同样适用于其余步骤。</p>
<p>因此，通过网络的单个请求/回复会将<em>一件</em>事（调用方法）分解为<em>八件</em>事。更糟糕的是，如上所述，CLIENT、SERVER 和 NETWORK 可能会彼此<em>独立地</em>发生故障。工程师的代码必须处理上文提及的<em>任何</em>步骤发生的故障。典型的工程设计中很少会这样做。要想知晓原因，我们先来了解一下单机版代码中的以下表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board.find("pacman")</span><br></pre></td></tr></table></figure>

<p>从技术角度讲，即使 board.find 的实施本身没有错误，这段代码在运行时也会以一些古怪的方式发生故障。例如，CPU 可能在运行时自发过热。计算机的电源也可能自发地出现故障。内核可能出现恐慌。内存可能已满，无法创建 board.find 想要创建的某些对象。或者，它正在运行的计算机上的磁盘可能已满，board.find 无法更新某些统计文件，然后返回错误（即使可能不应该这样做）。伽马射线可能击中了服务器并剐蹭到 RAM。但是，在大多数情况下，工程师们并不担心这些问题。例如，单元测试永远不会涵盖“如果 CPU 发生故障”的情况，同时也很少涉及内存不足的情况。</p>
<p>在常见的工程设计中，这些类型的故障发生在一台计算机上；即一个<em>容错域</em>。例如，如果 board.find 方法由于 CPU 自发过热而发生故障，则可以肯定地说，整个计算机都处于故障状态。即使是从概念上也不可能处理该错误。可以对上文列出的其他类型的错误做出类似的假设。您可以尝试为其中一些情况编写测试，但是对于典型的工程设计来说，这毫无意义。如果确实发生了这些故障，可以肯定所有其他项也会发生故障。从技术角度讲，我们称他们<em>共担命运</em>。命运共担可极大地减少工程师必须处理的不同故障模式。</p>
<h2 id="硬实时分布式系统中的故障处理模式"><a href="#硬实时分布式系统中的故障处理模式" class="headerlink" title="硬实时分布式系统中的故障处理模式"></a>硬实时分布式系统中的故障处理模式</h2><p>硬实时分布式系统工程师必须对网络故障的所有方面都进行测试，因为服务器和网络<em>不会</em>共担命运。与单台计算机的情况不同，如果网络出现故障，客户端计算机将继续工作。如果远程计算机出现故障，客户端计算机将继续工作，如此等等。</p>
<p>为了详尽测试上文所述的请求/回复步骤的故障情况，工程师必须假定每个步骤都可能发生故障。而且，他们必须确保客户端和服务器上的代码始终能够针对这些故障正确运行。<br>让我们看一下出现问题的请求/回复的一次往返操作：</p>
<p>1.<strong>POST REQUEST 失败</strong>：NETWORK 无法传送消息（例如，中间路由器恰好不合时宜地崩溃），或者 SERVER 明确拒绝了该消息。<br>2.<strong>DELIVER REQUEST</strong> <strong>失败</strong>：NETWORK 已成功将 MESSAGE 传送到 SERVER，但是 SERVER 收到 MESSAGE 后立即崩溃。<br>\3. <strong>VALIDATE REQUEST 失败</strong>：SERVER 判定 MESSAGE 无效。原因可能无所不有。例如，数据包损坏、软件版本不兼容，或者客户端或服务器出现错误。<br>4.<strong>UPDATE SERVER STATE</strong> <strong>失败</strong>：SERVER 尝试更新其状态，但无法更新。<br>5.<strong>POST REPLY 失败</strong>：无论尝试回复成功还是失败，SERVER 都可能无法发布回复。例如，它的网卡可能恰好不合时宜地过热。<br>6.<strong>DELIVER REPLY 失败</strong>：即使 NETWORK 在上文的步骤中可以正常运行，NETWORK 仍可能无法像上文描述的那样将 REPLY 传送给 CLIENT。<br>7.<strong>VALIDATE REPLY 失败</strong>：CLIENT 判定 REPLY 无效。<br>8.<strong>UPDATE CLIENT STATE 失败</strong>：CLIENT 可能会收到消息 REPLY，但是无法更新其自身的状态、无法理解消息（由于不兼容）或由于其他原因而失败。</p>
<p>正是这些故障模式使得分布式计算变得困难重重。我将其称之为<em>天启的八种故障模式</em>。鉴于这些故障模式，让我们再次从 Pac-Man 代码中查看该表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board.find("pacman")</span><br></pre></td></tr></table></figure>

<p>该表达式扩展为以下客户端活动：</p>
<p>1.在网络上发布一条消息（例如 {action: “find”, name: “pacman”, userId: “8765309”}），该网络寻址到 Board 计算机。<br>2.如果网络不可用，或者显式拒绝了与 Board 计算机的连接，则会引发错误。这种情况有些特殊，因为客户端确切地知道服务器计算机可能未收到该请求。<br>3.等待回复。<br>4.如果从未收到回复，则超时。在此步骤中，超时意味着请求的结果为 UNKNOWN。它可能发生过也可能没发生过。客户端必须正确处理 UNKNOWN。<br>5.如果收到回复，则确定是成功回复、错误回复还是回复难以理解/发生损坏。<br>6.如果不是错误，则解组响应并将其转换为代码可以理解的对象。<br>7.如果是错误或无法理解的回复，则会引发异常。<br>8.无论如何处理异常，都必须确定应<em>重试</em>该请求还是放弃并停止操作。</p>
<p>该表达式还会启动以下服务器端活动：</p>
<p>1.收到请求（这可能根本不会发生）。<br>2.验证请求。<br>3.查找用户以查看该用户是否还处于活动状态。（服务器可能已经放弃该用户，因为它很长时间没有收到来自用户的任何消息。）<br>4.更新用户的保持活动表，以便服务器知道他们（可能）仍然还在。<br>5.查找用户的位置。<br>6.发布包含类似 {xPos: 23, yPos: 92, clock: 23481984134} 的响应。<br>7.任何其他服务器逻辑都必须正确处理客户端的后续影响。例如，无法接收消息、接收消息但不理解消息、接收消息但消息崩溃或成功处理消息。</p>
<p>总之，普通代码中的<em>一个表达式</em>在硬实时分布式系统代码中变成了<em>十五个</em>额外的步骤。发生这种扩展的原因是客户端和服务器之间的每次往返通信在八个不同的点都有可能发生故障。任何表示网络往返的表达式（例如 board.find(“pacman”)），都会产生以下结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(error, reply) = network.send(remote, actionData)</span><br><span class="line">switch error</span><br><span class="line">  case POST_FAILED:</span><br><span class="line">    // handle case where you know server didn't get it</span><br><span class="line">  case RETRYABLE:</span><br><span class="line">    // handle case where server got it but reported transient failure</span><br><span class="line">  case FATAL:</span><br><span class="line">    // handle case where server got it and definitely doesn't like it</span><br><span class="line">  case UNKNOWN: // i.e., time out</span><br><span class="line">    // handle case where the *only* thing you know is that the server received</span><br><span class="line">    // the message; it may have been trying to report SUCCESS, FATAL, or RETRYABLE</span><br><span class="line">  case SUCCESS:</span><br><span class="line">    if validate(reply)</span><br><span class="line">      // do something with reply object</span><br><span class="line">    else</span><br><span class="line">      // handle case where reply is corrupt/incompatible</span><br></pre></td></tr></table></figure>

<p>这种复杂性是难以避免的。如果代码无法正确处理所有情况，则该服务最终将以奇怪的方式发生故障。想象一下，若尝试为客户端/服务器系统（例如 Pac-Man 示例）可能遇到的所有故障模式编写测试，难度何其之大！</p>
<h2 id="测试硬实时分布式系统"><a href="#测试硬实时分布式系统" class="headerlink" title="测试硬实时分布式系统"></a>测试硬实时分布式系统</h2><p>测试单机版本的 Pac-Man 代码段相对比较简单。创建一些不同的 Board 对象，将它们置于不同的状态，创建一些不同状态的 User 对象，如此等等。工程师会特别认真地考虑边缘条件，可能会使用生成式测试或模糊测试。</p>
<p>在 Pac-Man 代码中，有四个地方使用 board 对象。在分布式 Pac-Man 中，该代码中有四个点具有五种不同的可能结果，如上文所示（POST_FAILED、RETRYABLE、FATAL、UNKNOWN 或 SUCCESS）。这极大地增加了测试的状态空间。例如，硬实时分布式系统的工程师必须处理许多排列。假设对 board.find() 调用失败，并显示 POST_FAILED。那么，您必须测试当它失败并显示 RETRYABLE 时会发生什么，然后必须测试当它失败并显示 FATAL 时会发生什么，如此等等。</p>
<p>但即使这样，测试也是不够的。在常规代码中，工程师可能会认为，如果 board.find() 有效，那么对 board 的下一个调用 board.move() 也将有效。在硬实时分布式系统工程中，没有这样的保证。服务器计算机随时都有可能发生独立故障。最终，工程师每次调用 board 时都必须针对所有五种情况编写测试。假设工程师提出了 10 种可以在单机版 Pac-Man 中进行测试的情况。但是，在分布式系统版本中，他们必须针对每种情况测试 <em>20</em> 次。这意味着测试矩阵会从 10 膨胀到 200！</p>
<p>但是等等，情况不止如此。工程师<em>也</em>可能拥有<em>服务器</em>代码。无论客户端、网络和服务器端出现怎样的错误组合，工程师都必须进行测试，以便客户端和服务器最终不会处于损坏状态。服务器代码可能如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">handleFind(channel, message)</span><br><span class="line">  if !validate(message)</span><br><span class="line">    channel.send(INVALID_MESSAGE)</span><br><span class="line">    return</span><br><span class="line">  if !userThrottle.ok(message.user())</span><br><span class="line">    channel.send(RETRYABLE_ERROR)</span><br><span class="line">    return</span><br><span class="line">  location = database.lookup(message.user())</span><br><span class="line">  if location.error()</span><br><span class="line">    channel.send(USER_NOT_FOUND)</span><br><span class="line">    return</span><br><span class="line">  else</span><br><span class="line">    channel.send(SUCCESS, location)</span><br><span class="line"></span><br><span class="line">handleMove(...)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">handleFindAll(...)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">handleRemove(...)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>需要测试四个服务器端函数。假设一台计算机上的每个函数都需进行五次测试，那么就需要进行 20 次测试。由于客户端将多条消息发送到同一服务器，因此测试应模拟不同请求的序列，以确保服务器保持稳健运行。请求的示例包括 find、move、remove 和 findAll。</p>
<p>假设一个构造有 10 种不同的场景，每种场景平均有 3 个调用，那么就需要进行超过 30 次测试。此外，一个场景还需要测试故障案例。对于每一个测试，您都需要模拟以下情况：如果客户端收到四种失败类型（POST_FAILED、RETRYABLE、FATAL 和 UNKNOWN）中的任何一种，然后使用无效请求再次调用服务器，将会发生什么情况。例如，客户端可能成功调用了 find，但是在调用 move 时，有时会收到 UNKNOWN。然后出于某种原因，它可能会再次调用 find。服务器是否可以正确处理这种情况？ 也许可以处理。但是如果不进行测试，您就无从知晓。因此，与客户端代码一样，服务器端测试矩阵的复杂性也会呈爆炸式增长。</p>
<h2 id="处理未知的未知情况"><a href="#处理未知的未知情况" class="headerlink" title="处理未知的未知情况"></a>处理未知的未知情况</h2><p>如果要考虑分布式系统可能会遇到的所有故障排列，尤其是在有多个请求时，这简直难以想象。我们发现处理分布式工程设计的一种方法是不信任<em>任何事物</em>。除非不会引发网络不通信，否则每一行代码都可能无法达到预期的效果。</p>
<p>也许最难处理的是上一节中所述的 UNKNOWN 错误类型。客户端无法时时知晓请求是否成功。也许它<em>确实</em>移动了 Pac-Man（或者在银行服务中，从用户的银行账户中提款），或者也许<em>没有</em>。工程师应该如何处理此类情形？ 这很难处理，因为工程师是人，而人往往要在真正的不确定性中挣扎。人类习惯于像下面这样查看代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool isEven(number)</span><br><span class="line">  switch number % 2</span><br><span class="line">    case 0</span><br><span class="line">      return true</span><br><span class="line">    case 1</span><br><span class="line">      return false</span><br></pre></td></tr></table></figure>

<p>人类理解此代码，是因为它执行了它<em>应该</em>执行的操作。分布式版本的代码让人类苦不堪言，它会将一些工作分配给服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool distributedIsEven(number)</span><br><span class="line">  switch mathServer.mod(number, 2)</span><br><span class="line">    case 0</span><br><span class="line">      return true</span><br><span class="line">    case 1</span><br><span class="line">      return false</span><br><span class="line">    case UNKNOWN</span><br><span class="line">      return WHAT_THE_FARG?</span><br></pre></td></tr></table></figure>

<p>人类几乎不可能弄清楚如何正确处理 UNKNOWN。UNKNOWN 的真正含义为何？ 是否应重试代码？ 如果应该，要重试多少次？ 重试之间应等待多长时间？ 当代码有副作用时，情况甚至会更糟。在单台计算机上运行的预算应用程序内部，从账户中提取资金非常容易，如以下示例所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Teller</span><br><span class="line">  bool doWithdraw(account, amount)</span><br><span class="line">    switch account.withdraw(amount)</span><br><span class="line">      case SUCCESS</span><br><span class="line">        return true</span><br><span class="line">      case INSUFFICIENT_FUNDS</span><br><span class="line">        return false</span><br></pre></td></tr></table></figure>

<p>但是，由于出现 UNKNOWN，该应用程序的分布式版本很古怪。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DistributedTeller</span><br><span class="line">  bool doWithdraw(account, amount)</span><br><span class="line">    switch this.accountService.withdraw(account, amount)</span><br><span class="line">      case SUCCESS</span><br><span class="line">        return true</span><br><span class="line">      case INSUFFICIENT_FUNDS</span><br><span class="line">        return false</span><br><span class="line">      case UNKNOWN</span><br><span class="line">        return WHAT_THE_FARG?</span><br></pre></td></tr></table></figure>

<p>在分布式工程设计中，要想知道为什么<em>事情并非总如表现的那样</em>，就需要弄清楚如何处理 UNKNOWN 错误类型。</p>
<h2 id="硬实时分布式系统群"><a href="#硬实时分布式系统群" class="headerlink" title="硬实时分布式系统群"></a>硬实时分布式系统群</h2><p>天启的八种故障模式可以发生在分布式系统中的任何抽象层。上文的示例仅限于一台客户端计算机、一个网络和一台服务器计算机。即使在这种简单的场景中，故障状态矩阵的复杂性也会呈爆炸式增长。与单台客户端计算机示例相比，实时分布式系统具有更复杂的故障状态矩阵。实时分布式系统由多台计算机组成，可以在多个抽象层上进行查看：</p>
<p>1.个别计算机<br>2.计算机组<br>3.计算机组群<br>4.其他（潜在）</p>
<p>例如，在 AWS 上构建的服务可能会将专用于处理特定可用区资源的计算机分成一组。可能还会有另外两组用于处理另外两个可用区的计算机。然后，可以将这些组划分到一个 AWS 区域组。而且，该区域组（逻辑上）可与其他区域组进行通信。然而，即使在这一更高、更合乎逻辑的抽象层，<em>仍然会出现所有相同的问题。</em></p>
<p>假设服务已将某些服务器划分到一个逻辑组 GROUP1。GROUP1 组有时可能会将消息发送到另一组服务器 GROUP2。这是<em>递归分布式工程设计</em>的一个示例。上文所述的所有相同的网络故障模式在此都适用。假设 GROUP1 想要向 GROUP2 发送请求。如下图所示，两台计算机的请求/回复交互就像上文所述的单台计算机一样。</p>
<p><img src="../images/two-machine-request-reply.1e17ff385870b005b8d260d809e34a2e78c7ea95.png" alt="two-machine-request-reply"></p>
<p>无论如何，GROUP1 中的某些计算机必须在（逻辑上）寻址到 GROUP2 的网络 NETWORK 上放置一条消息。GROUP2 中的某些计算机必须处理该请求等等。GROUP1 和 GROUP2 是由计算机组组成的这一事实并未改变基本原则。GROUP1、GROUP2 和 NETWORK 仍然可以彼此独立发生故障。</p>
<p>然而，这只是组级视图。每个组中还存在计算机到计算机级别的交互。例如，GROUP2 的结构可能如下图所示。</p>
<p><img src="../images/group-2-load-balancer.8ca4bed7e09adb925f696172f61b858a50cb1770.png" alt="group-2-load-balancer"></p>
<p>首先，通过负载均衡器将发送到 GROUP2 的消息发送到组中的一台计算机（可能是 S20）。系统设计人员知道 S20 在 UPDATE STATE 阶段可能会发生故障。因此，S20 可能需要将该消息传递给至少一台其他计算机，要么是同组的计算机，要么是其他组的计算机。S20 实际上是如何做到的？ 通过发送请求/回复消息，比如发送给 S25，如下图所示。</p>
<p><img src="../images/send-request.reply-message.ee869a6e7bfeded543dd25150a22f8a562457547.png" alt="send-request.reply-message"></p>
<p>因此，S20 正在递归地执行联网。同样的八个故障可能会再次各自独立地发生。分布式工程设计发生两次，而不是一次。在逻辑层级上，从 GROUP1 传递到 GROUP2 的消息可能会以所有八种方式发生故障。该消息会导致另一条消息（可能自己发生故障）以上文所述的所有八种方式独立发生故障。测试此场景至少涉及以下方面：</p>
<p>• 针对 GROUP1 到 GROUP2 组级消息传递的所有八种方式的测试均可能失败。<br>• 针对 S20 到 S25 服务器级消息传递的所有八种方式的测试均可能失败。</p>
<p>这个请求/回复消息传递示例告诉我们为什么即使在使用分布式系统 20 多年后，测试分布式系统仍然是一个特别棘手的问题。由于存在大量的边缘情况，因此测试颇具挑战性，但它在此类系统中特别重要。部署系统后，错误可能需要很长时间才能浮出水面。而且，错误可能会对系统及相邻系统产生难以预料的广泛影响。</p>
<h2 id="分布式错误通常是潜在的"><a href="#分布式错误通常是潜在的" class="headerlink" title="分布式错误通常是潜在的"></a>分布式错误通常是潜在的</h2><p>如果故障终究要发生，人们普遍认为越早越好。例如，最好找出服务中的扩展问题，这将需要六个月的时间来解决，<em>至少</em>在六个月后，服务才能达到如此规模。同样，最好在错误影响生产之前就找到它们。如果错误确实影响了生产，则最好快速找到它们，以免影响诸多客户或产生其他不利影响。</p>
<p>分布式错误，即那些由于无法处理天启的八个故障模式的所有排列而导致的错误，通常非常严重。随着时间的推移，从电信系统到核心 Internet 系统，大型分布式系统的例子比比皆是。这些故障不仅普遍而且成本高昂，而且几个月前部署到生产中的错误也可能引发这些故障。然后需要一段时间来触发实际导致这些错误发生（并蔓延到整个系统）的场景的组合。</p>
<h2 id="分布式错误的病毒式传播"><a href="#分布式错误的病毒式传播" class="headerlink" title="分布式错误的病毒式传播"></a>分布式错误的病毒式传播</h2><p>我来介绍另一个对于分布式错误至关重要的问题：</p>
<p>1.分布式错误必定涉及网络的使用。<br>2.因此，分布式错误更有可能传播到其他计算机（或计算机组），因为按照定义，它们<em>已经涉及将计算机链接到一起的唯一事项。</em></p>
<p>Amazon 也经历过这些分布式错误。这是一个时间久远但切题的示例，那就是 <a href="http://www.amazon.com" target="_blank" rel="noopener">www.amazon.com</a> 发生全站故障。该故障是由远程目录服务中的一个服务器在其磁盘被填满时出现故障引起的。</p>
<p>由于对该错误状况处理不当，远程目录服务器开始对收到的每个请求返回空响应。此外，它还开始非常快速地返回它们，因为不返回任何东西都比返回东西要快得多（至少在这种情况下如此）。同时，网站和远程目录服务之间的负载均衡器没有注意到所有响应的长度均为零。但是，它<em>确实</em>注意到它们比所有其他远程目录服务器快得多。因此，它从 <a href="http://www.amazon.com" target="_blank" rel="noopener">www.amazon.com</a> 向磁盘已满的一台远程目录服务器发送了大量流量。事实上，整个网站都瘫痪了，因为一台远程服务器无法显示任何产品信息。</p>
<p>我们迅速找到了故障服务器，并将其从服务中移除，恢复了网站。然后，我们遵循常规流程来确定根本原因并找到问题，以防止情况再次发生。我们在 Amazon 上分享了这些经验教训，以帮助预防其他系统出现相同的问题。除了学习有关此故障模式的特定经验教训之外，此事件还很好地说明了故障模式如何在分布式系统中快速且不可预测地传播。</p>
<h2 id="分布式系统中的问题总结"><a href="#分布式系统中的问题总结" class="headerlink" title="分布式系统中的问题总结"></a>分布式系统中的问题总结</h2><p>简而言之，为分布式系统进行工程设计很困难，因为：</p>
<p>• 工程师无法对错误状况进行组合。相反，他们必须考虑许多故障排列。大多数错误可以随时发生，与任何其他错误状况无关（因此，可能会与其他错误状况相结合）。<br>• 任何网络操作的结果都可能是 UNKNOWN，在这种情况下，请求可能已成功、失败或已接收但未处理。<br>• 分布式问题发生在分布式系统的所有逻辑层级，而不仅仅是低层级的物理计算机。<br>• 由于递归，分布式问题在更高层级的系统上会变得更加严重。<br>• 分布式错误通常会在部署到系统后很长时间才出现。<br>• 分布式错误可能会蔓延到整个系统。<br>• 上述许多问题都源自联网的物理定律，无法更改。</p>
<p>这仅仅是因为分布式计算既困难又古怪，但并不意味着没有办法解决这些问题。在整个 Amazon 创建者库中，我们深入研究了 AWS 如何管理分布式系统。希望您在为客户构建时能够利用我们所学到的一些知识，发挥它们的价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/Developer-RoadMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/Developer-RoadMap/" class="post-title-link" itemprop="url">Developer_RoadMap</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-02 22:05:12 / Modified: 23:07:16" itemprop="dateCreated datePublished" datetime="2020-03-02T22:05:12-05:00">2020-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Front-End-RoadMap"><a href="#Front-End-RoadMap" class="headerlink" title="Front-End RoadMap"></a>Front-End RoadMap</h1><p><img src="../images/frontend-3208362.png" alt="frontend"></p>
<h1 id="Back-End-RoadMap"><a href="#Back-End-RoadMap" class="headerlink" title="Back-End RoadMap"></a>Back-End RoadMap</h1><p><img src="../images/backend-3208384.png" alt="backend"></p>
<h1 id="DevOps-RoadMap"><a href="#DevOps-RoadMap" class="headerlink" title="DevOps RoadMap"></a>DevOps RoadMap</h1><p><img src="../images/devops.png" alt="devops"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/%E4%B8%BA%E4%BD%95%E8%8B%B1%E5%9B%BD%E4%BC%9A%E8%84%B1%E6%AC%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/%E4%B8%BA%E4%BD%95%E8%8B%B1%E5%9B%BD%E4%BC%9A%E8%84%B1%E6%AC%A7/" class="post-title-link" itemprop="url">为何英国会脱欧</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-02 21:13:45 / Modified: 22:14:42" itemprop="dateCreated datePublished" datetime="2020-03-02T21:13:45-05:00">2020-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>因何而来，因何而去。</p>
<p>英国虽然也算是欧盟的倡议者之一，但是当法德两国让渡国家利益谋求联合时，英国在干嘛？在算账。</p>
<p>等过了几年欧共体有声有色时，英国又觉得有利可图，厚着脸皮要加入。我法良心戴高乐连怼大英两回，最后连“美国的特洛伊木马”都骂出来了。</p>
<p>戴高乐逝世后，欧萌废物们把老将军的嘱咐抛诸脑后，硬是让英国人进了欧萌。时英国首相，人称“杂货店主”的爱德华希斯喜出望外，为啥？那时候英国失业人口一百万，二战后二十年最高峰值。</p>
<p>法德对大欧洲的坚持，一方面是出于对一战二战惨痛代价的反省，另一方面是美国与苏联的次第崛起。欧洲如果再不联合在一起，欧罗巴女神就会成为未来伊万大叔和山姆大叔的肉便器。这是为万世计，是长线价值投资；</p>
<p>英国作为大陆均势的开山鼻祖，天字第一号搅屎棍，人家才不在乎什么大欧洲。只要欧洲没有能够威胁到英国的统一力量，那么欧洲越烂越好，你们打出脑花子来，他还搬凳子嗑瓜子呢。</p>
<p>岛国就是这般地缘属性，天赋如此，不爽不要玩。</p>
<p>之所以还嚷嚷着加入了欧洲，无非是经济上垂涎人家欧洲市场，政治上美苏70年代稍微缓和，赶紧找欧洲人抱抱团。</p>
<p>巨头们互怼，中等强国肯定站队；巨头们握手，意味着可能要联手割其他人的韭菜，中等强国们自然抱团。</p>
<p>所以这里要感慨一下我朝太祖，居然咬咬牙就是不当小弟，为今天留下深厚的政治遗产，实在是无法想象他老人家所谋之远之深。</p>
<p>扯远了，回来。</p>
<p>导致英国加入欧盟的因素是不稳定的，易受外部影响的，那条件变了，英国自然会红杏出墙。</p>
<p>苏联解体后，英国被尊为欧盟三驾马车之一，加上和美国传统的特殊伙伴关系，一时间大不列颠对大欧洲理念还是很上心的，至少面子功夫给足。</p>
<p>但快三十年过去，天下几变。俄国人没有像想象中的那样被大西洋主义忽悠，转而走向了独立自主的道路，再次开始坚持自身的地缘利益；</p>
<p>与俄国人数次冲突，承担深重消耗的欧洲不想再继续成为美国人战略上的棋子，开始厌倦与俄国的对抗，转而寻求与俄国人和解；</p>
<p>远东的中国完成了工业化改造，开始谋求在经济和政治上与欧洲形成产业联合，进而减缓美国人的金融威胁；</p>
<p>美国人在蓝领阶层的推动下，向孤立主义回归，开始收缩海外投入，并且构建贸易壁垒。</p>
<p>你觉得这局面看上去是巨头们在握手吗？宴席上的伴乐已经到了终末，巨头们开始礼貌地微笑，并走回自己的餐桌。</p>
<p>这个时候，到了英国选桌子的时候了。</p>
<p>选欧盟这张桌子，且不说最后让渡的国家主权和被欧盟分走的利益。与俄国人和解就会对英美关系造成重大创伤，让英国丧失美国人那里的巨大利益。</p>
<p>选美国人的这张桌子，不仅能够保持原来的基础盘，还能凭借英国的特殊地位，继续从欧洲中国那里获取合作。</p>
<p>欧盟就算再想惩罚英国，依靠过去对欧洲的经济渗透与交错，欧盟也无法对英国在短期内建立过高的壁垒；</p>
<p>而在欧盟这里的损失，英国完全可以从别的地方找回来：和中国及亚洲的独立经济合作协定，条件更好，赚的更多；</p>
<p>而且不管我们怎么编段子嘲讽现在的英国，烂船还有三斤铁，英国人凭借着日不落帝国的遗产，还是能够维系住她的很多利益的。</p>
<p>不展开，就说一个，英联邦。</p>
<p><img src="../images/2020022501-20200302211439504.jpg" alt="022501"></p>
<p>这是一个极度松散的联合，所以很多人觉得这个组织除了给英国人一点意淫的题材外没有任何实际价值。但是这个看似松散的联合背后，其实是有着有价值的政治经济文化机制。</p>
<p>英联邦下的英联邦商会，其实就有着相当不错的力量。英国本身和这些前殖民地们就有着长期的传统商贸协定，虽然美国人二战时捏碎了帝国特惠制，但是其他较平等的协定仍然能够给英国带来巨大的利益。</p>
<p>可惜，这些利益在英国加入欧盟后逐一消失。欧盟的条例限制了英国脱离欧盟去与英联邦成员们进行贸易。</p>
<p>例如加拿大，本来英国人长期可进入的市场，现在需要欧盟和加拿大谈完，英国人的商品才能按照欧盟的法律进入加拿大；本来加拿大里英国人可直接获取的原料，现在需要加拿大人和欧盟谈完，才能按照欧盟的标准进入英国。</p>
<p>过去欧洲市场能够弥补英国人在这方面的损失，英国人忍了；现在肉这么少布鲁塞尔又这么磨叽，英国人的火气可想而知：我大英的小钱钱法国人德国人意大利人说两句也就算了，你波兰人能否决我，这生意还能做吗？</p>
<p>类似英联邦这样的牌，英国人还是有一些的。</p>
<p>最后，在经济之外，粗略聊一下政治。</p>
<p>只有岛田家的人，啊不，岛国的人才会做二五仔。你这么擅长做二五仔，你究竟是谁？</p>
<p>我是岛田不列颠。</p>
<p>英国人政治加点比较神，尤其是外交。西方文明有天下四百年，盎格鲁撒克逊人独占三百年，确实有不密之传。</p>
<p>英国人是不会在牌局混乱的时候下注的。当局势不明朗的时候，固守英伦三岛，与一切有可能联合也有可能背叛的力量台面下搅基，是大不列颠的一贯走位。</p>
<p>欧洲究竟是在危机的压力下与俄国人和解，与中国人联手，与美国人保持距离，走上独立繁荣的大欧洲？</p>
<p>还是在与移民的分化、与俄国的消耗、与中国的竞争中走向衰落？</p>
<p>英国人表示：吾当外和中美，内修金融，据英伦三岛，隔英吉利海峡以观天下之变。</p>
<p>英国人不出牌，他摸了几张牌，然后跳过了这一回合。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/01/%E4%B8%AD%E5%9B%BD%E6%80%8E%E6%A0%B7%E6%B6%88%E7%81%AD996/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/%E4%B8%AD%E5%9B%BD%E6%80%8E%E6%A0%B7%E6%B6%88%E7%81%AD996/" class="post-title-link" itemprop="url">中国怎样消灭996</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-01 21:32:48 / Modified: 22:38:22" itemprop="dateCreated datePublished" datetime="2020-03-01T21:32:48-05:00">2020-03-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>但是，古尔丹，代价是什么呢？</p>
<p>获得一份收益，付出一份代价。我读萨米尔阿明时有时会感慨：原来钢炼的片头说的真是真理。</p>
<p>你不想上班，就要失去上班工资的收益；你要这份收益，你就要付出上班的代价。</p>
<p>你说隔壁老王不上班也很滋润呀，对，他失去的工资收益用别的收益补偿了呗，可能是房租，可能是私活，可能是讨厌的家族遗产…</p>
<p>这些看不到的收益，补偿了隔壁老王不上班的代价。</p>
<p>所以当你痛苦996789这些烂事时，特别是你开始思考为什么这种现象如此广泛时，你最好去看看那些没有这种现象的国家，他们为什么没有？</p>
<p>他们为什么不需要996的收益？</p>
<p>他们在用什么补偿失去这些收益的代价？知乎作为工业党人的重要据点，已经有大量资料论证了那些不需要996还能过上好日子的国家，是凭什么：</p>
<p>美帝有美元、美金、美军、好莱坞的多重全球霸权，是现行的国际秩序制定者、科技第一国、金融主导国。这些全球霸权就是全球收益，在这些收益里切下一小块，就能给吸毒者发毒品，给三千万人发粮票；</p>
<p>英国依旧在国际外交中有重要影响力，依然是英联邦的名义领袖、国际金融的重要避风港、航空工业的核心技术掌握者，而且还是美帝的紧密伙伴；</p>
<p>法国则凭借自己较完整的工业体系，和对非洲铁血般地控制，经济、文化乃至军事，还是布鲁塞尔重要的大哥；</p>
<p>德国通过堪称俾斯麦复生的纵横捭阖，用欧元渗透了整个欧洲，并且还是欧盟体系内唯一能打的工业国，多项核心工业的主导者；</p>
<p>就连日本，社畜一词发源地的日本，都有着庞大的海外经济殖民地，海外日企资产高于国内。我们现在的对外援助套路就来自于日本。所以日本的社畜更多是对普通人的管制，企业之间的竞争比我朝要和缓多了。</p>
<p>说真的，日本工作留学的中国人那么多了，普通日本人真有我们这么“畜”？</p>
<p>所以，古尔丹，代价是什么呢？</p>
<p>代价就是，能不能够把代价转移到别人身上。</p>
<p>如果美帝不能把量化宽松的代价转移出去，那美债就是屎，美股就是屎，美企就会死。但是四重结界摆在这，它转移把代价转移给你，你只能接着，于是代价的代价在你身上，不在领粮票的三千万美国人身上。</p>
<p>美帝能找别人买单，墨西哥在为它买单，我朝也在为美国人买单，美帝的单，全世界都要买，拉丁美洲已经买出了血泪史。</p>
<p>任何繁荣都是建立在奴隶身上的，问题是你能不能找到奴隶，找不到，你就只能自己做奴隶。</p>
<p>希腊的工业不就是德国人的奴隶吗？</p>
<p>中非西非的政变和旧法郎经济区，不就是法国人的奴隶吗？</p>
<p>就连韩国人，都在美帝的奴隶外做了半个日本人的奴隶。反日情绪再高涨，也改变不了韩国财阀里到处都是日本人的钱的事实；</p>
<p>你看一眼菲律宾巨头的账本，日本政府的援助贷款，美帝的世行授信，欧洲人披着新加坡皮的投资，然后换来了整个国家的矿、林、农、渔。</p>
<p>当然还有人，廉价的人，从工人到雇农，到走私黑枪和毒品的小弟，到女人，妓女，还有童妓，全球最大量的童妓。</p>
<p>整个国家，不就是奴隶么？</p>
<p>我朝这个体量，如果人人都要过上不错的日子，那在现行秩序里找不到位置。我们需要的代价太大，不是三百万人口那些小而美，干点代理的活拿点分成就能搞定的。</p>
<p>虽然很多人讲法治，法治也确实有改善的空间，但是这个空间不会太大。我个人坚信，法制也好法治也罢，都是结果，有了足够的蛋糕才能讲分配。</p>
<p>解决一两家公司可以，解决多数人的996，只能靠算账。</p>
<p>而这笔帐，你现在算不过来。第四次工业革命要不要赶上？前三次你都错过了，再错过这次又不知道几百年能翻身。要赶？钱，干活的人；</p>
<p>产能要不要输出？不输出产能过剩经济萧条失业爆发还被人割韭菜。输出？继续印钱撒钱，通胀不可避，民生就是四处灭火；</p>
<p>国防要不要建设？核心利益，海外利益，更不要说你现在已经被大哥盯着搞。要？钱，人；</p>
<p>你站在国家角度看账本，看三秒就能理解冒牌天神里弗里曼的表情。</p>
<p>为什么要反腐？就这么点钱，都少拿点，要干正事。</p>
<p>还有减税呐。</p>
<p>想翻身，甚至只是想这么走下去，代价太多。</p>
<p>我不想为什么意识形态呐喊，我只是认为，现代化有一套无法躲避的逻辑，这个过程需要巨大的代价才能得以实现，这个代价是不分意识形态的，斯大林体制，刚果被砍手的黑人，墨西哥的毒品，拉丁美洲的军阀，东南亚的家族体制，都是代价。</p>
<p>因此我对我朝在最近20年内能否消灭996，抱以相当悲观的态度。</p>
<p>个人看奋斗，简历好一点，专业有远见一点，公司找的谨慎一点，技能和人脉丰富一点，知乎人均大神，躲还是好躲的。</p>
<p>但你说到历史的进程嘛。</p>
<p>我想，大概只有三种可能，能够“消灭”996：</p>
<p>一，我朝放弃现代化和独立道路，选择依附。这样中产阶级会极大萎缩，下层数量会激增，但中产阶级能够消灭996，毕竟代理人生活得还是很好的；</p>
<p>二，我朝show hand，滚滚红尘一波流，皇国兴废在此一战，还居然灭了美帝。就此重新划分世界后，产能、货币、文化输出，享受全球收益，就能为多数人消灭996；</p>
<p>三，我朝死磕第四次工业革命，勉力维系基本盘不崩，完成产业升级，并且实现多工业细项垄断，进而在现行国际秩序外建立“新秩序”，那也能实现多数人没有996。</p>
<p>所以，古尔丹，代价是什么呢？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/29/%E4%B8%80%E4%BA%A9%E4%B8%89%E5%88%86%E5%9C%B0%E9%A2%98%E5%BA%93-%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF%E7%AD%94%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%E4%B8%80%E4%BA%A9%E4%B8%89%E5%88%86%E5%9C%B0%E9%A2%98%E5%BA%93-%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF%E7%AD%94%E6%A1%88/" class="post-title-link" itemprop="url">一亩三分地题库+新手上路答案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-29 16:54:05 / Modified: 17:54:40" itemprop="dateCreated datePublished" datetime="2020-02-29T16:54:05-05:00">2020-02-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.一亩三分地 新手上路 网站规则 - 满分5大米(适用于所有用户)<br>2.一亩三分地 考试中心 满分95大米(只适用于2019年之后注册的新人)<br>3.一亩三分地 每日答题 题库</p>
<h3 id="网站规则-满分5大米"><a href="#网站规则-满分5大米" class="headerlink" title="网站规则 - 满分5大米"></a>网站规则 - 满分5大米</h3><ol>
<li>一亩三分地发帖可以选择内容用hide进行隐藏。隐藏方式：[hide=200]隐藏的内容[/hide] 下面哪个选项hi‍‌‌‌‌‌‌‌‍‍‍‌‌‌‍‌‌‌‌‌de正确。 (1.0 分)<br><strong>A. 两人第一次华山论剑，争的是荣名与[hide=188]《九阴真经》[/hide]；</strong><br>B. 第二次在桃花岛过招，是为了郭靖与[hide=188]欧阳克[\hide]争婚。<br>C. 第三次海上相斗，生死只隔一线，但(hide=188)洪七公(\ hide)手下尚自容让；<br>D. 现下第四次恶战，[hide188]才是各出全力[/hide]，再无半点留情。<br>E. 洪七公伸指疾点欧阳锋背心[hide=188]“凤尾穴”(/hide)，要迫他松手。</li>
<li>为什么一亩三分地除了租房广告找室友、学有飞友工友、本地版聚等少数版块之外，绝大多数板块都不允许拉群？ (1.0 分)<br>A. 地里信息是公开的，全部回复每个人都可以看到。而群里的信息，作为新入群的同学是无法看到历史消息的，并且无法查找<br>B. 公开自己的微信，将来可能会被人人肉或者骚扰<br>C. 地里的信息永远存在，有些群很可能不活跃甚至不存在了，里面的讨论也就消失了<br><strong>D. 以上全都理解并接受</strong></li>
<li>在下面哪些板块里留微信号等各种联系方式，事后可以要求版主删除？ (1.0 分)<br>A. 如果发在求职类板块里，可以删除，我的隐私你得尊重啊<br>B. 如果发在留学类板块里，可以删除，毕竟我年少不懂事嘛<br>C. 如果发在非正事、无聊帖子里，可以删除，毕竟没啥营养啊<br><strong>D. 绝大多数板块禁止留微信、拉群，如果你非要发出来，那就永远不删。另外，私下联系建议发站内信。</strong></li>
<li>为什么我们不鼓励用谐音或者各种拐弯抹角的说法来指代公司或者学校名称？比如：“湾区某元音开头和结尾公司” (1.0 分)<br>A. 也许有什么顾虑吧<br>B. 这样不好玩<br><strong>C. 写成这样子，别人看不懂，也搜不到。如果别人也这样写，你也看不懂、搜不到。信息没法分享和交流。</strong><br>D. 不知道</li>
<li>下面哪个说法是错误的？ (1.0 分)<br>A. 连续超过14天不登录，每天扣一个大米，直到大米数=100<br><strong>B. 抖包袱版看帖，不会消耗积分</strong><br>C. 可以消耗积分更改用户名（网站右上角设置-&gt;个人资料-&gt;更改用户名）<br>D. 看到干货帖子和回复，给作者加分，不会消耗我的积分<br>E. 每日签到、每日答题都可以拿到积分奖励<br>F. 手机app里也可以每日签到，好方便！<br>G. 给地里官方app五星好评，可以拿加分奖励: <a href="http://www.1point3acres.com/bbs/thread-446981-1-1.html" target="_blank" rel="noopener">www.1point3acres.com/bbs/thread-446981-1-1.html</a><br>H. 在手工加分的帖子里，多次回复骗取积分，会被系统检测到，积分扣除+额外扣分！<br>I. 网站上方导航栏 -&gt; 道具中心，可以兑换匿名卡，把自己的帖子匿名。</li>
</ol>
<h3 id="网站规则-满分95大米"><a href="#网站规则-满分95大米" class="headerlink" title="网站规则 - 满分95大米"></a>网站规则 - 满分95大米</h3><ol>
<li>一亩三分地里有哪些方面的信息？ (5.0 分)<br><strong>A. 美国大学各专业录取信息<br>B. 美国和中国公司面试题目<br>C. 买房买车租‍‌‌‌‌‌‌‌‍‍‍‌‌‌‍‌‌‌‌‌房等生活信息<br>D. 移民签证H1B等信息<br>E. 公开课、刷题、做项目<br>F. 八卦我司版：美国公司评价（各公司员工发帖）<br>G. 抖包袱版：各公司工资offer的详细数目<br>H. 缘来如此版可以发帖征友<br>I. 职场达人：中美职场和职业发展话题<br>J. TOEFL/GRE考试信息</strong></li>
<li>一亩三分地有积分限制，请戳这里阅读《攒积分和消耗积分完全指南》然后回答：下面哪些说法正确？ (10.0 分)<br><strong>A. 认真做考卷，很容易拿到满分<br>B. 每日签到（网站右上方），奖励1颗大米<br>C. 每日答题（网站右上方），答对了奖励1颗大米，答错了消耗1颗<br>D. 设置头像，奖励一颗大米（只能获得一次）<br>E. 验证邮箱，奖励一颗大米（只能获得一次）<br>F. 管理员每日选择2-3个干货帖子全站置顶，大家会奖励给你大米<br>G. 分享面经、录取信息、工资数目等干货，或者积极参与讨论<br>H. 积极参与论坛各种活动，比如给地里官方app五星好评<br>I. 《攒积分和消耗积分完全指南》里有更多获取积分方法的说明<br>J. 积分变更记录在网站右上角设置-&gt;积分里能找到（2019年3月2日之前的部分记录不显示，之后的全显示）</strong></li>
<li>一亩三分地发帖可以选择内容进行隐藏。举个例子：<br>黄蓉哭了一会，抽抽噎噎的道：“我听爹爹说过，洪老前辈有一套武功，当真是天下无双、古今独步，甚至全真教的王重阳也忌惮三分，叫做……叫做……咦，我怎么想不起来啦，明明刚才我还记得的，我想求他教你，这套拳法叫做……叫做……”其实她哪里知道，全是信口胡吹。洪七公在树顶上听她苦苦思索，实在忍不住了，喝道：“叫做‘[hide=200]降龙十八掌[/hide]’！”说着一跃而下。上述段落里，“降龙十八掌”五个字被隐藏，只有积分&gt;=200分的用户才能看到。<br>隐藏方式：[hide=200]隐藏的内容[/hide] 注意不要添加多余的空格！第二个hide前面的斜线别弄反方向！下面隐藏的内容哪个被188分正确隐藏？真相只有一个！ (10.0 分)<br>A. 柯南的名字是[hide=188]工藤新一[\hide]<br>B. 柯南的名字是[hide]工藤新一[/hide=188]<br><strong>C. 柯南的名字是[hide=188]工藤新一[/hide]</strong><br>D. 柯南的名字是[hide=188]工藤新一[\ hide]<br>E. 柯南的名字是[hide=188]工藤新一{\hide}<br>F. 柯南的名字是(hide=188)工藤新一(\hide)</li>
<li>在论坛发slack群、qq群、微信群等任何站外讨论方式，会如何？ (10.0 分)<br>A. 如果发在本地版聚、租房找室友、飞友学友工友版块，是允许的<br>B. 如果发在求职、面经、申请类板块里，都会被删帖扣分<br>C. 举报这些群，可能得到加分奖励<br><strong>D. 以上都正确</strong></li>
<li>下面哪种情况，管理员会按照你的要求，进行删帖？ (10.0 分)<br>A. 问了问题，得到了答案，然后我过河拆桥，删帖让其他人看不到<br>B. 尽管地里不允许，但是我到处留微信号，然后说隐私暴露要求删帖<br>C. 发帖赚到了积分，看到了有权限设置的内容，然后反悔<br><strong>D. 这些情况全都不删帖！</strong></li>
<li>你的一亩三分地账号很宝贵，在别的网站，考完托福你就离开了，申请完了你也不会再去。但是在一亩三分地，拿到录取以后，你找实习要回来，找全职工作要回来，申请OPT要回来，等H1b签证和绿卡要回来，甚至工作几年后要跳槽你也要回来看求职信息 - 随着地里的壮大，你会经常回来。<br>下面哪些方法可以保护你的账号？ (10.0 分)<br><strong>A. 给账号设置复杂密码，并且只在一亩三分地使用该密码。<br>B. 把地里的邮件放入白名单以免被判定为垃圾邮件而导致收不到密码重设等重要信息（地里从来不发广告）。<br>C. 绑定微信。如果账号有异常，会被系统要求扫码登录，而且扫码登录比输入密码方便。<br>D. 管理好用来注册账号的电子邮箱，如果连邮箱都没了，那就惨了。。。</strong><br>E. 别那么多有的没的，我爱咋地就咋地。</li>
<li>下面哪些发帖行为，值得鼓励和倡导？ (10.0 分)<br>A. 随便发就是了，反正有版主和管理员给调整<br><strong>B. 读一下各个版块的置顶信息，了解网站规则。<br>C. 发帖之前，先浏览有哪些版块，帖子要发在对应的板块里。</strong><br>D. 帖子设置回复可见，大家必须回复才能看到，然后一堆人发“顶”<br><strong>E. 帖子标题最好能用一句话概括主要内容，方便大家阅读<br>F. 地里很多帖子有分类设置，方便大家查找，发帖确保分类信息设置合理</strong><br>G. 很多帖子有权限设置，我积分不够，到处发“看不到啊”、“积分不够啊”，水掉论坛</li>
<li>新人积分不够。下面哪些做法正确？ (5.0 分)<br><strong>A. 分享干货、签到答题、参加活动等，争取早日攒够积分。</strong><br>B. 到处发帖抱怨积分不够、看不到，没准会有帮助呢。<br>C. 想各种办法绕开积分限制，比如要求楼主私下把信息发给我<br>D. 注册个小号，相互加分（嘿嘿，地里有后台系统检测哦）</li>
<li>下面哪些方式，可以获得积分奖励？ (5.0 分)<br><strong>A. 分享干货，无论是录取信息、面经题目、工资数据，还是各种生活经验。</strong><br>B. 在帖子里给别人加分，告诉对方给我加回来。<br><strong>C. 认真参与网站里的讨论，贡献我的看法和信息</strong><br>D. 没有分享干货，但是可以缠着别人要积分<br><strong>E. 干货帖子被全站置顶或者公众号推出，至少拿100分，很多帖子拿到200+</strong><br>F. 我有信息可以分享，但是大家来给我加分吧，谁加了分我私下里发给你</li>
<li>一亩三分地里可以购买VIP通行证，位于网站上方导航栏 -&gt; VIP。关于VIP，下面哪些说法正确？ (10.0 分)<br><strong>A. VIP可以瞬间解锁地里有权限的帖子，获得阅读权限<br>B. VIP下载附件不扣积分，不受权限限制<br>C. VIP用户可以自由搜索，不扣积分</strong><br>D. VIP是“免责金牌”，在地里不受规则约束，可以为所欲为<br><strong>E. VIP获得的只是阅读帖子权限，网站有的功能仍需积分（可以攒大米或者购买蓝莓）<br>F. VIP收入用来支付一亩三分地运营和发展的必要花费；我的打赏能支持一亩三分地做的更好</strong></li>
<li>下面哪种行为，在地里会被扣光积分，甚至封号？ (10.0 分)<br><strong>A. 戾气十足、人身攻击<br>B. 种种手段恶意刷分<br>C. 软硬广告或导流吸粉<br>D. 造谣或者发钓鱼贴<br>E. 多人共享账号<br>F. 违反版规，胡乱跨版发帖，到处留邮箱或微信号<br>G. 购买了VIP通行证，作为付费用户，违反网站规则。</strong></li>
</ol>
<h3 id="每日答题题库"><a href="#每日答题题库" class="headerlink" title="每日答题题库"></a>每日答题题库</h3><p>【题目】 公司之间级别对应，如下哪个是错误的？<br>Google T5 = Facebook E5/6<br>Uber Sr II = Lyft T6<br>Amazon L7 = Facebook E6<br>✓ Facebook L6 = Facebook E6</p>
<p>【题目】一亩三分地发帖可以选择内容用 hide 进行隐藏。隐藏方式：[hide=200]隐藏的内容[/hide] 下面哪个选项 hide 正确。<br>✓ A. 两人第一次华山论剑，争的是荣名与[hide=188]《九阴真经》[/hide]；<br>B. 第二次在桃花岛过招，是为了郭靖与[hide=188]欧阳克[\hide]争婚。<br>C. 第三次海上相斗，生死只隔一线，但(hide=188)洪七公(\ hide)手下尚自容让；<br>D. 现下第四次恶战，[hide188]才是各出全力[/hide]，再无半点留情。<br>E. 洪七公伸指疾点欧阳锋背心[hide=188]“凤尾穴”(/hide)，要迫他松手。</p>
<p>【题目】为什么一亩三分地除了租房广告找室友、学有飞友工友、本地版聚等少数版块之外，绝大多数板块都不允许拉群？<br>A. 地里信息是公开的，全部回复每个人都可以看到。而群里的信息，作为新入群的同学是无法看到历史消息的，并且无法查找<br>B. 公开自己的微信，将来可能会被人人肉或者骚扰<br>C. 地里的信息永远存在，有些群很可能不活跃甚至不存在了，里面的讨论也就消失了<br>✓ D. 以上全都理解并接受</p>
<p>【题目】在下面哪些板块里留微信号等各种联系方式，事后可以要求版主删除？<br>A. 如果发在求职类板块里，可以删除，我的隐私你得尊重啊<br>B. 如果发在留学类板块里，可以删除，毕竟我年少不懂事嘛<br>C. 如果发在非正事、无聊帖子里，可以删除，毕竟没啥营养啊<br>✓ D. 绝大多数板块禁止留微信、拉群，如果你非要发出来，那就永远不删。另外，私下联系建议发站内信。</p>
<p>【题目】为什么我们不鼓励用谐音或者各种拐弯抹角的说法来指代公司或者学校名称？ 比如：“湾区某元音开头和结尾公司”，你能猜到是哪家吗？<br>A. 也许有什么顾虑吧<br>B. 这样不好玩<br>✓ C. 写成这样子，别人看不懂，也搜不到。如果别人也这样写，你也看不懂、搜不到。信息没法分享和交流。<br>D. 不知道</p>
<p>【题目】下面哪个说法是错误的？<br>A. 连续超过 14 天不登录，每天扣一个大米，直到大米数=100<br>✓ B. 抖包袱版看帖，不会消耗积分<br>C. 可以消耗积分更改用户名（网站右上角设置-&gt;个人资料-&gt;更改用户名）<br>D. 看到干货帖子和回复，给作者加分，不会消耗我的积分 E. 每日签到、每日答题都可以拿到积分奖励<br>F. 手机 app 里也可以每日签到，好方便！<br>G. 给地里官方 app 五星好评，可以拿加分奖励: <a href="http://www.1point3acres.com/bbs/thread-446981-1-1.html" target="_blank" rel="noopener">www.1point3acres.com/bbs/thread-446981-1-1.html</a> H. 在手工加分的帖子里，多次回复骗取积分，会被系统检测到，积分扣除+额外扣分！<br>I. 网站上方导航栏 -&gt; 道具中心，可以兑换匿名卡，把自己的帖子匿名。</p>
<p>【题目】 下面哪个情况，不会消耗你的积分？<br>超过 14 天不登录<br>使用论坛搜索<br>下载附件<br>✓ 看到干货帖子和精华回复，给作者加分！</p>
<p>【题目】 下面哪个州，没有 income tax?<br>✓ Nevada<br>New York<br>Nebraska<br>Massachusetts</p>
<p>【题目】 下面哪个州，有 state income tax<br>Tennessee<br>Alaska<br>Washington<br>✓ Mississippi</p>
<p>【题目】 求内推如何作死？<br>一下子叫好多人给内推同一家公司<br>别人回复慢了就抱怨<br>简历上撒谎<br>✓ 这些都会作死</p>
<p>【题目】 下面哪种方法，可以妥妥拿到积分？<br>上传头像<br>每日签到（需绑定微信）<br>分享干货<br>✓ 这些全都可以</p>
<p>【题目】 回答别人的私信提问还需要消耗我 5 大米怎么办？<br>✓ 直接在版面回答，这样大家都能看见</p>
<p>【题目】 下面哪种行为，在地里会被扣光积分，甚至封号？<br>✓ 这些全都会</p>
<p>【题目】一亩三分地发帖可以用 hide 语法隐藏内容。下面哪个写法正确？<br>✓ 柯南的名字是[hide=200]工藤新一[/hide]<br>柯南的名字是[hide=200]工藤新一[\hide]<br>柯南的名字是[hide=200]工藤新一[hide]<br>柯南的名字是[hide=200]工藤新一[/hide=200]</p>
<p>【题目】 在 Linkedin 上求内推如何作死<br>看也不看对方情况，直接扔简历要求内推，国人必须帮助国人啊<br>写模板内容要求内推，不论男女都叫学姐<br>也不自我介绍，就要求对方介绍公司情况<br>✓ 这些都会作死</p>
<p>【题目】一亩三分地鼓励如何发面经？<br>遇到有人留邮箱，私下发面经的，点举报<br>积分隐藏[hide==188]内容[/hide]<br>✓ 以上都正确</p>
<p>【题目】 下面哪个大学在华盛顿州？<br>Washington University<br>✓ University of Washington<br>George Washington University<br>Washington College</p>
<p>【题目】下面哪个大学不在 Virginia/DC 附近<br>✓ Washington and Jefferson College<br>Trinity Washington University<br>George Washington University<br>Washington and Lee University</p>
<p>【题目】 下面哪个州，对公司友好，所以吸引了美国很多公司注册？<br>加利福尼亚<br>✓ 特拉华<br>佛罗里达<br>纽约</p>
<p>【题目】 下面哪个州，有 state income tax<br>South Dakota<br>Wyoming<br>✓ North Dakota<br>Tennessee</p>
<p>【题目】 下面哪个州，没有 state income tax<br>New York<br>New Jersey<br>✓ New Hampshire<br>New Mexico</p>
<p>【题目】 下面哪个州，没有 state income tax?<br>✓ Florida<br>Georgia<br>Hawaii<br>Idahoda</p>
<p>【题目】 下面哪个州，没有 state income tax?<br>Alabama<br>✓ Alaska<br>Arizona<br>Arkansas</p>
<p>【题目】下面哪个州冬天最暖和？<br>Minnesota<br>✓ Oklahoma<br>Michigan<br>Massachusetts</p>
<p>【题目】下面哪个大学实际上不存在？<br>University of California, San Francisco<br>University of Massachusetts, Dartmouth<br>✓ University of Michigan, Twin City<br>University of Nevada, Las Vegas</p>
<p>【题目】下面哪所大学所在城市不是波士顿？<br>✓ Boston College<br>Berklee College Of Music<br>Northeastern University<br>Boston University</p>
<p>【题目】下面哪个说法错误？<br>伊利诺伊大学在芝加哥有校区<br>✓ 芝加哥是美国著名的雨城<br>美国西北大学在芝加哥有校区<br>芝加哥 skydeck 上可以看到四个州</p>
<p>【题目】 Which company is the largest single✓site employer in the US?<br>Walmart<br>Ford<br>Costco<br>✓ Disney World</p>
<p>【题目】 下面哪种方法，可以妥妥拿到积分？<br>分享干货<br>上传头像<br>每日签到（需绑定微信）<br>✓ 这些全都可以</p>
<p>【题目】 下面哪家公司的总部不在西雅图<br>亚马逊<br>阿拉斯加航空公司<br>星巴克<br>✓ 波音</p>
<p>【题目】 给论坛 ios 或者安卓手机应用留评价如何获取 50 大米？<br>留 5 星评价<br>截屏作为证据<br>上传到第一个大区的”官方开发版“<br>✓ 以上步骤都需要</p>
<p>【题目】 地里发帖可以隐藏内容。假如要设置 200 积分以上才可以看到，下面哪个语法正确？<br>[hide]想要隐藏的内容[/hide]<br>[hide=200 ]想要隐藏的内容[/hide]<br>✓ [hide=200]想要隐藏的内容[/hide]<br>[hide=200]想要隐藏的内容[hide]</p>
<p>【题目】 地里面经数目最多的是哪家公司？<br>Facebook<br>Google<br>✓ Amazon<br>Uber</p>
<p>【题目】 Negotiate 工资的时候，哪种做法有利于得到更大的包裹？<br>拿地里抖包袱版的工资数字要对方 match<br>直接告诉对方自己目前薪酬，让对方看着良心办<br>开一个天价，谈不拢就散伙<br>✓ 精读地里谈工资宝典，知己知彼，百战不殆</p>
<p>【题目】 which state is University of Miami located?<br>California<br>Nevada<br>✓ Florida<br>Ohio</p>
<p>【题目】 下面哪个城市没有 SUNY（纽约州立大学）校区？<br>Albany<br>Buffalo<br>✓ Fulton<br>Stony Brook</p>
<p>【题目】 下面哪个州里有 Disney World？<br>✓ Florida<br>New York<br>North Carolina<br>Texas</p>
<p>【题目】 下面哪所大学所在城市不是波士顿？<br>✓ MIT<br>Boston University<br>Northeastern University<br>Emerson College</p>
<p>【题目】 关于旧金山市中心描述，下面哪个不正确？<br>走路得看着路，很多流浪汉，地上屎尿一不小心会踩上<br>车里一定不要放东西，但即使不放，也可能被砸车玻璃<br>Uber/Airbnb/Pinterest/Twitter 等著名科技公司都在 SOMA 区<br>✓ 旧金山创业公司很多，被称为“硅谷”</p>
<p>【题目】 一亩三分地是哪年创立的？<br>✓ 2009<br>2011<br>2013<br>2015</p>
<p>【题目】 下面哪个州在美国西海岸<br>VirginiaNorth<br>DakotaMaine<br>✓ Washington</p>
<p>【题目】 which state is University of Miami located?<br>Ohio<br>✓ Florida<br>Nevada<br>California</p>
<p>【题目】 加州大学有多个分校，下面哪个成立时间最短？<br>UC Davis<br>✓ UC Merced<br>UC Riverside<br>UC Santa Cruz</p>
<p>【题目】 下面哪个专业，不是 STEM，OPT 没法延期？<br>会计学以前不是，现在很多学校 stem 获批<br>数据科学<br>EECS<br>✓ 教育学</p>
<p>【题目】 哪种选校策略最合理？<br>按照排名高低选，谁高谁就好<br>交给中介选，反正不想操心<br>所有学校都申，蒙中哪个算哪个<br>✓ 根据自己下一步职业和学业目标，参考地里数据和成功率，认真斟酌</p>
<p>【题目】 一亩三分地是谁创立的？<br>✓ Warald<br>俞敏洪<br>李大辉<br>徐小平</p>
<p>【题目】 下面几个州，哪个离美国首都最远？<br>Maryland<br>Delaware<br>✓ North Carolina<br>Virginia</p>
<p>【题目】 地里数据科学类职位面经放在在什么版最合理？<br>数据科学版<br>美国面经版数据科学分类<br>✓ 数科面经版<br>找工求职版</p>
<p>【题目】 下面哪个公司总部在圣地亚哥？<br>✓ Qualcomm<br>AMD<br>Nvidia<br>Netflix</p>
<p>【题目】 下面哪种情况，管理员会按照你的要求，进行删帖？<br>问了问题，得到了答案，然后我过河拆桥，删帖让其他人看不到<br>发帖赚到了积分，看到了有权限设置的内容，然后反悔<br>尽管地里不允许，但是我到处留微信号，然后说隐私暴露要求删帖<br>✓ 这些情况全都不删帖！</p>
<p>【题目】 Miami University 在哪个城市<br>Miami, Florida<br>Las Vegas, Nevada<br>✓ Oxford, Ohio<br>Los Angeles, California</p>
<p>【题目】 想找室友或者当房东，帖子发在哪里？<br>✓ 租房广告|找室友版<br>房地产版<br>生活版<br>面经版</p>
<p>【题目】 在论坛发 slack 群，qq 群，微信群，任何站外讨论方式，会如何？<br>如果发在求职面经大区，申请大区，都会被删帖扣分<br>举报这些群，可能得到加分奖励<br>✓ 以上都正确<br>如果发在版聚，或者本地版块，是允许的</p>
<p>【题目】 下面哪类版块，可以拉群，而且不会被警告扣分？<br>录取结果汇报<br>求职、面经<br>内推<br>✓ 学友工友、找室友或者版聚本地</p>
<p>【题目】下面哪个说法错误？<br>雪城大学尽管在纽约州，但是离纽约城很远！<br>✓ 中国驻纽约领事馆位于法拉盛中国城，周围全是好吃的！<br>哥伦比亚大学离纽约中央公园很近<br>纽约州立大学石溪分校学费很便宜</p>
<p>【题目】 下面哪个学术会议不是机器学习领域的？<br>CVPR<br>ICML<br>SIGKDD<br>✓ ICSE</p>
<p>【题目】 下面哪个童话故事不是安徒生写的<br>✓ 尼尔斯骑鹅旅行记<br>冰雪女王<br>卖火柴的小女孩<br>国王的新装</p>
<p>【题目】 下面哪个作家是英国人？<br>✓Charles Dickens<br>Ernest Hemingway<br>Victor Hugo<br>Alexander Pushkin</p>
<p>【题目】 income tax on wages<br>✓North Dakota<br>South Dakota<br>Wyoming<br>Teness…</p>
<p>【题目】 下面哪个machine learning 的模型不是supervised<br>Logistic regression<br>✓Clustering<br>SVM<br>Decision Tree</p>
<p>【题目】 Apollo 11是哪一年登月的？<br>1969</p>
<p>【题目】 下面哪个公司的streaming service不是会员subscription付费模式运营的？<br>✓tubi</p>
<p>【题目】 著名篮球运动员姚明效力的NBA球队是休斯敦火箭队。取名“ 火箭队”是因为休斯敦是美国著名的?<br>钢城<br>汽车城<br>✓ 宇航工业城<br>电影城</p>
<p>【题目】 音乐家贝多芬出生于哪国？<br>✓ 德国<br>法国<br>意大利<br>英国</p>
<p>【题目】 下面哪个Ivy League，离东海岸最远？<br>Brown<br>Dartmouth<br>Princeton<br>✓ Cornell</p>
<p>【题目】 美国哪个州没有夏令时？<br>南达科他州<br>爱荷华州<br>✓亚利桑那州<br>阿肯色州</p>
<p>【题目】 下面哪部作品是喜剧？<br>麦克白<br>李尔王<br>✓仲夏夜之梦<br>哈姆雷特</p>
<p>【题目】 下面哪个公司总部不在湾区？<br>google<br>✓snapchat<br>facebook<br>Apple</p>
<p>【题目】 下面哪所纽约高校坐落于中央公园附近？<br>Fordham University<br>New York University<br>New York Institute of Technology<br>✓Columbia University</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向对象编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-29 14:05:42 / Modified: 15:06:46" itemprop="dateCreated datePublished" datetime="2020-02-29T14:05:42-05:00">2020-02-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于状态和数据的处理，我们有必要提一下“面向对象编程”（Object-oriented programming，缩写为 OOP）这个编程范式了。我们知道，<strong>面向对象的编程有三大特性：封装、继承和多态</strong>。</p>
<p>面向对象编程是种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。</p>
<p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。</p>
<p>目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。</p>
<p>现在，几乎所有的主流语言都支持面向对象，比如：Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP 等。</p>
<p>说起面向对象，就不得不提由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合作出版的《<a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">设计模式：可复用面向对象软件的基础</a>》（Design Patterns - Elements of Reusable Object-Oriented Software）一书，在此书中共收录了 23 种设计模式。</p>
<p>这本书的 23 个经典的设计模式，基本上就是说了两个面向对象的核心理念。</p>
<ul>
<li>“Program to an ‘interface’, not an ‘implementation’.”<ul>
<li>使用者不需要知道数据类型、结构、算法的细节。</li>
<li>使用者不需要知道实现细节，只需要知道提供的接口。</li>
<li>利于抽象、封装、动态绑定、多态。</li>
<li>符合面向对象的特质和理念。</li>
</ul>
</li>
<li>“Favor ‘object composition’ over ‘class inheritance’.”<ul>
<li>继承需要给子类暴露一些父类的设计和实现细节。</li>
<li>父类实现的改变会造成子类也需要改变。</li>
<li>我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。</li>
<li>继承更多的应该是为了多态。</li>
</ul>
</li>
</ul>
<h1 id="示例一：拼装对象"><a href="#示例一：拼装对象" class="headerlink" title="示例一：拼装对象"></a>示例一：拼装对象</h1><p>好，我们先来看一个示例，假设我们有如下的描述：</p>
<ul>
<li><strong>四个物体</strong>：木头桌子、木头椅子、塑料桌子、塑料椅子</li>
<li><strong>四个属性</strong>：燃点、密度、价格、重量</li>
</ul>
<p>那么，我们怎么用面向对象的方式来设计我们的类呢？</p>
<p>参看下图：</p>
<p><img src="../images/21f0377bc34b52e5c007a3f7c76054b7.png" alt="img"></p>
<ul>
<li>图的左边是“材质类” Material。其属性有燃点和密度。</li>
<li>图的右边是“家具类” Furniture。其属性有价格和体积。</li>
<li>在 Furniture 中耦合了 Material。而具体的 Material 是 Wood 还是 Plastic，这是在构造对象的时候注入到 Furniture 里就好了。</li>
<li>这样，在家具类中，通过材料的密度属性和家具的体积属性就可以计算出重量属性。</li>
</ul>
<p>这样设计的优点显而易见，它能和现实世界相对应起来。而且，材料类是可以重用的。这个模式也表现了面向对象的拼装数据的另一个精髓——喜欢组合，而不是继承。这个模式在设计模式里叫“桥接模式”。</p>
<p>和函数式编程来比较，函数式强调于动词，而面向对象强调于名词，面向对象更多的关注于接口间的关系，而通过多态来适配不同的具体实现。</p>
<h1 id="示例二：拼装功能"><a href="#示例二：拼装功能" class="headerlink" title="示例二：拼装功能"></a>示例二：拼装功能</h1><p>再来看一个示例。我们的需求是这样的——处理订单，处理订单有一个关键的动作就是计算订单的价格。有的订单需要打折，有的则不打折。</p>
<p>在进行面向对象编程时，假设我们用 Java 语言，我们需要先写一个接口—— <code>BillingStrategy</code>，其中就是一个方法：<code>GetActPrice(double rawPrice)</code>，输入一个原始的价格，输出一个根据相应的策略计算出来的价格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface BillingStrategy &#123;</span><br><span class="line">    public double GetActPrice(double rawPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口很简单，只是对接口的抽象，而与实现无关。现在我们需要对这个接口进行实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Normal billing strategy (unchanged price)</span><br><span class="line">class NormalStrategy implements BillingStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double GetActPrice(double rawPrice) &#123;</span><br><span class="line">        return rawPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Strategy for Happy hour (50% discount)</span><br><span class="line">class HappyHourStrategy implements BillingStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double GetActPrice(double rawPrice) &#123;</span><br><span class="line">        return rawPrice * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了两个策略，一个是不打折的：<code>NormalStrategy</code>，一个是打了 5 折的：<code>HappyHourStrategy</code>。</p>
<p>于是，我们先封装订单项 <code>OrderItem</code>，其包含了每个商品的原始价格和数量，以及计算价格的策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class OrderItem &#123;</span><br><span class="line">    public String Name;</span><br><span class="line">    public double Price;</span><br><span class="line">    public int Quantity;</span><br><span class="line">    public BillingStrategy Strategy;</span><br><span class="line">    public OrderItem(String name, double price, int quantity, BillingStrategy strategy) &#123;</span><br><span class="line">        this.Name &#x3D; name;</span><br><span class="line">        this.Price &#x3D; price;</span><br><span class="line">        this.Quantity &#x3D; quantity;</span><br><span class="line">        this.Strategy &#x3D; strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在我们的订单类—— <code>Order</code> 中封装了 <code>OrderItem</code> 的列表，即商品列表。并在操作订单添加购买商品时，加入一个计算价格的 <code>BillingStrategy</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Order &#123;</span><br><span class="line">    private List&lt;OrderItem&gt; orderItems &#x3D; new ArrayList&lt;OrderItem&gt;();</span><br><span class="line">    private BillingStrategy strategy &#x3D; new NormalStrategy();</span><br><span class="line"> </span><br><span class="line">    public void Add(String name, double price, int quantity, BillingStrategy strategy) &#123;</span><br><span class="line">        orderItems.add(new OrderItem(name, price, quantity, strategy));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Payment of bill</span><br><span class="line">    public void PayBill() &#123;</span><br><span class="line">        double sum &#x3D; 0;</span><br><span class="line">        for (OrderItem item : orderItems) &#123;</span><br><span class="line">            </span><br><span class="line">            actPrice &#x3D; item.Strategy.GetActPrice(item.price * item.quantity);</span><br><span class="line">            sum +&#x3D; actPrice;</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;%s -- %f(%d) - %f&quot;, </span><br><span class="line">            		item.name, item.price, item.quantity, actPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Total due: &quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，我们在 <code>PayBill()</code> 函数中，把整个订单的价格明细和总价打印出来。</p>
<p>在上面这个示例中，可以看到，我把订价策略和订单处理的流程分开了。这么做的好处是，我们可以随时给不同的商品注入不同的价格计算策略，这样一来就有很高的灵活度了。剩下的事就交给我们的运营人员来配置不同的商品使用什么样的价格计算的策略了。</p>
<p>注意，现实社会中，订单价格计算会比这个事复杂得多，比如：有会员价，有打折卡，还有商品的打包价等，而且还可以叠加不同的策略（叠加策略用前面说的函数式的 pipeline 或 decorator 就可以实现）。我们这里只是为了说明面向对象编程范式，所以故意简单化了。</p>
<p>其实，这个设计模式叫——策略模式。我认为，这是设计模式中最为经典的模式了，其充分体现了面向对象编程的方式。</p>
<h1 id="示例三：资源管理"><a href="#示例三：资源管理" class="headerlink" title="示例三：资源管理"></a>示例三：资源管理</h1><p>先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line"> </span><br><span class="line">void foo() &#123;</span><br><span class="line">    m.lock();</span><br><span class="line">    Func();</span><br><span class="line">    if ( ! everythingOk() ) return; </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    m.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，上面这段代码是有问题的，原因是，那个 <code>if</code> 语句返回时没有把锁给 unlock 掉，这会导致锁没有被释放。如果我们要把代码写对，需要在 return 前 unlock 一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line"> </span><br><span class="line">void foo() &#123;</span><br><span class="line">    m.lock();</span><br><span class="line">    Func();</span><br><span class="line">    if ( ! everythingOk() ) &#123;</span><br><span class="line">        m.unlock();</span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    m.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在所有的函数退出的地方都要加上 <code>m.unlock();</code> 语句，这会让我们很难维护代码。于是可以使用面向对象的编程模式，我们先设计一个代理类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class lock_guard &#123;</span><br><span class="line">	private: </span><br><span class="line">		mutex &amp;_m;</span><br><span class="line">	public:</span><br><span class="line">		lock_guard(mutex &amp;m):_m(m) &#123; _m.lock(); &#125;</span><br><span class="line">		~lock_guard() &#123; _m.unlock(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，我们的代码就可以这样写了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line"> </span><br><span class="line">void foo() &#123;</span><br><span class="line">	lock_guard guard(m);</span><br><span class="line">	Func();</span><br><span class="line">	if ( ! everythingOk() ) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个技术叫 RAII（Resource Acquisition Is Initialization）， 是 C++ 中的一个利用了面向对象的技术。这个设计模式叫“代理模式”。我们可以把一些控制资源分配和释放的逻辑交给这些代理类，然后，就只需要关注业务逻辑代码了。而且，在我们的业务逻辑代码中，减少了这些和业务逻辑不相关的程序控制的代码。</p>
<p>从上面的代码中，我们可以看到下面几个面向对象的事情。</p>
<ul>
<li>我们使用接口抽象了具体的实现类。</li>
<li>然后其它类耦合的是接口而不是实现类。这就是多态，其增加了程序的可扩展性。</li>
<li>因为这就是接口编程，所谓接口也就是一种“协议”，就像 HTTP 协议一样。浏览器和后端的程序都依赖于这一种协议，而不是具体实现（如果是依赖具体实现，那么浏览器就要依赖后端的编程语言或中间件了，这就太恶心了）。于是，浏览器和后端的程序就完全解开依赖关系，而去依赖于一个标准的协议。</li>
<li>这就是面向对象的编程范式的精髓！同样也是 IoC/DIP（控制反转 / 依赖倒置）的本质。</li>
</ul>
<h1 id="IoC-控制反转"><a href="#IoC-控制反转" class="headerlink" title="IoC 控制反转"></a>IoC 控制反转</h1><p>关于 IoC 的的概念提出来已经很多年了，其被用于一种面向对象的设计。我在这里再简单地回顾一下这个概念。我先谈技术，再说管理。</p>
<p>话说，我们有一个开关要控制一个灯的开和关这两个动作，最常见也是最没有技术含量的实现会是这个样子：</p>
<p><img src="../images/6095b6ad1e168cb3bd973bf41489b1ca.jpg" alt="img"></p>
<p>然后，有一天，我们发现需要对灯泡扩展一下，于是做了个抽象类：</p>
<p><img src="../images/9f8d0a147a15fe6c0273796bedce1dc3.jpg" alt="img"></p>
<p>但是，如果有一天，我们发现这个开关可能还要控制别的不单单是灯泡的东西，就会发现这个开关耦合了灯泡这种类别，非常不利于扩展，于是反转控制出现了。</p>
<p>就像现实世界一样，造开关的工厂根本不关心要控制的东西是什么，它只做一个开关应该做好的事，就是把电接通，把电断开（不管是手动的，还是声控的，还是光控，还是遥控的）。而我们造的各种各样的灯泡（不管是日光灯，白炽灯）的工厂也不关心你用什么样的开关，反正我只管把灯的电源接口给做出来。然后，开关厂和电灯厂依赖于一个标准的通电和断电的接口。于是产生了 IoC 控制反转，如下图。</p>
<p><img src="../images/4d1b95052b62dc82dc099302c8612613.jpg" alt="img"></p>
<p>所谓控制反转的意思是，开关从以前设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备。也就是说，开关从依赖设备这种情况，变成了，设备反过来依赖于开关所定义的接口。</p>
<p>这样的例子在生活中太多见了。比如说：</p>
<ul>
<li>钱就是一个很好的例子。以前大家都是“以物易物”，所以，在各种物品之前都需要相应的“交易策略”，比如：一头羊换 2 袋米，一袋米换一斤猪后腿肉……这种换算太复杂了。于是，“钱”就出来了，所谓“钱”，其实就是一种交易协议，所有的商品都依赖这个协议，而不用再互相依赖了。于是整个世界的运作就简单了很多。</li>
<li>在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。这就是反转控制。买卖双方把对对方的直接依赖和控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。</li>
<li>上面这个例子，可能还不明显，再举一个例子。海尔公司作为一个电器制商需要把自己的商品分销到全国各地，但是发现，不同的分销渠道有不同的玩法，于是派出了各种销售代表玩不同的玩法。随着渠道越来越多，发现，每增加一个渠道就要新增一批人和一个新的流程，严重耦合并依赖各渠道商的玩法。</li>
</ul>
<p>实在受不了了，于是制定业务标准，开发分销信息化系统，只有符合这个标准的渠道商才能成为海尔的分销商。让各个渠道商反过来依赖自己标准。反转了控制，倒置了依赖。</p>
<p>这个思维方式其实还深远地影响了很多东西，比如我们的系统架构。</p>
<ul>
<li>云计算平台中有很多的云产品线。一些底层服务的开发团队只管开发底层的技术，然后什么也不管了，就交给上层的开发人员。上层开发人员在底层团队开发出来的产品上面开发各种管理这个底层资源的东西，比如：生产底层资源的业务，底层资源的控制台，底层资源的监控系统。</li>
</ul>
<p>然而，随着接入的资源的越来越多，上层为各个云资源控制生产，开发控制台和监控的团队，完全干不过来了。这个时候依赖倒置和反转控制又可以解决问题了。为了有统一一致的云产品体验，各个云产品线需要遵从一定的协议或规范来开发。比如，每个云产品团队需要按照标准定义相关资源的生命周期管理，提供控制台，接入整体监控系统，通过标准的协议开发控制系统。</p>
<ul>
<li>集中式处理电子商务订单的流程。各个垂直业务线都需要通过这个平台来处理自己的交易业务，但是垂直业务线上的个性化需求太多。于是，这个技术平台开始发现，对来自各个业务方的需求应接不暇，各种变态需求严重干扰系统，各种技术决策越来越不好做，导致需求排期排不过来。</li>
</ul>
<p>这个时候，也可以使用依赖倒置和反转控制的思想来解决问题：开发一个插件模型、工作流引擎和 Pub/Sub 系统，让业务方的个性化需求可以以插件的方式插入订单流程中。业务方自己的数据存在自己的库中，业务逻辑也不要侵入系统，并可以使用工作流引擎或 Pub/Sub 的协议标准来自己定义工作流的各个步骤（甚至把工作流引擎的各个步骤的 decider 交给各个业务方自行处理）。</p>
<p>让各个业务方来依赖于标准插件和工作流接口，反转控制，让它们来控制系统，依赖倒置，让它们来依赖标准。</p>
<p>上面这些我想说什么？我想说的是：</p>
<ul>
<li>我们每天都在标准化和定制化中纠结。我们痛苦于哪些应该是平台要做的，哪些应该要甩出去的。</li>
<li>这里面会出现大量的与业务无关的软件或中间件，包括协议、数据、接口……</li>
<li>通过面向对象的这些方式，我们可以通过抽象来解耦，通过中间件来解耦，这样可以降低软件的复杂度。</li>
</ul>
<p>总而言之，我们就是想通过一种标准来让业务更为规范。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>不过，我们也需要知道面向对象的优缺点。</p>
<ul>
<li><strong>优点</strong><ul>
<li>能和真实的世界交相辉映，符合人的直觉。</li>
<li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。</li>
<li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。</li>
<li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。</li>
<li>拥有大量非常优秀的设计原则和设计模式。</li>
<li>S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。</li>
<li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li>
<li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。</li>
</ul>
</li>
</ul>
<p>还是好多人并不是喜欢面向对象，尤其是喜欢函数式和泛型那些人，似乎都是非常讨厌面向对象的。</p>
<p>通过对象来达到抽象结果，把代码分散在不同的类里面，然后，要让它们执行起来，就需要把这些类粘合起来。所以，它另外一方面鼓励相当厚重的代码黏合层（代码黏合层就是把代码黏合到这里面）。</p>
<p>在 Java 里有很多注入方式，像 Spring 那些注入，鼓励黏合，导致了大量的封装，完全不知道里面在干什么事情。而且封装屏蔽了细节，具体发生啥事你还不知道。这些都是面向对象不太好的地方。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/28/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/28/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">边缘计算</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-28 15:42:08 / Modified: 16:44:10" itemprop="dateCreated datePublished" datetime="2020-02-28T15:42:08-05:00">2020-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先，一说起边缘计算，网上大多数文章都会说这是和 IoT 相关的一个技术。其实，这个说法只说对了边缘计算的一部分，边缘计算可以做的事情还有很多很多。</p>
<p>所谓边缘计算，它是相对于数据中心而言。数据中心喜欢把所有的服务放在一个机房里集中处理用户的数据和请求，集中式部署一方面便于管理和运维，另一方面也便于服务间的通讯有一个比较好的网络保障。的确没错。不过，我们依然需要像 CDN 这样的边缘式的内容发布网络，把我们的静态内容推到离用户最近的地方，然后获得更好的性能。</p>
<p>如果我们让 CDN 的这些边缘结点拥有可定制的计算能力，那么就可以像秒杀那样，可以在边缘结点上处理很多事情，从而为我们的数据中心带来更好的性能，更好的扩展性，还有更好的稳定性。而我们的用户也会觉得响应飞快，从而有了更好的用户体验。</p>
<p>下面，让我们来看看为什么边缘计算会变成一个必然的产物。</p>
<h1 id="为什么要有边缘计算"><a href="#为什么要有边缘计算" class="headerlink" title="为什么要有边缘计算"></a>为什么要有边缘计算</h1><h2 id="从趋势上来说"><a href="#从趋势上来说" class="headerlink" title="从趋势上来说"></a>从趋势上来说</h2><p>首先，我们得看一下整个时代是怎么发展的。我们处在信息化革命时代，也有人叫数字化革命，总之就是电脑时代。这个时代，把各式各样的信息都给数字化掉，然后交给计算机来处理。所以，我们要清楚地知道，<strong>整个计算机发展的本质就是我们人类生活信息化建设的过程</strong>。</p>
<p>这个过程中，计算机硬件的发展也是非常迅猛的。CPU 的处理速度，硬盘的大小和速度，网络的带宽和速度都在拼命地升级和降价。我们用越来越低的成本，获得越来越快的速度、越来越大的带宽、越来越快的存储……</p>
<p>所有的这一切，其实都是和信息还有数据有关。我们的信息和数据越来越多，越来越大，所以，我们需要更好、更快、更便宜的硬件和基础设施。这个演化过程中，在我参加工作这 20 年来就没有停止过，而且，我也不认为未来会停下来，这个过程只会越来越加剧。</p>
<p>下面是一个时代的变更图（不用太纠结其中的时间点，我只是想表示信息演进的过程）</p>
<p><img src="../images/3257b6428ef87f7a663bd3677bb49ddb.png" alt="img"></p>
<p>从一开始，我们处在 MB 时代，那个时候，电脑也是几百兆的硬盘就够了。因为那个时候的信息量不够大，只有内容服务提供商在提供内容，他们主要以新闻资讯为主，所以数据还不多。</p>
<p>然后，开始进入 UGC 时代，用户开始产生数据，他们写博客，发贴子，拍照片，拍视频……于是，信息越来越多，于是我们的数据进入了 GB 时代，于是计算机的硬件，网络的基础设施都在升级。</p>
<p>再然后，我们进入了大数据时代，这个时代也是移动互联网的时代。以前你要打开电脑才能上网，现在你只要手机有电，你就是在线的，而且这个时代，大量的线下服务走到线上，比如外卖、叫车……于是，有各种各样的 App 在收集你的行为和数据。这个时候，是计算机在记录每个人的上网行为的时候，所以，数据量也不是一般的大。</p>
<p>然后，这个趋势只会越来越大，下一个时间，我们的数据和信息只会越来越大，因为计算机正在吞噬可以被数字化的一切事情。除了继续吞噬线上的业务，一定会开始吞噬线下的信息和数据。比如，通过摄像头识别线下的各种活动，如车牌；通过一些传感器来收集线下的各种数据，如农业、水利……于是，数据只会变得越来越大。</p>
<p>这个时候，我们想一想，如果把这么大量的数据都拿到数据中心来做分析和计算，一个数据中心顶得住吗？我现在已经接到好几个用户和我说，数据量太大了，不知道怎么架构数据中心了，各种慢，各种贵，各种痛苦……</p>
<p>而且，还有另外一个需求就是要实时，对于大数据处理的实时需求越来越成为刚需了，因为，如果不能实时处理、实时响应，那么怎么能跟得上这个快速的时代呢。这就好像一个人脸识别的功能。如果苹果手机的人脸识别需要到服务器上算，然后把结果返回，那么用户的体验就很糟糕了。这就是为什么苹果在手机里直接植入了神经网络的芯片。</p>
<p><strong>我们可以看到，数量越来越大，分析结果的速度需要越来越快，这两个需求，只会把我们逼到边缘计算上去。</strong>如果你还是在数据中心处理，你会发现你的成本只会越来越高，到一时候就完全玩不下去了。</p>
<h2 id="从成本上来说"><a href="#从成本上来说" class="headerlink" title="从成本上来说"></a>从成本上来说</h2><p>上面这个是第一个示例，我们再来看看数据中心的成本，当一个公司需要支持几十万用户时候，并没有什么感觉。当他们要支撑上千万乃至上亿的用户的时候，我们就会发现，一个几十万用户的系统架构和一个支撑上千万用户的架构，在成本上来说，完全不是一个数量级的。就像文本中的图所画的一样（只是一个草图，用于说明问题）。</p>
<p><img src="../images/f5337ffab2d65ae5fc114ba21da82de7.png" alt="img"></p>
<p>在这个图中，我们可以看到，当需要处理的数据或是用户请求的规模越来越大时，我们的成本是呈现快速上升的曲线，而不是一个线性上升的成本关系。</p>
<p>我们可以来算一下，根据我过去服务过的 40 多家公司的经验，可以看到如下的投入：</p>
<ul>
<li>几十万用户的公司，只需要处理百级 QPS 的量，只需要 10 台左右的服务器；</li>
<li>上百万用户的公司，只需要处理千级 QPS 的量，需要有 50 台左右的服务器；</li>
<li>上千万用户的公司，需要处理万级到十万级 QPS 的量，需要 700 台左右的服务器；</li>
<li>上亿用户的公司，其需要处理百万级 QPS 的量，需要上万台的服务器。</li>
</ul>
<p>可以看到，十万用户到上亿用户，也就多了 100 倍，为什么服务器需要 1000 倍？完全不是呈线性的关系。</p>
<p>这时因为，当架构变复杂了后，你就要做很多非功能的东西了，比如，缓存、队列、服务发现、网关、自动化运维、监控等。</p>
<p>那么，我们不妨开个脑洞。如果我们能够把那上亿的用户拆成 100 个百万级的用户，那么只需要 5000 多台机器（100 个 50 台服务器的数据中心）。</p>
<p>我们还是同样服务了这么多的用户，但我们的成本下降得很快。只不过，我们需要运维 100 个小数据中心。不过，运维 100 个 50 台服务器的小数据中心的难度应该远远低于运维一个 10000 台服务器的数据中心。</p>
<p>好了，问题来了，什么样的业务可以这么做？我觉得有地域性的业务是可以这么做的，比如：外卖、叫车、共享单车之类的。</p>
<p>然而，100 个 50 台服务器的小数据中心也会带来一些复杂的问题，因为当你的公司有 100 万用户的时候的业务形态和有 1 亿用户的业务形态是完全不一样的，1 亿用户的业务形态可能会复杂得多得多。也就是说，我们不可能在一个小数据中心只有 50 台服务器，因为那是百万用户的业务形态，只有几十个服务。当公司成长到上亿用户的规模时，可能会有上百个服务，50 台服务器是不够部署的。</p>
<p>所以，我上面那种多个数据中心的理想只存在于理论上，而实际上不会发生。</p>
<p>但是，我们依然可以沿着这条路思考下去。我们不难发现，我们完全可以用边缘结点处理高峰流量，这样，我们的数据中心就不需要花那么大的成本来建设了。</p>
<p>于是，还是到了边缘计算。</p>
<h1 id="边缘计算的业务场景"><a href="#边缘计算的业务场景" class="headerlink" title="边缘计算的业务场景"></a>边缘计算的业务场景</h1><p>通过上面的两个案例分析，我觉得边缘计算一定会成为一个必然产物，其会作为以数据中心为主的云计算的一个非常好的补充。这个补充在我看来，其主要是做下面一些事情。</p>
<ul>
<li>处理一些实时响应的业务。它和用户靠得很近，所以其可以实时响应用户的一些本地请求，比如，某公司的人脸门禁系统、共享单车的开锁。</li>
<li>处理一些简单的业务逻辑。比如像秒杀、抢红包这样的业务场景。</li>
<li>收集并结构化数据。比如，把视频中的车牌信息抠出来，转成文字，传回数据中心。</li>
<li>实时设备监控。主要是线下设备的数据采集和监控。</li>
<li>P2P 的一些去中心化的应用。比如：边缘结点作为一个服务发现的服务器，可以让本地设备之间进行 P2P 通讯。</li>
<li>云资源调度。边缘结点非常适合用来做云端服务的调度。比如，允许用户使用不同生产商的云存储服务，使用不同生产商但是功能相同的 API 服务（比如支付 API 相关）。因为是流量接入方，所以可以调度流量。</li>
<li>云资源聚合。比如，我们可以把语音转文字的 API 和语义识别的 API 相结合，聚合出来一个识别语音语义的 API，从而简化开发人员的开发成本。</li>
<li>……</li>
</ul>
<p>其实还有很多，我觉得边缘计算带来的想象力还是很令人激动的。</p>
<p>关于现实当中的一些案例，你可以看看 <a href="https://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146" target="_blank" rel="noopener">Netflix 的全球边缘架构的 PPT</a>。</p>
<h1 id="边缘计算的关键技术"><a href="#边缘计算的关键技术" class="headerlink" title="边缘计算的关键技术"></a>边缘计算的关键技术</h1><p>在我看来，边缘计算的关键技术如下。</p>
<ul>
<li>API Gateway。关于网关，这个就不说了，我们在管理设计篇中有一篇就是专门讨论这个东西的。</li>
<li>Serverless/FaaS。就是服务函数化，这个技术就像是 AWS Lambda 服务一样，你写好一个函数，然后不用关心这个函数运行在哪里，直接发布就好了。然后就可以用了。</li>
</ul>
<p>Serverless 这个词第一次被使用大约是 2012 年由 Ken Form 所写的一篇名为《Why The Future of Software and Apps is Serverless》的文章。这篇文章谈到的内容是关于持续集成及源代码控制等，并不是我们今天所特指的这一种架构模式。</p>
<p>但 Amazon 在 2014 年发布的 AWS Lambda 让 “Serverless” 这一范式提高到一个全新的层面，为云中运行的应用程序提供了一种全新的系统体系结构。至此再也不需要在服务器上持续运行进程以等待 HTTP 请求或 API 调用，而是可以通过某种事件机制触发代码的执行。</p>
<p>通常，这只需要在 AWS 的某台服务器上配置一个简单的功能。此后 Ant Stanley 在 2015 年 7 月的名为《Server are Dead…》的文章中更是围绕着 AWS Lambda 及刚刚发布的 AWS API Gateway 这两个服务解释了他心目中的 Serverless，“Server are dead…they just don’t know it yet”。</p>
<p>如果说微服务是以专注于单一责任与功能的小型功能块为基础，利用模块化的方式组合出复杂的大型应用程序，那么我们还可以进一步认为 Serverless 架构可以提供一种更加 “ 代码碎片化 “ 的软件架构范式，我们称之为 Function as a Services（FaaS）。所谓的 “ 函数 “（Function）提供的是相比微服务更加细小的程序单元。</p>
<p>目前比较流行的几个开源项目是：</p>
<ul>
<li><a href="https://github.com/serverless/serverless" target="_blank" rel="noopener">Serverless Framework</a></li>
<li><a href="https://github.com/fission/fission" target="_blank" rel="noopener">Fission: Serverless Functions for Kubernetes</a></li>
<li><a href="https://github.com/open-lambda/open-lambda" target="_blank" rel="noopener">Open Lambda</a></li>
<li><a href="https://github.com/openfaas/faas" target="_blank" rel="noopener">Open FaaS</a></li>
<li><a href="https://github.com/iron-io/functions" target="_blank" rel="noopener">IronFunction</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%B1%95/" class="post-title-link" itemprop="url">数据库扩展</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-27 20:23:17 / Modified: 21:24:10" itemprop="dateCreated datePublished" datetime="2020-02-27T20:23:17-05:00">2020-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="读写分离-CQRS"><a href="#读写分离-CQRS" class="headerlink" title="读写分离 CQRS"></a>读写分离 CQRS</h1><p>读写分离是数据库扩展最简单实用的玩法了，这种方法针对读多写少的业务场景还是很管用的，而且还可以有效地把业务做相应的隔离。</p>
<p>如下图所示，数据库只有一个写库，有两个读库，所有的服务都写一个数据库。对于读操作来说，服务 A 和服务 B 走从库 A，服务 D 和服务 E 走从库 B，服务 C 在从库 A 和从库 B 间做轮询。</p>
<p><img src="../images/77892f8385a4fa21e97ca41075780b71.png" alt="img"></p>
<p>这样的方法好处是：</p>
<ul>
<li>比较容易实现。数据库的 master-slave 的配置和服务框架里的读写分离都比较成熟，应用起来也很快。</li>
<li>可以很好地把各个业务隔离开来。不会因为一个业务把数据库拖死而导致所有的业务都死掉。</li>
<li>可以很好地分担数据库的读负载，毕竟读操作是最耗数据库 CPU 的操作。</li>
</ul>
<p>这样的方法不好的地方是：</p>
<ul>
<li>写库有单点故障问题。如果是写库出了性能问题，那么所有的业务一样不可用。对于交易型的业务，要得到高的写操作速度，这样的方式不行。</li>
<li>数据库同步不实时，需要强一致性的读写操作还是需要落在写库上。</li>
</ul>
<p>综上所述，一般来说，这样的玩法主要是为了减少读操作的压力。</p>
<p>当然，这样的读写分离看上去有点矬，那么，我们还是为之找一个更靠谱的设计——CQRS。关于 CQRS，我在这里只做一个简单的介绍，更多的细节你可以上网自行 Google。</p>
<p>CQRS 全称 Command and Query Responsibility Segregation，也就是命令与查询职责分离。其原理是，用户对于一个应用的操作可以分成两种，一种是 Command 也就是我们的写操作（增，删，改），另一种是 Query 操作（查），也就是读操作。Query 操作基本上是在做数据整合显现，而 Command 操作这边会有更重的业务逻辑。分离开这两种操作可以在语义上做好区分。</p>
<ul>
<li>命令 Command 不会返回结果数据，只会返回执行状态，但会改变数据。</li>
<li>查询 Query 会返回结果数据，但是不会改变数据，对系统没有副作用。</li>
</ul>
<p>这样一来，可以带来一些好处。</p>
<ul>
<li>分工明确，可以负责不同的部分。</li>
<li>将业务上的命令和查询的职责分离，能够提高系统的性能、可扩展性和安全性。并且在系统的演化中能够保持高度的灵活性，能够防止出现 CRUD 模式中，对查询或者修改中的某一方进行改动，导致另一方出现问题的情况。</li>
<li>逻辑清晰，能够看到系统中的哪些行为或者操作导致了系统的状态变化。</li>
<li>可以从数据驱动（Data-Driven）转到任务驱动（Task-Driven）以及事件驱动。</li>
</ul>
<p>如果把 Command 操作变成 Event Sourcing，那么只需要记录不可修改的事件，并通过回溯事件得到数据的状态。于是，我们可以把写操作给完全简化掉，也变成无状态的，这样可以大幅度降低整个系统的副作用，并可以得到更大的并发和性能。</p>
<p>文本中有 Event Sourcing 和 CQRS 的架构示意图。</p>
<p><img src="../images/ceeb536d0fa15afa4f5fde0b2cbe7787.png" alt="img"></p>
<p>图片来源 - <a href="https://www.slideshare.net/planetcassandra/codecentric-ag-cqrs-and-event-sourcing-applications-with-cassandra" target="_blank" rel="noopener">CQRS and Event Sourcing Application with Cassandra</a></p>
<h1 id="分库分表-Sharding"><a href="#分库分表-Sharding" class="headerlink" title="分库分表 Sharding"></a>分库分表 Sharding</h1><p>一般来说，影响数据库最大的性能问题有两个，一个是对数据库的操作，一个是数据库中数据的大小。</p>
<p>对于前者，我们需要从业务上来优化。一方面，简化业务，不要在数据库上做太多的关联查询，而对于一些更为复杂的用于做报表或是搜索的数据库操作，应该把其移到更适合的地方。比如，用 ElasticSearch 来做查询，用 Hadoop 或别的数据分析软件来做报表分析。</p>
<p>对于后者，如果数据库里的数据越来越多，那么也会影响我们的数据操作。而且，对于我们的分布式系统来说，后端服务都可以做成分布式的，而数据库最好也是可以拆开成分布式的。读写分离也因为数据库里的数据太多而变慢，于是，分库分表就成了我们必须用的手段。</p>
<p><img src="../images/8ab721d3d6512a7f607fe393f6550f64.png" alt="img"></p>
<p>上面的图片是一个分库的示例。其中有两个事，这里需要提一下，一个是关于分库的策略，一个是关于数据访问层的中间件。</p>
<p><strong>关于分库的策略</strong>。我们把数据库按某种规则分成了三个库。比如，或是按地理位置，或是按日期，或是按某个范围分，或是按一种哈希散列算法。总之，我们把数据分到了三个库中。</p>
<p><strong>关于数据访问层</strong>。为了不让我们前面的服务感知到数据库的变化，我们需要引入一个叫 “ 数据访问层 “ 的中间件，用来做数据路由。但是，老实说，这个数据访问层的中间件很不好写，其中要有解析 SQL 语句的能力，还要根据解析好的 SQL 语句来做路由。但即便是这样，也有很多麻烦事。</p>
<p>比如，我要做一个分页功能，需要读一组顺序的数据，或是需要做 Max/Min/Count 这样的操作。于是，你要到三个库中分别求值，然后在数据访问层这里再合计处理返回。但即使是这样，你也会遇到各种令人烦恼的事，比如一个跨库的事务，你需要走 XA 这样的两阶段提交的操作，这样会把数据库的性能降到最低的。</p>
<p>为了避免数据访问层的麻烦，分片策略一般如下。</p>
<ul>
<li>按多租户的方式。用租户 ID 来分，这样可以把租户隔离开来。比如：一个电商平台的商家中心可以按商家的 ID 来分。</li>
<li>按数据的种类来分。比如，一个电商平台的商品库可以按类目来分，或是商家按地域来分。</li>
<li>通过范围来分。这样分片，可以保证在同一分片中的数据是连续的，于是我们数据库操作，比如分页查询会更高效一些。一般来说，大多数情况是用时间来分片的，比如，一个电商平台的订单中心是按月份来分表的，这样可以快速检索和统计一段连续的数据。</li>
<li>通过哈希散列算法来分（比如：主键 id % 3 之类的算法。）此策略的目的是降低形成热点的可能性（接收不成比例的负载的分片）。但是，这会带来两个问题，一个就是前面所说的跨库跨表的查询和事务问题，另一个就是如果要扩容需要重新哈希部分或全部数据。</li>
</ul>
<p>上面是最常见的分片模式，但是你还应考虑应用程序的业务要求及其数据使用模式。这里请注意几个非常关键的事宜。</p>
<ol>
<li>数据库分片必须考虑业务，从业务的角度入手，而不是从技术的角度入手，如果你不清楚业务，那么无法做出好的分片策略。</li>
<li>请只考虑业务分片。请不要走哈希散列的分片方式，除非有个人拿着把刀把你逼到墙角，你马上就有生命危险，你才能走哈希散列的分片方式。</li>
</ol>
<h1 id="数据库扩展的设计重点"><a href="#数据库扩展的设计重点" class="headerlink" title="数据库扩展的设计重点"></a>数据库扩展的设计重点</h1><p>先说明一下，这里没有讲真正数据库引擎的水平扩展的方法，我们只是在业务层上谈了一下数据扩展的两种方法。关于数据库引擎的水平扩展，你可能看一下我之前发过的《分布式数据调度的相关论文》一文中的 AWS Aurora 和 Google Spanner 的相关论文中提到的那些方法。</p>
<p>接下来，我们说一下从业务层上把单体的数据库给拆解掉的相关重点。</p>
<p>首先，你需要把数据库和应用服务一同拆开。也就是说，一个服务一个库，这就是微服务的玩法，也是 Amazon 的服务化的玩法——服务之间只能通过服务接口通讯，不能通过访问对方的数据库。在 Amazon 内，每个服务都会有一个自己的数据库，比如地址库、银行卡库等。这样一来，你的数据库就会被 “ 天生地 “ 给拆成服务化的，而不是一个单体的库。</p>
<p>我们要知道，在一个单体的库上做读写分离或是做分片都是一件治标不治本的事，真正治本的方法就是要和服务一起拆解。</p>
<p>当数据库也服务化后，我们才会在这个小的服务数据库上进行读写分离或分片的方式来获得更多的性能和吞吐量。这是整个设计模式的原则——先做服务化拆分，再做分片。</p>
<p>对于分片来说，有两种分片模式，一种是水平分片，一种是垂直分片。水平分片就是我们之前说的那种分片。而垂直分片是把一张表中的一些字段放到一张表中，另一些字段放到另一张表中。垂直分片主要是把一些经常修改的数据和不经常修改的数据给分离开来，这样在修改某个字段的数据时，不会导致其它字段的数据被锁而影响性能。比如，对于电商系统来说，商品的描述信息不常改，但是商品的库存和价格经常改，所以，可以把描述信息和库存价格分成两张表，这样可以让商品的描述信息的查询更快。</p>
<p>我们所说的 sharding 更多的是说水平分片。水平分片需要有以下一些注意事项。</p>
<ul>
<li>随着数据库中数据的变化，我们有可能需要定期重新平衡分片，以保证均匀分布并降低形成热点的可能性。 但是，重新平衡是一项昂贵的操作。 若要减少重新平衡的频率，我们需要通过确保每个分片包含足够的可用空间来处理未来一段时间的变化。 另外，我们还需要开发用于快速重新平衡分片的工具和脚本。</li>
<li>分片是静态的，而数据的访问则是不可预期的，可能会需要经常性地调整我们的分片，这样一来成本太高。所以，我们最好使用一个索引表的方式来进行分片。也就是说，把我们数据的索引动态地记录在一个索引表中。这样一来，我们就可以非常灵活地调度我们的数据了。当数据调度到另一台结点上时，我们只需要去索引表里改一下这个数据的位置就好了。</li>
<li>如果程序必须要从多个分片检索数据的查询，则可以使用并行任务从各个分片上提取此数据，然后聚合到单个结果中。 但是，此方法不可避免地会在一定程度上增加解决方案数据访问逻辑的复杂性。</li>
<li>数据分片后，我们很难在分片之间保持引用完整性和一致性，也就是所谓的跨分片的事务，因此应尽量减少会影响多个分片中的数据的操作。如果应用程序必须跨分片修改数据，那么我们需要评估一致性以及评估是否采用两阶段提交的方式。</li>
<li>配置和管理大量分片可能是一个挑战。在做相应的变更时，一定要先从生产线上拉出数据，然后根据数据计划好新的分片方式，并做好相当的测试工作。否则，这个事出了问题会是一个灾难性的问题。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1436668936&auto=0&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
