<!DOCTYPE html>


<html lang="en">
	

		<head>
			<meta charset="utf-8" />
			 
			<meta name="keywords" content="life,think,work,blog,code" />
			 
			<meta name="description" content="a place holder" />
			
			<meta
				name="viewport"
				content="width=device-width, initial-scale=1, maximum-scale=1"
			/>
			<meta
				name="google-site-verification"
				content="Xe5wkkWgdmMwA81kCWOHLlJSlYSRE47NKPlVzl8ynK8"
			/>
			<title> Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
			
			<link rel="shortcut icon" href="/favicon.ico" />
			 
<link rel="stylesheet" href="/dist/main.css">

			<link
				rel="stylesheet"
				href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
			/>
			
<link rel="stylesheet" href="/css/custom.css">
 
			<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
			 
 

		<link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>
	</html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
	<div class="cover-frame">
		<div class="bg-box">
			<img src="/images/cover3.jpg" alt="image frame" />
		</div>
		<div class="cover-inner text-center text-white">
			<h1><a href="/">Blog</a></h1>
			<div id="subtitle-box">
				
				<span id="subtitle"></span>
				
			</div>
			<div>
				
			</div>
		</div>
	</div>
	<div class="cover-learn-more">
		<a href="javascript:void(0)" class="anchor"
			><i class="ri-arrow-down-line"></i
		></a>
	</div>
</section>
 
<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

<script>
	try {
	  var typed = new Typed("#subtitle", {
	    strings: ['It doesn&#39;t work...... why?', 'It works...... why?', 'I used to have a life... But Now I&#39;m a programmer.'],
	    startDelay: 100,
	    typeSpeed: 50,
	    loop: false,
	    backSpeed: 20,
	    showCursor: true
	  });
	} catch (err) {
	  console.log(err)
	}
</script>


<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-九种跨域方式实现原理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/14/%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"
    >九种跨域方式实现原理</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/14/%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2020-04-14T17:18:59.000Z" itemprop="datePublished">2020-04-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。</p>
<h2 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h2><h3 id="1-什么是同源策略及其限制内容？"><a href="#1-什么是同源策略及其限制内容？" class="headerlink" title="1.什么是同源策略及其限制内容？"></a>1.什么是同源策略及其限制内容？</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p><img src="../images/image-20200414122053700.png" alt="image-20200414122053700"></p>
<p><strong>同源策略限制内容有：</strong></p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求发送后，结果被浏览器拦截了</li>
</ul>
<p>但是有三个标签是允许跨域加载资源：</p>
<ul>
<li><pre><code class="html"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span>
<span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;html</span><br><span class="line">  &lt;link href&#x3D;XXX&gt;</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><pre><code class="html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span>
<span class="xml"><span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.常见跨域场景</span><br><span class="line"></span><br><span class="line">**当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</span><br><span class="line"></span><br><span class="line">![image-20200414122216907](..&#x2F;images&#x2F;image-20200414122216907.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特别说明两点：</span><br><span class="line"></span><br><span class="line">**第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。**</span><br><span class="line"></span><br><span class="line">**第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”**。</span><br><span class="line"></span><br><span class="line">这里你或许有个疑问：**请求跨域了，那么请求到底发出去没有？**</span><br><span class="line"></span><br><span class="line">**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了**。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</span><br><span class="line"></span><br><span class="line">## 二、跨域解决方案</span><br><span class="line"></span><br><span class="line">### 1.jsonp</span><br><span class="line"></span><br><span class="line">#### 1) JSONP原理</span><br><span class="line"></span><br><span class="line">**利用 &#96;&#96; 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**</span><br><span class="line"></span><br><span class="line">#### 2) JSONP和AJAX对比</span><br><span class="line"></span><br><span class="line">JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</span><br><span class="line"></span><br><span class="line">#### 3) JSONP优缺点</span><br><span class="line"></span><br><span class="line">JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**</span><br><span class="line"></span><br><span class="line">#### 4) JSONP的实现流程</span><br><span class="line"></span><br><span class="line">- 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</span><br><span class="line">- 创建一个&#96;&#96;标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback&#x3D;show）。</span><br><span class="line">- 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是&#96;show(&#39;我不爱你&#39;)&#96;。</span><br><span class="line">- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</span><br><span class="line"></span><br><span class="line">在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javascript</span><br><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">function jsonp(&#123; url, params, callback &#125;) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    let script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">    window[callback] &#x3D; function(data) &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      document.body.removeChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params &#x3D; &#123; ...params, callback &#125; &#x2F;&#x2F; wd&#x3D;b&amp;callback&#x3D;show</span><br><span class="line">    let arrs &#x3D; []</span><br><span class="line">    for (let key in params) &#123;</span><br><span class="line">      arrs.push(&#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src &#x3D; &#96;$&#123;url&#125;?$&#123;arrs.join(&#39;&amp;&#39;)&#125;&#96;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;say&#39;,</span><br><span class="line">  params: &#123; wd: &#39;Iloveyou&#39; &#125;,</span><br><span class="line">  callback: &#39;show&#39;</span><br><span class="line">&#125;).then(data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></span></span>
</code></pre>
</li>
</ul>
<p>上面这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show(&#39;我不爱你&#39;)</code>，最后会运行show()这个函数，打印出’我不爱你’</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.get(<span class="string">&#x27;/say&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; wd, callback &#125; = req.query</span><br><span class="line">  <span class="built_in">console</span>.log(wd) <span class="comment">// Iloveyou</span></span><br><span class="line">  <span class="built_in">console</span>.log(callback) <span class="comment">// show</span></span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;我不爱你&#x27;)`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-jQuery的jsonp形式"><a href="#5-jQuery的jsonp形式" class="headerlink" title="5) jQuery的jsonp形式"></a>5) jQuery的jsonp形式</h4><p><strong>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:<span class="string">&quot;http://crossdomain.com/jsonServerResponse&quot;</span>,</span><br><span class="line">dataType:<span class="string">&quot;jsonp&quot;</span>,</span><br><span class="line">type:<span class="string">&quot;get&quot;</span>,<span class="comment">//可以省略</span></span><br><span class="line">jsonpCallback:<span class="string">&quot;show&quot;</span>,<span class="comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span></span><br><span class="line">jsonp:<span class="string">&quot;callback&quot;</span>,<span class="comment">//-&gt;把传递函数名的那个形参callback，可省略</span></span><br><span class="line">success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-cors"><a href="#2-cors" class="headerlink" title="2.cors"></a>2.cors</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p>
<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>
<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>
<h4 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1) 简单请求"></a>1) 简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求</p>
<p>条件1：使用下列方法之一：</p>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
<p>条件2：Content-Type 的值仅限于下列三者之一：</p>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p>
<h4 id="2-复杂请求"><a href="#2-复杂请求" class="headerlink" title="2) 复杂请求"></a>2) 复杂请求</h4><p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
<p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line"><span class="comment">// 预检的存活时间</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">  res.end() </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义后台返回的内容</span></span><br><span class="line">app.put(<span class="string">&#x27;/getData&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.end(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">let xhr = new XMLHttpRequest()</span><br><span class="line">document.cookie = &#x27;name=xiamen&#x27; // cookie不能跨域</span><br><span class="line">xhr.withCredentials = true // 前端设置是否带cookie</span><br><span class="line">xhr.open(&#x27;PUT&#x27;, &#x27;http://localhost:4000/getData&#x27;, true)</span><br><span class="line">xhr.setRequestHeader(&#x27;name&#x27;, &#x27;xiamen&#x27;)</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (xhr.readyState === 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">      console.log(xhr.response)</span><br><span class="line">      //得到响应头，后台需设置Access-Control-Expose-Headers</span><br><span class="line">      console.log(xhr.getResponseHeader(&#x27;name&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line">//server1.js</span><br><span class="line">let express = require(&#x27;express&#x27;);</span><br><span class="line">let app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">//server2.js</span><br><span class="line">let express = require(&#x27;express&#x27;)</span><br><span class="line">let app = express()</span><br><span class="line">let whitList = [&#x27;http://localhost:3000&#x27;] //设置白名单</span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  let origin = req.headers.origin</span><br><span class="line">  if (whitList.includes(origin)) &#123;</span><br><span class="line">    // 设置哪个源可以访问我</span><br><span class="line">    res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, origin)</span><br><span class="line">    // 允许携带哪个头访问我</span><br><span class="line">    res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;name&#x27;)</span><br><span class="line">    // 允许哪个方法访问我</span><br><span class="line">    res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT&#x27;)</span><br><span class="line">    // 允许携带cookie</span><br><span class="line">    res.setHeader(&#x27;Access-Control-Allow-Credentials&#x27;, true)</span><br><span class="line">    // 预检的存活时间</span><br><span class="line">    res.setHeader(&#x27;Access-Control-Max-Age&#x27;, 6)</span><br><span class="line">    // 允许返回的头</span><br><span class="line">    res.setHeader(&#x27;Access-Control-Expose-Headers&#x27;, &#x27;name&#x27;)</span><br><span class="line">    if (req.method === &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">      res.end() // OPTIONS请求不做任何处理</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(&#x27;/getData&#x27;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.setHeader(&#x27;name&#x27;, &#x27;jw&#x27;) //返回一个响应头，后台需设置</span><br><span class="line">  res.end(&#x27;我不爱你&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&#x27;/getData&#x27;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.end(&#x27;我不爱你&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line">app.listen(4000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p>
<h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p>
<blockquote>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
</blockquote>
<ul>
<li>message: 将要发送到其他 window的数据。</li>
<li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:4000/b.html&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> //等它加载完触发一个事件</span><br><span class="line">  //内嵌在http://localhost:3000/a.html</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;frame&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        frame.contentWindow.postMessage(<span class="string">&#x27;我爱你&#x27;</span>, <span class="string">&#x27;http://localhost:4000&#x27;</span>) <span class="comment">//发送数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">//接受返回数据</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(e.data) <span class="comment">//我不爱你</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// b.html</span><br><span class="line">  window.onmessage = function(e) &#123;</span><br><span class="line">    console.log(e.data) //我爱你</span><br><span class="line">    e.source.postMessage(&#x27;我不爱你&#x27;, e.origin)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4.websocket"></a>4.websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// socket.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:3000&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      socket.send(<span class="string">&#x27;我爱你&#x27;</span>);<span class="comment">//向服务器发送数据</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data);<span class="comment">//接收服务器返回的数据</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// server.js</span><br><span class="line">let express = require(&#x27;express&#x27;);</span><br><span class="line">let app = express();</span><br><span class="line">let WebSocket = require(&#x27;ws&#x27;);//记得安装ws</span><br><span class="line">let wss = new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class="line">wss.on(&#x27;connection&#x27;,function(ws) &#123;</span><br><span class="line">  ws.on(&#x27;message&#x27;, function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    ws.send(&#x27;我不爱你&#x27;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-Node中间件代理-两次跨域"><a href="#5-Node中间件代理-两次跨域" class="headerlink" title="5. Node中间件代理(两次跨域)"></a>5. Node中间件代理(两次跨域)</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> 代理服务器，需要做以下几个步骤：</p>
<ul>
<li>接受客户端请求 。</li>
<li>将请求 转发给服务器。</li>
<li>拿到服务器 响应 数据。</li>
<li>将 响应 转发给客户端。</li>
</ul>
<p><img src="../images/image-20200414122242142.png" alt="image-20200414122242142"></p>
<p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html(http://127.0.0.1:5500)</span></span><br><span class="line"> &lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">        type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: &#123; <span class="attr">name</span>: <span class="string">&#x27;xiamen&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span> &#125;,</span><br><span class="line">        contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(result) <span class="comment">// &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server1.js 代理服务器(http://localhost:3000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 第一步：接受客户端请求</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span></span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 第二步：将请求转发给服务器</span></span><br><span class="line">  <span class="keyword">const</span> proxyRequest = http</span><br><span class="line">    .request(</span><br><span class="line">      &#123;</span><br><span class="line">        host: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        port: <span class="number">4000</span>,</span><br><span class="line">        url: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        method: request.method,</span><br><span class="line">        headers: request.headers</span><br><span class="line">      &#125;,</span><br><span class="line">      serverResponse =&gt; &#123;</span><br><span class="line">        <span class="comment">// 第三步：收到服务器的响应</span></span><br><span class="line">        <span class="keyword">var</span> body = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        serverResponse.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">          body += chunk</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;The data is &#x27;</span> + body)</span><br><span class="line">          <span class="comment">// 第四步：将响应结果转发给浏览器</span></span><br><span class="line">          response.end(body)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;The proxyServer is running at http://localhost:3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server2.js(http://localhost:4000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">title</span>: <span class="string">&#x27;fontend&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    response.end(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">4000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;The server is running at http://localhost:4000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>&#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</code></p>
<h3 id="6-nginx反向代理"><a href="#6-nginx反向代理" class="headerlink" title="6.nginx反向代理"></a>6.nginx反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p>
<p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<p>先下载<a target="_blank" rel="noopener" href="http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// proxy服务器</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">81</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.domain1.com;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        <span class="attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin http://www.domain1.com;  <span class="comment">#当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后通过命令行<code>nginx -s reload</code>启动nginx</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// a.html(http://localhost:3000/b.html)</span><br><span class="line"> <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:4000/c.html&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">let</span> first = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">   <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span></span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">     if(first)&#123;</span><br><span class="line"><span class="javascript">     <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="javascript">       <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">       iframe.src = <span class="string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span></span><br><span class="line"><span class="javascript">       first = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">     &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">     <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(iframe.contentWindow.name);</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>b.html为中间代理页，与a.html同域，内容为空。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// c.html(http://localhost:4000/c.html)</span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.name = <span class="string">&#x27;我不爱你&#x27;</span>  </span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8.location.hash +  iframe"></a>8.location.hash +  iframe</h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"> <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//检测hash的变化</span></span></span><br><span class="line"><span class="javascript">     <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line">   &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// b.html</span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.parent.parent.location.hash = location.hash </span></span><br><span class="line"><span class="javascript">   <span class="comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// c.html</span><br><span class="line">console.log(location.hash);</span><br><span class="line"> let iframe = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line"> iframe.src = &#x27;http://localhost:3000/b.html#idontloveyou&#x27;;</span><br><span class="line"> document.body.appendChild(iframe);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> helloa</span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span> <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(frame.contentWindow.a);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   hellob</span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> a = <span class="number">100</span>;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul>
<li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li>
<li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li>
<li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li>
<li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何学习React"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/13/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0React/"
    >如何学习React</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/13/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0React/" class="article-date">
  <time datetime="2020-04-13T17:21:34.000Z" itemprop="datePublished">2020-04-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="如何学习React"><a href="#如何学习React" class="headerlink" title="如何学习React"></a>如何学习React</h1><p>如果你是一个 React (或者前端) 新手, 出于以下的原因, 你可能会对这个生态圈感到困惑:</p>
<ul>
<li>React 的目标群体历来是喜欢尝试新事物的开发者和前端专家.</li>
<li>Facebook 开源的内容是应用在他们的实际应用中, 因此他们没有关注那些比 Facebook 小的工程需求.</li>
<li>现有的 React 指引水平参差不齐.</li>
</ul>
<p>在本文中, 我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础.</p>
<h2 id="如何踏入-React-生态圈"><a href="#如何踏入-React-生态圈" class="headerlink" title="如何踏入 React 生态圈"></a>如何踏入 React 生态圈</h2><p>所有的软件都是建立在某个技术栈之上的, 你需要对整个技术栈有足够深入的理解, 才能建造你的应用. 为什么 React 生态圈的工具似乎总让人感觉压力山大呢, 因为它总是以错误的顺序被解释:</p>
<p>你应该按照以下的顺序进行学习, <strong>而不是跳着学或者同时学习</strong>:</p>
<ul>
<li><a href="#user-content-学习-react-本身">React</a></li>
<li><a href="#user-content-学习-npm"><code>npm</code></a></li>
<li><a href="#user-content-学习-javascript-打包工具">JavaScript “打包工具”</a></li>
<li><a href="#user-content-学习-es6">ES6</a></li>
<li><a href="#user-content-学习路由-routing">Routing</a></li>
<li><a href="#user-content-学习-flux">Flux</a></li>
</ul>
<p><strong>你不需要把这些都学完才去使用 React.</strong> 只需要在你遇到问题需要解决的时候, 才进入下一步的学习.</p>
<p>另外, 在 React 社区中, 有一些前沿主题是经常被提及到的, 以下的这些主题很有意思, 但也很难弄懂, 所以它们远没有上面的主题流行, <strong>大多数应用也不需要用到这些.</strong></p>
<ul>
<li><a href="#user-content-学习内联样式">内联样式</a></li>
<li><a href="#user-content-学习服务器端渲染">服务器端渲染</a></li>
<li><a href="#user-content-学习-immutablejs">Immutable.js</a></li>
<li><a href="#user-content-学习-relay-falcor-等">Relay, Falcor 等</a></li>
</ul>
<h2 id="学习-React-本身"><a href="#学习-React-本身" class="headerlink" title="学习 React 本身"></a>学习 React 本身</h2><p>有一种常见的误解是: 你需要花费大量时间在配置工具上, 然后才开始学习 React. 在官方文档里, 你可以找到 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/getting-started.html#quick-start-without-npm">copy-paste HTML template</a>. 只需要保存为 <code>.html</code> 文件, 你就可以马上开始学习了. <strong>这个步骤不需要任何工具, 你也无需额外学习工具使用, 直到你能熟练掌握 React 基础.</strong></p>
<p>我依然觉得, 学习 React 最简单的方法是通过官方教程 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/tutorial.html">the official tutorial</a>.</p>
<h2 id="学习-npm"><a href="#学习-npm" class="headerlink" title="学习 npm"></a>学习 <code>npm</code></h2><p><code>npm</code> 是 Node.js 包管理工具, 也是前端工程师和设计师分享 JavaScript 代码最流行的方式. 它包含了名为 <code>CommonJS</code> 的模块系统, 让你可以安装 JavaScript 写的命令行工具. 作为背景知识, 可以阅读 <a target="_blank" rel="noopener" href="http://0fps.net/2013/01/22/commonjs-why-and-how/">这篇文章</a> 了解 <code>CommonJS</code> 对于浏览器的重要性, 阅读  <a target="_blank" rel="noopener" href="http://wiki.commonjs.org/wiki/Introduction">CommonJS Spec Wiki</a> 了解关于 <code>CommonJS</code> API 的更多内容</p>
<p>在 React 生态圈中, 大部分可重用的组件、库和工具遵循 <code>CommonJS</code> 模块规范, 可通过 <code>npm</code> 来安装.</p>
<h2 id="学习-JavaScript-打包工具"><a href="#学习-JavaScript-打包工具" class="headerlink" title="学习 JavaScript 打包工具"></a>学习 JavaScript 打包工具</h2><p>出于若干技术原因, <code>CommonJS</code> 模块 (也就是 <code>npm</code> 里的所有内容) 不能直接用到浏览器. 你需要一个 JavaScript “打包工具(bundler)” 来把这些模块打包成 <code>.js</code> 文件, 使你可以在网页中通过 <code>&lt;script&gt;</code> 标签引入它们.</p>
<p>JavaScript 打包工具包括 <code>webpack</code> 和 <code>browserify</code>. 它们都是好的选择, 但我个人更喜欢 <code>webpack</code> , 因为它有许多功能简化大型应用开发. 鉴于 webpack 文档可能令人感到困惑, 我也写了两篇文章: <a target="_blank" rel="noopener" href="https://github.com/petehunt/react-webpack-template">plug-and-play template for getting started</a> 和针对更复杂用例的 <a target="_blank" rel="noopener" href="https://github.com/petehunt/webpack-howto">how-to guide for webpack</a>.</p>
<p>要记住的一点: <code>CommonJS</code> 使用了 <code>require()</code> 函数来引入模块, 因此许多人对此感到疑惑, 并认为需要导入 <code>require.js</code> 到工程里. 出于若干技术原因, 我建议你避免使用 <code>require.js</code>. 它在 React 生态圈并不流行.</p>
<h2 id="学习-ES6"><a href="#学习-ES6" class="headerlink" title="学习 ES6"></a>学习 ES6</h2><p>在 JSX (你会在 React tutorial 中学习到) 以外, 你可能会注意到 React 例子中一些有趣的语法. 这被称为 ECMAScript6, 是 JavaScript 的最新版本. 由于 ES6 很新, 你可能还没学习到, 浏览器也可能尚未兼容, 但别担心, 通过合适的配置, 你的打包工具会为你自动转换成兼容代码.</p>
<p>如果你只想要使用 React 来把事情做完, <strong>你可以跳过 ES6 的学习,</strong> 或者留到以后再学习.</p>
<p>你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件. 这并不是真的, 大多数人 (包括 Facebook) 用的还是 <code>React.createClass()</code>.</p>
<h2 id="学习路由-routing"><a href="#学习路由-routing" class="headerlink" title="学习路由 (routing)"></a>学习路由 (routing)</h2><p>“单页面应用” 是时下的技术热点. 当网页加载完成, 用户点击链接或者按钮的时候, JavaScript 会更新页面和改变地址栏, 但网页不会刷新. 地址栏的管理就是通过 <strong>路由(router)</strong> 来完成的.</p>
<p>目前 React 生态圈最受欢迎的路由解决方案是 <a target="_blank" rel="noopener" href="https://github.com/rackt/react-router">react-router</a>. 如果你正在创建一个单页面应用, 有什么理由不去使用它呢?</p>
<p><strong>如果你创建的并非单页面应用, 请不要使用路由.</strong> 无论如何, 大部分项目都是从大型应用中的小组件开始的.</p>
<h2 id="学习内联样式"><a href="#学习内联样式" class="headerlink" title="学习内联样式"></a>学习内联样式</h2><p>在 React 出现之前, 很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表. 鉴于 React 使开发可重用组件变得容易, 你的样式表可以变得没那么复杂了. 社区中许多人 (包括我) 正尝试完全抛弃样式表.</p>
<p>由于一些原因, 其实这是个相当疯狂的主意. 这让媒体查询 (media quries) 更加困难了, 而且这种技术可能有性能上的局限性. <strong>当你开始用 React 的时候, 只要用你平常使用的方法去写就好了.</strong></p>
<p>一旦你找到了用 React 开发的感觉, 你就可以关注那些可作为替代的技术了. 其中一种流行技术是 <a target="_blank" rel="noopener" href="https://en.bem.info/">BEM</a>. 我建议你逐渐停用 CSS 预处理器, 因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=VkTCL6Nqm6Y">在 OSCON 上发表过关于这个的演讲</a>). 说了这么多, 总之 React 就像其他 JavaScript 库一样, 可以和 CSS 预处理器很好地配合工作.</p>
<p>另一种可选项是 <a target="_blank" rel="noopener" href="http://glenmaddern.com/articles/css-modules">CSS 模块</a>, 更具体地说, 是 <a target="_blank" rel="noopener" href="https://github.com/gajus/react-css-modules">react-css-modules</a>. 虽然有了这些 CSS 模块, 你还是写 CSS (或者是 SASS/LESS/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件. 你也不需要担心用到 BEM 那样的方法学去管理类名, 因为模块系统在底层已经帮你处理好了.</p>
<h2 id="学习服务器端渲染"><a href="#学习服务器端渲染" class="headerlink" title="学习服务器端渲染"></a>学习服务器端渲染</h2><p>服务器端渲染经常被称为 “通用应用” 或 “同构应用”. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能, 因为用户不用等到 JS 下载完才看到初始界面, 并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成.</p>
<p>如果你发现首屏渲染速度过慢, 或者想提高网站在搜索引擎的排行, 你就需要服务器端渲染了. 尽管 Google 现在也会索引客户端渲染的内容, 但截至 2016 年 1 月, 这样做仍被证实会对排行有负面影响, 这可能是由于客户端渲染的性能问题所造成的.</p>
<p>服务器端渲染还需要许多工具的辅助, 因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的, 你应该先构建你的应用, 之后再关心服务器端渲染的问题. 不用担心, 你不需要重写所有组件去支持它.</p>
<h2 id="学习-Flux"><a href="#学习-Flux" class="headerlink" title="学习 Flux"></a>学习 Flux</h2><p>你可能听过 Flux, 不过关于 Flux 有大量的错误资讯.</p>
<p>许多人一坐下来刚开始构建应用, 就认为需要用 Flux 来定义他们的数据模型. <strong>这样采用 Flux 是不对的, Flux 应该在大量组件被建立完成以后才被引入.</strong></p>
<p>React 组件之间存在层级关系. 在很多时候, 你的数据模型也跟随这种层级. 这种情况下, Flux 不会给你很大帮助. 但有些时候, 你的数据模型没有层次, 当你的 React 组件开始接受没有关联的 <code>props</code> 的时候, 或者当小部分组件开始变得复杂的时候, 你才可能需要看看 Flux.</p>
<p><strong>你会知道什么时候需要用 Flux. 如果你不确定是否需要用它, 你就不需要它.</strong></p>
<p>如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 <a target="_blank" rel="noopener" href="http://redux.js.org/">Redux</a>. 当然也有许多其他选择, 你或者会有兴趣尝试使用它们, 但我的建议是只需要用最流行的 Redux 就足够了.</p>
<h2 id="学习-Immutable-js"><a href="#学习-Immutable-js" class="headerlink" title="学习 Immutable.js"></a>学习 Immutable.js</h2><p><a target="_blank" rel="noopener" href="https://facebook.github.io/immutable-js/">Immutable.js</a> 提供了一系列的数据结构, 以帮助解决构造 React 应用时的某些性能问题. 这是一个很棒的库, 你可能会在应用发展的过程里大量用到它, 但直到你在意识到性能问题以前, 它是完全不必要的.</p>
<h2 id="学习-Relay-Falcor-等"><a href="#学习-Relay-Falcor-等" class="headerlink" title="学习 Relay, Falcor 等"></a>学习 Relay, Falcor 等</h2><p>这些技术可以帮你减少 AJAX 请求数, 它们仍然是非常前沿的, 所以如果你没有遇到过多 AJAX 请求的问题, 就不需要用到 Relay 或者 Falcor.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-学习Spring之前要先学习什么"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/12/%E5%AD%A6%E4%B9%A0Spring%E4%B9%8B%E5%89%8D%E8%A6%81%E5%85%88%E5%AD%A6%E4%B9%A0%E4%BB%80%E4%B9%88/"
    >学习Spring之前要先学习什么</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/12/%E5%AD%A6%E4%B9%A0Spring%E4%B9%8B%E5%89%8D%E8%A6%81%E5%85%88%E5%AD%A6%E4%B9%A0%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2020-04-12T08:05:10.000Z" itemprop="datePublished">2020-04-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>开门见山，先放结论。</p>
<p>要开始学习Spring（以IOC和Spring MVC为核心），只需要做好以下准备即可：</p>
<ol>
<li>《Java核心技术》前6章。</li>
<li>Java反射原理（选学）。</li>
<li>Servlet。</li>
</ol>
<p>而想理解上面的结论，则首先必须理解Spring是干什么的。</p>
<p>打开Spring的官方网站，点击projects页面，你会看到一个偌大的结构图。其中列出许多项目，包括：Spring Boot、Spring Cloud 、Spring Data…。对初学来说，乍一看着实吓一跳，完全不知道从何下手。</p>
<p>但透过表现看本质。无论是Spring Data，还是Spring Cloud，都是建立在Spring Framework上的一个个具体领域的应用.</p>
<p>在Spring Framwork中，包含了Spring体系的核心机制及应用，包括IOC、AOP，SpringMVC、Data Access等。而且，即使在Spring Framework内部，各个功能之间也不是水平的，而是存在依赖关系的。</p>
<p>其中最底层，最核心的概念有两个：IOC和AOP。两者之间，尤以IOC为重。</p>
<p>在实践中，Spring全家桶中使用最广泛就是IOC和Spring MVC。从上图中，我们也可以看到，Spring MVC是依赖于IOC的。因此要学习Spring MVC，就必须先学习IOC。</p>
<p>而在公司的内部培训，我都会有意把IOC 和SpringMVC完全独立起来进行，因为并不是所有的工程师（例如测试工程师）都对SpringMVC有需求。</p>
<p>到这里，思路就清晰了。如果要学习Spring，必须掌握的就是IOC。因此，所谓的Spring前置知识，某种意义上，就是Spring IOC的前置知识。</p>
<p>然后，我们再来简单讲解下IOC的概念。</p>
<p>对初学者来说，初听到IOC，会觉得特别高大上。但如果真掰开讲明白，你就会发现其实特别简单。</p>
<p>为了便于理解，我用一个例子的说明。</p>
<p>这里有一个应用，包含两个Jar包，一个是myApp.jar，一个是lib.jar。其中myApp.jar包含了程序的主逻辑，由程序员A编写。lib.jar中定义了一个接口，和该接口的实现类，由程序员员B编写。</p>
<p>如下图：</p>
<p><img src="../images/image-20200412030845603.png" alt="image-20200412030845603"></p>
<p>在lib.jar中，有一个接口Person，两个实现类Student、Teacher。在myApp.jar，通过代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">null</span>；</span><br></pre></td></tr></table></figure>

<p>从而导致myApp.jar依赖于lib.jar。但因为语句Person p只是做了定义，而没有实际赋值。这时候我们就称myApp.jar仅依赖于lib.jar（通过接口Person），但并没有实现“注入”。</p>
<p>然后，我们把程序进一步修改下，如图：</p>
<p><img src="../images/image-20200412030909037.png" alt="image-20200412030909037"></p>
<p>其中修改了语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>

<p>这样，MyApp.jar就把Student的实例“注入”到了对象p中，也就是说，通过new关键字创建对象，这就是最常见的依赖注入方法。</p>
<p>但这种写法有一个很大的缺点，那就是因为myApp.jar不仅依赖于Person接口，还依赖于具体的实现类Student，这是一种明显的<strong>强耦合</strong>。而如果哪天myApp.jar不想使用Student了，而想使用Teacher，那么程序员就不得不回过头来修改myApp.jar的代码。</p>
<p>而在实际应用中，myApp.jar中往往包含了程序主流程。而主流程一旦完成，就应该保持相对稳定。如果有改变，也应该通过扩展的方式。这也就是架构设计中著名的“<strong>开关原则</strong>”，即主业务对修改关闭，对扩展开放。而使用Spring就可以达到这样的目的。</p>
<p>下面我们就引入Spring IOC机制，把代码修改下。如图：</p>
<p><img src="../images/image-20200412030928800.png" alt="image-20200412030928800"></p>
<p>这样，在myApp.jar包中，就把对Person对象的具体注入从代码中移除，代之在spring.xml文件中定义。任何时候，只要修改Spring.xml的配置，就能改变myApp.jar中具体Person对象的注入。从而保证了“开关原则”。</p>
<p>而上面的整个过程，就是通过Spring框架中的IOC机制来实现的。</p>
<p>从中，你也能体察到Spring框架为什么对企业级程序这么重要性。因为企业级程序必然是复杂的，而要解决复杂度的前提就是解耦。可以说，没有解耦，所有企业级应用都会崩溃在千丝万缕的业务逻辑中。</p>
<p>看到这里，你可能已经发现，对Spring的核心概念IOC来说，并没有涉及任何高深的Java语法，最多也就是接口和抽象类。因此学习Spring IOC，参考《Java核心技术》，只要学到前6章就可以了。</p>
<p>因为Spring IOC的核心机制是建立在Java“反射”基础上的。因此，如果你有兴趣继续探究Spring IOC的核心原理，就有必要提前学习下Java与反射相关的概念。</p>
<p>再说下Spring中另一个最常用的功能Spring MVC。</p>
<p>Spring MVC的运行时建立在两个技术基础上：IOC和Servlet。如果不懂IOC，就搞不明不白Spring MVC是如何配置的。如果不懂Servlet，则就搞不理解Spring是如何注入及拦截Servlet消息的。而之后一旦Spring MVC在运行中出了问题，则必然会茫然不知所措。</p>
<p>虽然Spring MVC中的V（view），最常见的输出目标是JSP页面。但因为现代的企业应用越来越倾向于前后端分离，后端系统只负责输出REST接口。因此在Spring MVC框架中，View这一层就没有存在的必要，学习JSP也就没有价值了。</p>
<p>最后，再总结一下学习Spring（以IOC和Spring MVC为核心）必备的前置知识：</p>
<ol>
<li>《Java核心技术》前6章。</li>
<li>Java反射原理（选学）。</li>
<li>Servlet。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何评价Clojure"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/11/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7Clojure/"
    >如何评价Clojure</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/11/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7Clojure/" class="article-date">
  <time datetime="2020-04-11T22:36:40.000Z" itemprop="datePublished">2020-04-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1-Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。"><a href="#1-Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。" class="headerlink" title="1.Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。"></a><strong>1.Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键</strong>。</h4><p>首先，因为根植于JVM之上，并且做到了跟Java语言的相互调用，它能吸引很多成熟的Java开发者。其次，它可以使用Java社区丰富的开源软件，不需要从头去构建一个社区，你可以看到很多Clojure开源代码都是简单地包装Java的开源包，但是通过Clojure高度抽象简单的语法提供更便利的使用的方式；<br>第三，由于JVM平台本身的高度成熟和优化，clojure的编译器生成的byte code跟Java编译器生成的byte code并无二致（不完全是），它的性能和稳定性也能马上得到保证，这比从头构建一个新平台成本低得多。</p>
<p>构建于JVM之上，Clojure就是一门“严肃”的语言，而非很多人眼中的Lisp“玩具”语言，你学习后可以马上使用并且实践。但是Clojure又是Lisp方言，Lisp的神奇能力它还都保留，这样兼具美学和实用的语言如何让人不爱？我相信很多熟悉Scheme之类方言的童鞋，并且有Java背景的，都会对Clojure有相见恨晚的感觉。</p>
<h4 id="2-Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The-joy-of-clojure》概括的。"><a href="#2-Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The-joy-of-clojure》概括的。" class="headerlink" title="2.Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The joy of clojure》概括的。"></a><strong>2.Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The joy of clojure》概括的。</strong></h4><p>（1）简单： 鼓励纯函数，极简的语法（少数special form），个人也认为clojure不能算是多范式的语言（有部分OO特性），为了支持多范式引入的复杂度，我们在C++和Scala身上都看到了。<br>（2）专注：前缀运算符不需要去考虑优先级，也没有什么菱形继承的问题，动态类型系统（有利有弊），REPL提供的探索式编程方法（告别修改/编译/运行的死循环，所见即所得）。<br>（3）实用：前面提到，构建在JVM之上，跟Java语言的互操作非常容易。直接调用Java方法，不去发明一套新的调用语法，努力规避Java语言中繁琐的地方(doto,箭头宏等等）。<br>（4）清晰：纯函数（前面提到），immutable var，immutable数据结构，STM避免锁问题。不可变减少了心智的负担，降低了多线程编程的难度，纯函数也更利于测试和调试。<br>（5）一致：语法的一致性：例如doseq和for宏类似，都支持destructring,支持相同的guard语句（when,while）。数据结构的一致性：sequence抽象之上的各种高阶函数。</p>
<p>具体到STM，我个人认为这个特性在日常编程中，其实你用到的机会不多。在web编程里，你的并发模型Web Container已经帮你处理（tomcat,jetty），事务也是数据库帮你处理，几乎找不到场合去使用STM。这个特性在做一些中间件或者底层framework的时候才可能用到。这个特性的设计上面已经提到，跟clojure的设计目标是紧密相关的，跟immutable数据结构也是密不可分，同时它也不是没有代价，事务历史记录和慢事务频繁回滚的代价，有时候你还是需要退回去使用Java那套锁机制，庆幸的是Clojure不阻止你去使用，并且提供了类似locking这样的宏来方便你使用。</p>
<h4 id="3-Scheme我对它的了解也就是做过SICP的习题。"><a href="#3-Scheme我对它的了解也就是做过SICP的习题。" class="headerlink" title="3.Scheme我对它的了解也就是做过SICP的习题。"></a>3.Scheme我对它的了解也就是做过SICP的习题。</h4><p>粗粗看过《Programming Scheme》，两者对比的优缺点似乎谈不上来。需要对Scheme更熟悉的专家来做个对比。</p>
<p><strong>Clojure的设计缺陷不能说是缺陷，这是由于它设计的目标决定的，有得必有失</strong>。</p>
<p>首先还是JVM，基于JVM有种种好处，但是JVM的启动速度实在悲剧，因此用Clojure写一些小的script处理日常事务，显得还是不够得心应手，这样的工作我还是用Ruby，Python的脚本语言来搞定更便捷。不过目前Clojure有一些其他语言之上的实现，比如<a href="https://link.zhihu.com/?target=https%3A//github.com/rouge-lang/rouge">rouge-lang/rouge · GitHub</a> 和 <a href="https://link.zhihu.com/?target=https%3A//github.com/halgari/clojure-py">halgari/clojure-py 路 GitHub</a>  这些实现应该会比JVM的启动快很多（抱歉，我没测试过）。</p>
<p>不仅如此，因为Clojure跟JVM平台的绑定如此之深，并且为了真正发挥Clojure的威力，你还需要去熟悉Java平台的东西，熟悉Java语言、类库、内存模型、GC优化、多线程和网络编程、开源类库等等。可以这样认为：<strong>想成为一个好的Clojure程序员，首先需要是一名好的Java程序员</strong>。这也一定程度上阻碍了Clojure的推广，提高了学习成本。</p>
<p>其次，Clojure的API设计上，有时候不符合你的直觉，而是符合Clojure的哲学，比如contains?函数对vector等数组型集合的调用上。关于这一点，Rich的回答是“<strong>Elegance and familiarity are orthogonal.</strong>”，也就是优雅和熟悉是正交关系的。保持API内在的一致性，比直觉的“熟悉”更重要。Clojure不妥协于你的“直觉”。</p>
<p>第三，弱类型的好处足够多，灵活，减少声明代码，适合探索式编程；同样，坏处也不是没有，没有类型保障，错误可能要等到运行时才能发现，静态代码检查工具也没有办法帮你发现，这就需要你一定程度的测试代码来保证运行时行为。</p>
<p>第四，性能上，虽然clojure生成的字节码已经很高效，也有type hint这样的技术来帮助提升性能，但是会有不少的转型(checkcast)、装箱和拆箱（boxing and unboxing）以及类型判断分支跳转的多余指令，这在一些性能敏感的应用里可能会暴露出来。尽管我认为大多数网站型的应用瓶颈都会落在IO上。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何看待检察日报称『禁食猫狗肉』立法有破冰意义"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%A3%80%E5%AF%9F%E6%97%A5%E6%8A%A5%E7%A7%B0%E3%80%8E%E7%A6%81%E9%A3%9F%E7%8C%AB%E7%8B%97%E8%82%89%E3%80%8F%E7%AB%8B%E6%B3%95%E6%9C%89%E7%A0%B4%E5%86%B0%E6%84%8F%E4%B9%89/"
    >如何看待检察日报称『禁食猫狗肉』立法有破冰意义</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%A3%80%E5%AF%9F%E6%97%A5%E6%8A%A5%E7%A7%B0%E3%80%8E%E7%A6%81%E9%A3%9F%E7%8C%AB%E7%8B%97%E8%82%89%E3%80%8F%E7%AB%8B%E6%B3%95%E6%9C%89%E7%A0%B4%E5%86%B0%E6%84%8F%E4%B9%89/" class="article-date">
  <time datetime="2020-04-11T04:31:15.000Z" itemprop="datePublished">2020-04-10</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="../images/image-20200410233222992.png" alt="image-20200410233222992"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何看待基辛格的《新冠病毒大流行将永远改变世界秩序》"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%9F%BA%E8%BE%9B%E6%A0%BC%E7%9A%84%E3%80%8A%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92%E5%A4%A7%E6%B5%81%E8%A1%8C%E5%B0%86%E6%B0%B8%E8%BF%9C%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F%E3%80%8B/"
    >如何看待基辛格的《新冠病毒大流行将永远改变世界秩序》</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%9F%BA%E8%BE%9B%E6%A0%BC%E7%9A%84%E3%80%8A%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92%E5%A4%A7%E6%B5%81%E8%A1%8C%E5%B0%86%E6%B0%B8%E8%BF%9C%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F%E3%80%8B/" class="article-date">
  <time datetime="2020-04-10T02:02:19.000Z" itemprop="datePublished">2020-04-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="新冠疫情会永远改变世界秩序-全文翻译"><a href="#新冠疫情会永远改变世界秩序-全文翻译" class="headerlink" title="新冠疫情会永远改变世界秩序-全文翻译"></a>新冠疫情会永远改变世界秩序-全文翻译</h2><p>基辛格</p>
<p>新冠疫情的这种超现实氛围，让我想起当年突出部战役时，我在84步兵师作为一名年轻人的感受。现在，正如1944年后期，能感觉到一种未成形的危险，不盯着任何具体的人，而是随意打击并毁灭。但老黄历和当下有个重要区别：美国能扛过那时候，是因为被一种终极的国家目的武装了起来。现在，在一个分裂的国家里，要去克服一个在深度和全球广度上都前所未见的困难，高效和有远见的政府是必需的。维持公众信任对社会团结来说至关重要，在各个社会群体之间的关系上、在国际和平与稳定上，也是如此。</p>
<p>国家们能团结、繁荣，是基于一个信念：他们的体制可以<strong>预见灾难、控制其冲击、并恢复稳定</strong>。当新冠疫情结束后，很多国家的体制会被认为是<strong>失败的</strong>。这个论断是否客观公平，已经不重要。现实是，世界将不会再和疫情前一样。在现在去争辩过去，只会让<strong>必须要去做的事</strong>更难做。</p>
<p>新冠病毒打击的范围和严重程度前所未有。病毒呈指数传播，每五天美国的病例翻一倍。就在我写的时候，依然没有解药。医疗供给不足以应对正在扩大的病例波次，重症护理资源濒临极限，有些超出极限，有些已经过载崩溃。测试进度仍然不足以完成确认传染范围的工作，离扭转病毒传播还很远。一个有效的疫苗可能要12到18个月后。</p>
<p>美国政府已经做了扎实的工作来避免迫在眉睫的灾难。终极考验是： 遏制并扭转病毒传播的手段和效果范围，能否维系公众对美国人<strong>自我管理能力的认可</strong>。危机中的工作，不管多么繁重与必不可少，都不能挤压一个<strong>紧急任务</strong>：同时应对疫情后<strong>秩序转变</strong>的努力。</p>
<p>领导人们正在处理几乎牵扯全国的危机，但病毒瓦解社会的效果没有边界。在伤害人类健康（希望是暂时的）的同时，病毒所导致的政治与经济剧变可能会<strong>持续数代人</strong>。没有国家——包括美国在内——可以仅靠自身国家的努力来克服病毒。要应对当下的种种挑战，必须要形成全球合作思维和执行计划的结合。如果我们无法并行做到，那么我们将面对互相之间<strong>最糟糕的一面</strong>。</p>
<p>从<strong>马歇尔计划和曼哈顿计划</strong>的发展中吸取经验，美国有必要在三大方向采取重要行动：</p>
<p>首先，加强全球对传染性疾病的抵抗能力。小儿麻痹症疫苗和消灭天花这样的医学胜利，或者人工智能依据大数据进行医疗诊断的新兴奇迹，使得我们放松警惕，进入一种危险的自满。我们需要发展新方法和新技术，能够在大规模人口数量级上实现传染病的控制和疫苗研发生产。城市、国家和地区必须始终如一地准备，用现有的、合作计划并开发的前沿科学来保护自己的人民远离疫病大流行。</p>
<p>其次，努力去治愈世界经济的伤口。全球领导人已经从2008金融危机中学到重要教训。现有经济危机则更复杂：从速度和全球规模来看，新冠病毒的传染进程在历史上从未有过。所有必要的公共卫生手段，例如保持社交距离、关闭学校和商业场所，都会加重经济创伤。世界上最脆弱的人群面对即将到来的混乱，也要有减轻对他们影响的措施。</p>
<p>最后，<strong>捍卫自由世界秩序的原则</strong>。有个建立现代政府的<strong>古老概念</strong>：一个<strong>筑有高墙的城市</strong>，被<strong>强大</strong>的统治者所保护。他们有些暴虐，有些仁慈，但总能为人民远离<strong>外部</strong>敌人提供有力保护。启蒙思想家们<strong>改造</strong>了这个概念，认为<strong>正当国家</strong>的目标是要为人民提供基本所需：安全、秩序、良好的经济，还有公正。个体无法单凭自己确保这些事情的实现。疫情刺激了一个<strong>错误</strong>：一个繁荣依赖于全球贸易和人口流动的时代里，<strong>筑有高墙的城市将要复兴</strong>，。</p>
<p>世界的民主国家需要<strong>捍卫并维系启蒙思想的价值观</strong>。<strong>拥有合法性的制衡力量</strong>在全球衰减，将会造成国内与国际上社会交流的解体。当然，合法性与力量这个千年问题，不会仅靠克服新冠疫情的努力就能同时解决。因此<strong>全面的制约</strong>是必要的，不管是国内政治还是国际外交，<strong>优先级</strong>必须得到确定。</p>
<p>我们从突出部战役，走进了繁荣发展和人类尊严得以巩固的的世界。现在，我们生活在一个时代节点。对领导人们的历史性挑战，是要在处理危机的同时建立未来。<strong>失败会让世界陷入火海</strong>。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>国家的性格，很大程度上是由这个国家的平均年龄决定的。二战和冷战早期的各主要国家就像是几个二十多岁的壮小伙子，一言不合就要杀人全家。冷战中后期的美苏就像是三十多岁的成年人，也会发怒，但会考虑后果，如果能背后捅刀，绝对不会当面硬碰硬。而如今的各主要国家，宛如一群四五十岁的油腻中年，生活的主要矛盾已经从升官发财转移成了自己经常闹意见的前列腺，走两步都要喘半天，打完人一巴掌，第一件事就是去医院治手。</p>
<p>社会需要平衡，左了右了都不行。传统上，除了极特殊的年代外，决策层往往是中老年人把持，这确实有一定的科学性，毕竟年轻人太过鲁莽，容易坏事；但执行层，好歹一直都还是年轻人的天下，这就形成了某种制衡，倒逼上面进行改革。可是随着社会整体的老龄化和固化，各国的执行层也开始逐渐老去，年轻人就只能被逐渐挤到国家机器的边缘甚至外部。再发展下去，变成日本那样，就连体制外大大小小的岗位也都被老年人填满，这个国家连一个不老土的网页都已经做不出来，你还指望它能在国家决策上有什么改革的冲劲儿？</p>
<p>基辛格就像是一个老去的少年，用他所熟悉的少年思维去考量这个世界，把高楼幻化成古堡，把磨坊理解成巨龙，用他独特的方式去警告世界，宛如一个白发少年提醒着一群童颜老人，充满了魔幻的不真实感。</p>
<p><strong>可是，世界老了</strong>。</p>
<p>世界就像一个摇摇欲坠的老国企。欧洲早已开始了自己的退休生活，他们所关心的是在尽可能少费力气的基础上拿到尽可能多的退休金，那些明争暗斗仿佛发生在一亿年前。美国就像一个跃跃欲试的老领导，沉浸在自己当年的荣光里，就像那个笑话讲的，“坐在电梯里面上了18楼，过程中一直在做俯卧撑，于是就跟人吹嘘是因为自己努力做俯卧撑上到的18楼”。中国则像这个老国企里的顶梁柱，很努力地听话出活，但却因为一群老人占据着大大小小的岗位不肯退，混到快四十岁了也得不到晋升。是啊，就连这个全单位最年富力强的小伙子，也快四十岁了。官瘾，当然还是有的；可你让他为了当官去和所长斗一斗，把所长斗倒了他来当？开什么玩笑，要恰饭的，老婆要买包，孩子要上钢琴课。</p>
<p>现在，流感来了，这群大腹便便的老爷子全部病倒，你惊奇地发现，除了这个四十来岁的“小伙子”还算勉强坚持住了以外，竟然没有任何一个人的免疫力足以抵抗这场传染病。没病的时候，老干部们或许还下下象棋；病来了，病就是老干部们最要命的事儿。单位那档子事儿，哎……我上次去上班，是几月份了啊……</p>
<p>年轻人总是幻想不同。这是最好的时代，这是最坏的时代。无论好还是坏，年轻人都是喜欢的。</p>
<p>可恐怕事实不能如愿。这不是最好的时代，也不是最坏的时代。我宁可相信基辛格，甚至宁可相信亨廷顿。可惜世界不会那样。</p>
<p>这只是个衰老的时代。</p>
<p>大病过后，老人还会继续老下去。没有人会死去，他们只是在轮椅上继续默默衰老。老所长不会退休，四十岁的“小伙子”也不会接班，只是老领导的呓语越来越没人愿意听，每个人都在消磨着漫长的人生。留给未来的，只是这个效益越来越差的老厂子，和大同小异的冬去春来。</p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p><strong>巴菲特一辈子看了五次熔断，基辛格一辈子看到两次铁幕</strong></p>
<p>说到制裁，我的答复是“制裁有核国家，结果不过是中国俄罗斯东盟中亚一起，剩下的一起，铁幕徐徐落下罢了”百年未有之变局，最差也不过如此只不过上次是丘吉尔+杜鲁门与斯大林对垒，而现在的政坛，除了KGB出身的普京，全加起来也未必有丘吉尔一半够分量</p>
<p><strong>这次疫情根本性的改变了我们与西方世界之间的相互认知</strong></p>
<p>过去我们因为长期在科技、军事、经济上处于弱势，于是被灌输制度和主义需要抉择和进化，认为西式皿煮滋油是真正的解放，甚至把肤色当做一种耻辱急于强调“我虽然是黄种人，但我是美国人”。将舶来品奉为圭臬的代价是，在别人跑过的路上，你永远追不上他，越是在对方的语境里对话，你的话语权越低下西方看我们也是，我们是愚昧、肮脏、野蛮的代名词，同种同文的4V尚且认为我们极度落后吃不起茶叶蛋，却完全不知道我们已经发展到5分钟手机充值不到账就要砸营业厅。所以，大洋彼岸从来没到过中国的红脖子对我们的误解，该有多深呢？“这不文明”中“文明”的含义并非形容词，而是的名词，“这不是西方文明”。</p>
<p><strong>一次疫情把各自的老底全晾出来看清楚</strong></p>
<p>我们看他们，低效政府、无耻政客、堕落媒体、愚昧民众，这距离我们高呼媒体是第四权利的日子没过去多久他们看我们，爆表级别的工业能力和物资投放，为战争准备的社会结构，特别是经此一疫14亿令行禁止的民众怕的是，我们认为他们蠢却忽略了他们近百年来积累下在科技、经济、军事上的巨大优势更怕的是，他们从今往后会全方位铁腕对待中国</p>
<p><strong>东西方的隔阂真的是因为制度吗？</strong>当然不是，若是因为制度，沙特早就不是今天的沙特，朝鲜也断不能具备玩弄六方会谈的能力，普京也不值得英美各国如此的恐惧和排挤隔阂在于，地球的资源，不够14亿人过上美式生活，中国越发展，他们的话语权越小，中国人过上好日子，他们就得降低生活水平，中国在产业链上爬上去一环，就得有人从上面掉下来还记得贸易战吗？要求中国放弃2025中国智造计划，这种无耻条件等于是给中国发射一枚“智子”，你就踏踏实实吃糠咽菜，用资源和环境为代价给他们生产低端制造品才好如果中国放弃发展，相信我们会是人家最好的战略盟友，谁不希望有14亿跪着的韭菜呢？然而现在，所有对中国报以落后幻想的国家，无论承认与否，都不得不接受14亿站着也要把钱挣了的人民这才是隔阂，才是铁幕的根源</p>
<p><strong>未来会打仗吗？最差到什么地步？</strong></p>
<p>拥核国家正面刚的概率基本不存在，真的刚起来，劝架的比打架的多经济上提高门槛，产业链回流，去全球化，甚至可以叫做封锁的态势势不可挡，别迷信咱们好了他们还要很久才能缓过来，救股市不要人命在政客眼里，都不过是决策，甚至是更救命的决策最差莫过于国内产能积压严重，梧桐一把，出师有名还把东盟搞到手，一带一路和东盟，一个在手就足够全球化的推手是美国，目的在于收割财富，有11个航母编队推进这个事情，中国没那么强大的海军，两三只航母编队，维持东盟和一带一路中，已经可以保证国家继续发展</p>
<p><strong>该以什么心态面对？</strong></p>
<p>最可笑的莫过圣母心泛滥，千万别有，好似多读了几本书，就该对全人类负有责任。你所关心和体贴的，在大洋对岸的底层美国人，在政客的眼中，是不配拥有检测权的韭菜。最宣传善良博爱大国责任的美国都准备对疫情中的委内瑞拉动手了，性命攸关，你当他是程心？还是逼自己做程心？也别慌，接下来会有失业、断供等等各种艰难的事情需要面对，但仅仅疫情中国家不惜代价救命的操作，绝对可以放宽心，工业链条完整，粮食充足，过过苦日子也总比把刀把子交给别人好的多</p>
<p><strong>丢掉幻想，准备战斗</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-曾国藩攻陷天京后为何要屠城"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/08/%E6%9B%BE%E5%9B%BD%E8%97%A9%E6%94%BB%E9%99%B7%E5%A4%A9%E4%BA%AC%E5%90%8E%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B1%A0%E5%9F%8E/"
    >曾国藩攻陷天京后为何要屠城</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/08/%E6%9B%BE%E5%9B%BD%E8%97%A9%E6%94%BB%E9%99%B7%E5%A4%A9%E4%BA%AC%E5%90%8E%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B1%A0%E5%9F%8E/" class="article-date">
  <time datetime="2020-04-09T01:29:07.000Z" itemprop="datePublished">2020-04-08</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>中国历史上就没几支不屠城的军队，抛开近现代的国军共军不谈，历史上以军纪好而著名的军队我第一时间能想起来的只有岳家军和戚家军，前者尤为知名。这种军队有什么特点呢？第一，中央军，虽然冠名岳家军和戚家军，但士兵正儿八经的效忠于帝国，并非将领私兵；第二，兵员质量较高，没有大量的囚犯少年犯之类的社会渣滓；第三，最根本的原因，有稳定的军饷供给。<br>所以归根结底还是经济问题啊！</p>
<p>第一个原因，举个例子，东汉末年那会儿的西凉军，效忠皇帝么？当然不，这是董卓的私兵，他们砍起关中和关东的百姓会觉得是在砍自己人么？人家压根没有什么国家观念好么，董大大说砍谁，就砍谁。同样，湘军本来就是曾国藩自己练出来的团练私兵，名义上效忠清帝国而已，大清的子民又与湘军何干？<br>第二个原因，战争年代当兵是件高风险的事情，安分守己的老百姓有几个愿意从军的？汉武帝为了征西域连“七科谪”都用上了，即商人、商人的子女孙子、商人的侄儿、原本有“市籍”者、罪吏、亡徒、赘婿这七种没有社会地位的人都拖上战场，类似黑五类。这种人本来就没啥社会地位，和囚犯一起干着炮灰的活，打下城池你猜他们会干什么？汉武拓边时期，那可是结结实实把四夷给屠了个爽。 同样，湘军的组成也是不敢恭维，特别是曾国藩前期第一波就打输了（靖港兵败），所训练的新兵损失惨重，这种情况下再招兵什么人会来？流氓无产者啊。<br>最后一个原因，清廷养不起湘军，没有钱粮，又要士兵玩命砍人，曾国藩除了放任士兵劫掠，还真没有啥好办法，后来他的一个老乡想出了一个办法缓解了这一矛盾——加入红军可以分到土地！当然，玩笑归玩笑，共军的组织体系比湘军这种封建军队强太多了，也高效的多。从农民手中收粮食不必被假手于地主，给士兵发饷也不必假手于将领，这两点极大的提高了效率，没有了中间环节抽油水，共军才能用非常低的成本养活一支庞大的军队，而湘军若想从后方的老乡手中获得粮饷，便要让地主们对老乡更加的敲骨吸髓，权衡之下，杀人劫财才是最高效的选择。至于什么太平天国是邪教之类的话就不用拿来给湘军洗地了，太平天国就算信了飞面教也是逃不过这一劫的，抢劫这么纯粹的事情，别用剿匪给玷污了。<br>这个世界还真是™的无情啊。</p>
<p>综合来看，这件事给我们一个启示，想要建立一支军纪严明的军队，第一件事就要解决经济问题。国家能直接给每一个士兵发饷，士兵才能效忠国家，反过来，国家不给钱了，让军队自己想办法，军队便不得不采用一些灰色的手段为士兵们或者军队的其他人员赚得粮饷，这样的军队还会想着去为国家杀敌么？活下去都成问题就别谈理想了吧，军人不是圣人，只要有一个军官为了利益出卖理想，他迟早会拉下水一群人，最后形成休戚与共的小团体，军队会逐渐变成军官的私兵。当他们的利益和国家的利益发生冲突的时候，卖国的时候到了。归根结底，军队是要像姨太太一样养起来的，千万不能让军队自己赚钱，放在现在就叫：军队一律不得经商！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-新冠病毒-2020黑天鹅"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/08/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92-2020%E9%BB%91%E5%A4%A9%E9%B9%85/"
    >新冠病毒_2020黑天鹅</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/08/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92-2020%E9%BB%91%E5%A4%A9%E9%B9%85/" class="article-date">
  <time datetime="2020-04-08T04:31:43.000Z" itemprop="datePublished">2020-04-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>以下是给红杉创始人和CEO们发来的一份说明，希望能给大家提供一些指导，让大家在应对冠状病毒蔓延带来的潜在业务后果的同时，也能保证企业的健康。</p>
<p>尊敬的创始人和CEO们</p>
<p>冠状病毒是2020年的黑天鹅。你们中的一些人（也是我们中的一些人）已经受到了病毒的亲身影响。我们知道你们所承受的压力，并在这里提供帮助。人命关天，我们希望条件尽快改善。在此期间，我们应该居安思危，对可能出现的情况要有心理准备。</p>
<p>在座的各位都收到了很多关于COVID-19附近的预防措施的建议，以保护您、您的员工和您的家人的健康和福利。和许多人一样，我们也研究了现有的信息，并很乐意分享我们的观点–如果您有兴趣，请告诉我们。本说明是关于其他方面的内容：确保您的企业健康，同时应对病毒传播的潜在商业后果。</p>
<p>不幸的是，由于红杉在全球许多地区都有分布，我们正在获得冠状病毒对全球业务影响的第一手资料。与所有危机一样，有一些企业可以从中受益。然而，许多一线国家的企业因病毒的爆发而面临着挑战，包括。</p>
<p>业务活动的下降。一些公司的增长率在12月至2月间急剧下降。随着病毒的影响波及范围的扩大，一些原本按部就班的公司现在有可能错过第一季度至2020年的计划。</p>
<p>供应链中断。中国前所未有的封锁，直接影响到了全球供应链。硬件企业、直销企业和零售企业可能需要寻找替代供应商。纯软件公司受供应链中断的影响较小，但由于级联经济影响，仍面临风险。</p>
<p>缩减旅行和取消会议。许多公司已经禁止所有的 “非必要 “旅行，有些公司已经禁止所有的国际旅行。虽然旅游公司受到直接影响，但所有依赖面谈会议进行销售、业务发展或合作讨论的公司都受到影响。</p>
<p>我们需要相当长的时间–也许需要几个季度–才能确信病毒已经被控制住。全球经济要想恢复健康，还需要更长的时间。你们中的一些人可能会经历需求疲软，一些人可能会面临供应方面的挑战。虽然美联储和其他央行可以降息，但货币政策可能是缓解全球健康危机对经济影响的钝器。</p>
<p>我们建议你质疑关于你的企业的每一个假设，包括。</p>
<p>现金跑路。你真的有你认为的那么多的跑道吗？如果经济不景气，你能承受几个糟糕的季度吗？你是否已经制定了应急计划？你在哪里可以在不从根本上损害业务的情况下削减开支？现在就问这些问题，避免未来可能带来的痛苦后果。</p>
<p>筹款。私人融资可能会大幅减弱，就像2001年和2009年发生的那样。如果在2020年和2021年以有吸引力的条件筹集资金证明很难，你会怎么做？你能不能把充满挑战的局面变成一个机会，让自己获得持久的成功？许多最具代表性的公司都是在困难时期锻造和塑造的。1987年黑色星期一后不久，我们就与思科公司合作。谷歌和PayPal在互联网公司的大萧条之后艰难地渡过了难关。最近，Airbnb、Square和Stripe都是在全球金融危机中成立的。约束力使人的思维集中，为创造力提供了沃土。</p>
<p>销售预测。即使你没有看到你的公司有任何直接或直接的曝光，也要预测你的客户可能会改变他们的消费习惯。看似已经确定的交易可能不会成交。关键是不要被动挨打。</p>
<p>营销。随着销售疲软，你可能会发现你的客户终生价值下降，这反过来表明你需要控制客户获取支出，以保持营销支出的稳定回报。随着经济和筹资的不确定性增加，你甚至可能需要考虑提高营销支出的投资回报率。<br>人头数。考虑到上述所有的财务压力点，现在可能是时候对你的财务进行批判性的评估了，你是否能以更少的投入做更多的事情，提高生产力。</p>
<p>资本支出。在你制定了财务独立的路线之前，请检查你的资本支出计划在更不确定的环境下是否合理。也许你没有理由改变计划，而且据你所知，环境的变化甚至可能会带来加速的机会。但这些都是应该深思熟虑的决定。</p>
<p>在经历了近五十年来的每一次商业衰退之后，我们学到了一个重要的教训–没有人会后悔根据环境的变化做出快速果断的调整。在经济不景气时，收入和现金水平的下降速度总是快于支出。在某些方面，商业反映了生物学。正如达尔文所推测的那样，生存下来的人 “不是最强壮的人，也不是最聪明的人，而是最能适应变化的人。”</p>
<p>经久不衰的公司的一个显著特点是他们的领导人对这样的时刻的反应方式。你的员工们都知道COVID-19，都在想你会有什么反应，对他们意味着什么。错误的乐观情绪很容易将你带入歧途，使你无法制定应急计划或采取大胆的行动。要避免这个陷阱，要以现实的态度对待，当情况发生变化时果断地采取行动。在这个紧张的时刻，展现出您的团队所需要的领导力。</p>
<p>以下是我们的合作伙伴Alfred Lin的一些观点，他作为一名运营主管，经历了另一个黑天鹅时刻。</p>
<blockquote>
<p>2008年金融危机爆发前，我是Zappos公司的首席运营官/首席财务官，当时我被传唤到红杉的办公室，参加著名的<a target="_blank" rel="noopener" href="https://www.sequoiacap.com/article/rip-good-times">R.I.P. Good Times演讲</a>。我们当时不知道，就像我们现在不知道，我们将面临多长时间或多尖锐或浅薄的经济衰退。我可以确认的是，这次演讲让我们的团队和业务变得更加强大。Zappos从金融危机中走出来，在我们的竞争对手被打得遍体鳞伤之后，我们已经做好了抓住机遇的准备。”</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Coronavirus/" rel="tag">Coronavirus</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-入关学导论"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/06/%E5%85%A5%E5%85%B3%E5%AD%A6%E5%AF%BC%E8%AE%BA/"
    >入关学导论</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/06/%E5%85%A5%E5%85%B3%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="article-date">
  <time datetime="2020-04-07T03:43:46.000Z" itemprop="datePublished">2020-04-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>当今知乎有无数的人从事或从事过键政学研究,号称是键政的文章和回答充满了专栏、热榜和各个回答。</p>
<p>与之相随,“蛮夷入关学”作为键政学学科体系下的一门具有独特魅力的分支，逐渐显露头角。目前世面上正在初步形成了以山高县语录为基础，以七十二贤冲塔言论为补充的理论体系，即“蛮夷入关学”（以下简称为入关学）。与之伴随的问题就是蛮夷入关学已经普及到只要学点皮毛就能研究的程度。以至于“入关，入关“的言论充斥了知乎。</p>
<p>我们提出的问题或许不合时宜,但面对目前知乎上各色各样的入关学研究,大多不以根本目的为导向和结构的入关学回答、文章、专栏时,我们不能不说,入关学若想继续发展。入关学需要明确研究什么、为什么研究。笔者在借鉴知乎显学六学的理论建设的基础上，对入关学进行了一次梳理总结：[1]。</p>
<h2 id="一、什么是入关学"><a href="#一、什么是入关学" class="headerlink" title="一、什么是入关学"></a>一、什么是入关学</h2><p>入关学（THE Science Of Enter The Gate），是一门研究山高县相关入关言论及其所代表的思想的新兴学科，其基础载体是山高县相关语录，以七十二贤冲塔言论为补充，以历史上的现实例子为渊源。从学科划分角度上来说，入关学是一门交叉学科，其覆盖领域包括政治学、军事学、地缘政治学、经济学、政治经济学、历史学等等，是一门相当前沿的综合性学科，并且还有很多发展的空间，值得研究者们去不断探索。 但随着近日入关学在人民群众中的普及，它也暴露出了许多问题：入关学的研究对象究竟是什么？入关学的使命是什么？入关学对人类社会有什么积极的意义？</p>
<p>入关学的研究对象和方法<br>目前知乎上的疑问主要是，入关学的研究对象到底是山高县的回答？还是评论区的精彩（献祭）言论？还是地缘政治学、军事学、经济学、明清易代史？ 笔者认为，其实三者一个密不可分的整体，缺少哪个都不能独立存活。山高县的回答基础来源于地缘政治学和军事学，为了使国人更清晰的理解而创造性地发明了将之粗略地投射到明清易代史的语境中，以此使得更多人方便理解学习。在入关学领域中，评论区的言论是山高县回答与键政研究者的结合体，经过知乎上各大学者（粉丝）的研究（冲塔），评论区的言论已经成为入关学丰富的增长点，是入关学理论知识在各个学者研究中不断突破、优化、细化的基础，被大批入关学学者应用于入关学研究中;然而，评论区言论在入关学教育中的应用尚浅，尚未得到应有的重视，但评论区言论对入关学领域的重要性决定了其在入关学教育中应用的必要，应用在入关学教育中是必然的。</p>
<p>入关学的主要内容<br>目前入关学的主要内容分3类：</p>
<p>（1）通过历史研究，以明亡清兴的历史教训论证了身为一个蛮子的正确自我认知[2]：</p>
<p>即入关的必要性 1.入关是女真团结的唯一途径，是女真求活的唯一选择，是女真崛起的唯一道路。 2. 扫帚不到，灰尘不会自己走掉。大明再烂，没有女真步步紧逼，一时半会儿也完不了。 3.蹲鹰和挖参固然能挣一些钱，然而改变不了摸鱼是绝大多数女真年轻人唯一出路的现实。 4. 摸鱼的命，不要操天朝的心。靠蹲鹰挖参和摸鱼，不仅买不来洪承畴，连范文程都买不来。 5.与其在关外吃敕书，不如到京城印敕书。 6.没了大明的敕书，女真也没饿死。 7. 靠同胞之情，同种之谊，既不可能让叶赫归顺，也不可能让朝鲜归降。 8. 在赫图阿拉再怎么读半吊子圣贤书，也改变不了摸鱼的现实。 9. 入关前不要搬着圣贤书胡思乱想，入关后自有正统儒学大师为我所用。</p>
<p>（2）通过对M国的研究，论证了M国治球不义不利，丧失人心、天道更易，而应有德之人居之：</p>
<p>具体又分为三方面论证：</p>
<p>1.M国崛起史、得球史寡廉鲜耻、不仁不义，实在人神共愤：</p>
<p>1.1</p>
<p>1845年，M国悍然吞并墨西哥领土德克萨斯后。仍不知足，得陇望蜀，竟恬不知耻的向墨西哥购买加利福尼亚和新墨西哥的广袤领土。[3]</p>
<p>1.2</p>
<p>英国在1807年就禁止贩奴，1833年就全面解放奴隶。而M国政权，直到1862年才解放奴隶，死不悔改、落后反动。[4]</p>
<p>1.3</p>
<p>M国是近现代极权迫害的极致，暴行不义，违反人权。</p>
<p>具体有以下方面：第一是政治迫害，比如独立战争时期，各个殖民地成立委员会，迫使每一个人宣誓效忠于合众国，胆敢不宣誓者，一律关进大牢，没收一切财产。第二是没收财产，比如1777年11月，国会建议各州没收变卖效忠派的财产。这个提议迅速得到支持。第三是人格侮辱，典型例子是托马斯布朗事件：乔治亚洲的著名效忠派托马斯·布朗，此人是一个富有的种植园主，1774年才来到殖民地。1775年一群独立派来到他家中，要求他向独立事业宣誓效忠的，他拒绝了，于是其他人打破了布朗头盖骨，剥下了他的部分头皮，并把他吊到他家门前的树上，又来了一出“涂沥青，粘羽毛”的戏码。而后他们又架上一堆火烤他，最终他的两个脚趾头被烧掉。第四则是互杀俘虏。[5]</p>
<p>爱国群众对效忠派M奸粘羽毛，涂沥青</p>
<p>由上诉例子可得结论：M国是近现代极权迫害的祖宗，违反人权，暴行不义。</p>
<p>（3）通过对M国治理全球方式的研究，论证了M国全球治理的不可持续性和必然衰亡性：</p>
<p>3.1 M国全球治理的不可持续性：</p>
<p>M国对世界经济的统治，宛如蒙古对中亚的统治。原本收税就行了，结果还是蒙古那一套——抢，没事就去抢劫自己治下的百姓来维持生活。例如索罗斯之流说白了就是蒙古抢劫大队长[6]。</p>
<p>而目前全世界最大的危机正是全球性的财政危机，连用货币政策和财政政策辗转腾挪的空间都很小的情况下，天降伟人特朗普还在全世界不停的火上浇油。俗话说国无完国，但会完蛋，饿虎不择食，蝼蚁且贪生。完蛋预期面前，这个世界要出多少幺蛾子，实难想象[7]。</p>
<p>3.2 M国全球治理的必然衰亡性：</p>
<p>M国是一个世界性的帝国，对一个世界性帝国来说，逆全球化四个字意味着什么？ 天子失德，诸侯离心，蛮夷崛起，四方扰攘之时。苏松二府的繁华，秦淮河畔的纸醉金迷，东林书院里的风声雨声读书声，又能代表什么呢？ 分析M国，要以其全球统治体系的运行状况为出发点，光盯着M国这个南直隶，是看不出什么的。[8]</p>
<p>但是全球化是其致命漏洞的，Dani Rodrik在2000年就指出，尽管全球化（在当时看来）势不可挡，但内在地蕴含着危机，根源在于全球经济一体化与全球政治上层建筑之间不可调和的矛盾。 Rodrik这篇文章[9]提出了一个“全球化三元悖论”，即经济一体化（或者说全球化）、民主政治和民族国家难以同时兼得，最多保证其二。</p>
<p>简而言之，经济全球化要求各国采取削减贸易壁垒，统一税制与监管，开放资本流动等一体化措施，这会对国家主权造成威胁；如果要在保证各国主权完整的情况下强行推进全球化，当国内部分群体利益受损时，只能牺牲这部分人的利益，而这又违背了民主原则；保证民主与主权完整必然会使全球化放缓[10]。</p>
<p>综上所述，M国的全球治理体系存在重大缺陷，必然走向衰亡。</p>
<p>入关学的历史渊源</p>
<p>许多研究者认为入关学是最近才出现的，这其实是不对的，因为通过文献研究，笔者发现，其实入关学的历史比一般意义上久远的多。广义上讲应该有两千余年的悠远历史。 理论依据：吾入关，秋毫不敢有所近，籍吏民，封府库，而待将军。(《史记·项羽本纪》)</p>
<p>根据史记的记载，刘邦其实才是入关学的第一位创始人、第一位研究者。刘项之争，刘弱项强，项羽分封刘邦于偏僻、资源贫瘠的蜀地（华夏文明当时的边缘地带），而自己占据华夏文明当时的中心地带，并挟制义帝作为大义，妄图通过资源封锁刘邦，通过占据道德的制高地谴责刘邦，通过占据文明的解释权将刘邦蛮夷化，这样的处境不能不说是很相似的阿！</p>
<p>在这样的困境面前，刘邦通过潜心研究入关学，采用张良、韩信的计策，暗度（入）陈仓（关），进入到肥沃、发达、人力资源丰富的关中平原，以此获得了和项羽争霸的资本，最终夺取天下。这正是刘邦研究入关学的证据和成果！</p>
<p>此外，入关学还经过了历代各位大家的不断补充，在不同的历史时期里，入关学的表现形式包括并展现为：北伐、南下、东征等。</p>
<p>例如：</p>
<p>前1046年：武王伐纣，入关学萌芽 前206年：刘邦暗度陈仓、还定三秦，诞生了第一为入关学家</p>
<p>227年：诸葛亮上出师表，被誉为千古奇文，这是入关学的第一次高峰</p>
<p>1644年，清军入关，这是入关学第一次进行朝代更替规模的应用</p>
<p>1941年12月，日军偷袭珍珠港，南下南洋，最终失败，昭（招）和（核）名副其实，这表明了入关学仍存在的缺陷，即如果研究不当、理解偏差，将一定灭亡</p>
<p>2019年，山高县于知乎开讲入关学，一时云从者众，成为知乎键政一大显学，与曹学等并列知乎键政奇学</p>
<h2 id="二、入关学的两大理论"><a href="#二、入关学的两大理论" class="headerlink" title="二、入关学的两大理论"></a>二、入关学的两大理论</h2><p>建州的发展与大明的治理的现状不可共存理论</p>
<p>海东青和高丽参确实是建州经济的支柱，007式的蹲鹰和挖参虽然苦，但在建州也是让绝大多数摸鱼诸申羡慕的好工作。然而蹲鹰和挖参，改变不了摸鱼是绝大多数女真年轻人唯一出路的现实。建州固然不可能靠摸鱼崛起，更不可能靠蹲海边抓海东青和钻长白山挖高丽参而崛起啊。[11]</p>
<p>所以，建州如果在现状下要想赢得尊重，只有一条路可走，就是——剃发易服。 蛮夷干什么都是错的，想解决挨骂问题，当然只能靠留头不留发，留发不留头（手动狗头）。 所以，从而明确了入关学研究的意义：即建州想解决尊重问题。首先，得入关，入关就是一切，一切为了入关，不入关，一切免谈。 你不入关，大M以抢劫治天下且有无数砖家穴者论述其合理性与合法性。在这种人类历史上空前无耻的舆论氛围面前，不入关消灭大M，绝其社稷，谈何赢得尊重？ 至于入关之后，山高认为应该做两件事（剃发易服笑笑就好）： 1：剿兵安民，彻底消灭与清算大M的金融铁骑及其走狗。 2：闯王来了不纳粮，不利用国际贸易与结算体系为自己牟利。 当昭告天下： ——今我华起义军，行天诛。非图一家一姓之荣华，实为五洲苍生之乞活![12]</p>
<p>从经济学角度讲，垄断资本主义规则下，自由资本主义是侵蚀垄断利润的规则破坏者（所谓发达国家粉碎机）。M国既然以垄断资本主义逻辑运行，那么它就必然要打击自由资本主义，以维持市场秩序。 而建州由于人口太多，发不起垄断资本主义阶段失业无产阶级的奶头乐，是很难向垄断资本主义转型的，除非有世界范畴内的垄断利润可吃（甚至哪怕入了关，也不过996变成986）。 所以说中国对M国而言，既是规则破坏者，又是地位挑战者。 所以M苏在经济上是可以共存的（M苏在没有核武器的时代也没有打热战），建州和M国之间则不一样。[13]</p>
<p>明确蛮夷的地位及入关是唯一的解决方法理论</p>
<p>入关学家逗比南波万 @逗比南波万 认为，当下我们面临的重要困惑是：</p>
<p>为何我们政治文化地位跟经济军事地位不符合？ 为何全世界都不待见建州人？ 为何舆论的高地我们没法占领？ 为何英M一张表单，能让我们投入千亿真金白银，再吸收一大群洋垃圾？ 为何？一句话，因为你是蛮夷。 华夏文明，如烈日当空，五千年来都是棋手，一直以天朝上国自居，何来蛮夷之说？因为现代化是英M开创，全世界的现代化都不可避免混入西化。你说现代化是你自己的，那是胡扯。你警察，西装咋回事？我们是天朝上国，划分出：南蛮、北狄、东夷、西戎。欧M是现代化正统，我们就是东夷。不想承认，也没办法。 综上，逗比南波万通过研究入关学理论，认为解决方案是： 入关！入关是让我们早饭M国。蛮夷灭了正统，自有衍圣公带头来跪。成了，我们就是真命天子，是罗马正统，是天道正义之剑。[14]</p>
<h2 id="三、入关学的具体应用"><a href="#三、入关学的具体应用" class="headerlink" title="三、入关学的具体应用"></a>三、入关学的具体应用</h2><p>键政一向被视作咸吃萝卜淡操心，甚至有观点认为键政是“地沟油的命，ZNH的心”，故很多人认为入关学也是如此。 笔者认为这有失偏颇。笔者经过总结发现，其实入关学理论能帮助我们正确认知世界，占领舆论高地和积极应对生活。从而帮助我们更积极、更向上、更正能量。</p>
<p>正确认知世界，占领舆论高地<br>入关学理论是山高县键政理论体系的基础，为学生认识和理解山高县键政理论体系提供渠道，训练并培养学生的键政思维，为培养键政方面人才提供了方法。入关学理论也是知乎键政体系扩展和发展的重要动力，通过重视入关学理论的研究，我们就可以借助入关学理论理解和认知当今世界体系的由来和发展，从思维和实践中培养更加优秀、专业的键政人才。只有认知世界正确了，我们才能形成良好的思维，将理论知识灵活运用于既定事实之中，占领舆论的高地、提升爱国主义教育。因此，入关学的研究可以更好培养出爱国主义正能量知乎键政体系的人才。</p>
<p>培养积极心态<br>作为当今重压之下浮躁内卷佛系的青年，入关学倡导的思想更能让人乐观向上、充满希望。 学习入关学后将明白面包会有的，楼上楼下，电灯电话也会有的。我们将在有生之年，用铁与火，在冲绳海沟，将日本人的舰队埋葬；在安达曼海与孟加拉湾，将印度人的舰队，变成一堆废铁；在北大西洋和南赤道，在密克罗尼西亚，在所罗门群岛，将美国人的所有航母舰队，变成一具又一具的海底铁棺材。</p>
<p>俗话说，白白胖胖，充满希望，人最怕的就是失去希望，变成一具行尸走肉，只要还有希望，就还拥有一切。</p>
<p>四、结论与展望 本文首次以理论的高度总结了入关学的定义、渊源及其应用，是对当今入关学发展的一次大一统性工作。不过限于作者水平，观点上难免会有疏漏，甚至存在争议，但态度是端正的，毕竟摸鱼是女真年轻人唯一的出路，可是谁不想念四书五经呢？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Bash入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/05/Bash%E5%85%A5%E9%97%A8/"
    >Bash入门</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/05/Bash%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2020-04-05T19:10:02.000Z" itemprop="datePublished">2020-04-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Shell是Linux下经典的文本互动方式，而Bash是现在最常用的一种Shell。我在这里总结了Bash的要点知识。</p>
<h2 id="1-Shell综述"><a href="#1-Shell综述" class="headerlink" title="1. Shell综述"></a>1. Shell综述</h2><p>Linux图形化桌面算不上精美。幸好，Linux提供了更好的与树莓派互动的方式：Shell。打开终端（Terminal），桌面上就会出现一个黑色背景的窗口，里面就运行着一个Shell。如果你敲击键盘，会发现字符会显示在$提示符的后面，形成一串文本形式的命令。所谓的Shell，就是运行在终端中的文本互动程序。Shell分析你的文本输入，然后把文本转换成相应的计算机动作。</p>
<p>在后面的内容中，我将用$来表示Linux系统Shell的命令提示符。比如说输入date命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$date</span></span><br></pre></td></tr></table></figure>

<p>date用于日期时间的相关功能。敲击回车键Enter后，Shell会显示出系统当前的时间。</p>
<p>Shell看起来简陋，但实际上比图形化桌面强大得多。它是Unix体系下的文本交互界面。你只需要用键盘来输入文本，就可以和操作系统交互。但这还是不够具体。说到底，Shell其实是一个运行着的程序。这个程序接收到你按下回车键之间的输入，就会对输入的文本进行分析。比如下面这个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$free</span> -h</span><br></pre></td></tr></table></figure>

<p>包括空格在内总共7个字符。Shell程序会通过空格，区分出命令的不同部分。第一个部分是命令名。剩下的部分是选项和参数。在这个例子中，Shell会进一步分析第二个部分，发现这一部分的开头是”-“字符，从而知道它是一个选项。</p>
<p>有了命令名，Shell下一步就要执行该命令名对应的动作。这听起来就像是在戏剧舞台上，演员按照脚本演戏。Shell命令可以分为如下三类：</p>
<ul>
<li>Shell内建函数（built-in function）</li>
<li>可执行文件（executable file）</li>
<li>别名（alias）</li>
</ul>
<p>Shell的内建函数是Shell自带的功能，而可执行文件是保存在Shell之外的脚本，提供了额外的功能。Shell必须在系统中找到对应命令名的可执行文件，才能正确执行。我们可以用绝对路径来告诉Shell可执行文件所在的位置。如果用户只是给出了命令名，而没有给出准确的位置，那么Shell必须自行搜索一些特殊的位置，也就是所谓的默认路径。Shell会执行第一个名字和命令名相同的可执行文件。这就相当于，Shell帮我们自动补齐了可执行文件的位置信息。我们可以通过which命令，来确定命令名对应的是哪个可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$which</span> date</span><br></pre></td></tr></table></figure>



<p>别名是给某个命令一个简称，以后在Shell中就可以通过这个简称来调用对应的命令。在Shell中，我们可以用alias来定义别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$alias</span> freak=<span class="string">&quot;free -h&quot;</span></span><br></pre></td></tr></table></figure>

<p>Shell会记住我们的别名定义。以后我在这个Shell中输入命令freak时，都将等价于输入free -h。</p>
<p>在Shell中，我们可以通过type命令来了解命令的类型。如果一个命令是可执行文件，那么type将打印出文件的路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$type</span> date</span><br><span class="line"><span class="variable">$type</span> <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<p>总的来说，Shell就是根据空格和其他特殊符号，来让电脑理解并执行用户要求的动作。到了后面，我们还将看到Shell中其他的特殊符号。</p>
<h2 id="2-Shell的选择"><a href="#2-Shell的选择" class="headerlink" title="2. Shell的选择"></a>2. Shell的选择</h2><p>Shell是文本解释器程序的统称，所以包括了不止一种Shell。常见的Shell有sh、bash、ksh、rsh、csh等。在树莓派中，就安装了sh和bash两个Shell解释器。sh的全名是Bourne Shell。名字中的玻恩就是这个Shell的作者。而bash的全名是Bourne Again Shell。最开始在Unix系统中流行的是sh，而bash作为sh的改进版本，提供了更加丰富的功能。一般来说，都推荐使用bash作为默认的Shell。树莓派，以及其他Linux系统中广泛安装sh，都是出于兼容历史程序的目的。</p>
<p>我们可以通过下面的命令来查看当前的Shell类型：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$echo $SHELL</span><br></pre></td></tr></table></figure>

<p>echo用于在终端打印出文本。而$是一个新的Shell特殊符号。它提示Shell，后面跟随的不是一般的文本，而是用于存储数据的变量。Shell会根据变量名找到真正的文本，替换到变量所在的位置。SHELL变量存储了当前使用的Shell的信息你可以在bash中用sh命令启动sh，并可以用exit命令从中退出。</p>
<h2 id="3-命令的选项和参数"><a href="#3-命令的选项和参数" class="headerlink" title="3. 命令的选项和参数"></a>3. 命令的选项和参数</h2><p>我们已经看到，一行命令里还可以包含着选项和参数。总的来说，选项用于控制命令的行为，而参数说明了命令的作用对象。比如说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$uname</span> -m</span><br></pre></td></tr></table></figure>

<p>在上面的命令中，选项-m影响了命令uname的行为，导致uname输出了树莓派的CPU型号。如果不是该选项的影响，uname输出的将是”Linux”。我们不妨把每个命令看做多功能的瑞士军刀，而选项让命令在不同的功能间切换。由一个”-“引领一个英文字母，这成为短选项。多个短选项的字母可以合在一起，跟在同一个”-“后面。比如，下面的两个命令就等价：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$uname</span> -m -r</span><br><span class="line"><span class="variable">$uname</span> -mr</span><br></pre></td></tr></table></figure>



<p>此外还有一种长选项，是用”–”引领一整个英文单词，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$date</span> --version</span><br></pre></td></tr></table></figure>

<p>上面的命令将输出date程序的版本信息。</p>
<p>如果说选项控制了瑞士军刀的行为，那么参数就提供了瑞士军刀发挥用场的原材料。就拿echo这个命令来说，它能把字符打印到终端。它选择打印的对象，正是它的参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> hello</span><br></pre></td></tr></table></figure>



<p>有的时候，选项也会携带变量，以便来说明选项行为的原材料。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> date --<span class="built_in">set</span>=<span class="string">&quot;1999-01-01 08:00:00&quot;</span></span><br></pre></td></tr></table></figure>

<p>选项”–set”用于设置时间，用等号连接的，就是它的参数。date会把日期设置成这一变量所代表的日期。如果用短选项，那么就要用空格取代等号了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> date -s <span class="string">&quot;1999-01-01 08:00:00&quot;</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，Shell对空格敏感。当一整个参数信息中包含了空格时，我们需要用引号把参数包裹起来，以便Shell能识别出这是一个整体。</p>
<p>所谓的选项和参数提供给命令的附加信息。因此，命令最终会拿这些字符串做什么，是由命令自己决定的。因此，有时会发现一些特异的选项或参数用法。这个时候，你就要从文档中寻找答案。</p>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><p>我们可以在Bash中输入一行的命令。Bash会把输入的命令转化为特定的动作。从这一节起，我们将看到Bash的可编程性。Bash提供了某些类似于C语言那样的编程语法，从而允许你用编程的方式，来组合使用Linux系统。我们首先看Bash用变量存储数据的能力。正如我们在C语言中看到的，变量是内存中的一块儿空间，可以用于存储数据。我们可以通过变量名来引用变量中保持的数据。借助变量，程序员可以复用出现过的数据。Bash中也有变量，但Bash的变量只能存储文本。</p>
<p><strong>1）变量赋值</strong></p>
<p>Bash和C类似，同样用“=”来表示赋值。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=World</span><br></pre></td></tr></table></figure>

<p>就是把文本World存入名为var的变量，即赋值。根据Bash的语法，赋值符号“=”的前后不留空格。赋值号右边的文本内容会存入赋值号左边的变量。</p>
<p>如果文本中包含空格，那么你可以用单引号或双引号来包裹文本。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=<span class="string">&#x27;abc bcd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=<span class="string">&quot;abc bcd&quot;</span></span><br></pre></td></tr></table></figure>



<p>在Bash中，我们可以把一个命令输出的文本直接赋予给一个变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$now</span>=`date`</span><br></pre></td></tr></table></figure>

<p>借助``符号，date命令的输出存入了变量now。</p>
<p>我们还可以把一个变量中的数据赋值给另一个变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$another</span>=<span class="variable">$var</span></span><br></pre></td></tr></table></figure>



<p><strong>2）引用变量</strong></p>
<p>我们可以用$var的方式来引用变量。在Bash中，所谓的引用变量就是把变量翻译成变量中存储的文本。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=World</span><br><span class="line"><span class="variable">$echo</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>就会打印出World，即变量中保存的文本。</p>
<p>在Bash中，你还可以在一段文本中嵌入变量。Bash也会把变量替换成变量中保存的文本。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> Hello<span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>文本将打印出HelloWorld。</p>
<p>为了避免变量名和尾随的普通文本混淆，我们也可以换用${}的方式来标识变量。比如说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="variable">$varIsGood</span></span><br></pre></td></tr></table></figure>

<p>由于Bash中并没有varIsGood这个变量，所以Bash将打印空白行。但如果将命令改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="variable">$&#123;var&#125;</span>IsGood</span><br></pre></td></tr></table></figure>

<p>Bash通过${}识别出变量var，并把它替换成数据。最终echo命令打印出WorldIsGood。</p>
<p>在Bash中，为了把一段包含空格的文本当做单一参数，就需要用到单引号或双引号。你可以在双引号中使用变量。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="string">&quot;Hello <span class="variable">$var</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>将打印Hello World。与此相对，Bash会忽视单引号中的变量引用，所以单引号中的变量名只会被当做普通文本，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="string">&#x27;Hello $var&#x27;</span></span><br></pre></td></tr></table></figure>

<p>将打印Hello $var。</p>
<h2 id="5-数学运算"><a href="#5-数学运算" class="headerlink" title="5. 数学运算"></a>5. 数学运算</h2><p>在Bash中，数字和运算符都被当做普通文本。所以你无法像C语言一样便捷地进行数学运算。比如执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$result</span>=1+2</span><br><span class="line"><span class="variable">$echo</span> <span class="variable">$result</span></span><br></pre></td></tr></table></figure>

<p>Bash并不会进行任何运算。它只会打印文本“1+2”。</p>
<p>在Bash中，你还可以通过$(())语法来进行数值运算。在双括号中你可以放入整数的加减乘除表达式。Bash会对其中的内容进行数值运算。比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> $((<span class="number">2</span> + (<span class="number">5</span>*<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>

<p>将打印运算结果12。此外，在$(())中，你也可以使用变量。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=1</span><br><span class="line"><span class="variable">$echo</span> $((<span class="variable">$var</span> + (<span class="number">5</span>*<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>

<p>将打印运算结果11。</p>
<p>你可以用Bash实现多种整数运算：</p>
<ul>
<li>加法：$(( 1 + 6 ))。结果为7。</li>
<li>减法：$(( 5 – 3 ))。结果为2。</li>
<li>乘法：$(( 2*2 ))。结果为4。</li>
<li>除法：$(( 9/3 ))。结果为3。</li>
<li>求余：$(( 5%3 ))。结果为2。</li>
<li>乘方：$(( 2**3 ))。结果为8。</li>
</ul>
<p>现在，你就可以把数学运算结果存入变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$result</span>=$(( <span class="number">1</span> + <span class="number">2</span> ))</span><br></pre></td></tr></table></figure>



<h2 id="6-返回代码"><a href="#6-返回代码" class="headerlink" title="6. 返回代码"></a>6. 返回代码</h2><p>在Linux中，每个可执行程序会有一个整数的返回代码。按照Linux惯例，当程序正常运行完毕并返回时，将返回整数0。因此，C程序中返回0的语句，都出现在C程序中main函数的最后一句。例如下面的foo.c程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">  a = <span class="number">6</span>;</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">  c = <span class="number">6</span>/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序可以正常运行。因此，它将在最后一句执行return语句，程序的返回代码是0。在Shell中，我们运行了程序后，可以通过$?变量来获知返回码。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gcc</span> foo.c</span><br><span class="line">$./a.out</span><br><span class="line"><span class="variable">$echo</span> $?</span><br></pre></td></tr></table></figure>



<p>如果一个程序运行异常，那么这个程序将返回非0的返回代码。比如删除一个不存在的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> none_exist.file</span><br><span class="line"><span class="variable">$echo</span> $?</span><br></pre></td></tr></table></figure>



<p>在Linux中，可以在一个行命令中执行多个程序。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$touch</span> demo.file; ls;</span><br></pre></td></tr></table></figure>



<p>在执行多个程序时，我们可以让后一个程序的运行参考前一个程序的返回代码。比如说，只有前一个程序返回成功代码0，才让后一个程序运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> demo.file &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;rm succeed&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果rm命令顺利运行，那么第二个echo命令将执行。</p>
<p>还有一种情况，是等到前一个程序失败了，才运行后一个程序，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> demo.file || <span class="built_in">echo</span> <span class="string">&quot;rm fail&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果rm命令失败，第二个echo命令才会执行。</p>
<h2 id="7-Bash脚本"><a href="#7-Bash脚本" class="headerlink" title="7. Bash脚本"></a>7. Bash脚本</h2><p>你还可以把多行的Bash命令写入一个文件，成为所谓的Bash脚本。当Bash脚本执行时，Shell将逐行执行脚本中的命令。编写Bash脚本，是我们开始实现Bash代码复用的第一步。</p>
<p><strong>1）脚本的例子</strong></p>
<p>用文本编辑器编写一个Bash脚本hello_world.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Hello</span><br><span class="line"><span class="built_in">echo</span> World</span><br></pre></td></tr></table></figure>

<p>脚本的第一行说明了该脚本使用的Shell，即/bin/bash路径的Bash程序。脚本正文是两行echo命令。运行脚本的方式和运行可执行程序的方式类似，都是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./hello_world.bash</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果用户不具有执行Bash脚本文件的权限，那么他将无法执行Bash脚本。此时，用户必须更换文件权限，或者以其他身份登录，才能执行脚本。当脚本运行时，两行命令将按照由上至下的顺序依次执行。Shell将打印两行文本：</p>
<blockquote>
<p>Hello<br>World</p>
</blockquote>
<p>Bash脚本是一种复用代码的方式。我们可以用Bash脚本实现特定的功能。由于该功能记录在脚本中，因此我可以反复地运行同一个文件来实现相同的功能，而不是每次想用的时候都要重新敲一遍命令。我们看一个简单的Bash脚本hw_info.bash，它将计算机的信息存入到名为log的文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Information of yc&#x27;s computer:&quot;</span> &gt; <span class="built_in">log</span></span><br><span class="line">lscpu &gt;&gt; <span class="built_in">log</span></span><br><span class="line">uname –a &gt;&gt; <span class="built_in">log</span></span><br><span class="line">free –h &gt;&gt; <span class="built_in">log</span></span><br></pre></td></tr></table></figure>



<p><strong>2）脚本参数</strong></p>
<p>和可执行程序类似，Bash脚本运行时，也可以携带参数。这些参数可以在Bash脚本中以变量的形式使用。比如test_arg.bash:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span></span><br></pre></td></tr></table></figure>

<p>在Bash中，你可以用$0、$1、$2……的方式，来获得Bash脚本运行时的参数。我们用下面的方式运行Bash脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./test_arg.bash hello world</span><br></pre></td></tr></table></figure>

<p>$0是命令的第一部分，也就是./test_arg.bash。$1代表了参数hello，而$2代表了参数world。因此，上面程序将打印：</p>
<blockquote>
<p>./test_arg.bash<br>hello<br>world</p>
</blockquote>
<p>如果变更参数，同一段脚本将有不同的行为。这大大提高了Bash脚本的灵活性。上面的hw_info.bash脚本中，我们把输出文件名写死成log。我们也可以修改脚本，用参数作为输出文件的文件名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Information of yc&#x27;s computer:&quot;</span> &gt; <span class="variable">$1</span></span><br><span class="line">lscpu &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">uname –a &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">free –h &gt;&gt; <span class="variable">$1</span></span><br></pre></td></tr></table></figure>



<p>借助参数，我们就可以自由地设置输出文件的名字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./hw_info.bash output.file</span><br></pre></td></tr></table></figure>



<p><strong>3）脚本的返回代码</strong></p>
<p>和可执行程序类似，脚本也可以有返回代码。还是按照惯例，脚本正常退出时返回代码0。在脚本的末尾，我们可以用exit命令来设置脚本的返回代码。我们修改hello_world.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Hello</span><br><span class="line"><span class="built_in">echo</span> World</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>其实在脚本的末尾加一句exit 0并不必要。一个脚本如果正常运行完最后一句，会自动的返回代码0。在脚本运行后，我们可以通过$?变量查询脚本的返回代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$./hello_world.bash</span><br><span class="line"><span class="variable">$echo</span> $?</span><br></pre></td></tr></table></figure>



<p>如果在脚本中部出现exit命令，脚本会直接在这一行停止，并返回该exit命令给出的返回代码。比如下面的demo_exit.bash:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> hello</span><br><span class="line"><span class="built_in">exit</span> 1 <span class="built_in">echo</span> world</span><br></pre></td></tr></table></figure>

<p>你可以运行该脚本，检查其输出结果，并查看其返回代码。</p>
<h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><p>在Bash中，脚本和函数有很多相似的地方。脚本实现了一整个脚本文件的程序复用，而函数复用了脚本内部的部分程序。一个函数可以像脚本一个包含多个指令，用于说明该函数如果被调用会执行哪些活动。在定义函数时，我们需要花括号来标识函数包括的部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_info</span></span> ()&#123;</span><br><span class="line">  lscpu &gt;&gt; <span class="built_in">log</span></span><br><span class="line">  uname –a &gt;&gt; <span class="built_in">log</span></span><br><span class="line">  free –h &gt;&gt; <span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_info</span><br></pre></td></tr></table></figure>

<p>脚本一开始定义了函数my_info，my_info是函数名。关键字function和花括号都提示了该部分是函数定义。因此，function关键字并不是必须的。上面的脚本等效于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_info</span></span> ()&#123;</span><br><span class="line">  lscpu &gt;&gt; <span class="built_in">log</span></span><br><span class="line">  uname –a &gt;&gt; <span class="built_in">log</span></span><br><span class="line">  free –h &gt;&gt; <span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_info</span><br></pre></td></tr></table></figure>

<p>花括号中的三行命令，就说明了函数执行时需要执行的命令。需要强调的是，函数定义只是食谱，并没有转化成具体的动作。脚本的最后一行是在调用函数。只有通过函数调用，函数内包含的命令才能真正执行。调用函数时，只需要一个函数名就可以了。</p>
<p>像脚本一样，函数调用时还可以携带参数。在函数内部，我们同样可以用$1、$2这种形式的变量来使用参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_info</span></span> ()&#123;</span><br><span class="line">  lscpu &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">  uname –a &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">  free –h &gt;&gt; <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_info output.file</span><br><span class="line">my_info another_output.file</span><br></pre></td></tr></table></figure>

<p>在上面的脚本中，进行了两次函数调用。函数调用时，分别携带了参数output.file和another_output.file。</p>
<h2 id="9-跨脚本调用"><a href="#9-跨脚本调用" class="headerlink" title="9. 跨脚本调用"></a>9. 跨脚本调用</h2><p>在Bash中使用source命令，可以实现函数的跨脚本调用。命令source的作用是在同一个进程中执行另一个文件中的Bash脚本。比如说，有两个脚本，my_info.bash和app.bash。脚本my_info.sh中的内容是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_info</span></span> ()&#123;</span><br><span class="line">  lscpu &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">  uname –a &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">  free –h &gt;&gt; <span class="variable">$1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>脚本app.bash中的内容是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> my_info.bash</span><br><span class="line">my_info output.file</span><br></pre></td></tr></table></figure>

<p>运行app.bash时，执行到source命令那一行时，就会执行my_info.bash脚本。在app.bash的后续部分，就可以使用my_info.bash中的my_info函数。</p>
<h2 id="10-逻辑判断"><a href="#10-逻辑判断" class="headerlink" title="10. 逻辑判断"></a>10. 逻辑判断</h2><p>我们已经介绍了函数和脚本两种组合命令的方式。这两种方式都可以把多行命令合并起来，组成一个功能单元。函数和脚本都实现了一定程度的代码复用。从这一节起，我们将看到选择和循环两种语法结构，这两种语法结构可以改变脚本的运行顺序，从而编写出更加灵活的程序。Bash除了可以进行数值运算，还可以进行逻辑判断。逻辑判断是决定某个说法的真假。我们在生活中很自然地进行各种各样的逻辑判断。比如“3大于2”这个说法，我们会说它是真的。逻辑判断就是对一个说法判断真假。在Bash中，我们可以用test命令来进行逻辑判断：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span> 3 -gt 2; <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>命令test后面跟有一个判断表达式，其中的-gt表示大于，即greater than。由于“3大于2”这一表达式为真，所以命令的返回代码将是0。如果表达式为1，那么命令的返回代码是1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span> 3 -lt 2; <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>表达式中的-lt表示小于，即less than。</p>
<p>数值大小和相等关系的判断，是最常见的逻辑判断。除了上面的大于和小于判断，我们还可以进行以下的数值判断：</p>
<ul>
<li>等于： $test 3 -eq 3; echo $?</li>
<li>不等于： $test 3 -ne 1; echo $?</li>
<li>大于等于： $test 5 -ge 2; echo $?</li>
<li>小于等于： $test 3 -le 1; echo $?</li>
</ul>
<p>Bash中最常见的数据形式是文本，因此也提供了很多关于文本的判断：</p>
<ul>
<li>文本相同: $test abc = abx; echo $?</li>
<li>文本不同： $test abc != abx; echo $?</li>
<li>按照词典顺序，一个文本在另一个文本之前： $test apple &gt; tea; echo $?</li>
<li>按照词典顺序，一个文本在另一个文本之后： $test apple &lt; tea; echo $?</li>
</ul>
<p>Bash还可以对文件的状态进行逻辑判断：</p>
<ul>
<li>检查一个文件是否存在： $test –e a.out; echo $?</li>
<li>检查一个文件是否存在，而且是普通文件： $test –f file.txt; echo $?</li>
<li>检查一个文件是否存在，而且是目录文件： $test –d myfiles; echo $?</li>
<li>检查一个文件是否存在，而且是软连接： $test –L a.out; echo $?</li>
<li>检查一个文件是否可读： $test –r file.txt; echo $?</li>
<li>检查一个文件是否可写： $test –w file.txt; echo $?</li>
<li>检查一个文件是否可执行： $test –x file.txt; echo $?</li>
</ul>
<p>在做逻辑判断时，可以把多个逻辑判断条件用“与、或、非”的关系组合起来，形成复合的逻辑判断。</p>
<ul>
<li>非，与expression的真假相反：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! expression</span><br></pre></td></tr></table></figure>

<ul>
<li>与，必须expression1和expression2都为真时，结果才为真：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 –a expression2</span><br></pre></td></tr></table></figure>

<ul>
<li>或，只要expression1和expression2的一个为真时，结果就为真：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 –o expression2</span><br></pre></td></tr></table></figure>





<h2 id="11-选择结构"><a href="#11-选择结构" class="headerlink" title="11. 选择结构"></a>11. 选择结构</h2><p>逻辑判断可以获得计算机和进程的状态。进一步，Bash可以根据逻辑判断，让程序有条件地运行，这也就是所谓的选择结构。选择结构是一种语法结构，可以让程序根据条件决定执行哪一部分的指令。最早的程序都是按照指令顺序依次执行。选择结构打破了这一顺序，给程序带来更高的灵活性。最简单的，我们可以根据条件来决定是否执行某一部分程序，比如下面的demo_if.bash脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var=`whoami`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> = <span class="string">&quot;root&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span>   </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are root&quot;</span>   </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are my God.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这个脚本中使用了最简单的if结构。关键字if后面跟着[]，里面是一个逻辑表达式。这个逻辑表达式就是if结构的条件。如果条件成立，那么if将执行then到fi之间包含的语句，我们称之为隶属于then的代码块。如果条件不成立，那么then的代码块不执行。这个例子的条件是判断用户是否为root。因此，如果是非root用户执行该脚本，那么Shell不会打印任何内容。</p>
<p>我们还可以通过if…then…else…结构，让Bash脚本从两个代码块中选择一个执行。该选择结构同样有一个条件。如果条件成立，那么将执行then附属的代码块，否则执行else附属的代码块。下面的demo_if_else.bash脚本是一个小例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">filename=<span class="variable">$1</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$filename</span> ]</span><br><span class="line"><span class="keyword">then</span>   </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$filename</span> exists&quot;</span> </span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$filename</span> NOT exists&quot;</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The End&quot;</span></span><br></pre></td></tr></table></figure>



<p>if后面的“-e $filename”作为判断条件。如果条件成立，即文件存在，那么执行then部分的代码块。如果文件不存在，那么脚本将执行else语句中的echo命令。末尾的fi结束整个语法结构。脚本继续以顺序的方式执行剩余内容。运行脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./demo_if_else.bash a.out</span><br></pre></td></tr></table></figure>

<p>脚本会根据a.out是否存在，打印出不同的内容。</p>
<p>我们看到，在使用if…then…else…结构时，我们可以实现两部分代码块的选择执行。而在then代码块和else代码块内部，我们可以继续嵌套选择结构，从而实现更多个代码块的选择执行。比如脚本demo_nest.bash:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var=`whoami`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You are <span class="variable">$var</span>&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> = <span class="string">&quot;root&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;You are my God.&quot;</span> </span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$var</span> = <span class="string">&quot;yc&quot;</span> ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;You are a happy user.&quot;</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;You are the Others.&quot;</span></span><br><span class="line">   <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>



<p>在Bash下，我们还可以用case语法来实现多程序块的选择执行。比如下面的脚本demo_case.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var=`whoami`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You are <span class="variable">$var</span>&quot;</span> </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$var</span> <span class="keyword">in</span></span><br><span class="line">root)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are God.&quot;</span></span><br><span class="line">;;</span><br><span class="line">yc)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are a happy user.&quot;</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are the Others.&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>这个脚本和上面的demo_nest.bash功能完全相同。可以看到case结构与if结构的区别。关键字case后面不再是逻辑表达式，而是一个作为条件的文本。后面的代码块分为三个部分，都以文本标签)的形式开始，以;;结束。在case结构运行时，会逐个检查文本标签。当条件文本和文本标签可以对应上时，Bash就会执行隶属于该文本标签的代码块。如果是用户yc执行该Bash脚本，那么条件文本和yc标签对应上，脚本就会打印：</p>
<blockquote>
<p>You are a happy user.</p>
</blockquote>
<p>文本标签除了是一串具体的文本，还可以包含文本通配符。结构case中常用的通配符包括：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
<th>文本标签例子</th>
<th>符合条件的文本</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>任意文本</td>
<td>*</td>
<td>Xyz, 12a3, …</td>
</tr>
<tr>
<td>？</td>
<td>任意一个字符</td>
<td>a?c</td>
<td>abc, axc, …</td>
</tr>
<tr>
<td>[]</td>
<td>范围内一个</td>
<td>[1-5] [b-d]</td>
<td>2b, 3d, …</td>
</tr>
</tbody></table>
<p>上面的程序中最后一个文本标签是通配符*，即表示任意条件文本都可以触发此段代码块的运行。当然，前提是前面的几个文本标签都没有“截胡”。</p>
<h2 id="12-循环结构"><a href="#12-循环结构" class="headerlink" title="12. 循环结构"></a>12. 循环结构</h2><p>循环结构是编程语言中另一种常见的语法结构。循环结构的功能是重复执行某一段代码，直到计算机的状态符合某一条件。在while语法中，Bash会循环执行隶属于while的代码块，直到逻辑表达式不成立。比如下面的demo_while.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">now=`date +<span class="string">&#x27;%Y%m%d%H%M&#x27;</span>`</span><br><span class="line">deadline=`date --date=<span class="string">&#x27;1 hour&#x27;</span> +<span class="string">&#x27;%Y%m%d%H%M&#x27;</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$now</span> -lt <span class="variable">$deadline</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   date</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;not yet&quot;</span></span><br><span class="line">   sleep 10</span><br><span class="line">   now=`date +<span class="string">&#x27;%Y%m%d%H%M&#x27;</span>`</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;now, deadline reached&quot;</span></span><br></pre></td></tr></table></figure>

<p>关键字do和done之间的代码是隶属于该循环结构的代码块。在while后面跟着条件，该条件决定了代码块是否重复执行下去。这个条件是用当前的时间与目标时间对比。如果当前时间小于目标时间，那么代码块就会重复执行下去。否则，Bash将跳出循环，继续执行后面的语句。</p>
<p>如果while的条件始终是真，那么循环会一直进行下去。下面的程序就是以无限循环的形式，不断播报时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  date</span><br><span class="line">  sleep 1 </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>语法while的终止条件是一个逻辑判断。如果在循环过程中改变逻辑判断的内容，那么我们很难在程序执行之前预判循环进行的次数。正如我们之前在demo_while.bash中看到的，我们在循环进行过程中改变着作为条件的逻辑表达式，不断地更新参与逻辑判断的当前时间。与while语法对应的是for循环。这种语法会在程序进行前确定好循环进行的次数，比如demo_for.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> `ls <span class="built_in">log</span>*`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  rm <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>在这个例子中，命令ls log*将返回所有以log开头的文件名。这些文件名之间由空格分隔。循环进行时，Bash会依次取出一个文件名，赋值给变量var，并执行do和done之间隶属于for结构的程序块。由于ls命令返回的内容在是确定的，因此for循环进行的次数也会在一开始确定下来。</p>
<p>在for语法中，我们也可以使用自己构建一个由空格分隔的文本。由空格区分出来的每个子文本会在循环中赋值给变量。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> yc anna yutian</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$user</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>此外，for循环还可以和seq命令配合使用。命令seq用于生成一个等差的整数序列。命令后面可以跟3个参数，第一个参数表示整数序列的开始数字，第二个参数表示每次增加多少，最后一个参数表示序列的终点。因此，下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$seq</span> 1 2 10</span><br></pre></td></tr></table></figure>

<p>将返回：</p>
<blockquote>
<p>1 3 5 7 9</p>
</blockquote>
<p>可以看到，seq返回的也是由空格分隔开的文本。因此，seq的返回结果也可用于for循环。</p>
<p>结合for循环和seq命令，我们可以解一些有趣的数学问题。比如高斯求和，是要计算从1到100的所有整数的和。我们可以用Bash解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">total=0 </span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> `seq 1 1 100`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  total=$(( <span class="variable">$total</span> + <span class="variable">$number</span> ))</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$total</span></span><br></pre></td></tr></table></figure>



<p>这个问题还可以用do while循环来求解：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">total=0</span><br><span class="line">number=1 </span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$number</span> -gt 100 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  total=$(( <span class="variable">$total</span> + <span class="variable">$number</span> ))</span><br><span class="line">  number=$((<span class="variable">$number</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$total</span></span><br></pre></td></tr></table></figure>

<p>这里break语句的作用是在满足条件时跳出循环。</p>
<p>如果想计算1到100所有不被3整数的和，则可以使用continue语句，跳过所有被3整数的数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">total=0 </span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> `seq 1 1 100`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">if</span> (( <span class="variable">$number</span> % 3 == 0 )) </span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  total=$(( <span class="variable">$total</span> + <span class="variable">$number</span> ))</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$total</span></span><br></pre></td></tr></table></figure>



<h2 id="13-Bash与C语言"><a href="#13-Bash与C语言" class="headerlink" title="13. Bash与C语言"></a>13. Bash与C语言</h2><p>到了这里，我们已经介绍完Bash语言的基本语法。Bash语言和C语言都是Linux下的常用语言。它们都能通过特定的语法来编写程序，而程序运行后都能实现某些功能。尽管在语法细节上存在差异，但两种语言都有以下语法：</p>
<ul>
<li>变量：在内存中储存数据</li>
<li>循环结构：重复执行代码块</li>
<li>选择结构：根据条件执行代码块</li>
<li>函数：复用代码块</li>
</ul>
<p>编程语言的作者在设计语言时，往往会借鉴已有编程语言的优点。这是编程语言之间相似性的一大原因。程序员往往要掌握不止一套编程语言。相似的语法特征，会让程序员在学习新语言时感到亲切，从而促进语言的推广。</p>
<p>Bash和C的相似性，也来自于它们共同遵守的编程范式——面向过程编程。支持面向过程编程的语言，一般都会提供类似于函数的代码封装方式。函数把多行指令包装成一个功能。只要知道了函数名，程序可以通过调用函数来使用函数功能，最终实现代码复用。除了面向过程编程，还有面向对象和函数式的编程范式。每种编程范式都提供了特定的代码封装方式，并达到代码复用的目的。值得注意的是，近年来出现的新语言往往会支持不止一种编程范式。</p>
<p>除了相似性，我们还应该注意到Bash和C程序的区别。Bash的变量只能是文本类型，C的变量却可以有整数、浮点数、字符等类型。Bash的很多功能，如加减乘除运算，都是调用其他程序实现的。而C直接就可以进行加减乘除运算。可以说，C语言是一门真正的编程语言。C程序最终会编译成二进制的可执行文件。CPU可以直接理解这些文件中的指令。</p>
<p>另一方面，Bash是一个Shell。它本质上是一个命令解释器程序，而不是编程语言。用户可以通过命令行的方式，来调用该程序的某些功能。所谓的Bash编程，只是命令解释器程序提供的一种互动方法。Bash脚本只能和Bash进程互动。它不能像C语言一样，直接调用CPU的功能。因此，Bash能实现的功能会受限，运行速度上也比不上可执行文件。</p>
<p>但另一反面，Bash脚本也有它的好处。 C语言能接触到很底层的东西，但使用起来也很复杂。有时候，即使你已经知道如何用C实现一个功能，写代码依然是一个很繁琐的过程。Bash正相反。由于Bash可以便捷地调用已有的程序，因此很多工作可以用数行的脚本解决。此外，Bash脚本不需要编辑，就可以由Bash进程理解并执行。因此，开发Bash脚本比写C程序要快很多。Linux的系统运维工作，如定期备份、文件系统管理等，就经常使用到Bash脚本。总之，Bash编程知识是晋级为资深Linux用户的必要条件。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bash/" rel="tag">Bash</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">prev page</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/13/">next page</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Aaron
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">🏡</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">🏛</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">📚</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">🏷</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>