<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/12/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/27/The-Key-To-Accelerating-Your-Coding-Skills/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/27/The-Key-To-Accelerating-Your-Coding-Skills/" class="post-title-link" itemprop="url">The Key To Accelerating Your Coding Skills</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-27 22:46:12 / Modified: 23:50:10" itemprop="dateCreated datePublished" datetime="2020-01-27T22:46:12-05:00">2020-01-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>When you learn to code, there is a moment when everything begins to change. At Firehose, we like to call this the <em>inflection point of coding.</em> After this phase, the way you operate as a developer will be dramatically different. Building up to the inflection point is the process of becoming self-sufficient in programming, to the point where you no longer need any hand-holding. It can be a frustrating experience, but once it’s behind you, it is incredibly empowering.</p>
<p>At Firehose, our goal isn’t just to teach you Ruby, how to build web applications, or how to write tests. Although we do teach these skills and more, <strong>our primary goal is to accelerate students past the inflection point so they gain the ability to solve any problem they encounter</strong>. We believe that being able to problem solve on your own is an invaluable skill, and this method of teaching will take you much further than simply learning how to build a set of apps.</p>
<h3 id="The-Tutorial-Phase-3-8-weeks-of-serious-coding"><a href="#The-Tutorial-Phase-3-8-weeks-of-serious-coding" class="headerlink" title="The Tutorial Phase (3-8 weeks of serious coding)"></a>The Tutorial Phase (3-8 weeks of serious coding)</h3><p>When you start out learning to code, there’s a lot of information that you don’t know yet. This information is called <em>domain-specific knowledge.</em> Examples include: knowing how to write a loop in ruby or how to extract something from a database using Ruby on Rails. Domain-specific knowledge encompasses the protocols unique to a certain programming environment.</p>
<p>The first step to becoming a self-sufficient developer is learning how to do specific tasks. Once you master certain tasks, the broad strokes of how the pieces fit together will start to become apparent. Over time, you’ll begin to recognize patterns and eventually, the things that initially seemed confusing and foreign will become second nature.</p>
<h3 id="For-students-starting-out-the-most-important-skill-to-acquire-is-attention-to-detail"><a href="#For-students-starting-out-the-most-important-skill-to-acquire-is-attention-to-detail" class="headerlink" title="For students starting out, the most important skill to acquire is attention to detail."></a>For students starting out, the most important skill to acquire is attention to detail.</h3><p>Paying close attention to detail is important when going through materials like documentation or tutorials. Even the most minor typos and misspellings will result in error messages or bugs. Seeing error messages is a frustrating experience at first, but it’s a crucial step in the learning process. Dealing with error messages and problems in this phase teaches you one of the most important skills of programming within a safe environment: being detail-oriented.</p>
<p><strong>Debugging error messages is incredibly important</strong>. The fact of the matter is, error messages are just a part of programming: they are seen by inexperienced and very experienced developers alike. The only difference is, the more experience you have dealing with error messages, the less time you’ll need to spend trying to fix them. Here’s why:</p>
<ul>
<li>Over time, you will <strong>learn how to read error messages</strong> and extract the relevant details of the problem quickly. The first time you see an error message, it will take you a while to decode what it actually means. But after you’ve seen hundreds of error messages (and you will see hundreds!), you will be able to pinpoint the problem’s location and the relevant details you need in order to fix it.</li>
<li>You should <strong>learn from each error message that you resolve</strong>. Don’t just fix the error and be done with it; understand what is wrong with the code you’re fixing. By learning from each of your errors, the next time you make the same mistake, you’ll be able to fix it much faster.</li>
<li>Initially, you will probably ask for help on each error message you see. Over time, you’ll learn to ask for help less frequently by double-checking your code and <a href="http://blog.thefirehoseproject.com/posts/10-minutes-learn-programming/" target="_blank" rel="noopener">conducting smart Google searches.</a></li>
</ul>
<p>In the tutorial phase, you will follow instruction. At first, you’ll find it challenging to follow instructions and error messages will happen frequently. Over time, you’ll develop the skill to debug errors and pay better attention to small details, and you’ll be able to make progress much quicker. As you’re wrapping up the tutorial phase, you’ll notice you’re able to write code at a much more rapid pace.</p>
<p>At this point, some people feel confident– like they’re ready to ditch the training wheels and start building things without structured guidance– and will happily dive into the deep end. Other students will reach for more tutorials, trying to obtain more domain-specific knowledge in search of a “full understanding.” Unfortunately, tutorials will only take you so far, and true confidence isn’t found in tutorials or guides. True confidence comes from struggling through a problem you have no idea how to solve, and discovering a solution on your own.</p>
<p><strong><em>The dirty little secret of programming is…\</em></strong></p>
<p>You will never know everything you need to know to solve all your problems. Going into the journey, you probably envisioned yourself eventually learning everything you need to learn, and then being squared away. <em>This moment will never happen.</em></p>
<p>Programming is a life-long learning experience. Experienced software engineers seek to find solutions to problems they haven’t solved yet because it gives them the opportunity to learn more. If you find yourself waiting for the moment when you finally feel like you know everything there is to know about coding, know this: the day you’re waiting for will never come. And that is a wonderful thing.</p>
<p><strong>You will be ready to jump into the next phase of your journey when:</strong></p>
<ul>
<li>You’ve seen enough error messages that <strong>they no longer startle you</strong>. Instead, you know how to decipher what they mean and where to look for the problems in your code.</li>
<li><strong>You’re a pro at Googling for solutions</strong>. When you’re working to add a feature or see a confusing error message, you know what to search for to find the information you need.</li>
<li>You’re able to <strong>reference code you’ve written in other parts of your application and follow patterns</strong> within them, rather than always seeking out step-by-step instructions.</li>
</ul>
<h3 id="The-Inflection-Point-2-4-weeks-with-the-right-mentality"><a href="#The-Inflection-Point-2-4-weeks-with-the-right-mentality" class="headerlink" title="The Inflection Point (2-4 weeks with the right mentality)"></a>The Inflection Point (2-4 weeks with the right mentality)</h3><p>The inflection point stage is one of the most frustrating stages of learning to code, but in many ways, it’s the only stage that matters. It’s the point when you phase out of using tutorials and begin solving problems for which no one has lined up a solution for you.</p>
<p>At some points, you will feel like you aren’t ready to tackle this phase and like you want to return to building something with an outline of exactly what to do. Don’t fall prey to this mentality. The reason you’ll feel frustrated is:</p>
<h3 id="During-the-inflection-phase-you-will-be-coding-10-20-times-SLOWER-than-in-the-previous-phase"><a href="#During-the-inflection-phase-you-will-be-coding-10-20-times-SLOWER-than-in-the-previous-phase" class="headerlink" title="During the inflection phase, you will be coding 10-20 times SLOWER than in the previous phase."></a><em>During the inflection phase, you will be coding 10-20 times SLOWER than in the previous phase.</em></h3><p>You may start questioning yourself and wondering if you are actually capable of becoming a programmer. Feelings of insecurity and doubt are common in this stage.</p>
<p>Despite the fact that you’ll feel like you’re learning and accomplishing things at a much slower rate, in reality, you are achieving the things that matter the most. While your domain-specific knowledge is screeching to a putter, everything you’re learning will be about procedural knowledge.</p>
<p>Procedural knowledge is the ability to teach yourself what you don’t know along the way. When you need to implement a new feature, what type of Google search should you do? At this point in time, you’ll feel like you’re “in the dark” when it comes to many of the things you want to accomplish. Learning how to find the light on your own is critical because you can never know everything there is to know, so you need to be able to teach yourself how to solve the problem at hand.</p>
<p><strong>Most people do not realize that in order to learn to code, you need to learn both domain-specific and procedural knowledge.</strong></p>
<h3 id="For-the-rest-of-your-life-go-outside-your-limits-every-single-day"><a href="#For-the-rest-of-your-life-go-outside-your-limits-every-single-day" class="headerlink" title="For the rest of your life, go outside your limits every single day"></a>For the rest of your life, go outside your limits every single day</h3><p>Some software engineers stay inside their comfort zone once they find their footing. These types of programmers are known as maintenance programmers– not something you should strive to be. Instead, you should strive to go outside your limits every single day. The most common reason programmers quit their jobs is because “it’s not challenging anymore since I’ve solved all the interesting problems.”</p>
<p>Rather than trying to pull coding projects into your comfort zone, you should be seeking out problems that are outside your current skill set. This is the only way to build on and expand your skills.</p>
<p>In the words of a Firehose student upon passing his inflection point:</p>
<blockquote>
<h4 id="I-still-feel-like-I’m-in-the-deep-end-I’m-just-getting-more-comfortable-knowing-that’s-where-I’ve-got-to-be"><a href="#I-still-feel-like-I’m-in-the-deep-end-I’m-just-getting-more-comfortable-knowing-that’s-where-I’ve-got-to-be" class="headerlink" title="I still feel like I’m in the deep end! I’m just getting more comfortable knowing that’s where I’ve got to be!"></a>I still feel like I’m in the deep end! I’m just getting more comfortable knowing that’s where I’ve got to be!</h4></blockquote>
<h3 id="In-web-development-there-are-actually-two-inflection-points-that-will-come-together"><a href="#In-web-development-there-are-actually-two-inflection-points-that-will-come-together" class="headerlink" title="In web development, there are actually two inflection points that will come together."></a>In web development, there are actually two inflection points that will come together.</h3><p><strong>The web development inflection point</strong> is the point when you become capable of building any database-driven application that you want. This means being able to build a web application with many pages that stores and retrieves information from a simple database. Web developers call this: “mastering CRUD.” At this phase, you should also be able to integrate with any 3rd party library (a ruby gem for example) simply by following the documentation provided on GitHub or a blog post.</p>
<p><strong>The algorithm and data structures inflection point</strong> is a less superficial inflection point, but it is actually more important. Someone who has conquered this point will have mastered the programming language they’re working in, in addition to mastering the fundamentals of programming and having a depth of knowledge for solving complex coding challenges.</p>
<p>People who have conquered the algorithm and data structures inflection point will be able to:</p>
<ul>
<li>Write sorting algorithms</li>
<li>Implement and reverse linked lists</li>
<li>Understand and write programs leveraging stacks, queues, and trees</li>
<li>Write computer programs using recursive or iterative solutions</li>
</ul>
<p>In short, once you pass this inflection point, you will have mastered data manipulation and will understand the performance implications of your code decisions. Traditional computer science degrees focus exclusively on getting students past the algorithm and data structures inflection point. Many universities teach this with programming languages that are generally not used in the industry, like Scheme, Racket, or LISP.</p>
<p><strong>In most technical interviews, the interviewer will assume you’ve passed the web development inflection point, given that’s easier to do, and focus their questions on evaluating your skill in algorithms and data structures.</strong> These questions will generally focus on the topics we mentioned above: sorting algorithms, reversing linked lists, and using stacks, queues, and trees.</p>
<h3 id="Once-a-developer-has-passed-both-the-web-development-inflection-point-and-the-algorithm-and-data-structures-inflection-point-they-hold-the-keys-to-the-kingdom"><a href="#Once-a-developer-has-passed-both-the-web-development-inflection-point-and-the-algorithm-and-data-structures-inflection-point-they-hold-the-keys-to-the-kingdom" class="headerlink" title="Once a developer has passed both the web development inflection point and the algorithm and data structures inflection point, they hold the keys to the kingdom."></a>Once a developer has passed both the web development inflection point and the algorithm and data structures inflection point, they hold the keys to the kingdom.</h3><p>These developers will be able to solve challenges that intersect the two: complex algorithms that need to be built in the context of advanced web applications. This is at the heart of what professional web developers do every single day.</p>
<h3 id="Consequences-of-the-Inflection-Point"><a href="#Consequences-of-the-Inflection-Point" class="headerlink" title="Consequences of the Inflection Point"></a>Consequences of the Inflection Point</h3><p>The biggest consequence of the inflection point will sound a bit counterintuitive when you first hear it. Take a deep breath in:</p>
<blockquote>
<h4 id="When-learning-to-code-domain-specific-knowledge-doesn’t-matter-in-the-grand-scheme-of-things"><a href="#When-learning-to-code-domain-specific-knowledge-doesn’t-matter-in-the-grand-scheme-of-things" class="headerlink" title="When learning to code, domain-specific knowledge doesn’t matter in the grand scheme of things."></a>When learning to code, domain-specific knowledge doesn’t matter in the grand scheme of things.</h4></blockquote>
<p>Yup. I’m not joking– it really doesn’t matter that much at all. Once you pass the inflection point, these concepts will fluidly translate with just a week or two of tutorials, maybe even days!</p>
<p><strong>What ultimately really matters is:</strong></p>
<ul>
<li>You have a <strong>solid grasp on a web development framework</strong></li>
<li>You have a <strong>solid grasp on writing algorithmically complex code</strong> in any programming language</li>
</ul>
<h3 id="Hiring-managers-want-developers-with-solid-web-development-and-algorithm-skills"><a href="#Hiring-managers-want-developers-with-solid-web-development-and-algorithm-skills" class="headerlink" title="Hiring managers want developers with solid web development and algorithm skills."></a>Hiring managers want developers with solid web development and algorithm skills.</h3><p>While I was working at PayPal, my team hired a Senior Rails Developer who had no experience in Rails– he had been coding a lot in Python, LISP, and Perl. Within a couple of days, he was already making a big impact. And within weeks: a huge impact. He quickly rose to become the technical team lead and was one of the best hiring decisions I’ve ever been involved in.</p>
<p><strong><em>Don’t sweat the stack\</em></strong>. Many people will say things like, “AngularJS is hot these days,” “JavaScript is on the rise,” or “the latest fad is…” My response to that is: “so?” When you’re learning how to program, your singular goal should be to find the inflection point and annihilate it. Once you do, learning that new, sexy fad won’t be a difficult task at all.</p>
<p><strong><em>Become self-reliant\</em></strong>. Having the ability to learn new coding skills without structured guidance means you no longer need to wait for anyone to help you out. This means that for the majority of what you need to learn, you can simply search the internet and read the various material on what you need to know.</p>
<p>This doesn’t mean you immediately “know” everything, but just that everything is now “figure-out-able,” so in essence, you are unstoppable.</p>
<h3 id="The-Skills-You-Will-Develop-During-the-Inflection-Point"><a href="#The-Skills-You-Will-Develop-During-the-Inflection-Point" class="headerlink" title="The Skills You Will Develop During the Inflection Point"></a>The Skills You Will Develop During the Inflection Point</h3><p>As a software developer, the best reference material is similar code that you have already written. When you fully understand the code you’ve written, you don’t need to commit all the details to memory. This means that <strong>the first question you should ask yourself when building a new feature is: “Have I built something similar before?”</strong> If the answer is yes, revisit the code and walk through the code line-by-line in your head. Re-explain to yourself what it’s doing and ask yourself, “could I use the same approach now?”</p>
<p><strong><em>Videos suck at explaining domain-specific details\</em></strong> because they take so darned long to watch. Say you want to integrate with the Google Maps API. Once you’ve experienced doing so once, it can take less than a minute to open the code up in GitHub, copy the code, and paste it into a new project. Videos, on the other hand, can often take 10-30 minutes to re-watch.</p>
<h3 id="Strategies-for-Passing-the-Inflection-Point-as-Efficiently-as-Possible"><a href="#Strategies-for-Passing-the-Inflection-Point-as-Efficiently-as-Possible" class="headerlink" title="Strategies for Passing the Inflection Point as Efficiently as Possible"></a>Strategies for Passing the Inflection Point as Efficiently as Possible</h3><p>Because passing the inflection point is the most important part of learning to code, you should set yourself up to make the process as smooth as possible. This means you should start preparing while you’re in the tutorial phase and maintain the right mindset during this period of time.</p>
<p><strong>During the tutorial phase, take breaks from going over structured material and give yourself challenge problems along the way</strong>.</p>
<ul>
<li>For every handful of lessons, <strong>try to do something that is outside the scope of the tutorial</strong> you’re following. If the tutorials you’re going through provide “challenges” or “self-directed” pieces, do all of them. Solving unguided challenges will give you the important experience of doing things without structured guidance.</li>
<li><strong>Try to use tutorials as little as possible</strong>. At Firehose, we often walk students through how to integrate certain gems or do things using the provided documentation. Rather than simply following the instructions explained in tutorials that are geared towards people who are just starting out, many students will follow the documentation and use the tutorials as a back-up. <strong>Note that documentation will treat you like a developer who has passed the inflection point</strong>. Getting comfortable reading and following documentation on GitHub will give you a leg up when you’re on your own.</li>
<li>Focus on the essentials and use repetition. Learn how to do common things like spinning-up an application from scratch, pushing a new app to GitHub and Heroku, and building a database migration early on.</li>
</ul>
<p>*<em>Pushing through the inflection point can be challenging. Here are some pointers to get you through it:<br>*</em></p>
<ul>
<li>Understand that <strong>this is a difficult process and go easy on yourself</strong>. Also, set realistic expectations. You can’t compare your “superman”-level speed of going through tutorials to your “snail”-speed of learning things on your own. Keep in mind that you’re learning plenty, but at this phase, you’re learning a brand new skill of figuring new things out on your own.</li>
<li>If you’re struggling with self-confidence, know that what you’re feeling is completely normal. Keep working. If you continue to struggle, try talking to someone who has recently passed the inflection point. They will be able to relate to the position you’re in and will assure you that what you’re experiencing is only temporary. <strong>Work consistently, but don’t overwork yourself</strong>. At this phase of the game, know that you can only be productive for around 6 hours a day at the most. Working in an exhausted state will only prolong the time you spend building up to the inflection point.</li>
</ul>
<p>The best way to gain confidence at this stage is to power through any doubts you have. Your emotions may start to feel like a roller coaster. At times, you’ll feel like you’re on fire, but after 15 hours of struggling on the same problem, it’s very common to feel the polar opposite.</p>
<p>It can be frustrating to have no idea if something will take you 5 minutes or 5 hours, but every time you power through and successfully implement a new feature, the rush of confidence will be everything you need. After solving a handful of hard problems without any help, you’ll be addicted to the feeling of building things outside your comfort zone.</p>
<h3 id="How-to-know-when-you’ve-passed-the-inflection-point"><a href="#How-to-know-when-you’ve-passed-the-inflection-point" class="headerlink" title="How to know when you’ve passed the inflection point"></a>How to know when you’ve passed the inflection point</h3><p>The final stage of the inflection point process is acceptance. Acceptance that software development is a process of continuous learning. Acceptance that the feeling that you’ve successfully learned everything just means you should start thinking about solving more complicated problems.</p>
<p><strong>Have you experienced the inflection point yet? Share this post and start a conversation with your friends– you would be surprised how many people have reached and surpassed this moment.</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/26/What-are-some-of-the-most-basic-things-every-programmer-should-know/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/26/What-are-some-of-the-most-basic-things-every-programmer-should-know/" class="post-title-link" itemprop="url">What-are-some-of-the-most-basic-things-every-programmer-should-know</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-26 23:23:50" itemprop="dateCreated datePublished" datetime="2020-01-26T23:23:50-05:00">2020-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-27 00:27:24" itemprop="dateModified" datetime="2020-01-27T00:27:24-05:00">2020-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>Calling a function from within a loop is no more efficient than running all the function’s code within said loop.</li>
<li>Executing a loop of N iterations inside a loop of M iterations will consume at least M times as much time as executing the loop of N iterations once.</li>
<li>Numeric values are not inherently binary, hexadecimal or base-10. A numeric value is the same no matter the base in which you choose to express it. Therefore it doesn’t make sense to ask how to convert an integer value to binary, only how to express it as binary.</li>
<li>One byte is 8 bits and can represent 256 values. The number of values any variable can represent is determined by 2^n where n is there number of bits reserved for the variable</li>
<li>Retrieving and removing a value from a stack is called popping and returns the most recent value added, while retrieving and removing a value from a queue is called dequeuing and returns the oldest value.</li>
<li>A 1-dimensional array of X bytes consumes at least X bytes of memory. A 2-D array of X-by-Y bytes consumes at least X*Y bytes of memory.</li>
<li>A 2-dimensional array is basically the same as a 1-dimensional array whose values are accessed by calculating the index with Y<em>width+X. *</em>Edit:** My point here is not that all 2 dimensional arrays are really just 1-D arrays. My point is that a simple 2-D array of 2 fixed dimensions can generally be implemented with a 1-D array.</li>
<li>Printable text in a program is generally referred as a string. Every character in a string generally takes at least 1 byte.</li>
<li>Unicode is a standard that allows most known characters in all languages around the world to be represented by a single coding scheme. (There’s much more to know here, but not all of it is basic and understood by all programmers.)</li>
<li>UTF-8 is a Unicode encoding scheme that allows the most common Latin-based characters to be represented in 1 byte, while other characters can take 2 or more bytes.</li>
<li>If it’s not tested, it doesn’t work.</li>
<li>Source control is your friend - make sure you use it.</li>
<li>Just because you wrote it doesn’t mean you own it — don’t be offended if someone else on your team has to change your code.</li>
<li>Don’t reinvent the wheel, library code is there to help.</li>
<li>The fastest code is code that’s never executed — look for early outs.</li>
<li>Just because you didn’t write it doesn’t mean it’s crap.</li>
<li>Source code is just a hint to the compiler about what you want to do, it won’t necessarily do it (e.g. You might declare a function as inline but the compiler doesn’t have to obey).</li>
<li>Code that’s hard to understand is hard to maintain.</li>
<li>Code that’s hard to maintain is next to useless.</li>
<li>“Whilst I’m editing this file I’ll just…” is a great way to introduce feature creep and bugs.</li>
<li>The neater your code layout, the easier it is to read. The easier it is to read, the easier it is to understand and maintain.</li>
<li>Code is not self documenting. Help others by adding comments to guide them. You may understand it now but what about in 5 years time?</li>
<li>Bad Code can and will come back to haunt you.</li>
<li>There is no such thing as a 5 minute job. It’ll always take at least half a day.</li>
<li>Magic numbers are bad.</li>
<li>Constants don’t take up storage, they’re compile time text substitutions.</li>
<li>Project management will always want you to do twice as much in half the time.</li>
<li>If there is a bug, the user will find it.</li>
<li>A code review is not a criticism.</li>
<li>It’s not the quantity of code that matters, it’s the quality. Any idiot can bang out 40kloc but that doesn’t make it fit for purpose.</li>
<li>The true cost of poorly written code is in the maintenance.</li>
<li>Eat your own dog food — fixing bugs in your own code helps you code better and improves your understanding.</li>
<li>Code rots over time.</li>
<li>If the user didn’t ask for a feature, don’t add it.</li>
<li>If it’s not tested, it doesn’t work (yes, I know I’ve included that twice but it’s really important).</li>
<li>Networking basics - ssh tunnels, subnets, basic routing tables, TCP protocol, HTTP basics.</li>
<li>Memory - probably should know a little about how memory is laid out, virtual addresses, paging, page frame; user space and kernel not details - but just an accurate higher level idea.</li>
<li>Basic Data types and their sizes (uint, float, string, character/rune etc.</li>
<li>If you are in JVM or any runtime oriented landscape probably should know how GC overall works; generational collection in JVM is interesting to follow. Mark and sweep.</li>
<li>Basic and extremely <em>practical</em> knowledge of data structures and algorithms - you need to be able to apply things you’ve learned - I know many people who know all theory in the world but to them it seems no problem can be applicable to any catalogue full of algorithms and data structures they know off. Linked lists, stacks, queues, trees and graphs and some of the basic algorithms of sort, search etc.</li>
<li>Working knowledge of computer hardware - if leave this to readers; I prefer to understand a lot of details.</li>
<li>You probably should be proficient in one of those editors like Vim, Emacs, Sublime, IntelliJ, Eclipse (any but one) …</li>
<li>Should be able to step through code. (Think gnu tool chain, gdb, IntelliJ debuggers for Java world for example).</li>
<li>Understand relational calculus a bit - write sql queries . Know what is and how to use a relational DB - and a NoSql Db.</li>
<li>Know what files are and how file system works in general from kernel and user space view points - understand why IO is a bottleneck - good if you know scatter gather, mmap and other voodoo ;-)</li>
<li>Functional programming - know functions as data, first order functions, higher order functions, map, flatMap/bind, fold. You do not need to be a Haskeler or a Lisper for this. Fairly common to have such constructs in most modern languages today.</li>
<li>Understand what pointers are (if you are in JVM world ignore this but it would still be worthwhile to know); and how things are allocated and accessed.</li>
<li>Know about threads - Green threads, Coroutines; how concurrency maybe managed and how does it translate to core utilization.</li>
<li>Knowledge of HTML5 canvas and other simple constructs.</li>
<li>CSS Box model and general CSS</li>
<li>Knowledge of ES 6 fundamentals.</li>
<li>Knowledge of Node package manager and a JS build system</li>
<li>There will always be someone somewhere, you’d write a better code</li>
<li>Always test your code, for both, usual cases and edge cases</li>
<li>Never trust the user input, always sanitize it</li>
<li>Always check for buffer overflows</li>
<li>Leave the code better than you got it</li>
<li>You will spend more time thinking about the code, than actually coding</li>
<li>A bad design will haunt you as soon as the requirement changes even slightly</li>
<li>Under-commit and over-deliver, always</li>
<li>Your success will depend more on your soft-skills and how you articulate the problems and solutions to them, than your technical ability</li>
<li>When asked for an estimate on a feature, always overestimate for a 20% buffer</li>
<li>Do not get emotionally attached with the code. The fact that you wrote it does not mean that someone else cannot change it</li>
<li>You’ll see a few of your prototype implementations (POCs) making it to the product, and a lot of them being scrapped, don’t take it to heart, that’s the way things work</li>
<li>Use source control, and do frequent commits (squash commits before pushing to remote), it will save you in case of a disaster</li>
<li>Bad code will come back to haunt you in future</li>
<li>Take code reviews positively. Do not get into a code review with an ego, take review positively and learn to improve</li>
<li>Learn to read between the lines from the business requirements and try to convert them into technical requirements</li>
<li>It is a good idea to discuss your solution with another programmer before starting to implement it, you might learn more</li>
<li>Always document the code well, it will help others (including yourself) in the future</li>
<li>Improve your skills over time, otherwise you will become obsolete in the industry</li>
<li>Your QA folks should be your friends, that will save you a lot of trouble</li>
<li>Try going into meetings with solutions to problems, rather than just problems, your folks will start liking you</li>
<li>Never, ever, push a feature in production unless it is well-tested</li>
<li>Love your job, but not your company, you never know when your company might stop loving you</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/25/%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/25/%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1/" class="post-title-link" itemprop="url">设计自己的进度条</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-25 19:11:39" itemprop="dateCreated datePublished" datetime="2020-01-25T19:11:39-05:00">2020-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-26 23:57:59" itemprop="dateModified" datetime="2020-01-26T23:57:59-05:00">2020-01-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>进度条的设计是一个很多人都知道的故事：同样的耗时，如果不给任何进度提示，只是在完成之后才弹出一个完成消息，中间没有任何动态变化，那么整个过程就会让人等得非常焦急，导致一些人干脆把程序关了了事。如果有进度不断更新，那么对整个过程耗时的心理感受就会远低于实际值，用户也不会郁闷到把程序关了。（你有多少次在银行处理手续的时候，看着工作人员把一堆材料不停地倒腾来去，心里多希望他们可以在柜台小窗口上投影一个进度条？）</p>
<p>这里的原因在于，没有进度提示的话，我们无法判断这个等待什么时候才是个尽头。如果有不断增长的进度条，那么我们对于什么s时候会达到100%就会有一个粗略的估计，这个估计是一剂定心丸，让我们知道这事情总会并且会在不久的将来完成。</p>
<p>做事情也是同样的道理，善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成TODO列表。前阵子流行的GTD方法学，核心的理念就在于，如果你把任务分割了，你就有了进度条，你就知道，事情在不断的进展，你总会完成任务或到达你的目标，你会有一个时间估计。反之如果没有这个分割，整个的任务或目标对你来说就只有两种状态——“完成”和“未完成”，如果不幸是一个比较漫长的目标，那么你会发现你的进度条总是“未完成”，一次又一次的等待未果会耗尽你的耐心，让你下意识的产生“这事什么时候才能完呢？”的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的，这就会让你心生怯意，不敢进一步投入时间，免得血本无归。在这样的心理下，不少人就会选择保守策略——退出，以免到头来花了时间还一事无成。</p>
<p>而所谓的规划其实就是针对这种心理弱点的做事方法。如果你对整个目标的几个重大步骤有清晰的界定，能够对每个步骤的耗时作出靠谱的上界估计，你就不会被不确定的未来，不确定的时间投入感到恐惧，就不会被这种不确定感压迫到过早退出。</p>
<p>不要过早退出循环</p>
<p>我们在尝试新的事物的时候，总是会遇到各种各样的困难，不同的人会在碰壁不同的次数之后退出。用程序员喜欢的话来说就是，我们都在for循环，区别在于你是什么情况下break;的。有的人退出阈值高，这是能坚持的一类人，有的人退出阈值低，这类人很可能遇到一些障碍就退出了。</p>
<p>过早退出的原因往往在于对于未来的不确定性，对于投资时间最终无法收到回报的恐惧，感受到的困难越大，这种恐惧越大，因为越大的困难往往暗示着这个任务需要投资的时间越大。所以其实我们都是直觉经济学家，当我们说“畏难”的时候，其实我们畏惧的不是困难本身，而是困难所暗示的时间经济学意义。</p>
<p>然而，我们的情绪大脑毕竟比较原始，仅根据碰壁的次数或硬度来判断事情的难易并不一定靠谱，如果你遇到困难，不妨用一用互联网，用一用群体的智慧，看看别人当时是怎么想怎么办的，绝大多数情况下你并不孤单，你遇到的问题早就有人遇到过，你踩过的坑里面尽是前人的脚印，不要仅仅因为一时摸不着头绪，找不着出路就退出，这不是informed decision，问一问自己作出退出的决策是否基于足够的信息，我是否进行了足够的调查，至少，是否去简单用了用搜索引擎。</p>
<p>模仿高德纳先生的名言：过早退出是一切失败的根源。</p>
<p>兴趣遍地都是，专注和持之以恒才是真正稀缺的。</p>
<p>很多人看了书中的故事之后得出这样的结论：兴趣最重要。然而，我觉得区别他们和其他人的，并不是他们拥有超过常人的兴趣，而是他们拥有超过常人的毅力。</p>
<p>其实人天生就对新事物怀有好奇心，难以找出谁没有对任何事物或领域产生过兴趣，然而不同的是，有些人的兴趣只能持续几天，当遇到第一个困难，第一道坎的时候，他们就熄灭了，然而另一些人的兴趣火花会变成火苗，火苗会变成火种，一直稳定的燃烧很多年。区别他们的并不是兴趣的有无，而是他们的性格里面有没有维持兴趣的火种一直燃烧下去的燃料。</p>
<p>一个人有专注和持之以恒的性格，即便在一个没有多大兴趣的领域也能成为专家（更何况，兴趣的很大一类来源就是“我擅长做这件事情”）；反之就算有兴趣也很快会被一些冷水泼灭。</p>
<p>生活中的选择远比我们想象得要多，细微的选择差异造就了不同的人生</p>
<p>唐雅薇同学的故事中，有这么一个细节吸引了我的注意：当时她正在找工作阶段，对女生在IT行业的发展很迷茫，恰逢微软的郭蓓菁女士到他们学校演讲，演讲完了之后她立即就奔上讲台拦住郭女士询问女生与IT的问题。</p>
<p>这是一个细节，但我相信不是所有人都有勇气上去拦住名人问普通问题的，我们会给自己找很多很多的理由和接口，我想最常见的应该是两个原因：1. 如果被批评了自尊心会受到打击。2.认为问了也问不出特别的信息。然而事实却是相反：1. 自尊心受到打击算不上实质性的损失。2. 你想不出能问出什么特别的信息并不代表就真的问不到重要的信息。别把不知道当成没有。</p>
<p>一个小小的思维差异，可能导致很多人在遇到困惑的时候原地打转，冲突不出，而另一些人则取经得到宝贵的经验，站在别人的肩膀上越过了障碍。唐雅薇从郭女士那儿得到了最宝贵的信息：女生在IT行业也能有很好的发展。信心，是这样一种奇怪的东西，就算你没有确切的证明未来会更好，你也会坚持下去，你不会过早退出循环；而来源于过来人的信息则是信心最靠谱的保障。</p>
<p>你是不是意识到，在平常的生活中，你所作出的选择比你想象的要多得多呢？有没有想过有一些看似细小的选择可能会产生巨大的影响？</p>
<p>想想看，试一下，是不是真的没什么损失，还有可能得到巨大的回报呢？</p>
<p>靠专业技能的成功是最具可复制性的</p>
<p>它需要的只是你在一个领域坚持不懈地专注下去，只需要选择一个不算太不靠谱的方向，然后专心致志的专下去，最后必然能成为高手或者绝顶高手。世上有很多成功带有偶然因素和运气成分或出身环境，但至少这一样，被无数人复制了无数遍，否则就不会存在学校和教育了。</p>
<p>反思是让人得以改进自己的最重要的思维品质</p>
<p>很多人在成年之后甚至未及成年，性格就难以再发生大的变化。性格是这样一种自我实现和强化的陷阱：如果你是不容易专注的人，你会发现生活中处处都是分散你注意力的东西，你的思维难以在一个事情上停留半小时，于是你的时间变得琐碎，你很难在一个领域有长久的积累和深入的思考，这样的现实可能会让你感到沮丧，后者让你更加无法专心，这样的现实可能会让你感到焦虑，为了避开焦虑你又会去寻求其他的刺激，结果是恶性循环。</p>
<p>反思是改变自己的第一步，我们常常容易发现别人的问题，别人的错误，却难以发现自己思维中的问题，因为我们很少会把自己的思维当成目标去思考。</p>
<p>作为程序员，相信没有人不知道能修改自身的程序，而能修改自身的程序的前提就是，首先这个程序必须有法子能够指向自身。</p>
<p>饿死在干草堆之间的驴子</p>
<p>有很多在迷茫期的同学，迷茫都是相似的：面前有两条路，到底选哪一条？“转行还是不转行？”“学C++还是学Java。？“做管理还是做程序员？”有些问题其实不是问题：比如“学C++还是学Java。”答案是都学而且还不仅学两个。有些问题不是一个泛泛的答案能够适合的，比如转行还是不转行，需要考虑很多自身因素。</p>
<p>但更重要的是，有人会因为无法作出决定就推迟决定，然而实际上推迟决定是最差的决定，在推迟决定期间，时间悄悄流逝，你却没有任何一条路上的积累，白白浪费了时间。</p>
<p>如果你有一些钱不知道花在A还是B上，你先不作决定，没问题，因为钱还是你的，但如果你有一些时间，不知道花在A上还是B上，不行，因为过了这段时间，这段时间就不是你的了。</p>
<p>所以，不管有多纠结，也不要从纠结中逃离，试图推延决定，既然终究是个痛苦的决定，就痛一回，好好思考和调查之后作出一个决定并坚持下去，只要不是太不靠谱的行业（相信也没谁会在纠结了之后却选了一个不靠谱的行业的），经过你的积累总会成为高手。</p>
<p>一生的知识积累，自学的起码占90%</p>
<p>你会在这本书当中看到的一个重复出现的现象就是自学，大规模的自学，逃课自学，上网找书自学，程序员行业是最适合自学的行业，网络是程序员的天堂，需要的资源、工具，比课堂上的多出何止百倍，如果说还有一个学科，并不需要传统的教育就可以成才，估计非程序员莫属了。作为程序员如果没有查过wikipedia，没有看过几本原版电子书，没有在国内外主要邮件列表里面提过问题吵过架，没有用技术博客记录学习的独特体会，没有订阅技术牛人们的博客，怎么好意思说身在这个行业呢？</p>
<p>最后，看完了书还是说“说起来容易做起来难”的，怪自己，不怪书。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B9%9D%E7%A7%8D%E7%B4%A0%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B9%9D%E7%A7%8D%E7%B4%A0%E8%B4%A8/" class="post-title-link" itemprop="url">优秀程序员的九种素质</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-24 18:43:09 / Modified: 19:46:23" itemprop="dateCreated datePublished" datetime="2020-01-24T18:43:09-05:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>软件是怎么被创造出来的？</p>
<p>首先，它们的诞生都是有人想要造一个东西。这其中的很多故事你都耳熟能详：张小龙创造微信、乔布斯创造 iOS、暴雪想做一款不一样的射击游戏……他们首先有着这样的意图，然后，他们立项做这样的产品。</p>
<p>每一款软件项目背后，都有很多人在参与。你无法想象微信这样复杂的 App 靠张小龙自己可以开发出来；你也不会相信 iOS 是乔布斯一个人设计出来的；像守望先锋这种游戏的背后，有成百上千的游戏策划、美术设计、程序开发人员。</p>
<p>从立项到第一个版本的发布，每个成功的软件都需要有计划、有步骤地进行，什么时候发布第一个版本、第一个版本有什么样的功能、什么时候发布第二个版本、第二个版本有哪些地方要改进，这些都是研发过程中需要考虑的问题。</p>
<p>比如，守望先锋是在 2013 年立项，他们计划做一个基于职业的 MMO 游戏，他们先花了几个月的时间做了第一个 Demo 演示，只有四个英雄和一个张地图。</p>
<p>然后，他们要在 2014 年的“暴雪嘉年华”发布这个游戏的试玩版，包含 12 个英雄和 4 张地图。</p>
<p>最终这个游戏在 2016 年 5 月正式发布了。这样从立项一步步到最终发布，历时三年，中间经过了诸多环节。</p>
<p>类似的例子还有微信，2010 年 11 月 20 日立项，2011 年 1 月 21 日第一版上线，当时的功能还非常简陋，只能发送文本消息和照片。之后才是一个个版本的迭代，直到你现在看到的微信。</p>
<p>像这种有人参与、有计划、有步骤地造一件产品，我们通常称为「工程」。</p>
<p>村上春树在《当我谈跑步的时候，我谈些什么》，他说自己能够持续写作和跑步，就是因为具备两个特质，一个是集中力，一个是耐力。村上写长篇的时候每天早晨集中写作四小时，他一个人坐在书桌前，没有任何打扰，将意识集中倾斜在书稿中，其他什么都不考虑。另外，没有耐力也不行。你集中写了一星期然后伸伸懒腰说，我累了，然后就休息一个月，这样是写不成长篇的。你必须每天集中写作，坚持半年，一年，甚至更长才行。</p>
<p>一个优秀的程序员需要什么特质呢？ Redis 之父萨尔瓦托·桑菲利普（Salvatore Sanfilippo）写的 9 种高能程序员的特质：</p>
<p>1、高效完成子任务</p>
<p>从处理编程子任务上，可以看出一个程序员的短板和长处，比如实现一个函数或者一个算法。事实上，擅于使用基本的编程技能来高效完成任务的程序员，并没有人们想象的那么多。有时候，团队里有些不称职的程序员，他们甚至不知道该怎么写一个简单的排序算法。</p>
<p>2、合理使用自己的经验</p>
<p>桑菲利普认为，经验就是一系列解决方案，它们已经被证实可以用于处理一些重复性的任务。经验老道的程序员知道该如何处理各种子任务，这样不但省掉了很多设计工作，而且避免了很多设计错误，而设计错误是简洁性最大的敌人。</p>
<p>3、准确预测工期</p>
<p>花在编码上的时间不仅要看数量，也要看质量。造成注意力不集中的因素既有内部的，也有外部的。集中注意力和避免被打扰，对于提高编程效率来说是至关重要的。</p>
<p>4、设计权衡：用 5% 换取 90%</p>
<p>项目的「非根本性」目标在很大程度上导致了设计的复杂性，或者导致无法达成其他更重要的目标，因为根本性功能和非根本性功能在设计上存在竞争关系。如果意识不到这点，复杂性就会随之而来。对于设计者来说，如果项目要最大化产出，就要把精力集中在重要的事情上，并在合理的时间内完成。</p>
<p>5、简洁性</p>
<p>简洁性是成败之间最为明显的分界点，理解复杂性的产生过程有助于理解什么是简洁性。不愿意做出设计权衡和设计错误的累积是导致复杂性的两个主要因素。</p>
<p>6、拒绝完美主义（为了偏袒设计而放弃生产力）</p>
<p>完美主义可以分为两种：一种是追求程序极致性能的工程文化，另一种是个人特质。不管是哪一种完美主义，它们都会对程序员实现快速交付造成阻碍。完美主义和对外部评判的恐惧会导致设计上的偏袒，程序员根据主观的心理因素和无关紧要的衡量参数做出设计决策，却忽略了健壮性、简洁性和及时交付。</p>
<p>7、理解知识理论的价值</p>
<p>在处理复杂任务时，具备一些理论方面的知识会对设计产生重要影响，比如数据结构方面的知识、了解计算能力的局限性和一些重要的算法。虽然程序员没有必要成为无所不知的超级专家，但是至少要知道一些问题的潜在解决方案，避免设计出复杂、缓慢、低内存效能的解决方案。</p>
<p>8、理解机器原理</p>
<p>程序的很多问题都是源于对计算机工作原理的误解，即使是使用高级语言开发的程序也不外乎如此。这种情况可能导致一个项目需要重新设计和实现，因为项目所使用的工具和算法出现了根本性的错误。</p>
<p>7 和 8 说的道理差不多，这也是极客时间会连续推出数学、算法、数据结构、网络协议、软件工程等课程的原因，后面还有架构设计、操作系统、编译原理等等。</p>
<p>9、调试技能</p>
<p>查找和解决 bug 经常会占用程序员大量的时间。查找引起 bug 的问题根源，在合理的步骤内修复 bug，以简单的方式编写包含较少 bug 的代码，对于程序员来说，做到这几点就可以显著提升效率。</p>
<p>能否运用调试技能快速解决问题是衡量一个程序员水平的重要标准。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/23/%E5%B5%A9%E5%AD%A6%E8%9B%AE%E5%A4%B7%E8%AE%BA%E5%92%8C%E5%85%A5%E5%85%B3%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/%E5%B5%A9%E5%AD%A6%E8%9B%AE%E5%A4%B7%E8%AE%BA%E5%92%8C%E5%85%A5%E5%85%B3%E8%AE%BA/" class="post-title-link" itemprop="url">嵩学蛮夷论和入关论</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-23 23:35:00" itemprop="dateCreated datePublished" datetime="2020-01-23T23:35:00-05:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-24 01:53:11" itemprop="dateModified" datetime="2020-01-24T01:53:11-05:00">2020-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作为一个时常混迹于中文网络“键政圈”的人，我深知“键政”的快乐在于看各种大佬针锋相对，互相打脸，晾出干货，表达私货，“嵩学”以其独特的叙事风格和独道观点引起各方键政大佬的交流，我作为吃瓜人看的是不亦乐乎。</p>
<p>“键政”多年，我深感“键政”中多数人只不过是拾人牙慧、宗教狂热、党同伐异、复读机、说书人、追星狂，能自己生产“键政”话题，思想者寥寥。山高县作为“寥寥”和“大多数”人之间的人，其引人瞩目的各种臭屁，嬉闹，极端，严肃，欢乐的暴论是非常有趣的，希望看完本文的读者也能去关注他一波。</p>
<p>本文力求还原山高县所谓“嵩学”的大部分观点，话术，同时附上一些我自己的理解，以馈那些后来入场的、忙着追星“嵩学”的或计划着批判“嵩学”的、有意研究中文网络“键政“的、甚至写小说的读者。</p>
<p><strong>“嵩学”思想体系1——”蛮夷论“与“入关论”</strong></p>
<p><strong>—————————————历史给皇罗的代号是拜占庭———————————</strong></p>
<p>山高县其人所开创的所谓“嵩学”中最令人（至少是我）眼前一亮的核心理论即是：“蛮夷论”和“入关论”。</p>
<p><strong>原理说明:</strong></p>
<p>这其中，蛮夷论是嵩学叙事的<strong>框架：“它以17世纪中的“明朝灭亡，清朝建立”这个大背景作为隐喻，类比概括了当今国际上中国及世界其他国家/地区的哲学关系。”</strong></p>
<table>
<thead>
<tr>
<th>表： 女真人如何从东北一隅的小小部落最后成为打败了17世纪世界上最强大的国家-明朝，并建立了清朝。</th>
</tr>
</thead>
<tbody><tr>
<td>里： 中国作为一个懂呀黄种民族该如何打败盎格鲁撒克逊民族统治下的超级大国-美国及其国际秩序，并建立中国理想的秩序。</td>
</tr>
</tbody></table>
<p>并由此得出（实际上我觉得他是先有结论，后有理论的，但这其中历史的启发起到什么角色，这只有山高县自己知道）：<strong>中国无法在当今世界获得理解和支持，并屡屡碰壁和挨打的核心原因在于——我们是美国主导的以盎格鲁撒克逊民族为“中华”正统的世界秩序中的“女贞”蛮夷。</strong></p>
<p>为了解决这个问题，山高县给出了“入关论”这一<strong>解决方案</strong>。</p>
<blockquote>
<p>大清追上大明，靠的是入主中原，而不是在赫图阿拉读四书五经。</p>
</blockquote>
<p>其具体做法是：<strong>突破一二岛链，控制东南亚，扼住马六甲咽喉，维护印度洋航道，肢解印度。</strong></p>
<p><strong>原理补充</strong>：“中华蛮夷”体系话术中的黑词：</p>
<table>
<thead>
<tr>
<th>大明</th>
<th>美国</th>
</tr>
</thead>
<tbody><tr>
<td>建州女真</td>
<td>中国</td>
</tr>
<tr>
<td>入关</td>
<td>马六甲</td>
</tr>
<tr>
<td>成化梨庭</td>
<td>种族屠杀</td>
</tr>
<tr>
<td>赫图阿拉</td>
<td>北京</td>
</tr>
<tr>
<td>赫图阿拉各部旧账</td>
<td>中国历史</td>
</tr>
<tr>
<td>四书五经</td>
<td>西方金融/政治/社会等各种思想</td>
</tr>
<tr>
<td>儒学大师</td>
<td>为西方思想唱赞歌的学者</td>
</tr>
<tr>
<td>剃发易服</td>
<td>全盘西化</td>
</tr>
<tr>
<td>剿匪安民</td>
<td>彻底消灭与清算北美匪帮的金融铁骑及其走狗</td>
</tr>
<tr>
<td>闯王来了不纳粮</td>
<td>不利用国际贸易结算体系为自己谋利</td>
</tr>
<tr>
<td>挖参</td>
<td>低端产业</td>
</tr>
<tr>
<td>敕书</td>
<td>国际贸易体系准入证</td>
</tr>
<tr>
<td>叶赫部</td>
<td>香港，台湾等受西方资助的分离势力总称</td>
</tr>
<tr>
<td>金融铁骑</td>
<td>全球金融投机客 ex：索罗斯</td>
</tr>
<tr>
<td>颜色卫兵</td>
<td>以策动颜色革命为生的人</td>
</tr>
<tr>
<td>苏松二府，秦淮河畔，东林书院</td>
<td>美国令人向往的繁荣生活</td>
</tr>
</tbody></table>
<p><strong>评论：</strong></p>
<p>很多知乎er在评价山高县时，常言：其故弄玄虚，腹中无物，说书先生，我同意这句评价的三分之二。首先，山高县所谓的“蛮夷论”我认为最为出彩，但其实这个理论并不新鲜，它就是“西方中心论”的本土化新视角重构，我之所以觉得它出彩，就在于他是中国人听得懂的本土化语言和本土化视角。</p>
<p>山高县很喜欢民族主义叙事，本人有明显的民族主义倾向（虽然他否认<a href="https://zhuanlan.zhihu.com/p/96784759#ref_3" target="_blank" rel="noopener">[3]</a>），但显然也不是走火入魔的那一种（比如有人对这套已经“脱敏”了的“西方中心论”竟然还“过敏”，无法理解），他认为当今世界是美利坚天朝的世界，我们潜意识里的“自居天朝上国”是可笑和危险的。</p>
<p>虽然观点缺乏内核创新，但我仍然认为他这套“蛮夷之论”非常有益于键政圈的发展，在中文键政圈中，不同的叙事方法，对于丰富思想是大有裨益的。例如在解释HK问题时，左壬用阶级叙事，右壬用自由民主“圣贤书”，用经济理论的，用文明冲突的，用社会心理学的，都对，都可以。代入这套“蛮夷论”中，也可以有精彩的回答。</p>
<blockquote>
<p><strong>你如何看待香港现状及未来发展？</strong></p>
<p>现状：宁为大明狗，不做女真豚，杀进建奴，能做大明的狗就是最大的荣幸啊。</p>
<p>未来：我叶赫那拉就算只剩一个女子，也要毁灭建州！</p>
</blockquote>
<p>但山高县的这套“蛮夷论”显然不是什么正经的科学，它像是文明冲突论，又像是社会心理学，你也可以再用回其他叙述体系，他们是相互涵盖和补充的。它诞生最初的目的是躲避知乎键政的审查体系（粉丝不明白他的苦心，非要冲塔献祭，炫耀自己所学，所以傲慢是中文键政生存的最大障碍啊！），方便粉丝理解。事实上一开始山高县对此并不上心，在他的回答中大清也可以用来类比西方，美国也可以用蒙古类比。</p>
<blockquote>
<p><strong>如何看待英国工党误国这一观点？</strong></p>
<p>都说老佛爷卖国，没有老佛爷卖国，旗人这铁杆庄稼能发到辛亥年吗？</p>
<p>大英乙烷的情况下，真以为大英祖产靠节衣缩食就能保住？趁着能卖，卖个好价钱，让百姓吃上几十年铁杆庄稼，某种程度上说也算没辜负大英祖宗打下的江山。</p>
<p>苏伊士运河事件之后的大英，旗人们能吃几十年铁杆庄稼已经是最好的结局了，还要啥自行车？</p>
</blockquote>
<p>但这个“蛮夷论”的走红不能不引起引起我们的思考，它漏洞百出，机械类比，没有支撑，甚至“创始人”自己都不在意，为什么会引来那么多吃瓜群众呢？<strong>在“蛮夷论”中西方的各种思潮被比作“四书五经”，那么我们的“四书五经”呢，我们有载的三千年的历史教会了我们什么呢？</strong></p>
<blockquote>
<p><strong>如何评价中国的自由主义者？</strong></p>
<p>长期脱离不了逆民族阶段的一群废物。</p>
<p>自由主义想在中国真正登堂入室，必须是视美国为异端，极端反美的自由主义。</p>
<p>中国自近代以来，长期作为思想输入国是现实，入关前很难摆脱。逆民作为主要受众这一阶段时每种思想传播的必经阶段，这本来没什么，问题是你自由主义一百多年了还摆脱不了逆民阶段，那就只能说是扶不上墙的烂泥，不能怪别人了。</p>
</blockquote>
<p>我深以为然，民族主义者接受不了“西方中心论”，“嵩学”换个视角换个说法，告诉你的也是“西方中心论”，大多数人就能接受了。积贫积弱的年代，民众还能觉得“逆民话术”是良药苦口，现在的普通民众只觉得自由主义者那套“逆向民族主义”话术臭不可闻。所以说，很多“四书五经”从“天朝”而来，不是让你“空中楼阁”的，赶紧本土化才是正途。本朝西来的原教旨“马拉车”主义导致了什么？“马拉车”主义最后是因为什么纠正了错误，实现了摧枯拉朽的成功？不就是本土化吗？</p>
<p><strong>————————————入关！入关！入关！—————————————————</strong></p>
<p>紧接着“蛮夷论”的，顺其自然就是脱离蛮夷的方法了——入关</p>
<p>知乎对于“入关论”的批评远远多于“蛮夷论”。毕竟“蛮夷论”是对现状的总结，不管你讨不讨厌，你不能对现实视而不见。而“入关论”这种计划性的理论那就是谁都能说上一把的<strong>了。</strong></p>
<p><strong>一个有趣的现象是，知乎上有人说：“无论左中右，都有同意入关论的。同时，无论左中右，也都有反对入关论的。”</strong></p>
<p>举个例子，许多反对者将入关论类比为“昭和日本”“纳粹德国”的法西斯扩张理论，而反对他们的人则举出“美西战争”，“殖民战争”来反驳。</p>
<p>仅从上面的例子其实我们就可以分析出为何左中右无法划分复杂的政治诉求。</p>
<p>比如举出“法西斯”来反驳入关论的人。首先，假设他可能是个左派，他反对这种帝国主义行为，但显然反对法西斯的不止左派，那么显然你不能说反对法西斯就是某某派。然后就是，为什么反对法西斯呢？那就更是层层细分了，比如痛恨法西斯的反人类行为，有些人就举出“南京大屠杀”的例子，毕竟我们也是法西斯的受害者，比如看到了法西斯的悲惨下场，有人就举出“占领区”“两颗原子弹”“一亿玉碎”这样的例子。又比如有些人假设了别人的立场，认为维护西方立场的人，也不同意新法西斯，虽然他们并不管中国人死活。（当然我们也不能假设这种人不存在，毕竟我们大部分都翻墙看过）。</p>
<p>我洋洋洒洒的举例了几百字是想说明什么呢？我是想说，“<strong>无论左中右都同意或反对入关论。”这是个伪命题</strong>，有这种观点的人可能只是从只言片语中就认定了一个人的左中右，十年来，我混键政的最大体会就是不要透过一两句话就给一个人定性，富丽堂皇的好话谁都会说，一个把马克思的话当成签名的人其实可能是最拥护资本主义体制的人，一个看起来懦弱的反战者可能是最勇敢的战士，一个满口反战的人在对同胞举起屠刀时会毫不犹豫，一口一个自由和民主的人，追求的可能不是你的自由民主。</p>
<p>所以我认为所谓的“左中右”都同意或反对入关论并不存在，我甚至不认为在这件事上用左中右划分是科学的。</p>
<p><strong>我认为，一个人可以同时同意和反对入关论。</strong></p>
<p>比如我，我同意入关论，因为就我现在的知识、视野、思维深度以及立场来看，我认为中美在现如今的国际秩序下不能共存，我认为一直以牺牲中国人利益为代价的国际秩序不能接受。活用“蛮夷论”的表达就是“我不想在建州摸鱼给天朝上贡，天朝也容不得我建州女贞这么大一个边患。”同时我也不甚认同入关论，因为我认为，入关必然血雨腥风，难道要共和国和帝国主义同流合污？，我不认为入关是推翻美利坚天朝统治的唯一解，至少它不应该是第一选项。“我有祖宗之法，不愿兴刀兵扰黎民，然匪朝不灭，天怒人怨！”</p>
<p>入关论说到底只是一种推翻“大明”的方法，代表了山高县对于解决“蛮夷论”的一种处理问题的哲学体现。山高县作为普通民众，既没有资源充分了解入关的可行性，也没有提供可以说服大众的可靠论据，可以说既没有资格也没有能力。为什么必须是马六甲？为什么必须要肢解印度？肢解印度的成本和后果呢？这些实际操作层面的东西我都保留意见。<strong>只能说山高县给我们指了一条路，虽然方向我认同，但怎么走我要再观察。</strong></p>
<p>山高县是个复杂的人，说难听点，他前后矛盾，很可能其实真的只是玩一玩，是个说书先生。（当然就算是说书也不妨碍“嵩学”的严肃性，裸着生殖器洗澡就不能思考浮力定理了吗？山高县？他懂个锤子“嵩学”）</p>
<p>他曾说：<strong>“1：剿兵安民，彻底消灭与清算北美匪帮的金融铁骑及其走狗。2：闯王来了不纳粮，不利用国际贸易与结算体系为自己牟利。”</strong><a href="https://zhuanlan.zhihu.com/p/96784759#ref_4" target="_blank" rel="noopener">[4]</a>想要表达自己“为万民乞活”的国际主义思想，转脸又表示“<strong>总有一天，我们要让他们知道，在寒冬腊月里摸鱼是什么滋味！要让他们，偿还这一切！用他们的土地，他们的手！”</strong><a href="https://zhuanlan.zhihu.com/p/96784759#ref_5" target="_blank" rel="noopener">[5]</a>关于入关后的秩序是怎样的，他一边画饼说平等，一边又想复仇。</p>
<p>他曾说：“<strong>宁为一步甲，胜做挖参人</strong>”<a href="https://zhuanlan.zhihu.com/p/96784759#ref_6" target="_blank" rel="noopener">[6]</a>（曹大佐也有“苦战胜过强耕”的想法，他们真的有共同语言）又给下面的话点赞：<strong>“实现没有阶级之分的理想社会。”</strong><a href="https://zhuanlan.zhihu.com/p/96784759#ref_7" target="_blank" rel="noopener">[7]</a>到底打不打，什么时候打，他其实还没个准。</p>
<p>综上，入关论应该是开放性的话题，怎么入关，何时入关，入关前干啥，到底入哪个关，开航母入关还是开集装箱船入关都可以讨论。<strong>这里的入关论其实指：打破美利坚天朝的压迫体系。这样就能解释为何那么多人“感觉”不光自己的派系同意入关论，对立派系也同意入关论，因为支持打破美利坚天朝压迫体系的人不分左中右，当然反对的也不分左中右啦。</strong></p>
<p><strong>冲塔暴论金腰带，安分守己无尸骸</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/22/%E6%8A%80%E6%9C%AF%E5%80%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/22/%E6%8A%80%E6%9C%AF%E5%80%BA/" class="post-title-link" itemprop="url">技术债</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-22 19:27:22 / Modified: 20:28:12" itemprop="dateCreated datePublished" datetime="2020-01-22T19:27:22-05:00">2020-01-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1 引子"></a>1 引子</h2><p>曾几何，一人一键盘，指尖到天明。跳动的字符，砰然的心动，这不是初恋，但很甜。</p>
<p>终有一天，心动变心痛。</p>
<blockquote>
<p>从今天起，专注搬砖</p>
<p>什么需求，都能实现</p>
<p>复制粘贴，这很简单</p>
<p>一天不行，就两天</p>
<p>前后端到AI，不过是概念</p>
<p>总之，都能实现</p>
</blockquote>
<h2 id="2-技术债"><a href="#2-技术债" class="headerlink" title="2 技术债"></a>2 技术债</h2><p>“人一切的痛苦，本质上都是对自己无能的愤怒。”</p>
<p>我们既想保代码，又要保业务，当这两者产生冲突，且必须取其一时，就会痛。代码流产，业务发芽，说来侥幸。</p>
<p>离业务越近的代码，越痛。月月痛、周周痛、天天痛，流得稀里哗啦。从0到1的实现者们，着实是个幸运儿，闭目思索，便可忆起当年需求。嗯，这段IF-ELSE的故事我知道。</p>
<p>从1到N的接力选手，就不那么好命了。过尽千帆皆不是，手捧黑盒独懵逼。三下五除二，拨开乌云，三行代码，美其名曰的Feature来自于此。产品欢呼，喜悦中却难以颜开。</p>
<p>我们深知，下次的Feature将会付出更多代价。即使可以欺骗内心，手指还是很诚实，噼里啪啦敲打之下，除了Feature还有Hack。</p>
<p>令人悲伤的是，这种临时方案带来的债务，不会随着需求的满足而清零，反而会变本加厉，直至产品消亡。下一次的需求需要付出更高的代价，人力、时间、风险、效果，都在瑟瑟和我们招手。</p>
<p>资源限制导致技术复杂性提升，技术复杂性引发研发成本提升，这便是技术债。</p>
<blockquote>
<p>技术债：指开发人员为了加速软件开发，在应该采用最佳方案时进行了妥协，改用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担。</p>
<p>——沃德·坎宁安（1992）</p>
</blockquote>
<h2 id="3-还债"><a href="#3-还债" class="headerlink" title="3 还债"></a>3 还债</h2><p>没有人想背负债务，但现实情况是，我们都是债务加重的刽子手。</p>
<p>可以问自己两个问题：</p>
<ol>
<li>如果接手一份完美的代码，能否保证其继续完美下去？</li>
<li>如果接手一份烂代码，能否保证其不会更烂？</li>
</ol>
<p>能与不能我们无法定论，现实情况是，这很难。因为业务会拖着代码一起跑。</p>
<blockquote>
<p>业务逼着你跑，你不跑不行，可能跑着就累死了；你停下来歇会儿，搞搞技术改造，又可能被业务压力压死了，反正都是死 。</p>
<p>——蚂蚁金服 右军</p>
</blockquote>
<p>所以，结论是没有什么灵丹妙药。业务要跑，债务要还，老婆孩子都得保。</p>
<p>因此，一定程度的负债是正常的，保持还债是必须的。</p>
<p>能认识到这样点，再看还债，内心会好过一点。</p>
<ul>
<li>曾经内心OS：业务给这么点时间，还要求代码质量，咋可能，应付着来吧。</li>
<li>现在内心OS：业务要支持，代码要保证，能保一点质量算一点，少挖坑，多填坑。</li>
</ul>
<p>西去终有经，内心的坚定能与拧巴的日子抗衡多久？这样做，“小拧巴”可能会少点，但“大拧巴”仍有很多。</p>
<p>对于大拧巴，除了少挖坑，多填坑，更需要机遇：</p>
<ul>
<li>抱紧大需求</li>
<li>暴露大问题</li>
</ul>
<p>不要幻想有一天业务静止，给重构留有余地。机遇之下，顺势重写。</p>
<p>为什么要重写？因为这已经不是小拧巴了。对待大拧巴，重构会花费大量精力琢磨过去，而非思考未来。对待烂代码，不要留恋。</p>
<p>除了小大拧巴，还有一个超级大拧巴等着我们——架构。</p>
<blockquote>
<p>设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。</p>
<p>——康威定律（1967）</p>
</blockquote>
<p>架构的宿命早已写在康威定律里。架构是人的映射，有什么样的Team，就有什么样的架构。代码可以优化，结构可以改善，语言可以更迭，但架构不容易改变。</p>
<blockquote>
<p>曾有人笑言，如果有4个软件团队开发编译器， 那么结果很可能是编译器有4个部分，或者有4步完成编译。</p>
</blockquote>
<p>架构，已经不单单是一个技术问题了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/21/%E5%8B%83%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/21/%E5%8B%83%E5%AD%A6/" class="post-title-link" itemprop="url">勃学</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-21 17:36:01 / Modified: 18:47:21" itemprop="dateCreated datePublished" datetime="2020-01-21T17:36:01-05:00">2020-01-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="勃学是什么"><a href="#勃学是什么" class="headerlink" title="勃学是什么"></a>勃学是什么</h2><p>勃学是哲学的一个分支。</p>
<p>具体地说，勃学是一门武装失败人士头脑的精神工具。失败人士是社会的重要组成成分（占99.99%以上），也是成功人士除了互相倾轧以外，主要的收入来源。随着资本回报率超过劳动回报率，失败人士的范围必将不断扩大。</p>
<p>在中国，失败人士（三本，一百本学生等）往往缺乏思辨能力，缺乏独立思考能力，也缺乏必要的国际视野，很容易就被知乎大V的各大live和600块钱的课程骗走。在这个时代，成功人士已经联合起来“不要想如何教育傻子，而是赚傻子的钱”，成立一个与其对抗的组织迫在眉睫。勃学将能武装这其中一部分可教之材的头脑，帮助他们实现失败人士的大统一、大团结。</p>
<p>总之，勃学是失败人士行动和思考的纲领性文件。勃学的第一部分就是“失败学”，与社会盛行的“成功学”形成鲜明对照。“失败学”不是教你如何失败，而是一个关于人成为失败人士后，该如何思考、生存、解脱的学说。</p>
<h2 id="勃学三大定律（鸡汤）"><a href="#勃学三大定律（鸡汤）" class="headerlink" title="勃学三大定律（鸡汤）"></a>勃学三大定律（鸡汤）</h2><p>勃学，是一门21世纪失败人士的处世哲学，是曾老师在丰富的个人阅历和当前知乎文化下共同孕育出的结果。</p>
<p>勃学的第一定律是自杀，就是在精神上否定和批判自己。就算自己上了985，清北复交浙，top50的MS，CMU/MIT/Stanford/Berkeley的PhD，BAT/FLAG/USA/startup的码农，scientist，quant，油工，拿到了200k的package，从apartment搬进了小黑屋再买了4000sqft的学区房，从雅阁换了BMW328再换了911，发了顶会的paper，升到了senior/staff职位，永远要明白，在现实中有更成功的人和方向去努力——而不要晒并沉浸于在很多其他人看起来不值一提的成就；</p>
<p>勃学第二定律是“成功人士从不上知乎”，就是业余时间少上知乎，多看书，多写代码读paper，多讨论观点，工作和学习时间不要上知乎，更不要指望通过知乎来学习，应该对自己现实中的中长期事业及其规划负责，最终实现为社会创造价值——而不要追着社会热点赚热钱；</p>
<p>勃学第三定律，就是要开阔眼界同时摆好心态，时刻要学习那些和自己一步之遥的成功人士，不单单是把他们当作前进的动力，还要思考如何在现有条件下一步步去达成成功人士的成就，并且评估每一步的可行性，然后毫不犹豫地开始按照计划一步步地做下去——而不要好高骛远，追求不切实际的目标而陷入鸡汤式的“知乎成功学”和“学习论”，也不要看到不如自己的人而止步不前。</p>
<p>我相信勃学家们是知乎上现实生活中和知乎影响力差距最大的一批人，据统计98.12%的勃学爱好者都比我帅、比我学历高、比我有钱、比我女朋友还多，总之都比我成功，但是在知乎上都是一群消极的娱乐恐怖分子。希望你们看到本文后，把我作为一个标准的失败人士用来参考权衡，来激励你们乐观成长，不断进步，早日走向真成(zi)功(sha)。</p>
<h2 id="勃学不如剥削"><a href="#勃学不如剥削" class="headerlink" title="勃学不如剥削"></a>勃学不如剥削</h2><p>勃勃的认真无疑大大降低了他自己的格调。</p>
<p>一个手撕各路大V成功者的正义战士，一个将知乎视作战场的革命领袖，一个爆料各种成功者黑幕的深喉。居然用如此认真且不开心的语气揭露一个沽名钓誉的low逼，一方面让我不胜惶恐，另一方面让我扼腕叹息。</p>
<p>不胜惶恐在于：我这样的微不足道的沽名钓誉者，仅仅靠着蹭了几次热点就引起了勃勃的重视，和糖超轮子哥哥并列，何德何能？</p>
<p>扼腕叹息在于：想当年那个无论如何黑他，他都和蔼地微笑的曾博似乎不见了。他真的在勃丝的拥趸之下迷醉了，不再看得懂娱乐式的结构，反讽式的抨击。而把知乎的名当成了一个粪量十足的东西。</p>
<p>不过也好，这样看来，曾博终于有了成功者的姿态，大约离成功不远了。</p>
<p>所以，借用他当年的一句话表达我此刻的心情：我还是退出薄党算了。。。</p>
<p>退出薄党之前，我送勃勃几句话：在一个娱乐作为本质的网站，任何革命到最后都不过是过家家。物理的长答案固然没有人看，但弃物从文也依旧不能唤醒人。这个世界就是由绝大部分劣等人构成的，他们生来就是被奴役的对象，不是马克思主义，也不是勃学可以拯救的。这些人，不需要勃学，只需要被剥削，他们腐朽提供的养料，正是供给精英得以滋养壮大的源泉。这个世界就是用绝大部分劣等人的输血来供养少数精英的肆意纵横，在这个过程中，整个人类群体才能向前发展。那些劣等人，不可能被任何方式唤醒，勃学不过是迷幻药，剥削才是他们面对的现实。我敬畏他们，我觉得他们的死重于泰山，死得其所。同样，身为精英的每一个人，又会成为更高等生物链的一个劣等存在。既然勃勃认定自己不能成为川普，又为什么一定觉得勃丝们领悟勃学之后能够成为你呢？低等的精英，同样作为劣等人群，用自己被压榨的养分，供养更上层的精英，这不仅是责任，更是觉悟。而不务正业，企图打乱这秩序的，不仅遭受各方排挤，而且徒劳无功。</p>
<p>不过，倘若能唤醒万分之一的人，也是勃勃的功劳造化。一命二运三风死积阴德五读书。日后若上天有灵，在投胎上给予勃勃以眷顾，也不枉勃勃的一番苦心孤诣了。</p>
<h2 id="几个解释"><a href="#几个解释" class="headerlink" title="几个解释"></a>几个解释</h2><p>近日来，作为哲学的一个分支，在和伪成功人士作斗争并且取得一些实用理论（称【应用勃学】）可喜进展的同时，我们解决几个勃学基本问题的需求也日益高涨了。<br>从第一天起，勃学就是从群众中来，到群众中去的哲学，每个人都有自己的解读权，每个人都可以——在不改变主分支的情况下——添加释义、词条，以至消极和积极学派并存。它们二元相持，互相矛盾又相互发展：这是哲学的基本规律。一个只有一种解读的哲学，将会是死如止水的哲学。</p>
<p>勃学的特点是：<strong>人人具有参与权</strong></p>
<p>然而，在以立党，江汉臣等人的积极勃学（又称【伪勃学】或成功勃学，左派勃学）与严肃等人的存在主义勃学（又称【中间勃学】，修正主义勃学），以及徐国曦等人的失败勃学（又称【悲观勃学】，右派勃学）的迅速发展和争锋相对之中，许多悬而未决、让人动摇的问题暴露了出来，以至于乍听勃学的人会把勃学与政治波普，李毅贴吧现象，屌丝自嘲等混淆，做出合理的联系但缺乏明智的区分。这些问题的提出恰于时机，而且有的直指其哲学本质，一针见血。因此在我谨在此给出一些我自己所体会的粗浅的回答，还望指正。</p>
<p>勃学<strong>并不属于任何一个人</strong>，也不是因为任何和一个人而产生、兴起。勃学早就存在于世界，呼之欲出，只不过它一直等待着一群真正的失败者，反思社会与人性，将其精髓与自己的实际生活相结合，把精华哲思整理成册。我作为一个彻底失败的人，有机会把他的一些本质讲出来给大家分享，帮助大家与<strong>失败</strong>对话。</p>
<p>勃学有以下几个基本定理和原则：</p>
<ol>
<li><p><strong>“失败”</strong>作为一个客体存在于人类社会，是不以人的意志为转移的。你可以获得成功，但是失败的人依然存在；精英话术只不过选择性无视了他们。</p>
</li>
<li><p><strong>失败与成功具有两面性</strong>：对社会而言，失败必然存在，而且占据绝大多数，这是因为资源有限与人类社会制度设计的本质缺陷造成的。对个人而言，失败和成功是你的主观感受；你可以觉得自己很失败，但不妨碍别人觉得你成功；或者你可以觉得自己很成功，但不能阻止别人揭穿你的失败。因此，勃学的理论适用性和你是一本还是100本无关。不过，个人感受和社会现实要逐渐结合，不可以有太大脱节，这是一个不断自我认知调整的过程。勃学的基础是建立在社会失败理论之上的，然而他服务的对象则是个人。</p>
</li>
<li><p>勃学“破”的问题：勃学是武装失败人士头脑的精神武器。勃学应当帮助失败人士首先<strong>认清失败现实</strong>，其次是学会<strong>解构由成功人士精英等构造的精神幻境</strong>，最后<strong>达到自我解放的目的</strong>。精神幻境有很多个，成功学仅仅是其一。精神幻境的构造是成功人士、精英等为了继续巩固社会资源分配制度构建的。失败人士不应该无知地安于奴役，而应该找到自己的意义。这就好像一只被家养的猫，在无知地情况下，它每天安于主人的玩弄。而一旦觉醒，这只猫将不再是任人调戏的宠物。在商品社会下，商业宣传，营销就是精神幻境，而失败人士就是这只猫，被不同的金钱势力玩弄着，滋滋滋送钱，最后却一事无成。失败人士要认识到自己的处境，并且解构这个精神幻境，最后联合起来，证明自己的力量与做宠物以外的存在意义。</p>
</li>
<li><p>勃学“立”的问题：勃学也是一门付诸于行动的哲学，这与他的来源：来自于群众生活，来自于失败人士的困境是密不可分的。勃学的生命力在于解决实际问题。然而，关于勃学的行动存在消极，积极，中间三派。</p>
<p><strong>消极派</strong>主张，全球失败人士只有同步ZS，才能真正从物理、物质上解构了成功人士的统治，达到全球制度设计和资源分配的合理化，并且让成功人士认识到自己的力量。这一步又分为精神和物理ZS两种。具体的解释是，精神ZS是彻底断绝自己的商业欲望，再也不做商业势力的玩物，又可以叫出世。物理ZS是彻底断绝自己的物理基础，具体表现为绝育，绝种，投胎。同步ZS的理论具有很多可玩味之处，其中一点就是个人不可以脱离组织先行ZS。另外，同步ZS仪的研制，也面临很多挑战；鉴于失败人士的特点，这个ZS仪的研发，很可能会以失败告终。</p>
<p><strong>积极派</strong>主张，全球失败人士果断拒绝成为商业社会资本愚民统治下的奴役，在精神觉醒后自我救赎，通过自学，努力发奋，找到真正的导师（例如江汉臣所指出的），最后仍然获得世俗意义上的成功。然而积极派面临的一个急迫问题就是，如何区分成功人士和伪成功人士，从而避免自己变成自己奋而反抗的那个人呢？据我所知，这一理论问题尚未得到解决。并且，积极派容易被人误认为是精英话术、精神鸡汤、变相偶像崇拜。积极派虽然有一定的理论基础，但和勃学的根本起源：失败人士的距离有越走越远的趋势，不过却符合现世中，普通失败人士的基本诉求：过上更好的生活，自己也能开live。因此，积极派可以说是勃学实践理论里面的修正主义，又可以叫做入世。</p>
<p><strong>中间派</strong>主张，是结合了精神ZS和入世成功两派所走的中间路线。既保留了勃学来源于失败人士的内核，又吸取了成功的世俗意义。但这里，中间派主张的世俗又要比开live高明一点，回归到了传统的寻找自我，自我提高的“精神成功”的道路。这一派的主张者主要是严肃。</p>
<p>然而，勃学实践的原教旨主义，则是<strong>全球失败人士同步ZS</strong>。因为原教旨认为，只有把问题本身消灭了，问题才会被解决。否则，失败人士将会源源不绝，苦难与罪恶将永远不会被抹去。</p>
</li>
<li><p>勃学的根源和理论基础：</p>
<p>正如上文所说，勃学起源自人类社会与生俱来的失败客体，服务于无法摆脱自己失败客体的失败人士。失败的定义是主观的，但也要和社会资源分配取得对应。人类社会制度的构建存在缺陷，失败，则是其中的癌症。这主要是人类是单个体意识生物，无法真正做到群体同理和群体通感，因此私有制成为社会进步的基础，为了进步就必须追求个人回报，而为了极少数人的个人回报就必然产生他人的失败。现代社会收入差距的指数化发展很好地说明了这一点。</p>
<p>失败人士的觉醒、联合将会完成癌症的<strong>自我实现</strong>；而人类的进化可能则必须等到未来实现群体同理与通感实现之后，才能达到。当然，这一部分内容过于超前和脱离现实，现阶段，服务于成功的修正主义勃学将会大行其道。</p>
</li>
</ol>
<p>哲学是抽象的艺术，具体问题请具体分析。指望一门学说解决所有实际问题是不切实际的，但我希望他能打开你觉醒的天窗。因为不管你觉不觉醒，失败就在那里。谢谢大家。</p>
<h2 id="曾博归来：知乎“勃学”亚文化的模因与迷思"><a href="#曾博归来：知乎“勃学”亚文化的模因与迷思" class="headerlink" title="曾博归来：知乎“勃学”亚文化的模因与迷思"></a>曾博归来：知乎“勃学”亚文化的模因与迷思</h2><p>本文使用模因、迷思等传播学理论对知乎网的“勃学”现象进行了初步探究，对“勃学”的发展历程进行了追溯，并在回溯中发现其制造迷思的机制。最后本文提出了对“勃学”现象进行进一步研究的若干研究方向。</p>
<h3 id="一、“勃学”现象起源、发展和现状概述"><a href="#一、“勃学”现象起源、发展和现状概述" class="headerlink" title="一、“勃学”现象起源、发展和现状概述"></a>一、“勃学”现象起源、发展和现状概述</h3><h4 id="（一）勃学的含义、特征与核心"><a href="#（一）勃学的含义、特征与核心" class="headerlink" title="（一）勃学的含义、特征与核心"></a>（一）勃学的含义、特征与核心</h4><p>“勃学”指最大的中文网络问答社区知乎网中由用户@勃失败 （原ID：曾博）提出、由以@勃失败@立党@江汉臣@徐国曦@严肃 和匿名用户等为代表的知乎用户发展的一套理论体系，而这些知乎用户大多拥有高学历和世俗意义上的“成功”。信仰勃学的人自称“勃学家”“勃丝”，其中前者突出对勃学理论的认同，后者更强调对曾博本人的喜爱与崇敬。</p>
<p>根据曾博本人的解释，</p>
<blockquote>
<p>“勃学是哲学的一个分支，具体地说，<strong>勃学是一门武装失败人士头脑的精神工具</strong>。失败人士是社会的重要组成成分（占99.99%以上），也是成功人士除了互相倾轧以外，主要的收入来源……勃学是失败人士行动和思考的纲领性文件。勃学的第一部分就是“失败学”，与社会盛行的“成功学”形成鲜明对照。“失败学”不是教你如何失败，而是一个关于人成为失败人士后，该如何思考、生存、解脱的学说。”[1]</p>
</blockquote>
<p>“勃学”一词中，“勃”既指“勃学家”的精神领袖曾博，又指“勃”的状态——自我觉醒并对抗伪精英主义的状态。</p>
<p>勃学主要包含了失败学、自杀学、投胎学等，<strong>主张人应当自我觉醒并认识到自己的失败，要主动对抗伪精英主义，并讽刺了社会阶级的逐渐固化。</strong>在具体的网络生活中，勃学集中体现为对“失败”的自我解嘲、对成功学和名不副实的知乎大V的讽刺、对知乎Live收取智商税行为的鄙视。曾博的思想流行多年，却始终无法摆脱个人色彩；而其总结出的勃学于2016年11月开始走红，如今已经形成了一种亚文化，大有星火燎原之势。</p>
<p>“勃学”亚文化的核心是拥有一整套且正在不断发展的模因（Meme）体系。</p>
<p>Meme这个词最初源自英国著名科学家理查德·道金斯（Richard Dawkins）所著的《自私的基因》（The Selfish Gene）一书，其含义是指“在诸如语言、观念、信仰、行为方式等的传递过程中与基因在生物进化过程中所起的作用相类似的那个东西。” [2]模因类比于基因（Gene），是形成某种文化的基石，而模因也是在复制和变异中发展的。“勃学”的模因在勃学家群体中复制，并不断变异，最终形成了一套理论体系。</p>
<p>模因论认为，隐喻概念在形成的过程中，使用了模因的机制，即通过一个中心概念派生出相关隐喻。而通过控制模因的意义，能够达成某种目的。比如，美国总统卡特说“能源危机是一场战争”，并将这样的概念通过媒体传播，这一模因就将“能源危机”与“威胁国家安全”进行了挂钩，并且提出了若干解决方案[3]。</p>
<p>由模因论出发，我们认为勃学将“浙大”与“三本”挂钩，将“曾博”与“失败人士”，将“开Live”与“成功”挂钩，由于浙大是中国顶尖高校，曾博又是世俗意义上的成功人士，这<strong>种看似荒谬的挂钩却让勃学的理论体系有了例证，并极大增加了受众广度与传播力度。</strong></p>
<p>要想研究勃学，就必须了解曾博本人和勃学中“失败人士”的定义。</p>
<p>曾博是浙江大学竺可桢学院年级第一、加州大学伯克利分校凝聚态物理PhD、现Facebook Research Scientist，履历光鲜、工作高薪，是世俗意义上绝对的社会精英，但曾博在网络上的形象并非如此。曾博早期出名于人人网和cc98（浙大内网），而后来到知乎，在账号“曾博”被封禁前已经拥有40000+粉丝。在人人网时期曾博就因与新东方讲师论战一炮而红，来到知乎后更是因为“浙大三本论”和“勃式提问”名声大噪，但有许多人厌恶曾博，认为他是浙大的耻辱，以看他笑话为乐。曾博无疑是世俗意义上的成功者，在此我们定义一个“狭义勃学”，即曾博个人的勃学理论与事例，下面我们在狭义勃学的体系中来观察曾博。</p>
<p>曾博曾是省高考模考第一，物理竞赛省级一等奖，拥有保送清华的机会，但被老师劝说放弃保送而参加高考，最终“考败来浙”。对于曾博来说，这样的落差是无法接受的。在他的著名答案中，他说：</p>
<blockquote>
<p>“对于那些进入竺可桢学院就觉得自己其实没有亏的人，我只能这么说一句：眼光还是太短浅了。超级大牛不算。但我们都是平凡人。我个人认为，浙大拿专业第一的实际市场价值，不如清华大学的专业前15-10。我给你们的建议是：如果你是考败来浙，建议复读。只需要1年，可以弥补你日后3年，5年都无法弥补的遗憾。我没有复读，我没有看到更广阔的天空，我没有更多的人脉，我不能成为高晓松的校友，我不能和街上的大神们有说有笑，我是傻逼。”[4]</p>
</blockquote>
<p>而在“在浙大当学霸是什么体验？”这个问题中，曾博的回答言简意赅：</p>
<blockquote>
<p>“不值一提”[5]</p>
</blockquote>
<p>可以看出，曾博在浙大取得了辉煌的成就，但他并不以之为然，反而多次在网络发表“不利于”浙大的言论。曾博的心中对清华有一种执念，这种执念因高考失败转化成一种对浙大的怨念，这种现象源于期望与实际之间的偏差，即心理落差。在心理学上，心理落差是指原有的自我概念、自我意向、自我定位或自我预期在新的情境中的实际感知和心理体验（真实的或者假象的）差别较大而形成的自我失落感。对曾博而言，他虽然申到UCB的PhD，在实际感知上战胜了绝大部分清华毕业生，但他的心理体验始终处于自卑状态，由此产生一种对清华近乎痴狂的向往之情，<strong>他认识到他的人生永远都缺少清华这一环，“我没有看到更广阔的天空，我没有更多的人脉……”，他失败了：笔者认为，这就是勃学中“失败”一词的起源。</strong>曾博在这个过程中真切地认识了自己的失败，并将其推广使之能被大众代入、接受。</p>
<p>一开始，笔者以为勃学中的成功是绝对精英化的，即人生不能出一点差错，而只要在某一个环节失败（如没考上清华），就永远失败了。随着勃学不断发展，笔者逐渐明白了“失败”的真正含义。勃学中的失败，指的是人人皆失败，区别只在于自己是否发现自己的失败。曾博这样解释失败：</p>
<blockquote>
<p>“‘失败’作为一个客体存在于人类社会，是不以人的意志为转移的。你可以获得成功，但是失败的人依然存在；精英话术只不过选择性无视了他们。失败与成功具有两面性：对社会而言，失败必然存在，而且占据绝大多数，这是因为资源有限与人类社会制度设计的本质缺陷造成的。对个人而言，失败和成功是你的主观感受；你可以觉得自己很失败，但不妨碍别人觉得你成功；或者你可以觉得自己很成功，但不能阻止别人揭穿你的失败。”[6]</p>
</blockquote>
<p>事实上，世上不存在绝对成功的人，每个人都在某个方面是失败者，但我们常陶醉在虚无的成功中忘记了自己的失败。勃学号召解构伪成功人士构建的精神幻境，抵制成功学、鸡汤、不合格的知乎Live，做到自我觉醒，最终达到自我解放的目的。这里的自我解放并不是指放弃对名利财富的追求，而是指认清成功失败的本质，不羡慕成功也不因失败而自暴自弃。</p>
<p>知乎用户@古伦木与欧巴 这样评价“失败”：</p>
<blockquote>
<p>“这种失败是修正的，他的存在基础是自我预期与现实落差之间的关系，也是一种反kitsch反世俗的朋克精神，是脱离低级趣味的人，同时也是把自己抛入残酷斗兽场的决绝人士。“</p>
</blockquote>
<p>这样看来，勃学是具有积极意义的。</p>
<p>再在狭义勃学中观察曾博，我们得知，曾博渴望成功却因一次打击而认清了社会现实，而<strong>他本身又是一个厌恶虚假、热爱光明的人，他痛恨一切伪装精英的人与行为，痛心于群众的愚昧无知与幼稚，一直试图用自身行动唤醒人们。</strong>他以“勃失败”的ID回到知乎，就是为了促进人们的觉醒，而一个人的力量是远远不够的，这才有了勃学。</p>
<p>笔者认为，勃学具有三个主要特征：<strong>戏谑性、阶级性、去中心性</strong>。</p>
<p>戏谑性：勃学的戏谑性主要体现在两方面：<strong>曾博本人经历的戏剧性与勃学理论的讽刺风格。</strong>曾博的戏剧性无需赘述，在勃学大规模流行前，在大多数知乎用户眼中曾博一直是一个悲剧性却小丑般的人物，其本人的精英化真实经历和网上言论共同构成了符号化“曾博”的戏剧性。而勃学理论诞生伊始便充满讽刺意味，其领军人物常公开对抗知乎不良风气与部分大V的难看吃相，一系列黑话如“浙大三本”“同步自杀”“深夜在浅色床单下痛哭”行尽讽刺的同时，也令未曾接触过勃学的人不知所云。</p>
<p>阶级性：尽管勃学是“武装失败人士头脑的精神武器”，但能真正理解、发扬勃学的人一定是取得了世俗“成功”的人。一个未曾在世俗上成功的人，无法真正理解巨大的心理落差带来的痛苦与深入骨髓的失败感，而只能成为跟风的勃学家，在失败的泥潭中越陷越深。勃学的领军人物都学历较高且未来光明，他们可以在成功中认清自己的失败，以勃学作为精神武器引领前路；但真正的三本生看到“浙大三本”的言论，恐怕只会对曾博嗤之以鼻。理<strong>论上，勃学是有一个准入门槛的，这个门槛就是“世俗精英”与否，这也就是勃学所谓的阶级性。</strong></p>
<p>去中心性：<strong>勃学的特点是人人具有参与权。</strong>尽管曾博是勃学的提出者与精神领袖，但勃学的解释与发展更仰仗不同流派的勃学家。勃学是曾博提出的，但不是曾博发明的。如果没有勃学，也会有波学、拨学，</p>
<blockquote>
<p>“勃学并不属于任何一个人，也不是因为任何和一个人而产生、兴起。勃学早就存在于世界，呼之欲出，只不过它一直等待着一群真正的失败者，反思社会与人性，将其精髓与自己的实际生活相结合，把精华哲思整理成册。”[6]</p>
</blockquote>
<p>当然不可否认的是，尽管曾博本人不以勃学领袖自居，但曾博的确是勃学的精神领袖，他是事实上的勃学中心人物。勃学的去中心化还体现在勃学没有一份纲领性文件，尽管曾博本人的许多回答都“摘自《勃学导论》《勃人勃语》”，但这些文献从未出现。实际上，勃学家们对勃学的不断解读构成了勃学的所有理论体系，《勃学导论》极有可能像《论语》一样由众人合力完成。</p>
<p><strong>勃学的核心思想是“向死而生”</strong>，这也是勃失败的知乎头像。前面说过，勃学号召失败人士自我觉醒，而自我觉醒的方法即是“自杀”。需要注意的是，这里的自杀并非肉体上的自杀，而是精神上的自杀：杀死过去迷信成功学、对自己没有清醒认识的自己，才能做到向死而生，真正过好自己的生活。</p>
<p>勃学还是一种对社会阶级逐渐固化、上升通道日益狭窄的讽刺，同时突出强调智商天赋的重要作用。曾博小号“小勃勃”在回答中说：</p>
<blockquote>
<p>“差在智商……社会对一个人达到一定智力水平所花时间的要求，是很苛刻的。一个50岁的人哪怕IMO满分，也想必无人问津。因为人类是一个害怕时间的生物，你只有那么一次，就是在高中时代证明自己的天才；你没有，那说明你不是。这也是为什么高考这么重要的道理。说到底，高考为什么这么重要，是因为我们都会死。你在跑步中摔了一跤，社会却已经没空把你慢慢扶起。”[8]</p>
</blockquote>
<p>勃学认为没有高智商和天赋，就彻底失败；就算上清华，没有上层阶级的出身，也无法完全改变命运，亦是一种失败。两层失败形成了勃学的悲观色彩，形成了勃学中的投胎学。从这一角度讲，勃学具有很大的消极意义。</p>
<p>曾博本人是一个模因更是一个“迷思”（Myth），但这里的曾博是一个概念化的“曾博”，是被广大勃学家自我代入后的曾博。勃学不断被重新解释解读，曾博是勃学家的精神领袖，更是勃学理论源源不断产生的源泉。</p>
<h4 id="（二）、勃学的起源与发展历程"><a href="#（二）、勃学的起源与发展历程" class="headerlink" title="（二）、勃学的起源与发展历程"></a>（二）、勃学的起源与发展历程</h4><h5 id="1、勃学起源的探讨"><a href="#1、勃学起源的探讨" class="headerlink" title="1、勃学起源的探讨"></a>1、勃学起源的探讨</h5><p>“勃学”一词的产生时间已不可考，但知乎匿名用户在2016年7月的回答中已经有了“勃学”“勃学家”等词语，曾老师在Facebook是否是成功人士？ - 匿名用户的回答 - 知乎，而曾博本人在2017年1月4日的答案中的“摘自《勃学纲领》”实质上确定了勃学的成立。在2015年曾博某个回答的评论区中，曾博对于“勃”字还是抵触的，但如今曾博却直接使用“勃”作为ID，结合其个人简介“哲学”来看，其目的就是要宣扬勃学。</p>
<p><strong>勃学作为一套理论体系刚刚兴起，但狭义勃学早已流行。</strong>曾博在2013年1月进入知乎，早期致力于物理科普，但他发现群众是愚昧的不可救的，便开始“黑”浙大，试图以狭义勃学唤醒人们，结果自然是失败的，但这也为他积累了大量粉丝。那时曾博的思想已经有了一批拥趸，受限于知乎的政治正确，勃学家群体还不敢公开发声，对勃学的研究停留在暗处。2016年3月，曾博留下一句“成功人士从不上知乎”后，大号自杀被永久封禁，人们对曾博冷嘲热讽，狭义勃学太过个人化的缺点暴露无遗。在经历了一段沉寂期后，曾博此次归来是有准备的：他重新构建了勃学的体系，使勃学可以被广大失败人士认同并接受。</p>
<p><strong>如曾博所言，勃学早就存在于世界，呼之欲出，只等待失败人士的觉醒。知乎的土壤提供了勃学发展的必要条件，而曾博的个人魅力更是促成勃学的重要因素。</strong></p>
<p>知乎是最大的中文网络知识问答平台，早期走精英化路线，开放注册后大量用户涌入，社区平均质量下降已成为不争的事实。在知乎中，大V主要是两类人：行业领袖与营销专家。行业领袖在自己专长的领域持续输出干货，这部分大V是勃学家所认同的；而营销专家善于借助热点话题为自己涨粉，通过各种手段变现，其中不乏吃相难看者，这部分大V是勃学所要批判的。曾博早期致力于物理科普，却发现群众无可救药，物理科普毫无用处；有真才实学的用户无出头之日，营销高手却轻松骗赞吸粉，收割粉丝的智商税，这种劣币驱逐良币的环境，激发了曾博的反抗冲动。知乎2016年上线的Live功能，更是勃学的主要批判对象：许多大V不负责任对待Live，反而将其视为轻松赚钱的方式，这些开Live“骗钱”的大V成为了勃学中的“成功人士”——<strong>这里的成功人士，要理解为广大失败人士的对立面</strong>：他们也许在世俗意义上没有失败人士成功，但他们选择站在失败人士的对立面上，收取失败人士的智商税，因此他们是勃学所要批判的对象。同时，成功一词更是对他们贩卖成功学的讽刺。</p>
<p>曾博的个人魅力，更是勃学形成的重要因素。曾博本身的精英化属性与其网络上的亲民姿态，共同构成一个传奇般的人物形象；狭义勃学中的许多理论虽然“话说得难听”，但却毫不留情地揭示了社会现实，同时对抗权威（知乎官方与大V），可以称曾博为一个鲁迅般的悲壮的反抗者；曾博虽然常黑浙大，常黑知乎，但早期他便为浙大成为世界一流大学建言献策，目前的所做所为也是一股让知乎回好的动力，他厌恶虚伪热爱光明，是希望一切向好的；加之曾博时常输出妙语，一方面巩固了其勃学精神领袖的地位，另一方面又为勃学亚文化的形成助力，影响力甚至远远超出知乎。</p>
<h5 id="2、勃学迷思的发展"><a href="#2、勃学迷思的发展" class="headerlink" title="2、勃学迷思的发展"></a>2、勃学迷思的发展</h5><p>勃学文化的发展既离不开勃学家群体的宣传，也倚仗其本身强大的生命力与进化性。勃学的黑话不断增加，同时已有的黑话也在不断被重新解释解读中促进了勃学理论的发展。</p>
<p>勃学的黑话及其含义如下：</p>
<ol>
<li><p><strong>浙大三本论</strong>：“浙大是三本”是一切勃学理论的源泉。浙大是大陆顶尖高校，和三本存在巨大距离，但曾博将三本与浙大牢牢挂钩，一方面批判了TOP2和其他学校的巨大差距，另一方面戏谑地咬定自己的失败。由此衍生出的词语还有四本、五本、一百本等，用来表示不如浙大的学校。在勃学发展前期，一度有清华是一本北大是二本之类的定义，这也源于曾博对清华的疯狂向往；随着勃学理论的发展，勃学认为“我”在哪个学校，哪个学校就是三本，只因“我”是失败的。至此，“三本”已经脱离了其本身定义，成为了勃学家自黑与勃学传播的重要素材。</p>
</li>
<li><p><strong>自杀（ZS）、向死而生</strong>：在勃学早期，曾博提出要研究全球失败人士同步自杀仪，实现失败人士大团圆大解放，但同步自杀是永远无法实现的。一方面，世上存在数量巨大的失败人士，这其中只有极少一部分人能够接受勃学的洗礼，其余的群众依然无可救药，他们迷信成功学迷信知乎Live，执着于给成功人士滋滋滋送钱；另一方面，觉醒者的自杀并不能真正解决问题，非但不能唤醒群众，反而会导致勃学失去领军人物。因此笔者认为，自杀真正的含义是寻求勃学理论的终极形态，是一种出世的哲学，是在精神上与过去的自己诀别，从而摆脱世俗的困扰，过好自己的一生，即向死而生。从这个角度来看，勃学实质上是一门精英主义哲学。</p>
</li>
<li><p><strong>成功人士从不上知乎</strong>：早期曾博对于成功人士的定义区别于现在，这句话的原始含义是真正的精英不需要在网络寻求存在感，而曾博本人却是知乎大V，因此曾博是失败人士。勃学发展至今，“成功人士”不再指代社会精英，这句话更多用来调侃知乎大V。</p>
</li>
<li><p><strong>滋滋滋送钱</strong>：语出勃失败的回答：</p>
<blockquote>
<p>“这个社会动荡和痛苦的来源，就是普通的失败人士不承认不接受自己的失败，还一定要去学什么成功学，给自己制造一种正能量充满希望的虚幻。试问，这除了给成功人士滋滋滋送钱以外还有什么任何的好处？成功是成功者自己的修行。你不愿意修行那就接受失败，再怎么也不能滋滋滋送钱啊你说不是？”[7]</p>
</blockquote>
<p>与之相应的，还有“刷刷刷掏钱”。这两个短语运用叠词生动描写了失败人士被成功人士欺骗掏钱的场景，是用来讽刺贩卖成功学的人的重要素材。</p>
</li>
<li><p><strong>深夜在浅色床单痛哭</strong>：语出小勃勃的回答：</p>
<blockquote>
<p>“高考只是生活中无数战场中的一个。在这每一次战役中，普通人靠运气，天才靠实力。其实这个问题翻译过来，就是：如果我既没有天分也没有运气，那我应该在世界上如何活下去？单凭努力么。这个问题我相信很多人仔细想想，会在深夜的浅色床单下痛哭。你问我怎么知道？因为我每天都在哭。”[8]</p>
</blockquote>
<p>这句话是对失败的自我解嘲自我反省，更赋予勃学极强的悲剧色彩。为什么选择深夜的浅色床单？笔者认为曾博并非随口说出。深夜暗指黑暗的社会现实与自己低下的智商与天赋，浅色则指尚未认清失败的内心。两者形成对比，又朗朗上口，成为了勃学的重要黑话。</p>
</li>
</ol>
<p><strong>勃学文化随时间逐渐构建，黑话数量增加，在句式内容上具有高度传播性。而勃学文化的扩张过程中内部出现分化，模因也不断被复制被重新解读，并由此形成不同的勃学流派。</strong></p>
<h4 id="（三）、勃学亚文化的现状与当下勃学研究综述"><a href="#（三）、勃学亚文化的现状与当下勃学研究综述" class="headerlink" title="（三）、勃学亚文化的现状与当下勃学研究综述"></a>（三）、勃学亚文化的现状与当下勃学研究综述</h4><p>在知乎，曾博（知乎用户）话题有5000人关注，勃失败本人也有16000关注，加上曾博大号现在的50000+关注，初步估计勃学的核心受众约<strong>30000</strong>人。而几个关于勃学的问题有60W+的浏览，初步估计勃学传播范围达<strong>50W</strong>人级别。根据笔者在贴吧的随机发问，大约一半的回帖者知道勃学或知道曾博。知乎用户“江汉臣”利用爬虫和数据分析技术首次描绘了勃学发展程度与勃学家群体画像。</p>
<p>根据江汉臣总结的数据，勃学在2017年初迎来井喷，这段时期曾博对抗以轮子哥为首的知乎大V，获取了极高的知名度。</p>
<p>而勃学相关问题的提问者、回答者、评论者、得赞的基尼系数都表示，勃学始终由少部分核心勃学家领衔发展，大部分勃学家处于吃瓜看戏状态。勃学家是一个联系紧密的群体，勃学家的主要活动平台是知乎，在QQ、微信中亦有勃学研究群存在。根据笔者观察推测，勃学家主要有如下特征：</p>
<ol>
<li>男性为主，勃学家领军人物皆为男性，勃学相关问题回答者也主要是男性。</li>
<li>学历较高，但本科集中在浙江大学及以下档次的国内985高校中，清华大学、北京大学两所院校勃学家较少。（根据@江汉臣指正 ，勃学知识贡献者中清华同学最多，其次是上海交大和浙大）</li>
<li>具有正义感，勇于对抗黑暗。</li>
<li>知乎重度用户。</li>
</ol>
<p><strong>原教旨主义勃学指全球失败人士同步自杀</strong>，但前文已阐述这种行为不可能实现的原因。勃学在发展过程中不断分化与修正，最终形成了三派：<strong>积极勃学、中间勃学与悲观勃学</strong>，分别对应行动的积极派、中间派、消极派。积极勃学主张失败人士抗拒成功人士的剥削，实现自我觉醒，是一种偏于精英主义的哲学；悲观勃学主张失败人士只有自杀才能真正从物质上解构成功人士的统治；而中间勃学则融合积极勃学与悲观勃学的思想，既保留了勃学来源于失败人士的内核，又吸取了成功的世俗意义。<strong>根据勃失败所言，现阶段，服务于成功的修正主义勃学将大行其道。</strong></p>
<p>目前网络上对于勃学的研究较少，大多数言论还是基于某具体事件对勃学进行重新解释，较有影响的回答和文章有《几个解释》《勃学是什么？——勃失败的回答》《勃学与屌丝文化有何异同？——古伦木与欧巴的回答》等。这些回答和文章或由曾博本人发出指导性文字，或由广大勃学家主动重新阐释勃学，因其派别不同而理论略有出入，但正因为勃学是去中心化的，勃学才能够在极短时间取得巨大发展。</p>
<p>本文将在以上研究的基础上，用符号学的视野讨论勃学的迷思是如何形成的，并试论了“勃学家”的群体结构，在文末提出了进一步研究的几个主要问题。</p>
<h3 id="二、勃学的迷思：一种哲学形成的方法、内涵及动机"><a href="#二、勃学的迷思：一种哲学形成的方法、内涵及动机" class="headerlink" title="二、勃学的迷思：一种哲学形成的方法、内涵及动机"></a>二、勃学的迷思：一种哲学形成的方法、内涵及动机</h3><h4 id="（一）勃学的迷思体现了失败人士的共同意识"><a href="#（一）勃学的迷思体现了失败人士的共同意识" class="headerlink" title="（一）勃学的迷思体现了失败人士的共同意识"></a>（一）勃学的迷思体现了失败人士的共同意识</h4><p>本文开头提到了勃学中的多种迷思，其中最主要的“失败人士”的迷思是曾博。在勃学家群体的诠释下，曾博突破了其本身含义，有了更深层次的内涵。基于形象和性格的联想，勃学家将曾博“失败人士”的形象进一步概念化，这也是曾博成为勃学精神领袖的原因。</p>
<p>皮尔士（Peirce）提出了三元的动态的符号结构，即突破了索绪尔（Saussure）所指与能指的二元静态结构，他提出由符号形体（Representment），符号解释（Interpretant）和符号对象（Object）构成的三元动态结构，即无限符号过程理论（Unlimited Semiosis）。</p>
<p>勃学迷思发展的过程就是无限符号的过程，在过程中“失败人士”“三本”等词语的内涵逐渐丰富且开始分化。</p>
<p>在“失败人士”“成功人士”等词语中，也存在这样的迷思分化现象，其中既包含勃学家与非勃学家之间迷思的分化，也包含勃学不同流派的迷思分化。在迷思分化之外，迷思还会进一步发展，如将“浙大三本论”推广到“清华三本论”“人人三本论”，将“自杀”推广到“向死而生”等，<strong>这时的曾博已经成为了一种概念符号，他不再是他本身，而是一切勃学迷思的源泉。</strong></p>
<p>曾博本人的言行成为了勃学家广泛学习的素材，最终形成了去中心化又带有个人崇拜色彩的勃学。勃学能够得到拥护的原因还在于曾博的个人经历极具代表性，使勃学家能够轻松自我代入，借助勃学迷思来表达自己的想法。勃学家多具有较强的自我意识，认可精英主义与本科出身论，对社会流行的成功学持否定态度，主张通过自身努力奋斗获得世俗意义的成功。勃学的爆发，与勃学家对社会现状的不满有很大关系；勃学的出现，促成了一批失败人士的自我觉醒，体现了失败人士的共同意志。</p>
<p>同时，勃学家群体表现出较强的行动力。他们公开批评知乎大V，建立多个勃学研究群，并积极发展勃学理论。有人指出勃学文化与屌丝文化相似，但笔者认为屌丝文化兴起于用户平权的贴吧，而勃学兴起于大V集中制的知乎，两者属性不同，群体也不重合，且屌丝文化对现实关心较少，勃学则致力于真正解构成功学，两者区别较大。</p>
<p>勃学还具有政治不正确性。曾博大号时期就常因无情批判而被讽刺为政治不正确，其七个小号连续遭到封禁，勃学讽刺部分知乎大V、知乎Live也“断了知乎的财路”。知乎进入变现时期，步伐较大而管理水平下降，知乎官方对曾博一直持打压态度。勃学所反对的，正是知乎赚钱的主要来源，但至今勃学还未遭到大规模打压，其中原因不得而知。但只要勃学还在知乎的平台上发展，就有被打压的风险，这一点是勃学家群体需要注意的。</p>
<h4 id="（二）勃学符号权力是怎么构成的"><a href="#（二）勃学符号权力是怎么构成的" class="headerlink" title="（二）勃学符号权力是怎么构成的"></a>（二）勃学符号权力是怎么构成的</h4><p>符号权利学派分析路径认为，符号集体建构了现实观并将其投射在符号上，符号建构和反射一种现实观，成为主流意识。</p>
<p>在勃学文化构建中，存在两种权力集团，一种是主动勃学家，另一种是被动勃学家和潜在勃学家。勃学领军人物及主动进行思考的是主动勃学家，他们是勃学理论发展的主力军；而大部分人是勃学受众，他们或积极吸收勃学，或对勃学持观望态度，甚至将勃学视作消遣，这些人是另一个权力集团。</p>
<p>如图所示，群体意识形成之前，被动勃学家就创新和选择性接受构成了勃学观念。</p>
<p>接下来我们讨论勃学家的群体结构。</p>
<h4 id="（三）、勃学家的群体结构及群体动力学思考"><a href="#（三）、勃学家的群体结构及群体动力学思考" class="headerlink" title="（三）、勃学家的群体结构及群体动力学思考"></a>（三）、勃学家的群体结构及群体动力学思考</h4><p>前文说到，勃学家集中在知乎上，且联系紧密。同时，核心勃学家互有私交，在知乎之外有更多层面的交流。在勃学家群体中，主动勃学家热衷于挖掘模因发展模因并对勃学理论不断再解释，被动勃学家则单纯吸收甚至玩梗。目前知乎官方并未对勃学进行打压，因此主勃学家能够通过自身影响力向粉丝宣传勃学，这些人是勃学共同的领袖。但主动勃学家中也存在矛盾，如@钟晓迪 退出等事件。</p>
<p>主动勃学家话语权有限，还有一些摇摆勃学家，如@白如冰 、@动机在杭州 、@赵劼 等，他们并不输出自己的观念，但较多为勃学相关回答及文章点赞、评论，这些人都是 10W+粉的知乎大V，在知乎拥有较大话语权，他们也为勃学的传播发扬贡献了力量。</p>
<p>勃学家群体的凝聚力在于勃学所传递的价值观本身的正义性和勃学家群体对这种价值观的认可，以及对勃学家精英身份的认同。前面说过，勃学具有阶级性，主动勃学家一般有准入门槛，这个门槛是世俗的精英主义，但正是这些世俗的精英能够体会勃学的内在含义并将其发扬光大。</p>
<p>勃学还创造了一个高语境环境，勃学家之间存在高度默契，能够通过高语境环境交流，这也能提高勃学家群体的相互认同。虽然勃学分为不同流派，但不同流派的勃学家能够在核心问题上取得一致，使勃学始终多元化发展。</p>
<h4 id="（四）、勃学文化的未来与进一步研究方向"><a href="#（四）、勃学文化的未来与进一步研究方向" class="headerlink" title="（四）、勃学文化的未来与进一步研究方向"></a>（四）、勃学文化的未来与进一步研究方向</h4><p>曾博说勃学是一门哲学，但无可争议的是勃学已经成为了知乎上的一种文化，并极有可能进一步传播形成下一个“屌丝文化”。屌丝文化以李毅大帝为源泉，勃学文化以曾博为源泉，一门哲学能够形成文化与其精神领袖丰富的经历是分不开的。</p>
<p>勃失败的个人介绍这样写道：“从不在各大社交网站中吸粉、倒卖咨询，骗三本学生的钱”。我们可以说，曾博此次带来勃学，可以将他看做一个鲁迅般的人物——教物理救不了中国人，只有从源头打碎成功学，从根本上认识自己，才能让中国人得到解放。知乎用户“一方通行”这样评价曾博：</p>
<blockquote>
<p>“初看曾博以为是一个现实主义者。再看曾博以为是一个假装自己是现实主义者的理想主义者。最后细看曾博，才发现是一个假装假装自己是现实主义的现实主义者。”[10]</p>
</blockquote>
<p>从这个角度来看，曾博无疑是伟大的。</p>
<p>勃学文化的未来尚不明朗，但其生命力远不会消减。如果知乎将来对勃学进行打压，勃学家也会以源源不断的生命力继续进行失败人士同步自杀事业；越来越多的勃学家的加入，也让勃学有了勃勃生机。相信随着勃学文化的发展，会有更多的模因被催生。</p>
<p>勃学文化在永久的将来是悲观的——前文分析过，全球失败人士同步自杀永远无法实现，但勃学的积极意义无可置疑，其消极意义亦需要全体勃学家的规避。勃学最大的危险在于没有方法论，这对于一门哲学是致命的，因此方法论的产生迫在眉睫。</p>
<p>未来的勃学研究方向主要包括细分勃学的理论及方法论研究、勃学的科学哲学体系研究、勃学与知乎的关系等，这都是要交给未来的主动勃学家做的事情。总的来说，这些研究将提供给后人更有价值的勃学参考资料，能够进一步促进勃学发展，建立真正属于失败人士的一门学说。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/The-Magpie-Developer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/The-Magpie-Developer/" class="post-title-link" itemprop="url">The_Magpie_Developer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 23:58:28" itemprop="dateCreated datePublished" datetime="2020-01-20T23:58:28-05:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-21 00:59:01" itemprop="dateModified" datetime="2020-01-21T00:59:01-05:00">2020-01-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>I’ve often thought that software developers were akin to <a href="http://en.wikipedia.org/wiki/Magpie" target="_blank" rel="noopener">Magpies</a>, birds notorious for stealing shiny items to decorate their complex nests. Like Magpies, software developers are unusually smart and curious creatures, almost by definition. But <strong>we are too easily distracted by shiny new toys and playthings</strong>.</p>
<p>I no longer find Scott Hanselman’s <a href="http://www.hanselman.com/blog/ScottHanselmans2007UltimateDeveloperAndPowerUsersToolListForWindows.aspx" target="_blank" rel="noopener">Ultimate Developer Tool list</a> inspiring. Instead, it’s fatiguing. The pace of change in the world of software <a href="http://www.codinghorror.com/blog/archives/000545.html" target="_blank" rel="noopener">is relentless</a>. We’re so inundated with the Shiny and the New that the very concepts themselves start to disintegrate, the words repeated over and over and over until they devolve into a meaningless stream of vowels and consonants. “Shiny” and “new” become mundane, even commonplace. It’s no longer unique for something to be new, no longer interesting when something is shiny. Eventually, <strong>you grow weary of the endless procession of shiny new things</strong>.</p>
<p>I’m not alone. Jeremy Zawodny also notes <a href="http://jeremy.zawodny.com/blog/archives/009248.html" target="_blank" rel="noopener">the diminishing luster of shiny new things</a>:</p>
<blockquote>
<p>Over a year ago I unsubscribed from <a href="http://www.micropersuasion.com/" target="_blank" rel="noopener">Steve’s blog</a> because he had a habit of writing in breathless fashion about the latest shiny new thing – often several times a day. I see too many people I know getting caught up in the breathless hype and <strong>forgetting to think about whether the latest shiny new thing really matters in the grand scheme of things</strong>.</p>
</blockquote>
<p>Dave Slusher <a href="http://www.evilgeniuschronicles.org/wordpress/2007/07/17/why-i-dropped-scoble-and-seceded-from-the-hunt-for-newer-shinier-things/" target="_blank" rel="noopener">concurs</a>:</p>
<blockquote>
<p>[Robert Scoble] says that he gets too much email and that is ineffective for getting PR releases to him. He suggests that what you should do now is leave him a message on his Facebook wall. Dear god and/or Bob. In the time I’ve followed Scoble, I must have seen something like this a dozen times from him. Don’t email, Twitter me. Don’t Twitter, Pwnce. Jaiku me. Leave a wall message, send an SMS, just call me, email me, don’t email me, don’t call me. Enough already! I’m not even trying to get in contact with him, and I find this constant migration from platform to platform to be a load of shit that just wearies me. I felt the same way when I dropped TechCrunch, well over a year ago. I got so tired of hearing about another slightly different way of doing what we were already doing and why that tiny difference was worth dropping everything and moving over. <strong>I officially renounce the search for the newer and shinier.</strong></p>
</blockquote>
<p>It isn’t just the neverending stream of tech news. It’s also the tidal push and pull of a <a href="http://www.codinghorror.com/blog/archives/000247.html" target="_blank" rel="noopener">thousand software religious wars</a> that continually wears us down, like errant rocks in a rapidly flowing stream. I bet <a href="http://www.megginson.com/blogs/quoderat/2006/03/06/programming-languages-of-distinction/" target="_blank" rel="noopener">the process David Megginson outlines</a> sounds awfully familiar:</p>
<blockquote>
<p>\1. Elite (guru) developers notice too many riff-raff using their current programming language, and start looking for something that will distinguish them better from their mediocre colleagues.</p>
<p>\2. Elite developers take their shopping list of current annoyances and look for a new, little-known language that apparently has fewer of them.</p>
<p>\3. Elite developers start to drive the development of the new language, contributing code, writing libraries, etc., then evangelize the new language. Sub-elite (senior) developers follow the elite developers to the new language, creating a market for books, training, etc., and also accelerating the development and testing of the language.</p>
<p>\4. Sub-elite developers, who have huge influence (elite developers tend to work in isolation on research projects rather than on production development teams), begin pushing for the new language in the workplace.</p>
<p>\5. The huge mass of regular developers realize that they have to start buying books and taking courses to learn a new language.</p>
<p>\6. Elite developers notice too many riff-raff using their current programming language, and start looking for something that will distinguish them better from their mediocre colleagues.</p>
</blockquote>
<p>I hope you’re sitting down, because I’ve got some bad news for you. That Ruby on Rails thing you were so interested in? That’s <a href="http://zedshaw.com/rants/rails_is_a_ghetto.html" target="_blank" rel="noopener">so last year</a>. We’ve <a href="http://stuffthathappens.com/blog/2008/01/02/scala-will-do/" target="_blank" rel="noopener">moved on</a>.</p>
<p>If you consider that, statistically, the vast majority of programmers have yet to experience a dynamic language of <em>any</em> kind – much less Ruby – the absurdity here is sublime. Some dynamic language features are trickling down to the bastions of Java and .NET, but slowly, and with varying levels of success. These so-called thought leaders have left a virtual ghost town before <a href="http://www.codinghorror.com/blog/archives/000686.html" target="_blank" rel="noopener">anyone else had a chance to arrive</a>.</p>
<p>I became a programmer because I love computers, and to love computers, <a href="http://www.codinghorror.com/blog/archives/000761.html" target="_blank" rel="noopener">you must love change</a>. And I do. But I think <strong>the magpie developer sometimes loves change to the detriment of his own craft</strong>. Andy Hunt and Dave Thomas, the <a href="http://www.codinghorror.com/blog/archives/000052.html" target="_blank" rel="noopener">Pragmatic Programmers</a> who were a big part of the last sea change in Ruby, said it quite well in <a href="http://media.pragprog.com/articles/sep_04_imaginate.pdf" target="_blank" rel="noopener">a 2004 IEEE column</a> (pdf).</p>
<blockquote>
<p>Users don’t care whether you use J2EE, Cobol, or a pair of magic rocks. They want their credit card authorization to process correctly and their inventory reports to print. You help them discover what they really need and jointly imagine a system.</p>
<p>Instead of getting carried away with the difficult race up the cutting edge of the latest technology, Pete concentrated on building a system [in COBOL] that works for him and his clients. It’s simple, perhaps almost primitive by our lofty standards. But it’s easy to use, easy to understand, and fast to deploy. Pete’s framework uses a mixture of technologies: some modeling, some code generation, some reusable components, and so on. He applies the fundamental pragmatic principle and uses what works, not what’s merely new or fashionable.</p>
<p><strong>We fail (as an industry) when we try to come up with the all-singing, all-dancing applications framework to end all applications frameworks.</strong> Maybe that’s because there is no grand, unified theory waiting to emerge. One of the hallmarks of postmodernism – which some think is a distinguishing feature of our times – is that there’s no “grand narrative,” no overarching story to guide us. Instead, there are lots of little stories.</p>
</blockquote>
<p><a href="http://www.codinghorror.com/blog/archives/000575.html" target="_blank" rel="noopener">Don’t feel inadequate</a> if you aren’t lining your nest with the shiniest, newest things possible. <strong>Who cares what technology you use</strong>, as long as it <em>works</em>, and both you and your users are happy with it?</p>
<p>That’s the beauty of new things: there’s always a new one coming along. Don’t let the pursuit of new, shiny things accidentally become your goal. Avoid becoming a magpie developer. Be selective in your pursuit of the shiny and new, and you may find yourself a better developer for it.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/19/teach-yourself-programming-in-10-years/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/19/teach-yourself-programming-in-10-years/" class="post-title-link" itemprop="url">Teach Yourself Programming in 10 years</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-19 18:57:49" itemprop="dateCreated datePublished" datetime="2020-01-19T18:57:49-05:00">2020-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-20 01:43:58" itemprop="dateModified" datetime="2020-01-20T01:43:58-05:00">2020-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Why-is-everyone-in-such-a-rush"><a href="#Why-is-everyone-in-such-a-rush" class="headerlink" title="Why is everyone in such a rush?"></a>Why is everyone in such a rush?</h2><p>Walk into any bookstore, and you’ll see how to <em>Teach Yourself Java in 24 Hours</em> alongside endless variations offering to teach C, SQL, Ruby, Algorithms, and so on in a few days or hours. The Amazon advanced search for [<a href="http://www.amazon.com/gp/search/ref=sr_adv_b/?search-alias=stripbooks&unfiltered=1&field-keywords=&field-author=&field-title=teach+yourself+hours&field-isbn=&field-publisher=&node=&field-p_n_condition-type=&field-feature_browse-bin=&field-subject=&field-language=&field-dateop=After&field-datemod=&field-dateyear=2000&sort=relevanceexprank&Adv-Srch-Books-Submit.x=16&Adv-Srch-Books-Submit.y=5" target="_blank" rel="noopener">title: teach, yourself, hours, since: 2000</a> and found 512 such books. Of the top ten, nine are programming books (the other is about bookkeeping). Similar results come from replacing “teach yourself” with “learn” or “hours” with “days.”</p>
<p>The conclusion is that either people are in a big rush to learn about programming, or that programming is somehow fabulously easier to learn than anything else. Felleisen <em>et al.</em> give a nod to this trend in their book <em><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html" target="_blank" rel="noopener">How to Design Programs</a></em>, when they say “Bad programming is easy. <em>Idiots</em> can learn it in <em>21 days</em>, even if they are <em>dummies</em>.” The Abtruse Goose comic also had <a href="http://abstrusegoose.com/249" target="_blank" rel="noopener">their take</a>.</p>
<p>Let’s analyze what a title like <em><a href="http://www.amazon.com/Sams-Teach-Yourself-Hours-5th/dp/0672333317/ref=sr_1_6?s=books&ie=UTF8&qid=1412708443&sr=1-6&keywords=learn+c%2B%2B+days" target="_blank" rel="noopener">Teach Yourself C++ in 24 Hours</a></em> could mean:</p>
<ul>
<li>Teach Yourself:</li>
</ul>
<p>  In 24 hours you won’t have time to write several significant programs, and learn from your successes and failures with them. You won’t have time to work with an experienced programmer and understand what it is like to live in a C++ environment. In short, you won’t have time to learn much. So the book can only be talking about a superficial familiarity, not a deep understanding. As Alexander Pope said, a little learning is a dangerous thing.</p>
<ul>
<li>C++:</li>
</ul>
<p>  In 24 hours you might be able to learn some of the syntax of C++ (if you already know another language), but you couldn’t learn much about how to use the language. In short, if you were, say, a Basic programmer, you could learn to write programs in the style of Basic using C++ syntax, but you couldn’t learn what C++ is actually good (and bad) for. So what’s the point?</p>
<p>  Alan Perlis</p>
<p>  once said: “A language that doesn’t affect the way you think about programming, is not worth knowing”. One possible point is that you have to learn a tiny bit of C++ (or more likely, something like JavaScript or Processing) because you need to interface with an existing tool to accomplish a specific task. But then you’re not learning how to program; you’re learning to accomplish that task.</p>
<ul>
<li><strong>in 24 Hours:</strong> Unfortunately, this is not enough, as the next section shows.</li>
</ul>
<h2 id="Teach-Yourself-Programming-in-Ten-Years"><a href="#Teach-Yourself-Programming-in-Ten-Years" class="headerlink" title="Teach Yourself Programming in Ten Years"></a>Teach Yourself Programming in Ten Years</h2><p>Researchers (<a href="http://www.amazon.com/exec/obidos/ASIN/034531509X/" target="_blank" rel="noopener">Bloom (1985)</a>, <a href="https://norvig.com/21-days.html#bh" target="_blank" rel="noopener">Bryan &amp; Harter (1899)</a>, <a href="http://www.amazon.com/exec/obidos/ASIN/0805803092" target="_blank" rel="noopener">Hayes (1989)</a>, <a href="https://norvig.com/21-days.html#sc" target="_blank" rel="noopener">Simmon &amp; Chase (1973)</a>) have shown it takes about ten years to develop expertise in any of a wide variety of areas, including chess playing, music composition, telegraph operation, painting, piano playing, swimming, tennis, and research in neuropsychology and topology. The key is <em>deliberative</em> practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. There appear to be no real shortcuts: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of #1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, <em>Sgt. Peppers</em>, was released in 1967.</p>
<p><a href="http://www.amazon.com/Outliers-Story-Success-Malcolm-Gladwell/dp/0316017922" target="_blank" rel="noopener">Malcolm Gladwell</a> has popularized the idea, although he concentrates on 10,000 hours, not 10 years. Henri Cartier-Bresson (1908-2004) had another metric: “Your first 10,000 photographs are your worst.” (He didn’t anticipate that with digital cameras, some people can reach that mark in a week.) True expertise may take a lifetime: Samuel Johnson (1709-1784) said “Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price.” And Chaucer (1340-1400) complained “the lyf so short, the craft so long to lerne.” Hippocrates (c. 400BC) is known for the excerpt “ars longa, vita brevis”, which is part of the longer quotation “Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”, which in English renders as “Life is short, [the] craft long, opportunity fleeting, experiment treacherous, judgment difficult.” Of course, no single number can be the final answer: it doesn’t seem reasonable to assume that all skills (e.g., programming, chess playing, checkers playing, and music playing) could all require exactly the same amount of time to master, nor that all people will take exactly the same amount of time. As Prof. <a href="http://www.amazon.com/K.-Anders-Ericsson/e/B000APB8AQ/ref=dp_byline_cont_book_1" target="_blank" rel="noopener">K. Anders Ericsson</a> puts it, “In most domains it’s remarkable how much time even the most talented individuals need in order to reach the highest levels of performance. The 10,000 hour number just gives you a sense that we’re talking years of 10 to 20 hours a week which those who some people would argue are the most innately talented individuals still need to get to the highest level.”</p>
<h2 id="So-You-Want-to-be-a-Programmer"><a href="#So-You-Want-to-be-a-Programmer" class="headerlink" title="So You Want to be a Programmer"></a>So You Want to be a Programmer</h2><p>Here’s my recipe for programming success:</p>
<ul>
<li>Get interested in programming, and do some because it is fun. Make sure that it keeps being enough fun so that you will be willing to put in your ten years/10,000 hours.</li>
</ul>
<ul>
<li><p>Program. </p>
<p>The best kind of learning is learning by doing. To put it more technically, “the maximal level of performance for individuals in a given domain is not attained automatically as a function of extended experience, but the level of performance can be increased even by highly experienced individuals as a result of deliberate efforts to improve.” </p>
<p>and “the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors.” The book <a href="http://www.amazon.com/exec/obidos/ASIN/0521357349" target="_blank" rel="noopener">Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life</a> is an interesting reference for this viewpoint.</p>
</li>
</ul>
<ul>
<li><p>Talk with other programmers; read other programs. This is more important than any book or training course.</p>
</li>
<li><p>If you want, put in four years at acollege (or more at a graduate school). This will give you access to some jobs that require credentials, and it will give you a deeper understanding of the field, but if you don’t enjoy school, you can (with some dedication) get similar experience on your own or on the job. In any case, book learning alone won’t be enough. “Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter” says Eric Raymond, author ofThe New Hacker’s Dictionary. One of the best programmers I ever hired had only a High School degree; he’s produced a lot ofgreatsoftware, has his own news group, and made enough in stock options to buy his own nightclub.</p>
</li>
</ul>
<ul>
<li>Work on projects with other programmers. Be the best programmer on some projects; be the worst on some others. When you’re the best, you get to test your abilities to lead a project, and to inspire others with your vision. When you’re the worst, you learn what the masters do, and you learn what they don’t like to do (because they make you do it for them).</li>
</ul>
<ul>
<li>Work on projects <em>after</em> other programmers. Understand a program written by someone else. See what it takes to understand and fix it when the original programmers are not around. Think about how to design your programs to make it easier for those who will maintain them after you.</li>
</ul>
<ul>
<li>Learn at least a half dozen programming languages. Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or Go).</li>
</ul>
<ul>
<li>Remember that there is a “computer” in “computer science”. Know how long it takes your computer to execute an instruction, fetch a word from memory (with and without a cache miss), read consecutive words from disk, and seek to a new location on disk. (Answers here.)</li>
</ul>
<ul>
<li>Get involved in a language standardization effort. It could be the ANSI C++ committee, or it could be deciding if your local coding style will have 2 or 4 space indentation levels. Either way, you learn about what other people like in a language, how deeply they feel so, and perhaps even a little about why they feel so.</li>
</ul>
<ul>
<li>Have the good sense to <strong>get off</strong> the language standardization effort as quickly as possible.</li>
</ul>
<p>With all that in mind, its questionable how far you can get just by book learning. Before my first child was born, I read all the <em>How To</em> books, and still felt like a clueless novice. 30 Months later, when my second child was due, did I go back to the books for a refresher? No. Instead, I relied on my personal experience, which turned out to be far more useful and reassuring to me than the thousands of pages written by experts.</p>
<p>Fred Brooks, in his essay <em><a href="http://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank" rel="noopener">No Silver Bullet</a></em> identified a three-part plan for finding great software designers:</p>
<ol>
<li>Systematically identify top designers as early as possible.</li>
</ol>
<ol start="2">
<li>Assign a career mentor to be responsible for the development of the prospect and carefully keep a career file.</li>
</ol>
<ol start="3">
<li>Provide opportunities for growing designers to interact and stimulate each other.</li>
</ol>
<p>This assumes that some people already have the qualities necessary for being a great designer; the job is to properly coax them along. <a href="http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html" target="_blank" rel="noopener">Alan Perlis</a> put it more succinctly: “Everyone can be taught to sculpt: Michelangelo would have had to be taught how not to. So it is with the great programmers”. Perlis is saying that the greats have some internal quality that transcends their training. But where does the quality come from? Is it innate? Or do they develop it through diligence? As Auguste Gusteau (the fictional chef in <em>Ratatouille</em>) puts it, “anyone can cook, but only the fearless can be great.” I think of it more as willingness to devote a large portion of one’s life to deliberative practice. But maybe <em>fearless</em> is a way to summarize that. Or, as Gusteau’s critic, Anton Ego, says: “Not everyone can become a great artist, but a great artist can come from anywhere.”</p>
<p>So go ahead and buy that Java/Ruby/Javascript/PHP book; you’ll probably get some use out of it. But you won’t change your life, or your real overall expertise as a programmer in 24 hours or 21 days. How about working hard to continually improve over 24 months? Well, now you’re starting to get somewhere…</p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Bloom, Benjamin (ed.) <em><a href="http://www.amazon.com/exec/obidos/ASIN/034531509X" target="_blank" rel="noopener">Developing Talent in Young People</a></em>, Ballantine, 1985.</p>
<p>Brooks, Fred, <em><a href="http://citeseer.nj.nec.com/context/7718/0" target="_blank" rel="noopener">No Silver Bullets</a></em>, IEEE Computer, vol. 20, no. 4, 1987, p. 10-19.</p>
<p>Bryan, W.L. &amp; Harter, N. “Studies on the telegraphic language: The acquisition of a hierarchy of habits. <em>Psychology Review</em>, 1899, 8, 345-375</p>
<p>Hayes, John R., <em><a href="http://www.amazon.com/exec/obidos/ASIN/0805803092" target="_blank" rel="noopener">Complete Problem Solver</a></em> Lawrence Erlbaum, 1989.</p>
<p>Chase, William G. &amp; Simon, Herbert A. <a href="http://books.google.com/books?id=dYPSHAAACAAJ&dq=" target="_blank" rel="noopener"perception+in+chess"+simon&ei=z4PyR5iIAZnmtQPbyLyuDQ">“Perception in Chess”</a> <em>Cognitive Psychology</em>, 1973, 4, 55-81.</p>
<p>Lave, Jean, <em><a href="http://www.amazon.com/exec/obidos/ASIN/0521357349" target="_blank" rel="noopener">Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life</a></em>, Cambridge University Press, 1988.</p>
<hr>
<p>AnswersApproximate timing for various operations on a typical PC:</p>
<table>
<thead>
<tr>
<th>execute typical instruction</th>
<th>1/1,000,000,000 sec = 1 nanosec</th>
</tr>
</thead>
<tbody><tr>
<td>fetch from L1 cache memory</td>
<td>0.5 nanosec</td>
</tr>
<tr>
<td>branch misprediction</td>
<td>5 nanosec</td>
</tr>
<tr>
<td>fetch from L2 cache memory</td>
<td>7 nanosec</td>
</tr>
<tr>
<td>Mutex lock/unlock</td>
<td>25 nanosec</td>
</tr>
<tr>
<td>fetch from main memory</td>
<td>100 nanosec</td>
</tr>
<tr>
<td>send 2K bytes over 1Gbps network</td>
<td>20,000 nanosec</td>
</tr>
<tr>
<td>read 1MB sequentially from memory</td>
<td>250,000 nanosec</td>
</tr>
<tr>
<td>fetch from new disk location (seek)</td>
<td>8,000,000 nanosec</td>
</tr>
<tr>
<td>read 1MB sequentially from disk</td>
<td>20,000,000 nanosec</td>
</tr>
<tr>
<td>send packet US to Europe and back</td>
<td>150 milliseconds = 150,000,000 nanosec</td>
</tr>
</tbody></table>
<hr>
<h2 id="Appendix-Language-Choice"><a href="#Appendix-Language-Choice" class="headerlink" title="Appendix: Language Choice"></a>Appendix: Language Choice</h2><p>Several people have asked what programming language they should learn first. There is no one answer, but consider these points:</p>
<ul>
<li><em>Use your friends</em>. When asked “what operating system should I use, Windows, Unix, or Mac?”, my answer is usually: “use whatever your friends use.” The advantage you get from learning from your friends will offset any intrinsic difference between OS, or between programming languages. Also consider your future friends: the community of programmers that you will be a part of if you continue. Does your chosen language have a large growing community or a small dying one? Are there books, web sites, and online forums to get answers from? Do you like the people in those forums?</li>
<li><em>Keep it simple</em>. Programming languages such as C++ and Java are designed for professional development by large teams of experienced programmers who are concerned about the run-time efficiency of their code. As a result, these languages have complicated parts designed for these circumstances. You’re concerned with learning to program. You don’t need that complication. You want a language that was designed to be easy to learn and remember by a single new programmer.</li>
<li><em>Play.</em> Which way would you rather learn to play the piano: the normal, interactive way, in which you hear each note as soon as you hit a key, or “batch” mode, in which you only hear the notes after you finish a whole song? Clearly, interactive mode makes learning easier for the piano, and also for programming. Insist on a language with an interactive mode and use it.</li>
</ul>
<p>Given these criteria, my recommendations for a first programming language would be <strong><a href="http://python.org/" target="_blank" rel="noopener">Python</a></strong> or <strong><a href="http://www.schemers.org/" target="_blank" rel="noopener">Scheme</a></strong>. Another choice is Javascript, not because it is perfectly well-designed for beginners, but because there are so many online tutorials for it, such as <a href="https://www.khanacademy.org/computing/cs/programming" target="_blank" rel="noopener">Khan Academy’s tutorial</a>. But your circumstances may vary, and there are other good choices. If your age is a single-digit, you might prefer <a href="http://alice.org/" target="_blank" rel="noopener">Alice</a> or <a href="http://www.squeak.org/" target="_blank" rel="noopener">Squeak</a> or <a href="https://blockly-demo.appspot.com/static/apps/index.html" target="_blank" rel="noopener">Blockly</a> (older learners might also enjoy these). The important thing is that you choose and get started.</p>
<hr>
<h2 id="Appendix-Books-and-Other-Resources"><a href="#Appendix-Books-and-Other-Resources" class="headerlink" title="Appendix: Books and Other Resources"></a>Appendix: Books and Other Resources</h2><p>Several people have asked what books and web pages they should learn from. I repeat that “book learning alone won’t be enough” but I can recommend the following:</p>
<ul>
<li><strong>Scheme:</strong> <a href="http://www.amazon.com/gp/product/0262011530" target="_blank" rel="noopener">Structure and Interpretation of Computer Programs (Abelson &amp; Sussman)</a> is probably the best introduction to computer science, and it does teach programming as a way of understanding the computer science. You can see <a href="http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/" target="_blank" rel="noopener">online videos of lectures</a> on this book, as well as the <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="noopener">complete text online</a>. The book is challenging and will weed out some people who perhaps could be successful with another approach.</li>
<li><strong>Scheme:</strong> <a href="http://www.amazon.com/gp/product/0262062186" target="_blank" rel="noopener">How to Design Programs (Felleisen <em>et al.</em>)</a> is one of the best books on how to actually design programs in an elegant and functional way.</li>
<li><strong>Python:</strong> <a href="http://www.amazon.com/gp/product/1887902996" target="_blank" rel="noopener">Python Programming: An Intro to CS (Zelle)</a> is a good introduction using Python.</li>
<li><strong>Python:</strong> Several online <a href="http://wiki.python.org/moin/BeginnersGuide" target="_blank" rel="noopener">tutorials</a> are available at <a href="http://python.org/" target="_blank" rel="noopener">Python.org</a>.</li>
<li><strong>Oz:</strong> <a href="http://www.amazon.com/gp/product/0262220695" target="_blank" rel="noopener">Concepts, Techniques, and Models of Computer Programming (Van Roy &amp; Haridi)</a> is seen by some as the modern-day successor to Abelson &amp; Sussman. It is a tour through the big ideas of programming, covering a wider range than Abelson &amp; Sussman while being perhaps easier to read and follow. It uses a language, Oz, that is not widely known but serves as a basis for learning other languages. &lt;</li>
</ul>
<hr>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>T. Capey points out that the <a href="http://www.amazon.com/exec/obidos/ASIN/0805803092" target="_blank" rel="noopener">Complete Problem Solver</a> page on Amazon now has the “Teach Yourself Bengali in 21 days” and “Teach Yourself Grammar and Style” books under the “Customers who shopped for this item also shopped for these items” section. I guess that a large portion of the people who look at that book are coming from this page. Thanks to Ross Cohen for help with Hippocrates.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/19/Linux-Windows-Mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/19/Linux-Windows-Mac/" class="post-title-link" itemprop="url">Linux_Windows_Mac</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-19 16:41:03 / Modified: 17:41:57" itemprop="dateCreated datePublished" datetime="2020-01-19T16:41:03-05:00">2020-01-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>简言之，我想对那些觉得 Linux 永远也学不会的“菜鸟”们说：</p>
<ol>
<li>Linux 和 Unix 里面包含了一些非常糟糕的设计。不要被 Unix 的教条主义者吓倒。学不会有些东西很多时候不是你的错，而是 Linux 的错，是“Unix 思想” 的错。不要浪费时间去学习太多工具的用法，钻研稀奇古怪的命令行。那些貌似难的，复杂的东西，特别要小心分析。</li>
<li>Windows 避免了 Unix，Linux 和 Mac OS X 的很多问题。微软是值得尊敬的公司，是真正在乎程序开发工具的公司。我收回曾经对微软的鄙视态度。请菜鸟们吸收 Windows 设计里面好的东西。另外 Visual Studio 是非常好的工具，会带来编程效率的大幅度提升。请不要歧视 IDE。要正视 Emacs，VIM 等文本编辑器的局限性。当然，这些正面评价不等于说你应该为微软工作。就像我喜欢 iPhone，但是却不一定想给 Apple 工作一样。</li>
<li>学习操作系统最好的办法是学会（真正的）程序设计思想，而不是去“学习”各种古怪的工具。所有操作系统，数据库，Internet，以至于 WEB 的设计思想（和缺陷），几乎都能用程序语言的思想简单的解释。</li>
</ol>
<p>先说说我现在对 Linux 和相关工具（比如 TeX）的看法吧。我每天上班都用 Linux，可是回家才不想用它呢。上班的时候，我基本上只是尽我所能的改善它，让它不要给我惹麻烦。Unix 有许许多多的设计错误，却被当成了教条，传给了一代又一代的程序员，恶性循环。Unix 的 shell，命令，配置方式，图形界面，都是相当糟糕的。每一个新版本的 Ubuntu 都会在图形界面的设计上出现新的错误，让你感觉历史怎么会倒退。其实这只是表面现象。Linux 所用的图形界面（X Window）在本质上几乎是没救的。我不想在这里细说 Unix 的缺点，在它出现的早期，已经有人写了一本书，名叫 Unix Hater’s Handbook，里面专门有一章叫做 The X-Windows Disaster。它分析后指出，X Window 貌似高明的 client-server 设计，其实并不像说的那么好。</p>
<p>这本书汇集了 Unix 出现的年代，很多人对它的咒骂。有趣的是，这本书有一个“反序言”，是 Unix 的创造者之一 Dennis Ritchie 写的。我曾经以为这些骂 Unix 的人都是一些菜鸟。他们肯定是智商太低，或者被 Windows 洗脑了，不能理解 Unix 的高明设计才在那里骂街。现在理解了程序语言的设计原理之后，才发现他们说的那些话里面居然大部分是实话！其实他们里面有些人在当年就是世界顶尖的编程高手，自己写过操作系统和编译器，功底不亚于 Unix 的创造者。在当年他们就已经使用过设计更加合理的系统，比如 Multics，Lisp Machine 等。</p>
<p>可惜的是，在现在的操作系统书籍里面，Multics 往往只是被用来衬托 Unix 的“简单”和伟大。Unix 的书籍喜欢在第一章讲述这样的历史：“Multics 由于设计过于复杂，试图包罗万象，而且价格昂贵，最后失败了。” 可是 Multics 失败了吗？Multics，Oberon，IBM System/38， Lisp Machine，…… 在几十年前就拥有了 Linux 现在都还没有的好东西。Unix 里面的东西，什么虚拟内存，文件系统，…… 基本上都是从 Multics 学来的。Multics 的机器，一直到 2000 年都还在运行。Unix 不但“窜改”了历史教科书，而且似乎永远不吸取教训，到现在还没有实现那些早期系统早就有的好东西。Unix 的设计几乎完全没有一致性和原则。各种工具程序功能重复，冗余，没法有效地交换数据。可是最后 Unix 靠着自己的“廉价”，“宗教”和“哲学”，战胜了别的系统在设计上的先进，统治了程序员的世界。</p>
<p>如果你想知道这些“失败的”操作系统里面有哪些我们现在都还没有的先进技术，可以参考这篇文章：Oberon - The Overlooked Jewel。它介绍的是 Niklaus Wirth（也就是 Pascal 语言的设计者）的 Oberon 操作系统。</p>
<p>胜者为王，可是 Unix 其实是一个暴君，它不允许你批评它的错误。它利用其它程序员的舆论压力，让每一个系统设计上的错误，都被说成是用户自己的失误。你不敢说一个工具设计有毛病，因为如果别人听到了，就会以为你自己不够聪明，说你“人笨怪刀钝”。这就像是“皇帝的新装”里的人们，明明知道皇帝没穿衣服，还要说“这衣服这漂亮”！总而言之，“对用户友好”这个概念，在 Unix 的世界里是被歧视，被曲解的。Unix 的狂热分子很多都带有一种变态的“精英主义”。他们以用难用的工具为豪，鄙视那些使用“对用户友好”的工具的人。</p>
<p>我曾经强烈的推崇 FVWM，TeX 等工具，可是现在擦亮眼睛看来，它们给用户的界面，其实也是非常糟糕的设计，跟 Unix 一脉相承。他们把程序设计的许多没必要的细节和自己的设计失误，无情的暴露给用户。让用户感觉有那么多东西要记，仿佛永远也没法掌握它。实话说吧，当年我把 TeXbook 看了两遍，做完了所有的习题（包括最难的“double bend”习题）。几个月之后，几乎全部忘记干净。为什么呢？因为 TeX 的语言是非常糟糕的设计，它没有遵循程序语言设计的基本原则。</p>
<p>这里有一个鲜为人知的小故事。TeX 之所以有一个“扩展语言”，是 Scheme 的发明者 Guy Steele 的建议。那年夏天，Steele 在 Stanford 实习。他听说 Knuth 在设计一个排版系统，就强烈建议他使用一种扩展语言。后来 Knuth 采纳了他的建议。不幸的是 Steele 几个月后就离开了，没能帮助 Knuth 完成语言的设计。Knuth 老爹显然有我所说的那种“精英主义”，他咋总是设计一些难用的东西，写一些难懂的书？</p>
<p>一个好的工具，应该只有少数几条需要记忆的规则，就像象棋一样。而这些源于 Unix 的工具却像是“魔鬼棋”或者“三国杀”，有太多的，无聊的，人造的规则。有些人鄙视图形界面，鄙视 IDE，鄙视含有垃圾回收的语言（比如 Java），鄙视一切“容易”的东西。他们却不知道，把自己沉浸在别人设计的繁复的规则中，是始终无法成为大师的。就像一个人，他有能力学会各种“魔鬼棋”的规则，却始终无法达到象棋大师的高度。所以，容易的东西不一定是坏的，而困难的东西也不一定是好的。学习计算机（或者任何其它工具），应该“只选对的，不选难的”。记忆一堆的命令，乌七八糟的工具用法，最后脑子里什么也不会留下。学习“原理性”的东西，才是永远不会过时的。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows 技术设计上的很多细节，也许在早期是同样糟糕的。但是它却向着更加结构化，更加简单的方向发展。Windows 的技术从 OLE，COM，发展到 .NET，再加上 Visual Studio 这样高效的编程工具，这些带来了程序员和用户效率的大幅度提高，避免了 Unix 和 C 语言的很多不必存在的问题。Windows 程序从很早的时候就能比较方便的交换数据。比如，OLE 让你可以把 Excel 表格嵌入到 Word 文档里面。不得不指出，这些是非常好的想法，是超越“Unix 哲学”的。相反，由于受到“Unix 哲学”的误导，Unix 的程序间交换数据一直以来都是用字符串，而且格式得不到统一，以至于很多程序连拷贝粘贴都没法正确进行。Windows 的“配置”，全都记录在一个中央数据库（注册表）里面，这样程序的配置得到大大的简化。虽然在 Win95 的年代，注册表貌似老是惹麻烦，但现在基本上没有什么问题了。相反，Unix 的配置，全都记录在各种稀奇古怪的配置文件里面，分布在系统的各个地方。你搞不清楚哪个配置文件记录了你想要的信息。每个配置文件连语法都不一样！这就是为什么用 Unix 的公司总是需要一个“系统管理员”，因为软件工程师们才懒得记这些麻烦的东西。</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>再来比较一下 Windows 和 Mac 吧。我认识一个 Adobe 的高级设计师。他告诉我说，当年他们把 Photoshop 移植到 Intel 构架的 Mac，花了两年时间。只不过换了个处理器，移植个应用程序就花了两年时间，为什么呢？因为 Xcode 比起 Visual Studio 真是差太多了。而 Mac OS X 的一些设计原因，让他们的移植很痛苦。不过他很自豪的说，当年很多人等了两年也没有买 Intel 构架的 Mac，就是因为他们在等待 Photoshop。最后他直言不讳的说，微软其实才是真正在乎程序员工具的公司。相比之下，Apple 虽然对用户显得友好，但是对程序员的界面却差很多。Apple 尚且如此，Linux 对程序员就更差了。可是有啥办法呢，有些人就是受虐狂。自己痛过之后，还想让别人也痛苦。就像当年的我。</p>
<p>我当然不是人云亦云。微软在程序语言上的造诣和投入，我看得很清楚。我只是通过别人的经历，来验证我已经早已存在的看法。所以一再宣扬别的系统都是向自己学习的 Apple 受到这样的评价，我也一点不惊讶。Mac OS X 毕竟是从 Unix 改造而来的，还没有到脱胎换骨的地步。我有一个 Macbook Air，一个 iPhone 5，和一个退役的，装着 Windows 7 的 T60。我不得不承认，虽然我很喜欢 Macbook 和 iPhone 的硬件，但我发现 Windows 在软件上的很多设计其实更加合理。</p>
<p>我为什么当年会鄙视微软？这很简单。我就是跟着一群人瞎起哄而已！他们说 Linux 能拯救我们，给我们自由。他们说微软是邪恶的公司…… 到现在我身边还有人无缘无故的鄙视微软，却不知道理由。可是 Unix 是谁制造的呢？是 AT&amp;T。微软和 AT&amp;T 哪个更邪恶呢？我不知道。但是你应该了解一下 Unix 的历史。AT&amp;T 当年发现 Unix 有利可图，找多少人打了多少年官司？说微软搞垄断，其实 AT&amp;T 早就搞过垄断了，还被拆散成了好几个公司。想想世界上还有哪一家公司，独立自主的设计出这从底至上全套家什：程序语言，编译器，IDE，操作系统，数据库，办公软件，游戏机，手机…… 我不得不承认，微软是值得尊敬的公司。</p>
<p>公司还不都一样，都是以利益为本的。我们程序员就不要被他们利用，作为利益斗争的炮灰啦。见到什么好就用什么，就学什么。自己学到的东西，又不属于那些垄断企业。我们都有自由的头脑。</p>
<p>当然我不是在这里打击 Linux 和 Mac 而鼓吹 Windows。这些系统的纷争基本上已经不关我什么事。我只是想告诉新人们，去除头脑里的宗教，偏激，仇恨和鄙视。每次仇恨一个东西，你就失去了向它学习的机会。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1436668936&auto=0&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
