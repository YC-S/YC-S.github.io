<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Aaron&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/22/index.html">
<meta property="og:site_name" content="Aaron&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Aaron">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/22/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Aaron's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Aaron's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">技术的发展方式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 22:28:35" itemprop="dateCreated datePublished" datetime="2020-01-17T22:28:35-05:00">2020-01-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这两部分的目的都是拓宽我们讨论“技术”的术语。技术应以三种不同的形式理解：作为嵌入工具（例如锅，锅，炉子）的过程；明确的指示（如食谱）；以及过程知识，或者我们也可以称为隐性知识，专有技术和技术经验。过程知识是一种很难作为指令写下来的知识。您可以给一个人一个设备齐全的厨房和一个非常详尽的食谱，但是除非他已经有烹饪经验，否则我们不应该指望他准备一道好菜。</p>
<p>我认为在谈论技术时，我们有两个很大的偏见。首先，我们在工具和配方方面考虑得太多，而实际上我们应该在过程知识和技术经验方面考虑得更多。其次，我们大多数人过多地关注数字世界，而对工业世界则关注不足。我们对数字世界的痴迷将我们对技术未来的期望朝着计算机朋克反乌托邦的方向发展。相反，我希望我们可以期待在工业进步的推动下，对技术未来充满喜悦。</p>
<h3 id="过程知识由经验丰富的员工代表"><a href="#过程知识由经验丰富的员工代表" class="headerlink" title="过程知识由经验丰富的员工代表"></a>过程知识由经验丰富的员工代表</h3><p><strong>过程知识由经验丰富的员工代表。</strong>我一直在研究半导体行业，这有助于更广泛地阐明我对技术创新的想法。在半导体生产中很容易识别出所有三种技术形式：工具，指令和工艺知识。TSMC，英特尔和三星是执行摩尔定律最负责的三家公司。这三家公司每年投资超过100亿美元，以推动这一技术前沿。</p>
<p>这些公司拥有的工具和知识产权很容易观察。我认为他们拥有的过程知识甚至更重要。工艺知识也可以称为技术和工业专长；就半导体而言，这包括如何存储晶圆，如何进入洁净室，在晶圆厂工艺的不同阶段应使用多少电流以及不计其数的其他知识。这种知识是通过经验赢得的。任何有详细说明但没有实际制造芯片经验的人都可能会搞砸。</p>
<p>我相信，技术最终会因为人和他们所拥有的过程知识的深入而进步。我将新工具和IP的创建视为我们积累的过程知识的认证。我不想将工具和IP视为技术进步的最终目的，而是希望将它们视为培训更好的科学家，工程师和技术人员的里程碑。</p>
<p>积累的工艺知识和资本使半导体公司能够继续生产越来越复杂的芯片。如果这些公司还不具备深厚的工艺知识储备，则不可能每24个月将晶体管密度提高一倍。这不仅是任何资本充足的公司都可以购买的工具；或蓝图，如果没有经验将它们编成代码，很难遵循这些蓝图。美国在设计和制造半导体方面拥有数十年的经验，并且已经开发了人才生态系统，成功地推动了摩尔定律的发展。这些人才库使美国能够在至关重要的技术上保持领先地位。</p>
<h3 id="美国的工业基础一直在下降"><a href="#美国的工业基础一直在下降" class="headerlink" title="美国的工业基础一直在下降"></a>美国的工业基础一直在下降</h3><p><strong>美国的工业基础一直在下降。</strong>但是，半导体领域的持续创新是美国制造业的一个例外。该国过去曾培育充满活力的工程实践社区（我喜欢布拉德·德龙（Brad DeLong）这个<a target="_blank" rel="noopener" href="https://ftalphaville-cdn.ft.com/wp-content/uploads/2016/05/DeLongTranscript.pdf">词</a>），这是谈论许多行业领域积累的过程知识的另一种方式。但是，并非所有的工程实践社区都处于良好状态。</p>
<p>美国制造业的<a target="_blank" rel="noopener" href="https://fred.stlouisfed.org/series/OUTMS">实际产出</a>低于2008年经济衰退之前的水平。这意味着整整十年美国制造业并没有真正的增长。（实际上，这一措施可能太过乐观了-ITIF提出了一个<a target="_blank" rel="noopener" href="http://www2.itif.org/2017-trade-vs-productivity.pdf?_ga=2.190785960.2044634082.1518783223-2101981348.1518102856">论据</a>，即由于计算机速度的过度质量调整而导致了制造业产出措施的偏差。带走了计算机，如今购买的计算机越来越少，而美国的实际产出却越来越少。制造业将进行有意义的降低）。<a target="_blank" rel="noopener" href="https://fred.stlouisfed.org/series/MANEMP">制造业就业人数</a>在1979年达到高峰，近20万工人; 它在2000年下降到1700万，在2008年下降到1400万，今天是1200万。自1979年以来，美国人口增长了40％，而制造业工人的数量几乎减少了一半。</p>
<p>当企业和工厂离开时，积累的过程知识也消失了。行业经验，扩展专业知识以及边做边学带来的所有事物都会衰减。我今年初访问了德国，与行业人士进行了交谈。德国人不断提出的一个观点是，美国已经实现了自身的工业化并分散了生产网络。尽管德国通过提升价值链来应对全球化，但美国制造业基地大多通过放弃生产来应对。</p>
<p>布拉德·塞瑟（Brad Setser）<a target="_blank" rel="noopener" href="https://www.cfr.org/blog/us-needs-more-manufactured-exports">表明</a>，美国的制成品出口水平低，在富裕国家中脱颖而出。叫我头脑简单，但我认为世界上最发达国家应该负责 向世界各地<em>出口商品</em>。相反，美国既有贸易赤字，也有经常账户赤字。美国的贸易逆差之所以高，不仅是因为它进口了很多商品。它之所以很高，是因为它的出口不多。为了使其他国家从美国进口更多商品，首先，美国应该出售更好的商品。</p>
<h3 id="知识应在整个供应链中传播，并在堆栈中上下流动"><a href="#知识应在整个供应链中传播，并在堆栈中上下流动" class="headerlink" title="知识应在整个供应链中传播，并在堆栈中上下流动"></a>知识应在整个供应链中传播，并在堆栈中上下流动</h3><p><strong>知识应在整个供应链中传播，并在堆栈中上下流动。</strong>成功的行业倾向于聚集到紧密的生产网络中。欣赏集群奇迹的最简单方法是看硅谷，那里的资本，学术界，大量急切的劳动力以及大小不一的公司彼此相邻。对于在硅谷待了一段时间的任何人来说，显而易见的是，这种经济联系的集中是使该系统运转的魔力的一部分。</p>
<p>工业集群还有许多其他例子。台湾的半导体产业成立，至今仍以台北南部的一个小型工业园区为中心。硅谷之所以被命名是因为它是半导体生产的中心（并且附近有足够的有毒<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_Superfund_sites_in_California">超级基金</a>站点可以证明这一遗产）。不仅仅是芯片：汽车，电子，生物技术，航空和机器零件都倾向于在地理位置上聚集。</p>
<p>接近使得更容易生成过程知识。但是，当我们通过<a target="_blank" rel="noopener" href="https://twitter.com/teasri/status/984611523548073989">分离</a>设计和制造来<a target="_blank" rel="noopener" href="https://twitter.com/teasri/status/984611523548073989">拆分</a>这些生产网络时会发生什么呢？有时候没什么大不了的，有时候效果很好。但是我相信，在大多数情况下，位错会使维护过程知识变得更加困难。</p>
<p>设计过程和生产过程都会生成有用的信息，而位错使该信息难以传播。我认为我们倾向于打折我们在生产过程中可以获得多少知识，以及如何将其反馈到设计过程中。也许更容易从计算示例中体会到这一点。 <a target="_blank" rel="noopener" href="https://ristret.com/arjun">Arjun Narayan</a>告诉我，好的软件设计需要对芯片有深刻的了解，反之亦然。最好的开发人员是那些了解流程如何在堆栈上下交互的人员。</p>
<p>当我们停止知识流向上堆积时会发生什么？我认为美国工业机器人行业的弱势具有启发意义。美国在制造高端精密制造设备方面<a target="_blank" rel="noopener" href="https://www.wsj.com/articles/powering-americas-manufacturing-renaissance-foreign-robots-1490549611">几乎没有地位</a>。在工厂自动化系统，机床，机器人手臂和其他类型的生产机械方面，最先进的供应商是日本，德国和瑞士。我认为，美国地位低下的原因可以直接归因于公司从众多制造业领域撤离。如果工程师不接触工业流程，他们将如何进行自动化系统的设计？</p>
<p>从A报价<a target="_blank" rel="noopener" href="https://www.wsj.com/articles/powering-americas-manufacturing-renaissance-foreign-robots-1490549611">文章</a>：“关于先进制造业，以总统奥巴马的一份报告，他在2012年的科学顾问委员会，编制得出的结论是‘硬道理’是美国落后于制造业创新等富裕国家。”</p>
<p>我看不出有足够的美国人为美国没有制造先进的工业机器人而烦恼。认为机器人将在将来完成所有制造工作可能很好。但是必须有人来制造这些机器人，并拥有先进机器人制造的知识产权，而且在大多数情况下，有人不是美国。工程实践界最健康的国家也率先为该行业设计工具，这绝非偶然。他们能够将知识嵌入到新工具中，因为它们继续生成过程知识。</p>
<h3 id="让我们尝试保留过程知识。"><a href="#让我们尝试保留过程知识。" class="headerlink" title="让我们尝试保留过程知识。"></a>让我们尝试保留过程知识。</h3><p><strong>让我们尝试保留过程知识。</strong>工业工作的减少使积累工艺知识变得更加困难。如果一个州失去了大部分电气工程师，土木工程师或核工程师的工作，那么进入这些领域的年轻人就会减少。技术发展放慢，这变成了自我强化的下降周期。</p>
<p>我认为我们应该尝试继续处理知识。</p>
<p>日本的<a target="_blank" rel="noopener" href="https://www.smithsonianmag.com/smart-news/this-japanese-shrine-has-been-torn-down-and-rebuilt-every-20-years-for-the-past-millennium-575558/">伊势神宫</a> 就是这种类型的非凡例子。每隔20年，看护人都会彻底拆除神殿并重新建造。木制神rine已经被重建了1200年。当地人希望确保他们永远不会忘记建造神社的生产知识。很明显，年长的一代想向年轻的一代传授建筑技术：“下次我将把这些职责留给您。”</p>
<p>定期拆除和重建木庙听起来不像是在浪费时间。但是我不确定本地优先事项是否在这里完全搞砸了。这些人知道，写下甚至建造单个木结构所需的每条指令都太困难了。想象为机械零件或芯片创建指令要困难得多。我们每隔一段时间就会发现不知道如何使用的古老工具。这些神社看守人认为，保存生产知识很重要，我认为这令人钦佩。</p>
<p>建立广阔的工业基础并实践实践学习曾经是美国的方式。<a target="_blank" rel="noopener" href="https://ftalphaville-cdn.ft.com/wp-content/uploads/2016/05/DeLongTranscript.pdf">布拉德·德隆（Brad DeLong）</a> 再次<a target="_blank" rel="noopener" href="https://ftalphaville-cdn.ft.com/wp-content/uploads/2016/05/DeLongTranscript.pdf">说道</a>：“当第二次工业革命的技术<a target="_blank" rel="noopener" href="https://ftalphaville-cdn.ft.com/wp-content/uploads/2016/05/DeLongTranscript.pdf">问世</a>时，美国凭借其广阔的棉花市场和丰富的自然资源以及卓越的工程技术社区，能够突飞猛进，并且实际上大大超过了英国几乎每个地方的生产效率 这样一来，二十世纪就变成了美国世纪，而不是第二个英国世纪，这在很大程度上是因为汉密尔顿的赌注促使美国不仅仅追随比较优势。</p>
<h3 id="未来不只是服务"><a href="#未来不只是服务" class="headerlink" title="未来不只是服务"></a>未来不只是服务</h3><p><strong>未来不只是服务。</strong>制造业不是总是低附加值的东西吗，而是应该由服务来驱动未来？我不确定。我怀疑我们能否将所有希望寄托在服务领域，因为它往往会遇到两个大问题：很多问题都是赢家通吃，其余大部分是零和。</p>
<p>美国服务业工作的问题之一是，大多数收益是由很少的工人获得的。两个服务部门生产率很高：技术和金融。但是其他行业，例如零售业，酒店业和食品服务业，并没有那么快地促进生产力的增长。因此，尽管总产量可以增加，但消费却不会保持上升趋势。这是因为对冲基金经理和机器学习工程师（而不是酒店员工和零售员工）非对称地产生了服务的整体生产收益，而这些高生产率的工人只能消耗那么多。</p>
<p>大量服务工作中的另一个问题是其中很多都是零和，<a target="_blank" rel="noopener" href="https://www.ineteconomics.org/perspectives/blog/is-productivity-growth-becoming-irrelevant">Adair Turner</a>很好地说明了这一点。太多的服务工作是要抵消其他服务工作的努力，例如在诉讼中，原告的律师为被告的律师创造了工作。通常，零和是不对称的：十几个黑客盗窃，随后各地的公司都需要花费数十亿美元来保护员工或承包商，以保护自己。一个州遭受了几次刑事灾难，政府随后需要雇用数百名官员，以使人们感到安全；少数人实施会计欺诈，随之而来的轩然大波迫使公司和银行将合规部门的规模扩大了数万个。</p>
<p>我之前链接到Brad Setser <a target="_blank" rel="noopener" href="https://www.cfr.org/blog/us-needs-more-manufactured-exports">作品中</a>有一条有趣的台词。他告诉我们，美国服务贸易盈余如此之高的原因之一是，美国人出国旅行的倾向很低。我认为这不是赚取贸易盈余的好方法。</p>
<p>我最喜欢的彭博列的类型已经成为诺亚史密斯<a target="_blank" rel="noopener" href="https://www.bloomberg.com/view/articles/2018-05-04/u-k-economy-needs-to-break-its-dependence-on-the-finance">扣篮上</a>的<a target="_blank" rel="noopener" href="https://www.bloomberg.com/view/articles/2017-07-20/the-u-s-special-relationship-with-britain-needs-a-rest">英国</a>。服务业约占英国经济的80％，这带来了许多问题。其中包括过去二十年来生产力的低水平增长，对金融危机的极大脆弱性以及最大公司的研发支出水平低下。马特·克莱因（Matt Klein）提出了一个有趣的<a target="_blank" rel="noopener" href="https://www.barrons.com/articles/italy-without-the-euro-would-not-be-argentina-or-turkeyit-would-be-the-u-k-1527078883">主张</a>：“带走大伦敦-繁荣的程度在一定程度上取决于是否愿意为来自中东和前苏联的寡头提供服务-英国是最贫穷的国家之一西欧国家。”</p>
<p>关于英国的另一件事：我真的很喜欢《<a target="_blank" rel="noopener" href="http://armscoop.com/wp-content/uploads/2016/08/The_Power_to_Compete_-_Hiroshi_Mikitani.pdf"><em>权力竞争》</em></a>（<a target="_blank" rel="noopener" href="http://armscoop.com/wp-content/uploads/2016/08/The_Power_to_Compete_-_Hiroshi_Mikitani.pdf"><em>Power to Compete）</em></a>，这本书是两位日本思想家之间对话的组成部分。（感谢诺亚提出建议。）有很多好的建议，其中一个是：“如果你看英国，我认为优先辩论和思考的政策使他们失败了。”（我会也表明这种对论据的博雅艺术强调将大学变成了<a target="_blank" rel="noopener" href="https://danwang.co/college-girardian-terror/">吉拉迪安恐怖的</a>孵化器。）</p>
<p><em>竞争</em>能力值得一读，因为只有两个人清楚地认识到了低增长的问题，并且认真地提供解决方案。没有一种态度让我觉得更清新。</p>
<h3 id="没有工业基础，我们如何做科幻小说"><a href="#没有工业基础，我们如何做科幻小说" class="headerlink" title="没有工业基础，我们如何做科幻小说"></a>没有工业基础，我们如何做科幻小说</h3><p><strong>没有工业基础，我们该如何做科幻小说？</strong>我已经否定了服务的理由；工业有积极的理由吗？是的，我想是这样。</p>
<p>互联网很重要，我们可能仍会低估其影响。但是我不认为我们应该让创新完全局限于数字世界，因为还有很多东西需要建设。这个世界还不够发达，每个人都只能以较低的收入获得住房，食物，水和能源。数以亿计的人仍然生活在极端贫困中，这意味着制造和物流还没有克服为所有人提供廉价物质舒适的障碍。</p>
<p>而且我认为，除非我们建立了许多其他东西，否则我们不能将自己称为“发达”世界。我们在20年代安装的信号设备的引导下，在20世纪70年代建造的地铁上工作。自从协和飞机退役以来，我们在地球上的行驶速度一直比较缓慢，而此时全球旅行者都希望能够更快地到达主要枢纽。我们确定发达国家不会经历过早的去工业化吗？当人们提到数字世界变得非常有趣的事实时，我倾向于认为这种回应带有“让他们吃iPhone”的口号。</p>
<p>我并不是说制造业具有特殊的道德价值，而且我之前<a target="_blank" rel="noopener" href="https://danwang.co/definite-optimism-as-human-capital/">已经承认</a>制造业中的许多都是令人不快和危险的。我对工业感兴趣，因为我认为维护工业基础是构建未来科幻技术的前提。</p>
<p>我在寻找什么？对于初学者：能源太便宜而无法计量；火星及以后的殖民地；我们的沙漠重新造林；纳米技术使我们可以印刷基本材料；预防，治疗或治愈大多数疾病的医疗器械和药品；对材料有更深刻的理解；还有很多其他事情。为了实现所有这些，我们需要开发更多的工具和机械。</p>
<p>在太空时代成长的人提醒我们，我们重新调整了技术期望值要低得多。这是弗里曼的儿子<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=QtYv3OjWCpE">乔治·戴森</a>（<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=QtYv3OjWCpE">George Dyson）</a>，他观看了从拜科努尔发射的太空旅游火箭后说：“我小时候，弗里曼正在建造这艘太空船，该太空船原本打算在1965年与50个人一起离开，前往火星和土星。然后的问题是，美国人还是俄罗斯人将接管太阳系。距人造卫星50年后，我们来到了这里，我正看着一个美国人支付3500万美元，乘坐苏维埃时代的火箭进入低地球轨道。”</p>
<p>让我们继续关注太空旅行的话题。木星的各个卫星上可能都有 <a target="_blank" rel="noopener" href="https://europa.nasa.gov/about-europa/faq/">温暖的海洋</a>。为什么我们没有优先考虑在我们自己的太阳系中可能存在于我们行星门口的外星生命？我现在正在自愿参加探索这些海洋的任务。如果我必须在那里筹集资金，我将提议写下一个<em>Moby-Dick</em>或《<em>海底两万个同盟》</em>，这当然取决于居住在这些深处的怪物的性质和经济价值。</p>
<p>我承认，所有这些创新都有可能出现。汽车正在变得无人驾驶，甚至可能很快就飞起来。私人空间的工作确实看起来很酷。繁荣可能会带回超音速喷气机。但是我发现它们的潜在总和并不令人兴奋。而且我们可能无法全部获得：美国无法建立全国性的收费系统，因为要求不同的州将其应答器转移到相同的无线电频率太困难了（<a target="_blank" rel="noopener" href="https://www.wired.com/story/national-tolling-system/">即使在</a>国会法案要求他们这样做之后也是如此） ）。如果我们无法确定各州之间可互操作的收费系统，那么我们多久才能制定出自动驾驶汽车的监管系统？</p>
<h3 id="美国应该效仿德国"><a href="#美国应该效仿德国" class="headerlink" title="美国应该效仿德国"></a>美国应该效仿德国</h3><p><strong>美国应该效仿另一个国家。</strong>我钦佩有一个国家，这个国家的经验将本文的许多主题融合在一起：我认为美国应该向德国学习。我认为德国是在培养工程实践社区方面做得最好的国家。几十年来，甚至数百年来，德国一直在进行工业深化。</p>
<p>我今年早些时候到那里研究了其在行业中的卓越表现。我不能声称完全了解系统如何工作，但是我至少可以确定成功的几个因素：学术合作，公司鼓励和对技能传承的承诺都可以发挥作用。老年工人的态度令我特别震惊，他们认为他们有责任将知识传授给年轻工人。今天，德国公司仍然是工业技术许多领域的领导者。</p>
<p>这并不是说德国一切都很好。德国和欧洲其他地区似乎错过了通向数字时代的巴士。这是 <a target="_blank" rel="noopener" href="https://marginalrevolution.com/marginalrevolution/2018/03/bruno-macaes-trump-europe.html">很难</a>说出许多欧洲公司在过去30年来在他们的行业领导者开始; 我能想到的最好的例子是英飞凌（Infineon），它是西门子公司的一个半导体分拆公司，市值为300亿美元，我想我们可以加入Spotify，尽管我不确定它是否真的是领导者。这里有一个显着的线<a target="_blank" rel="noopener" href="http://media.economist.com/news/business/21738401-they-are-last-europes-makers-mobile-devices-and-network-equipment-which-once-ruled">从</a>经济学：“如果爱立信和诺基亚继续萎缩，只有一个欧洲公司，施耐德电气公司，将成为世界上最大的35家科技公司的收入中离开了。”</p>
<p>德国和美国有不同的优势。前者擅长工业，后者擅长信息技术。但是我觉得奇怪的是，每个人都在对方擅长的方面很差。我无法辨别强迫我们选择其中一个的原则，而且我乐观地认为，一个国家应该能够在行业和互联网上都表现出色。</p>
<p>在过去的几十年中，美国和德国的增长都令人失望。我可以确定每个国家的关键数据点。在美国，主要城市的租金增长已经<a target="_blank" rel="noopener" href="https://www.wsj.com/articles/rising-rents-outpace-wages-in-wide-swaths-of-the-u-s-1438117026">超过了</a>收入的增长。由于我仍无法理解的原因，旧金山等城市的房主有能力否决新住房的创建。谁能相信他们能够摆脱<em>这个</em>困境？在德国，现在继承了全部财富的一半<a target="_blank" rel="noopener" href="https://www.ft.com/content/894689c2-4933-11e8-8ee8-cae73aab7ccb">以上，高于</a> 1970年代的20％（使财富几乎达到英国的水平）。似乎人们大多放弃了通过做新事物来创造财富的想法。</p>
<p>这是另一个问题：美国政府正在慢慢放弃其 <a target="_blank" rel="noopener" href="https://www.taxpolicycenter.org/taxvox/federal-government-autopilot-mandatory-spending-and-entitlement-crisis">财政回旋的余地</a>。1962年，非国防性可支配支出占联邦预算的60％以上。到2017年，这一数字已降至15％，并且预计将继续下降。随着份额的下降，我想知道这将如何影响立法者的思维方式，他们预计分配资金的责任将会减少。绝对而言，他们控制的预算仍然很大。但是我怀疑这会剥夺美国政客的主动权：他们可以让政府继续自动驾驶，因为他们的前任已经承诺了大多数可用资金。如果立法者不再有空间确定新的支出计划，除了找到要禁止的新事物然后与另一方争论之外，该怎么办？</p>
<p>美国和德国的创新方式不同，各自都有很大的缺陷。我希望他们能够修复这些缺陷。我相信，我们可以有一个国家，其财富主要是通过新的经济活动而不是通过继承来创造的；建造新的住房，而不是允许现有居民否决建筑；该国政府愿意考虑应该启动的新项目，而不是让预算自动执行。我认为我们不必在行业和互联网之间进行选择；我们的国家既可以拥有蓬勃发展的工业部门，也可以拥有蓬勃发展的互联网部门。</p>
<h3 id="发展是硬道理"><a href="#发展是硬道理" class="headerlink" title="发展是硬道理"></a>发展是硬道理</h3><p><strong>发展是唯一的硬道理（或经济增长的社会后果）。</strong>如果一个人在一个低增长的社会中生活了太长时间，那么就很容易忽视经济增长的好处。在我所读的大多数评论中，接受低速经济增长是隐藏的前提。我认为这是当今美国和欧洲知识社会中最深的偏见：它几乎遍及所有话题，从博客文章和畅销书到电影和流行歌曲。我发现没有比经济增长太低的普遍沮丧更加激进和令人耳目一新的话题。</p>
<p>我希望更多的人认为经济高速增长会产生重大的积极影响。当人们经历了几年的高增长之后，他们就有条件期望更多的增长。这种期望增加了公司和个人的风险偏好：在过去的40年中，人们已经看到自己的生活以一百种不同的方式变得越来越好，并且他们对更多的事情会有所改善感到乐观。他们会更乐于创业或尝试新的职业，而这些活动甚至都不会感觉像是冒险活动，因为新的机会一直在不断涌现。</p>
<p>所有这些都是基于以下事实：更高的增长提高了我们处理各种问题的能力。如果我们习惯了低增长，那么除非我们能够强迫财富重新分配，否则很难想象我们的生活会得到重大改善。但是，如果几十年来我们经历了高收入增长，那么就更容易想象我们可以解决我们的问题，因为我们不断积累更多的资源来解决这些问题。</p>
<p>对于企业来说，情况也是一样，因为他们希望明年的需求会比今天更大，因此他们有胆量去扩展和尝试新事物。我认为这些原则对于硅谷的公司很清楚，因为硅谷的公司高管根据六个月的预期职位而不是当前职位做出决策。我怀疑增长的历史也会对政府政策产生积极影响。它鼓励政府参与长期规划，因为立法者已经看到情况会好转，并期望有更大的回旋余地。</p>
<p>布赖恩·卡普兰（Bryan Caplan）的<a target="_blank" rel="noopener" href="http://www.econlib.org/library/Columns/y2004/Caplanidea.html">想法陷阱</a>为这种<a target="_blank" rel="noopener" href="http://www.econlib.org/library/Columns/y2004/Caplanidea.html">观点</a>提供了帮助，在撰写原始作品时我并不陌生。我发现卡普兰的想法引人注目，它影响了我的世界基线模型。低增长的国家将继续停滞不前，因为经济僵化是自我强化。高增长的国家将继续增长，因为活力是自我增强的。后者将拥有乐观的人，而前者将变得<a target="_blank" rel="noopener" href="https://danwang.co/the-complacent-class-tyler-cowen/">自满</a>。</p>
<p>反乌托邦的科幻小说是停滞增长的自然产物。难怪过去几十年来出版的许多科幻小说是如此惨淡。当数字技术加速发展但我们无能为力时，我们还能期待什么呢？如果更好的商店和更多的潮人咖啡馆是人们面对物理变化的唯一机会，那么很难想象未来会发生怎样的根本变化。另一方面，如果城市每十年重新划分自己的地盘并重塑自己，那么期待变化就容易得多。</p>
<p>我给美国，日本和欧洲选民的信息是，请<a target="_blank" rel="noopener" href="https://www.amazon.com/Stubborn-Attachments-Tyler-Cowen/dp/1732265135/">消除</a>对低速经济增长的这种冷漠态度。除了认真讨论如何实现GDP的持续增长之外，似乎您可以在任何政治问题上激怒选民。选举能够提出一项计划以实现GDP增长3％并维持几十年的领导人怎么样？不幸的是，甚至连卡普兰都不确定如何摆脱想法陷阱，因为他说打破这种平衡的唯一方法是“运气”。</p>
<h3 id="乐观是增长的推动力"><a href="#乐观是增长的推动力" class="headerlink" title="乐观是增长的推动力"></a>乐观是增长的推动力</h3><p><strong>乐观是增长的推动力（或者，更多的行业而更少的Twitter）。</strong>我不想挥舞着声称增长归结为运气，而是想以另一种方式挥舞着双手，并说要归结为乐观。我承认论点是圆滑的，因为乐观情绪可能是增长的内生因素。但是我建议，乐观主义也可能是由于接近行业，更多地享受科幻小说以及避免使用Twitter和政治。</p>
<p>我希望我们更多的人<a target="_blank" rel="noopener" href="https://amzn.to/2A4BNnv">学习30年代</a>，这个十年见证了美国人的创造力在机械改进方面的系统应用。那是在化学，橡胶，电机，科学仪器和许多其他事物上取得飞跃发展的时期。在过去的十年中，“技术”指的是航空，无线电，石油开采，电影院等领域的进步。人们认为技术在许多方面（不仅是少数几个方面）正在加速发展是多么令人耳目一新。</p>
<p>1939年是纽约世界博览会的一年。巨大的生产量鼓励人们去想象工业技术的前景，并思考未来将如何比过去更好。阅读Futurama展览的一些<a target="_blank" rel="noopener" href="https://www.believermag.com/issues/201205/?read=article_szerlip">报道</a>很有趣：“由通用汽车赞助700万美元，相当于今天的9,100万美元，它是有史以来最大的动画模型：35,738平方英尺。它需要约三千名木匠，电工，制图员和模型制作者的劳动，以及五十万个规模不等的微型建筑物的制造，以及五万辆未来派的银色汽车，其中有上万辆设计用于移动。</p>
<p>我认为，当我们决定取笑<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=PSxihhBzCjk">塑料制品</a>并随后庆祝华尔街时，美国文化发生了错误的转变。塑料是非同寻常的，但是我们顶尖大学的毕业生对加入投资银行的热情要高得多，而不是提高我们对材料的掌握程度。如果我们将优秀人才视为稀缺资源，那么我认为很遗憾资产管理吸引了这么多聪明的年轻人。我不确定改善资本配置是否是我们技术文明的最关键的推动力。从边缘上讲，更直接的改善可能来自于有聪明的人在行业中谋生。</p>
<p>我希望我们更多的人能够更多地接触工业流程。让我们更多地看一下重型机械，化学制品，火箭以及工业界的所有奇迹。还有其他人想订阅有关工业发展的杂志吗？我希望每月出版一次，以采访不同行业的工程师为特色。我们可以了解到当前的技术水平，它们如何到达这里，当前的约束是什么，即将发生的事情以及接下来的推测：如果我们解决了一些大的约束，我们可以取得什么样的进步期待？</p>
<p>这些都是我希望我们更多的人感兴趣的东西。从边缘看，我们应该转移注意力从什么？轻松：Twitter和政治。</p>
<p>我的意思是消除Twitter的愤怒面。Twitter的各个部分确实非常出色，每天我都为追随者在我的摘要中丢弃多少个重要链接而感到惊奇。<a target="_blank" rel="noopener" href="https://twitter.com/danwwang">我鸣叫/转发三件事</a>：信息密集的片段，有趣的图片和好玩的笑话。通常，我会尝试跟随同样的人。偶尔，愤怒的Twitter浪潮会在我的快乐小岛上消失，但这并不常见。</p>
<p>有无数的社会问题令人生气：我们可以整天在Facebook，Reddit或Twitter上争论，就像我们中的某些人一样。我对Twitter可以激起“接管”的愤怒感到惊讶。Twitter的全国性运动是谴责<em>《纽约时报》的</em>专栏作家，任何人都可以在场外玩。我认为我们不必屈服，让大家都知道我们觉得专栏很垃圾，专栏作家很糟糕，而且论文值得整体谴责。我们应该抵制这种<a target="_blank" rel="noopener" href="https://harpers.org/archive/2018/04/forget-about-it/?single=1">趋势</a>，认为大声的推文具有对另一端造成毁灭性打击的能力：“您只会失去一次纯真。”</p>
<p>不管媒体试图说服我们多少，我们大多数人都不需要关注日常的政治事务。让我们把目光转向更具生产力的用途，例如读书和学习技能。在2016年大选之后，我要做的第一件事就是取消订阅<em>《纽约客》</em>；我为自己迅速采取果断行动而感到自豪。像我一样，另一种可能性是离开美国。我知道这不是每个人的选择，但至少对于某些年轻人来说，也许这是度过国外的好时机。当无聊的辩论是周围的国家情绪时，请出去，转而到一个更理智的环境，在这里您可以真正地学到一些东西。</p>
<p>我知道很少有人对物质世界和工业技术充满好奇。我希望我们可以将注意力转向研究它们，而不必关注政治。</p>
<h3 id="优先事项正确的人呢"><a href="#优先事项正确的人呢" class="headerlink" title="优先事项正确的人呢"></a>优先事项正确的人呢</h3><p><strong>优先事项正确的人。</strong>在<a target="_blank" rel="noopener" href="https://danwang.co/definite-optimism-as-human-capital/">上一篇文章中</a>，我广泛引用了尼尔·斯蒂芬森的想法。他的小说强调物质世界的重要性。他相信科幻小说能够激发乐观情绪。我发现Matt Levine是另一位清楚了解数字技术局限性的作家。他的新闻通讯中有许多实例说明现实世界是如何混乱的，并且不能完全将其视为 <a target="_blank" rel="noopener" href="https://www.bloomberg.com/view/articles/2018-05-15/cbs-wants-to-get-rid-of-a-shareholder">财务</a>或 <a target="_blank" rel="noopener" href="https://www.bloomberg.com/view/articles/2017-04-20/juice-machines-and-red-flags">数字</a>抽象。</p>
<p>以下是我要强调的其他人，因为他们有适当的优先事项。他们每个人都在帮助建立数字世界方面发挥了作用。在完成这项工作之后，他们大多将注意力转移到改善物质世界上。</p>
<p><em>比尔盖茨</em>。微软的联合创始人离开公司后决定将精力集中在什么方面？不是计算机，互联网或移动设备。相反，它是慈善事业，着重于健康，教育和能源。他认为有足够的人致力于数字世界，而他（和他的首都）应该主要尝试改善物质世界。</p>
<p><em>弗里曼·戴森（Freeman Dyson）</em>拥有丰富的想象力，通常他的疯狂想法与数字世界无关。从来没有我不喜欢阅读戴森（Dyson）访谈。<a target="_blank" rel="noopener" href="https://www.wired.com/2014/03/quanta-freeman-dyson-qa/">这</a>是他早期的项目之一：“我们决定，我们将由一枚由核弹驱动的太空船绕太阳系。我们将飞船发射到太空中-“炸弹，炸弹，炸弹，炸弹”，每秒约四枚炸弹-一直上升到火星，然后又到达木星和土星，我们打算自己走。”</p>
<p><em>安迪·格罗夫（Andy Grove）</em>。这位前英特尔首席执行官在晚年成为了美国制造业的拥护者。他在2010年《彭博商业周刊》的一篇文章中阐述了<a target="_blank" rel="noopener" href="https://www.bloomberg.com/news/articles/2010-07-01/andy-grove-how-america-can-create-jobs">他的案情</a>。在这里，我只列出最不完整的摘要：格罗夫（Grove）怀疑初创企业能否提供大量工作；美国应该专注于将初创公司扩大为大公司；而且，当美国出口工作岗位时，它还出口了创新能力和扩展专业知识。换句话说，他对过程知识的丧失感到遗憾。他认识到，当制造业工作岗位离开美国时，“我们打破了经验链，这对技术创新至关重要。”</p>
<p>这是格罗夫的更多内容：“我们对个人业务的追求通常涉及将制造和大量工程转移到国外，这阻碍了我们将创新带入国内规模的能力。如果不扩大规模，我们不仅会失去工作，还会失去对新技术的控制。失去扩展能力最终将损害我们的创新能力。”</p>
<p>格鲁夫在他的论文结尾呼吁重建美国工业共同体。或正如我所说的，重新获得过程知识。大部分内容是由我对半导体行业的学习所推动的，我发现发现业界最重要的人物之一以相似的眼光令人振奋。我很高兴地指出，安迪·格罗夫（Andy Grove），泰勒·科恩（Tyler Cowen）和彼得·泰尔（Peter Thiel）的想法是本文的推动力。</p>
<h3 id="更好的资本配置不会导致技术加速。"><a href="#更好的资本配置不会导致技术加速。" class="headerlink" title="更好的资本配置不会导致技术加速。"></a>更好的资本配置不会导致技术加速。</h3><p><strong>更好的资本配置会始终导致技术加速吗？</strong>我不这么认为。实际上，我认为，过程知识流失的部分责任可以归因于美国金融业，包括投资者和金融分析师，其重点是资本回报率。（这也是Andy Grove提出的。）</p>
<p>我的基本观点是，技术最终会因为人而进步，尤其是因为他们设法积累了很多过程知识。我认为，美国金融部门没有充分认识到拥有大量技术经验丰富的工人的重要性。确定和衡量工具和IP的存量，而不是人们头脑中存在的过程知识，当然要容易得多。结果，投资者和财务分析师系统地奖励了最渴望减少员工人数的公司，他们认为这是成本。但是，仅仅因为我们不能直接测量过程知识，并不意味着我们应该忽略它的存在。</p>
<p>我相信工具和IP是开发过程知识的自然结果。但是，相反的顺序并不成立：仅拥有大量工具和IP并不能保证我们可以创建更多的工具。因此，我对工艺知识的流失感到不安，并敬佩像德国和日本这样的国家，它们一直在保持其工程实践社区的健康。</p>
<p><strong>这些观点有哪些挑战？</strong>我想保留过程知识，因为我认为这对于增长和构建未来的工业技术很重要。我也承认，我的论点面临许多挑战。以下是一些我觉得最有趣的内容。</p>
<p><em>德国制造业工人的数量也在下降</em>。是的，德国制造业的雇员人数也在下降（请参阅<a target="_blank" rel="noopener" href="https://www-genesis.destatis.de/genesis/online/data;jsessionid=CF7194DC417A91F63D99BEF7F37C5F00.tomcat_GO_2_1?operation=ergebnistabelleUmfang&levelindex=2&levelid=1531651280340&downloadname=42111-0004">统计信息</a>以及<a target="_blank" rel="noopener" href="https://www.vox.com/the-big-idea/2017/1/24/14363148/trade-deals-nafta-wto-china-job-loss-trump">Brad DeLong文章中</a>的图表）。这是否表明我最喜欢的国家也没有保留其工程实践社区？我想说几句话，它保存了它们。首先，尽管美国制造业的实际产出仍低于2008年的水平，但<a target="_blank" rel="noopener" href="https://fred.stlouisfed.org/series/DEUPROMANMISMEI">德国的实际制造业产出</a>已大大超过衰退前的水平，并已恢复到长期的增长趋势。如果我们看看遭受<a target="_blank" rel="noopener" href="https://www-genesis.destatis.de/genesis/online/data;jsessionid=CF7194DC417A91F63D99BEF7F37C5F00.tomcat_GO_2_1?operation=ergebnistabelleUmfang&levelindex=2&levelid=1531651280340&downloadname=42111-0004">失业</a>的行业，我们可以看到它们集中在采矿和纺织品生产等低价值行业；在过去十年中，德国在化学，汽车，机械和电气设备等高价值领域<em>获得了</em>就业。深入研究数据使我对德国以正确的方式做出反应的主张更加自信，因为它通过减少不太可能在过程知识中获得重大收益的工作，并继续在价值链中向上发展。</p>
<p><em>非物质化</em>。我记得读过Scott Sumner的一篇文章，概述了我们不再对物理事物感兴趣的所有方式。萨姆纳（Sumner）多产，我找不到职位了；我只记得他提供了许多例子，这些例子表明年轻人对经验的兴趣比对拥有东西的兴趣更大。（如果有人可以通过电子邮件将该帖子发送给我，我很乐意在此处链接。<em>更新</em>：该帖子在<a target="_blank" rel="noopener" href="https://www.econlib.org/archives/2016/10/non-materialist.html">这里</a>。）如果确实是这样，我们对通过音乐会和异国情调确立地位更加感兴趣休假，那么我们可能无法满足维持不断增长的工业基础所需的总需求。</p>
<p><em>大多数过程知识已经嵌入到工具中了吗？</em>我最近读过的最好的论文之一是Willy Shih，他<a target="_blank" rel="noopener" href="http://sloanreview.mit.edu/article/why-high-tech-commoditization-is-accelerating">主张</a>是肯定的。我建议阅读全文，该文章是本文的提示之一。我不确定是否容易引用任何汇总统计数据来试图反驳它，但是我可以提出一些建议。我认为目前还不是每个人都能有效使用最新工具的情况。我们看到半导体，航空和互联网领域的公司主要集中在少数几个国家。与此相关，国家间的收入继续<a target="_blank" rel="noopener" href="https://marginalrevolution.com/marginalrevolution/2018/07/technology-arrived-everywhere-income-diverged.html">分化</a>即使有足够资本的公司也可以购买相同的先进机械。这些事实表明，某些国家比其他国家更有效地使用工具，这可能是因为它们拥有更多的过程知识。</p>
<p>我很高兴地认识到，还有许多尚未解决的挑战。我并不是说我已经确定了哪些行业应该得到更好的发展，什么时候应该放开一个非生产性行业。如果我认为合理的业务决策摆脱了流程知识，那么批判它可能是错误的。我的文章的目的是要求更多的人考虑过程知识的增长方式，并建议我们应该在更多的方面推动技术前沿。</p>
<p><strong>作为人力资本的绝对乐观。</strong>我想通过回到半导体来解决这一问题。我相信技术进步不是不可避免的，并且我们有力地推动技术进步。每24个月使晶体管密度增加一倍，并不是天生的恩典，这是天生的恩赐。除非我们对此有所考虑，否则这种进展不会发生。摩尔定律不是一个承诺，而是一个挑战，到目前为止，我们已经很好地实现了。</p>
<p>有一天，我们可以举起手来宣布我们已经在半导体领域进行了足够的创新。“相反，未来是服务，而不是这种有毒的制造工作。”我们可以解雇所有书呆子，扔掉他们所有的书，并关闭所有这些工厂。假设我们要花几年的时间才能恢复常识。当我们随后想要振兴该行业时，它可能不像插入机器，清除蓝图上的灰尘，然后高兴地期望生产恢复到先前的水平那样简单。这些工程师所获得的来之不易的过程知识将逐渐消失，而工人将不得不重新学习一堆东西。</p>
<p>我认为过程知识的这种衰退已经发生在许多行业。在德国，情况并非完全如此（尽管它有自己的问题）。当我与德国人谈论工业时，他们宣称他们对去工业化保持警惕。他们说工程学是德国人身份的一部分，他们不太可能轻易放弃。我发现这是一件令人难以置信的事情。让我们再看一看英国，它似乎已经做出了一个有意识的 <a target="_blank" rel="noopener" href="http://news.mit.edu/2018/faculty-profile-john-van-reenen-0108">决定</a>，即它将不再从事工业生产：国家的工业部门。1980年代政府对研发的大量支持被取消，这种情况进一步恶化。如果我们愿意的话，很容易让行业下滑。</p>
<p>我希望我们更多的人 <a target="_blank" rel="noopener" href="https://patrickcollison.com/labs">学习生产网络</a>。这意味着更多地考虑系统。健康的生态系统很难维护，但是如果您构建它们并继续为其注入活力，它们将带来持续的突破。服务和技术等<a target="_blank" rel="noopener" href="https://www.nytimes.com/2018/07/09/opinion/supreme-court-conservative-republicans.html">法律</a>行业的人们可以很好地掌握这些生产系统 ; 我希望我们也可以从这些角度考虑工业基础。</p>
<p>我不认为互联网不过是令人惊叹的东西。但是我认为，数字世界的奇迹使人们很难看清其他所有事物的移动速度。许多技术领域都取得了谨慎的进展，但我们忽略了这一点，因为我们的手机使我们如此。当我们的物理世界停滞不前时，我们的应用程序会不断完善；我认为，消费者互联网的奇迹使我们迷惑了我们的技术基础有多强大。</p>
<p><a target="_blank" rel="noopener" href="https://danwang.co/why-is-peter-thiel-pessimistic-about-technological-innovation/">彼得·泰尔</a>（ <a target="_blank" rel="noopener" href="https://danwang.co/why-is-peter-thiel-pessimistic-about-technological-innovation/">Peter Thiel）</a>：“第一步是了解我们的位置。我们已经在沙漠中流浪了40年，我们认为这是一片迷人的森林。如果我们要找到一条摆脱沙漠和通往未来的道路，那么第一步就是要看到我们已经进入了沙漠。”</p>
<p>可能的后果之一是，过去几十年来出版的许多科幻小说都趋向于网络朋克反乌托邦。（<a target="_blank" rel="noopener" href="https://danwang.co/liu-cixins-three-body/">三体问题</a>是一个例外。）我们在城市的自然景观中看不到太多变化，相反，我们得到了传感器，信息和屏幕的大量增加。相比之下，50年代和60年代的科幻小说更为乐观。那是太空时代，那时我们正忙于重塑物理世界，到那时，30年代的工业成就已使他们显而易见。产业的深入发展导致人们对科幻小说持乐观态度，而数字扩散则将其推向反乌托邦。</p>
<p>1939年世界博览会上的Futurama展览非常受欢迎：人们认为该展览的科幻技术确实会在1960年出现。但是随后人们开始降低期望值。这是一<a target="_blank" rel="noopener" href="https://amzn.to/2A4BNnv">本</a>关于30年代技术<a target="_blank" rel="noopener" href="https://amzn.to/2A4BNnv">的书</a>的摘录：“ 25年后，通用汽车试图用新的未来世界来复制其早期的成功，展望了25年甚至更久……它无法捕捉大众的想象力，并且它对未来的预测已远远超出了预期。这两个标题相似的展品形成鲜明对比，这与总体数据和行业数据试图告诉我们的是一致的。”</p>
<p>我希望我们恢复乐观。仅仅告诉每个人还不够：“仅仅选择保持乐观。”相反，我建议我们可以通过对工业的更大理解以及实现更高的经济增长来培养乐观情绪。推进技术前沿不应该仅仅是别人的问题。取而代之的是，如何做到这一点应该让我们更多的人关注。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/16/google_hacking_introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/16/google_hacking_introduction/" class="post-title-link" itemprop="url">Google Hacking Introduction</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-16 20:27:57" itemprop="dateCreated datePublished" datetime="2020-01-16T20:27:57-05:00">2020-01-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、Google-Hacking介绍"><a href="#一、Google-Hacking介绍" class="headerlink" title="一、Google Hacking介绍"></a>一、Google Hacking介绍</h2><p>Google是一个伟大的信息收集工具，在如今的互联网时代，想想看一个人可以轻易的从搜索引擎中获取你详细的个人信息是件多么叫人激动又害怕的事情？Google也可以当作我们的第二个“社工库”。</p>
<p>搜索引擎的组成：</p>
<ul>
<li>爬行器（机器人、蜘蛛）</li>
<li>索引生成器</li>
<li>查询检索器</li>
</ul>
<h2 id="二、Google-Hacking基本搜索"><a href="#二、Google-Hacking基本搜索" class="headerlink" title="二、Google Hacking基本搜索"></a>二、Google Hacking基本搜索</h2><p>Intext 搜索出现的关键词</p>
<p>Inurl 搜索包含关键词的url</p>
<p>Intitle 搜索包含关键词的标题</p>
<p>Site 搜索包含关键词的站点</p>
<p>filetype 搜索包含关键词的文件类型</p>
<p>Link 对于页面包含的外部链接搜索</p>
<p>Daterange 搜索特定的日期范围</p>
<h2 id="三、Google搜索基本规则"><a href="#三、Google搜索基本规则" class="headerlink" title="三、Google搜索基本规则"></a>三、Google搜索基本规则</h2><p>Google 不分大小写</p>
<p>Google 可以使用通配符：*表示一个词/字</p>
<p>Google 会智能地保留一些内容，比如一些过时的词，一些不适合呈现的内容（比如违法信息）</p>
<p>最常用的：”关键字” ，双引号会使Google强制搜索包含关键字的内容</p>
<p>布尔操作符：AND(+) 、NOT(-) 、OR(|)，AND 现在已不需要，多个关键字google会都匹配到</p>
<h2 id="四、Google-Hacking常用语法"><a href="#四、Google-Hacking常用语法" class="headerlink" title="四、Google Hacking常用语法"></a>四、Google Hacking常用语法</h2><p><strong>1、搜索标题</strong></p>
<p>标题一般是一个网站内容的高度概括，比如后台登陆？WEBSHELL？例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intitle:&quot;Java &quot; [ Sec. Info ], [ Files ], [ Console ], [ Sql ], [ Php ], [ Safe mode ], [ String tools ], [ Bruteforce ], [ Network ], [ Self remove ] </span><br></pre></td></tr></table></figure>



<p><strong>2、搜索正文</strong></p>
<p>正文的话就各式各样了，试试login?、admin?、内容编辑？往往会有意想不到的收获。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intitle:&quot;index&quot; intext:&quot;Login to the Administrative Interface&quot;</span><br></pre></td></tr></table></figure>



<p><strong>3、关键网站/网址的搜索</strong></p>
<p>网站-&gt;site:</p>
<p>网址-&gt;inurl:</p>
<p>site：往往我们在对一个大型厂商进行测试时，除了利用工具进行域名爆破，还可以通过Google来帮助，例如site:qq.com；</p>
<p>inurl：是In-系指令中最强大的一个，换句话说，这个高级指令能够直接从网站的URL入手挖掘信息，只要略微了解普通网站的URL格式，就可以极具针对性地找到你所需要的资源，甚至隐藏内容。网站构建者通常将某一类信息集中在一个网站的目录中，所以搜索URL中的词本身就是对某一方面内容的一个限定。如果在加上一定的词进行组配，搜索结果将更贴近需求。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.com inurl:phpmyadmin&#x2F;index.php &amp; (intext:username &amp; password &amp; &quot;Welcome to&quot;)</span><br></pre></td></tr></table></figure>



<p><strong>4、文档类型的搜索</strong></p>
<p>filetype 爱查资料的人应该不陌生，当它配合上我们其他的关键词时有意思的东西可能就会出现。</p>
<p>目标文件类型：.pwl口令文件、.tmp临时文件、.cfg配置文件、.ini系统文件、.hlp帮助文件、.dat数据文件、.log日志文件、.par交换文件</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype:sql site:com and &quot;insert into&quot; admin &quot;2014&quot;</span><br></pre></td></tr></table></figure>



<p>文档示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Filetype:xls username password email</span><br><span class="line">Filetype:xls inurl: “password.xls”</span><br><span class="line">Filetype;xls private</span><br><span class="line">Inurl:admin filetype:xls</span><br><span class="line">Filetype:xls inurl:contact</span><br><span class="line">Filetype:xls inurl: “email.xls”</span><br><span class="line">Allinurl:admin mdb</span><br><span class="line">Filetype:mdb inurl:users.mdb</span><br><span class="line">Inurl:email filetype:mdb</span><br><span class="line">Inurl:backup filetype:mdb</span><br><span class="line">Inurl:profiles filetype:mdb</span><br><span class="line">Inurl:*db filetype:mdb</span><br></pre></td></tr></table></figure>



<p>SQL数据库示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nurl:nuke filetype:sql</span><br><span class="line">Filetype:sql password</span><br><span class="line">Filetype:sql “indetified by” –cvs</span><br><span class="line">“#dumping data for table username user users password”</span><br><span class="line">“#mysql dump” filetype:sql</span><br><span class="line">“#phpmyadmin mysql-dump” filetype:txt</span><br><span class="line">“#phpmyadmin mysql-dump”</span><br><span class="line">“insert into” –”the</span><br></pre></td></tr></table></figure>



<p>数据库文件示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filetype:cfm “cfapplication name ” password</span><br><span class="line">Filetype:mdb inurl:user.mdb</span><br><span class="line">Inurl:email filetype:mdb</span><br><span class="line">Inurl:forum filetype:mdb</span><br><span class="line">Inurl:&#x2F;db&#x2F;main.mdb</span><br><span class="line">Inurl:profiles filetype:mdb</span><br><span class="line">Filetype:asp dbq&#x3D;”* server.mappath(“mdb”)”</span><br><span class="line">Allinurl;admin mdb</span><br></pre></td></tr></table></figure>



<p><strong>5、link搜索</strong></p>
<p>link: 可以得到一个所有包含了某个指定URL的页面列表；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms</span><br><span class="line">查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username</span><br><span class="line">查找可注入点：site:域名 inurl:aspx|jsp|php|asp</span><br><span class="line">查找上传漏洞：site:域名 inurl:file|load|editor|Files</span><br><span class="line">查找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit</span><br><span class="line">查找存在的数据库：site:域名 filetype:mdb|asp|#</span><br><span class="line">查看脚本类型：site:域名 filetype:asp&#x2F;aspx&#x2F;php&#x2F;jsp</span><br><span class="line">迂回策略入侵：inurl:cms&#x2F;data&#x2F;templates&#x2F;images&#x2F;index&#x2F;</span><br></pre></td></tr></table></figure>



<p>各种敏感数据收集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filetyle:xls inurl:gov username passwordinurl:phpmyadmin&#x2F;main.php </span><br><span class="line">intitle:phpmyadminfiletype:inc inurl:config.inc hostfiletype:sql cdb_members </span><br><span class="line">inurl:forumdatafiletype:txt inurl:&quot;新建文本文档.txt&quot;密码inurl:phpinfo.php </span><br><span class="line">intitle:&quot;phpinfo()&quot;&quot;PHP Version&quot;+&quot;Server API&quot;filetype:log inurl:log mdb</span><br></pre></td></tr></table></figure>



<p><strong>6、缓存、快照搜索</strong></p>
<p>没有突破口时，缓存可能是一大杀器。通过爬虫，快照，在管理者不经意的情况下记录下敏感信息。</p>
<p>案例：</p>
<p>曾经碰到过一个学生可能都比较熟悉的名为教育技术服务平台的信息泄露，它们无意中把自己gitlab公开在外网，当然没有任何防范爬虫的措施，虽然设有登陆密码但是可以通过google快照来查看里面的各种敏感代码。</p>
<p><strong>如何访问谷歌的缓存链接？</strong></p>
<ol>
<li>在你的计算机上，使用 Google 搜索查找所需网页。</li>
<li>点击相应网站网址右侧的绿色向下箭头。</li>
<li>点击<strong>网页快照</strong>。</li>
<li>打开缓存版页面后，点击“当前页”链接即可返回实际页面。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/" class="post-title-link" itemprop="url">软件设计杂谈</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 21:33:19" itemprop="dateCreated datePublished" datetime="2020-01-15T21:33:19-05:00">2020-01-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在如今这个Lean/Agile横扫一切的年代，设计似乎有了被边缘化的倾向，做事的周期如此之快，似乎已容不下人们更多的思考。MVP（Minimal Viable Produce）在很多团队里演化成一个形而上的图腾，于是工程师们找到了一个完美的借口：我先做个MVP，设计的事，以后再说。</p>
<p>如果纯属个人玩票，有个点子，hack out还说得过去；但要严肃做一个项目，还是要下工夫设计一番，否则，没完没了的返工会让你无语泪千行。</p>
<h3 id="设计首先得搞懂要解决的问题"><a href="#设计首先得搞懂要解决的问题" class="headerlink" title="设计首先得搞懂要解决的问题"></a>设计首先得搞懂要解决的问题</h3><p>工程师大多都是很聪明的人，聪明人有个最大的问题就是自负。很多人拿到一个需求，还没太搞明白其外延和内涵，代码就已经在脑袋里流转。这样做出来的系统，纵使再精妙，也免不了承受因需求理解不明确而导致的返工之苦。</p>
<p>搞懂需求这事，说起来简单，做起来难。需求有正确的但表达错误的需求，有正确的但没表达出来的需求，还有过度表达的需求。所以，拿到需求后，先不忙寻找解决方案，多问问自己，工作伙伴，客户follow up questions来澄清需求模糊不清之处。</p>
<p>搞懂需求，还需要了解需求对应的产品，公司，以及（潜在）竞争对手的现状，需求的上下文，以及需求的约束条件。人有二知二不知：</p>
<ol>
<li>I know that I know</li>
<li>I know that I don’t know</li>
<li>I don’t know that I know</li>
<li>I don’t know that I don’t know</li>
</ol>
<p>澄清需求的过程，就是不断驱逐无知，掌握现状，上下文和约束条件的过程。</p>
<p>这个主题讲起来很大，且非常重要，但毕竟不是本文的重点，所以就此带过。</p>
<h3 id="寻找（多个）解决方案"><a href="#寻找（多个）解决方案" class="headerlink" title="寻找（多个）解决方案"></a>寻找（多个）解决方案</h3><p>如果对问题已经有不错的把握，接下来就是解决方案的发现之旅。这是个考察big picture的活计。同样是满足孩子想要个汽车的愿望，你可以：</p>
<ol>
<li>去玩具店里买一个现成的</li>
<li>买乐高积木，然后组装</li>
<li>用纸糊一个，或者找块木头，刻一个</li>
</ol>
<p>这对应软件工程问题的几种解决之道：</p>
<ol>
<li>购买现成软件（acuquire or licensing），二次开发之（如果需要）</li>
<li>寻找building blocks，组装之（glue）</li>
<li>自己开发（build from scratch, or DIY）</li>
</ol>
<p>大部分时候，如果a或b的Totacl Cost合理，那就不要选择c。做一个产品的目的是为客户提供某种服务，而不是证明自己能一行行码出出来这个产品。</p>
<p>Money是个很重要的点，可惜大部分工程师脑袋里没有钱的概念，或者出于job security的私心，而忽略了。工程师现在越来越贵，能用合理的价格搞定的功能，就不该雇人去打理（自己打脸）。一个产品，最核心的部分不超过整个系统的20%，把人力资源铺在核心的部分，才是软件设计之道。</p>
<p>对工程师而言，DIY出一个功能是个极大的诱惑。一种DIY是源自工程师的不满。任何开源软件，在处理某种特定业务逻辑的时候总会有一些不足，眼里如果把这些不足放在，却忽略了人家的好处，是大大的不妥。前两天我听到有人说 “consul sucks, …, I’ll build our own service discovery framework…”，我就苦笑。我相信他能做出来一个简单的service discovery tool，这不是件特别困难的事情。问题是值不值得去做。如果连处于consul这个层次的基础组件都要自己去做，那要么是心太大，要么是没有定义好自己的软件系统的核心价值（除非系统的核心价值就在于此）。代码一旦写出来，无论是5000行还是50行，都是需要有人去维护的，在系统的生命周期里，每一行自己写的代码都是一笔债务，需要定期不定期地偿还利息。</p>
<p>另外一种DIY是出于工程师的无知。「无知者无畏」在某些场合的效果是正向的，有利于打破陈规。但在软件开发上，还是知识和眼界越丰富越开阔越好。一个无知的工程师在面对某个问题时（比如说service discovery），如果不知道这问题也许有现成的解决方案（consul），自己铆足了劲写一个，大半会有失偏颇（比如说没做上游服务的health check，或者自己本身的high availability），结果bug不断，辛辛苦苦一个个都啃下来，才发现，自己走了很多弯路，费了大半天劲，做了某个开源软件的功能的子集。当然，对工程师而言，这个练手的价值还是很大的，但对公司来说，这是一笔沉重的无意义的支出。</p>
<p>眼界定义了一个人的高度，如果你每天见同类的人，看同质的书籍/视频，（读）写隶属同一domain的代码，那多半眼界不够开阔。互联网的发展一日千里，变化太快，如果把自己禁锢在一方小天地里，很容易成为陶渊明笔下的桃花源中人：乃不知有汉，无论魏晋。</p>
<h3 id="构建灵活且有韧性的系统"><a href="#构建灵活且有韧性的系统" class="headerlink" title="构建灵活且有韧性的系统"></a>构建灵活且有韧性的系统</h3><p>如果说之前说的都是废话，那么接下来的和真正的软件设计能扯上些关系。</p>
<h4 id="分解和组合"><a href="#分解和组合" class="headerlink" title="分解和组合"></a>分解和组合</h4><p>软件设计是一个把大的问题不断分解，直至原子级的小问题，然后再不断组合的过程。这一点可以类比生物学：原子（keyword/macro）组合成分子（function），分子组合成细胞（module/class），细胞组合成组织（micro service），组织组合成器官（service），进而组合成生物（system）。</p>
<p>一个如此组合而成系统，是满足关注点分离（Separation of Concerns）的。大到一个器官，小到一个细胞，都各司其职，把自己要做的事情做到极致。心脏不必关心肾脏会干什么，它只需要做好自己的事情：把新鲜血液通过动脉排出，再把各个器官用过的血液从静脉回收。</p>
<p>分解和组合在软件设计中的作用如此重要，以至于一个系统如果合理分解，那么日后维护的代价就要小得多。同样讲关注点分离，不同的工程师，分离的方式可能完全不同。但究其根本，还有有一些规律可循。</p>
<h4 id="总线（System-Bus）"><a href="#总线（System-Bus）" class="headerlink" title="总线（System Bus）"></a>总线（System Bus）</h4><p>首先我们要把系统的总线定义出来。人体的总线，大的有几条：血管（动脉，静脉），神经网络，气管，输尿管。它们有的完全负责与外界的交互（气管，输尿管），有的完全是内部的信息中枢（血管），有的内外兼修（神经网络）。</p>
<p>总线把生产者和消费者分离，让彼此互不依赖。心脏往外供血时，把血压入动脉血管就是了。它并不需要知道谁是接收者。</p>
<p>同样的，回到我们熟悉的计算机系统，CPU访问内存也是如此：它发送一条消息给总线，总线通知RAM读取数据，然后RAM把数据返回给总线，CPU再获取之。整个过程中CPU只知道一个内存地址，毋须知道访问的具体是哪个内存槽的哪块内存 —— 总线将二者屏蔽开。</p>
<p>学过计算机系统的同学应该都知道，经典的PC结构有几种总线：数据总线，地址总线，控制总线，扩展总线等；做过网络设备的同学也都知道，一个经典的网络设备，其软件系统的总线分为：control plane和data plane。</p>
<h4 id="路由（routing）"><a href="#路由（routing）" class="headerlink" title="路由（routing）"></a>路由（routing）</h4><p>有了总线的概念，接下来必然要有路由。</p>
<p>每一处分叉，就涉及到一次路由。</p>
<p>路由分为外部路由和内部路由。外部路由处理输入，把不同的输入dispatch到系统里不同的组件。做web app的，可能没有意识到，但其实每个web framework，最关键的组件之一就是<strong>url dispatch</strong>。HTTP的伟大之处就是每个request，都能通过url被dispatch到不同的handler处理。而url是目录式的，可以层层演进 —— 就像分形几何，一个大的系统，通过不断重复的模式，组合起来 —— 非常利于系统的扩展。遗憾的是，我们自己做系统，对于输入既没有总线的考量，又无路由的概念，if-else下去，久而久之，代码便绕成了意大利面条。</p>
<p>再举一例：DOM中的event bubble，在javascript处理起来已然隐含着路由的概念。你只需定义当某个事件（如onclick）发生时的callback函数就好，至于这事件怎么通过eventloop抵达回调函数，无需关心。好的路由系统剥茧抽丝，把繁杂的信息流正确送到处理者手中。</p>
<p>外部路由总还有「底层」为我们完成，内部路由则需工程师考虑。service级别的路由（数据流由哪个service处理）可以用consul等service discovery组件，service内部的路由（数据流到达后怎么处理）则需要自己完成。路由的具体方式有很多种，pattern matching最为常见。</p>
<p>无论用何种方式路由，数据抵达总线前为其定义Identity(ID)非常重要，你可以管这个过程叫data normalization，data encapsulation等，总之，一个消息能被路由，需要有个用于路由的ID。这ID可以是url，可以是一个message header，也可以是一个label（想象MPLS的情况）。当我们为数据赋予一个个合理的ID后，如何路由便清晰可见。</p>
<h4 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h4><p>对于那些并非需要立即处理的数据，可以使用队列。队列也有把生产者和消费者分离的功效。队列有：</p>
<ul>
<li>single producer single consumer（SPSC）</li>
<li>single producer multiple consumers（SPMC）</li>
<li>multiple producers single consumer（MPSC）</li>
<li>multiple producers multiple consumers（MPMC）</li>
</ul>
<p>仔细想想，队列其实就是总线+路由（可选）+存储的一个特殊版本。一般而言，system bus之上是系统的各个service，每个service再用service bus（或者queue）把micro service chain起来，然后每个micro service内部的组件间，再用queue连接起来。</p>
<p>有了队列，有利于提高流水线的效率。一般而言，流水线的处理速度取决于最慢的组件。队列的存在，让慢速组件有机会运行多份，来弥补生产者和消费者速度上的差距。</p>
<h4 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h4><p>存储在队列中的数据，除路由外，还有一种处理方式：pub/sub。和路由相似，pub/sub将生产者和消费者分离；但二者不同之处在于，路由的目的地由路由表中的表项控制，而pub/sub一般由publisher控制 [2]：任何subscribe某个数据的consumer，都会到publisher处注册，publisher由此可以定向发送消息。</p>
<h4 id="协议（protocol）"><a href="#协议（protocol）" class="headerlink" title="协议（protocol）"></a>协议（protocol）</h4><p>一旦我们把系统分解成一个个service，service再分解成micro service，彼此之间互不依赖，仅仅通过总线或者队列来通讯，那么，我们就需要协议来定义彼此的行为。协议听起来很高大上，其实不然。我们写下的每个function（或者每个class），其实就是在定义一个不成文的协议：function的arity是什么，接受什么参数，返回什么结果。调用者需严格按照协议调用方能得到正确的结果。</p>
<p>service级别的协议是一份SLA：服务的endpoint是什么，版本是什么，接收什么格式的消息，返回什么格式的消息，消息在何种网络协议上承载，需要什么样的authorization，可以正常服务的最大吞吐量（throughput）是什么，在什么情况下会触发throttling等等。</p>
<p>头脑中有了总线，路由，队列，协议等这些在computer science 101中介绍的基础概念，系统的分解便有迹可寻：面对一个系统的设计，你要做的不再是一道作文题，而是一道填空题：在若干条system bus里填上其名称和流进流出的数据，在system bus之上的一个个方框里填上服务的名称和服务的功能。然后，每个服务再以此类推，直到感觉毋须再细化为止。</p>
<h3 id="组成系统的必要服务"><a href="#组成系统的必要服务" class="headerlink" title="组成系统的必要服务"></a>组成系统的必要服务</h3><p>有些管理性质的服务，尽管和业务逻辑直接关系不大，但无论是任何系统，都需要考虑构建，这里罗列一二。</p>
<h4 id="代谢（sweeping）"><a href="#代谢（sweeping）" class="headerlink" title="代谢（sweeping）"></a>代谢（sweeping）</h4><p>一个活着的生物时时刻刻都进行着新陈代谢：每时每刻新的细胞取代老的细胞，同时身体中的「垃圾」通过排泄系统排出体外。一个运转有序的城市也有新陈代谢：下水道，垃圾场，污水处理等维持城市的正常功能。没有了代谢功能，生物会凋零，城市会荒芜。</p>
<p>软件系统也是如此。日志会把硬盘写满，软件会失常，硬件会失效，网络会拥塞等等。一个好的软件系统需要一个好的代谢系统：出现异常的服务会被关闭，同样的服务会被重新启动，恢复运行。</p>
<p>代谢系统可以参考erlang的supervisor/child process结构，以及supervision tree。很多软件，都运行在简单的supervision tree模式下，如nginx。</p>
<h4 id="高可用性（HA）"><a href="#高可用性（HA）" class="headerlink" title="高可用性（HA）"></a>高可用性（HA）</h4><p>每个人都有两个肾。为了apple watch卖掉一个肾，另一个还能保证人体的正常工作。当然，人的两个肾是Active-Active工作模式，内部的肾元（micro service）是 N(active)+M(backup) clustering 工作的（看看人家这service的做的），少了一个，performance会一点点有折扣，但可以忽略不计。</p>
<p>大部分软件系统里的各种服务也需要高可用性：除非完全无状态的服务，且服务重启时间在ms级。服务的高可用性和路由是息息相关的：高可用性往往意味着同一服务的冗余，同时也意味着负载分担。好的路由系统（如consul）能够对路由至同一服务的数据在多个冗余服务间进行负载分担，同时在检测出某个失效服务后，将数据路只由至正常运作的服务。</p>
<p>高可用性还意味着非关键服务，即便不可恢复，也只会导致系统降级，而不会让整个系统无法访问。就像壁虎的尾巴断了不妨碍壁虎逃命，人摔伤了手臂还能吃饭一样，一个软件系统里统计模块的异常不该让用户无法访问他的个人页面。</p>
<h4 id="安保（security）"><a href="#安保（security）" class="headerlink" title="安保（security）"></a>安保（security）</h4><p>安保服务分为主动安全和被动安全。authentication/authorization + TLS + 敏感信息加密 + 最小化输入输出接口可以算是主动安全，防火墙等安防系统则是被动安全。</p>
<p>继续拿你的肾来比拟 —— 肾脏起码有两大安全系统：</p>
<ol>
<li>输入安全。肾器的厚厚的器官膜，保护器官的输入输出安全 —— 主要的输入输出只能是肾动脉，肾静脉和输尿管。</li>
<li>环境安全。肾器里有大量脂肪填充，避免在撞击时对核心功能的损伤。</li>
</ol>
<p>除此之外，人体还提供了包括免疫系统，皮肤，骨骼，空腔等一系列安全系统，从各个维度最大程度保护一个器官的正常运作。如果我们仔细研究生物，就会发现，安保是个一揽子解决方案：小到细胞，大到整个人体，都有各自的安全措施。一个软件系统也需如此考虑系统中各个层次的安全。</p>
<h4 id="透支保护（overdraft-protection）"><a href="#透支保护（overdraft-protection）" class="headerlink" title="透支保护（overdraft protection）"></a>透支保护（overdraft protection）</h4><p>任何系统，任何服务都是有服务能力的 —— 当这能力被透支时，需要一定的应急计划。如果使用拥有auto scaling的云服务（如AWS），动态扩容是最好的解决之道，但受限于所用的解决方案，它并非万灵药，AWS的auto scaling依赖于load balancer，如Amazon自有的ELB，或者第三方的HAProxy，但ELB对某些业务，如websocket，支持不佳；而第三方的load balancer，则需要考虑部署，与Amazon的auto scaling结合（需要写点代码），避免单点故障，保证自身的capacity等一堆头疼事。</p>
<p>在无法auto scaling的场景最通用的做法是back pressure，把压力反馈到源头。就好像你不断熬夜，最后大脑受不了，逼着你睡觉一样。还有一种做法是服务降级，停掉非核心的service/micro-service，如analytical service，ad service，保证核心功能正常。</p>
<h3 id="把设计的成果讲给别人听"><a href="#把设计的成果讲给别人听" class="headerlink" title="把设计的成果讲给别人听"></a>把设计的成果讲给别人听</h3><p>完成了分解和组合，也严肃对待了诸多与业务没有直接关系，但又不得不做的必要功能后，接下来就是要把设计在白板上画下来，讲给任何一个利益相关者听。听他们的反馈。设计不是一个闭门造车的过程，全程都需要和各种利益相关者交流。然而，很多人都忽视了设计定型后，继续和外界交流的必要性。很多人会认为：我的软件架构，设计结果和工程有关，为何要讲给工程师以外的人听？他们懂么？</p>
<p>其实pitch本身就是自我学习和自我修正的一部分。当着一个人或者几个人的面，在白板上画下脑海中的设计的那一刻，你就会有直觉哪个地方似乎有问题，这是很奇特的一种体验：你自己画给自己看并不会产生这种直觉。这大概是面对公众的焦灼产生的肾上腺素的效果。:)</p>
<p>此外，从听者的表情，或者他们提的听起来很傻很天真的问题，你会进一步知道哪些地方你以为你搞通了，其实自己是一知半解。太简单，太基础的问题，我们take it for granted，不屑去问自己，非要有人点出，自己才发现：啊，原来这里我也不懂哈。这就是破解 “you don’t know what you don’t know” 之法。</p>
<p>记得看过一个video，主讲人大谈企业文化，有个哥们傻乎乎发问：so what it culture literally? 主讲人愣了一下，拖拖拉拉讲了一堆自己都不能让自己信服的废话。估计回头他就去查韦氏词典了。</p>
<p>最后，总有人在某些领域的知识更丰富一些，他们会告诉你你一些你知道自己不懂的事情。填补了 “you know that you don’t know” 的空缺。</p>
<h3 id="设计时的tradeoff"><a href="#设计时的tradeoff" class="headerlink" title="设计时的tradeoff"></a>设计时的tradeoff</h3><p>Rich hickey（clojure作者）在某个演讲中说：</p>
<blockquote>
<p>everyone says design is about tradeoffs, but you need to enumerate at least two or more possible solutions, and the attributes and deficits of each, in order to make tradeoff.</p>
</blockquote>
<p>所以，下回再腆着脸说：偶做了些tradeoff，先确保自己做足了功课再说。</p>
<h3 id="设计的改变不可避免"><a href="#设计的改变不可避免" class="headerlink" title="设计的改变不可避免"></a>设计的改变不可避免</h3><p>设计不是一锤子买卖，改变不可避免。我之前的一个老板，喜欢把 change is your friend 挂在口头。软件开发的整个生命周期，变更是家常便饭，以至于变更管理都生出一门学问。软件的设计期更是如此。人总会犯错，设计总有缺陷，需求总会变化，老板总会指手画脚，PM总有一天会亮出獠牙，不再是贴心大哥，或者美萌小妹。。。所以，据理力争，然后接受必要的改变即可。连凯恩斯他老人家都说：</p>
<blockquote>
<p>When the facts change, I change my mind. What do you do, sir?</p>
</blockquote>
<p>What do you do, sir?</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/14/How-is-computer-programming-different-from-20-years-ago/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/14/How-is-computer-programming-different-from-20-years-ago/" class="post-title-link" itemprop="url">How is computer programming different from 20 years ago</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-14 22:58:49" itemprop="dateCreated datePublished" datetime="2020-01-14T22:58:49-05:00">2020-01-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>Some programming concepts that were mostly theoretical 20 years ago have since made it to mainstream including many functional programming paradigms like <strong>immutability</strong>, <strong>tail recursion</strong>, <strong>lazily evaluated collections</strong>, <strong>pattern matching</strong>, <strong>first class functions</strong> and looking down upon anyone who don’t use them.</li>
<li>A desktop software now means <strong>a web page bundled with a browser</strong>.</li>
<li><strong>Object-Oriented Programming</strong> (OOP) has lost a lot of street credibility although it’<strong>s still probably the most popular programming model</strong>. New trait-based programming models are more pervasive in modern languages like Go, Rust and Swift. <strong>Composition</strong> is preferred over <strong>inheritance</strong>.</li>
<li>You are not officially considered a programmer anymore until you attend a <strong>$2K conference</strong> and share a <strong>selfie</strong> from there.</li>
<li>Because of the immense proliferation of multi-processor CPUs, <strong>parallel</strong> <strong>programming</strong> is now usually supported at the programming language level rather than primitive OS calls of 20 years ago. It brought in <strong>asynchronous</strong> programming primitives (async/await), parallel coroutines like goroutines in Go language or channels in D, composability semantics like observables with reactive programming.</li>
<li>A pixel is no longer a relevant unit of measurement.</li>
<li>Garbage collection has become the common way of safe programming but newer safety models are also emerging like <strong>lifetime semantics of Rust</strong> and snarky jokes in code reviews.</li>
<li><strong>3 billion</strong> devices run Java. That number <strong>hasn’t changed in the last 10 years though.</strong></li>
<li>A <strong>package management ecosystem is essential</strong> for programming languages now. People simply don’t want to go through the hassle of finding, downloading and installing libraries anymore. 20 years ago we used to visit web sites, downloaded zip files, copied them to correct locations, added them to the paths in the build configuration and prayed that they worked.</li>
<li>Being a software development team now involves all team members performing a mysterious ritual of <strong>standing up together for 15 minutes in the morning</strong> and drawing occult symbols with post-its.</li>
<li>Language tooling is richer today. A programming language was usually a compiler and perhaps a debugger. Today, they usually come with the <strong>linter, source code formatter, template creators, self-update ability</strong> and a list of arguments that you can use in a <strong>debate</strong> against the <strong>competing</strong> language.</li>
<li>Even programming languages took a side on the debate on <strong>Tabs</strong> vs <strong>Spaces</strong>.</li>
<li>Adobe Flash, which was the only way to provide some smooth interaction on the web, no longer exists, thankfully. Now we have to develop on three different platforms with entirely different programming models in order to provide the same level of interaction.</li>
<li>IDEs and the programming languages are getting more and more distant from each other. 20 years ago an IDE was specifically developed for a single language, like Eclipse for Java, Visual Basic, Delphi for Pascal etc. Now, we have text editors like <strong>VS Code</strong> that can support any programming language with IDE like features.</li>
<li>Code must run behind at least three levels of virtualization now. Code that runs on <strong>bare metal</strong> is unnecessarily performant.</li>
<li>Cross-platform development is now a standard because of wide variety of architectures like <strong>mobile devices</strong>, <strong>cloud servers</strong>, <strong>embedded IoT systems</strong>. It was almost exclusively PCs 20 years ago.</li>
<li><strong>Running your code locally</strong> is something you <strong>rarely</strong> do.</li>
<li>Documentation is always online and it’s called Google. No such thing as offline documentation anymore. Even if there is, nobody knows about it.</li>
<li>A tutorial isn’t really helpful if it’s not a video recording that takes orders of magnitude longer to understand than its text.</li>
<li>There is StackOverflow which simply didn’t exist back then. Asking a programming question involved talking to your colleagues.</li>
<li>People develop software on <strong>Macs</strong>.</li>
<li>Internet connectivity is the norm and being offline is an exception which is the opposite of how it was back then.</li>
<li><strong>Security</strong> is something we have to think about now.</li>
<li>Mobile devices can now show regular web pages, so no need to create a separate WAP page on a separate subdomain anymore. We create mobile pages on separate subdomains instead.</li>
<li><strong>We open source everything by default except the code that would really embarass us.</strong></li>
<li>There are many more talented women, people of color and LGBT in the industry now, thanks to everyone who fought against discrimination. I still can’t say we’re there in terms of equality but we are much better.</li>
<li>Getting hacked is a regular occurence. Losing all your user data usually circumvented by writing a blog post that recommends changing passwords and that’s pretty much it. Apology isn’t required.</li>
<li>Working as a programmer remotely is easier than ever thanks to the new technologies like video conferencing, ubiquitous internet access and Keurigs.</li>
<li>We don’t use IRC for communication anymore. We prefer a bloated version called <strong>Slack</strong> because we just didn’t want to type in a server address.</li>
<li>We run programs on <strong>graphics cards</strong> now.</li>
<li>Your project has no <strong>business</strong> <strong>value</strong> today unless it includes <strong>blockchain</strong> and <strong>AI</strong>, <strong>although a centralized and rule-based version would be much faster and more efficient.</strong></li>
<li>For some reason, one gigabyte is now insufficient storage space.</li>
<li>Because of side-channel attacks we can’t even trust the physical processor anymore.</li>
<li>A significant portion of programming is now done on the <strong>foosball</strong> table.</li>
<li>Since we have much faster CPUs now, numerical calculations are done in <strong>Python which is much slower than Fortran</strong>. So numerical calculations basically take the same amount of time as they did 20 years ago.</li>
<li><strong>Creating a new programming language or even creating a new hardware is a common hobby</strong>.</li>
<li><strong>Unit testing</strong> has emerged as a <strong>hype</strong> and like every <strong>useful</strong> thing, its benefits were <strong>overestimated</strong> and it has inevitably turned into a <strong>religion</strong>.</li>
<li>Storing passwords in plaintext is now <strong>frowned</strong> upon, but we do it anyway.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/Notes-For-Learning-DP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/13/Notes-For-Learning-DP/" class="post-title-link" itemprop="url">Notes_For_Learning_DP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 22:27:34" itemprop="dateCreated datePublished" datetime="2020-01-13T22:27:34-05:00">2020-01-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DP has always been an obstacle when preparing for interviews. For me it is one of the hardest topic. There were several times in the past that I tried to master it, but all attempts failed. Either because I could not find good resources, or because I did not have enough time to really dive into it, have a lot of practice, and identify different patterns. To tell the truth, I even feared that I would never be able to understand it well.</p>
<p>This winter I had another attempt, and made up my mind to grasp the techique. I solved/read 45 DP problems of different patterns in 4 days (yes, you might think that is quite slow). At the begining, I struggled as much as all my previous attempts, but slowly I found I am getting better and I started to be able to think in the DP-way. Today I solved several problems independently, with memoization and tabulation and even space optimizations, I think I am finally understand this category of problem. The process is hard and frustrating, I know! Thus, I want to share my experience so that you might get some help.</p>
<h2 id="Resources-My-way-of-learning"><a href="#Resources-My-way-of-learning" class="headerlink" title="Resources / My way of learning"></a>Resources / My way of learning</h2><p>The resources I recommend for learning DP. I use them in the order as listed.</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/dynamic-programming/">Dynamic Programming</a><br>If you are not familiar with DP yet, there’s no point in diving into Leetcode problems directly. The explanation of <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/dynamic-programming/#concepts">Basic Concepts</a> is very clear. You could also try the first several basic problems to have a taste of DP.</li>
<li>Some typical/famous DP problems (OPTIONAL)<br>I would recommend you to try to read (you might not be able to solve it, which is totally fine!) several DP problems to have a tiny peek into DP. You do not really need try to identify the pattern or memorize the solution. Just to get some <em>feeling</em> about DP. You may not need it, but this is helpful for me. I recommend Longest Common Subsequence, 0/1 Knapsack, Climbing Stairs.</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.">From good to great. How to approach most of DP problems.</a><br>A very good illustration of the motivation behind DP. DP is essentially an optimizaton for pure recursion. If we are solving overlapping subproblems, we can save result to subproblems, we avoid repeated computations. This also shows the implementaion: how to convert recursion code to memoization, and to tabulation. For me, it is very helpful.</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns">Dynamic Programming Patterns</a> (MUST READ)<br>Best post on DP ever! The summarized pattern, problem statement and approach are very helpful. I would say my previous efforts of learning DP brings me at point 3 (which is not easy as to understand the motivation and the implementation of DP are hard already!). For the last 4 days, I spent most of my time working on problems, grouped by patterns, mentioned in the post. All my previous nightmares on DP gone! You cannot afford to miss this post!<br>Other notes I made when reading the post:<ul>
<li>The statement, approach and code snippet for each pattern in the original post is helpful and comprehensive.</li>
<li>Pattern 1 and 2 are kind of similar.</li>
<li>One hint of pattern 3 problems is that they usually involve a list/array of numbers, either explicitly or implicity, like in 1130, 96 and 1039.</li>
<li>DP on strings is usually, if not always, done by comparing two chars at a time.</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCmJz2DV1a3yfgrR7GqRtUUA">Back to Back SWE</a><br>Video explanation on many algorithm problems, including DPs. Detailed, slow and clear. There are several sentences from this guy, which I always remind myself when solving DP problems: “<em>DP is not about building dp table. It is about identifying subproblem, and caching answers to subproblems in order to solve the original problem</em>“.</li>
</ol>
<h3 id="DP-implementation-tips"><a href="#DP-implementation-tips" class="headerlink" title="DP implementation tips"></a>DP implementation tips</h3><p>With the following tips in mind, the implementation for memoization and tabulation is trivial!</p>
<ul>
<li>The most important step, and also the first step, in solving DP problem is to identify the recursive equation. Then the implementation just follows <code>recursion -&gt; memoization -&gt; tabulation</code>.</li>
<li>For <strong>tabulation</strong>, every entry, like <code>dp[i][j]</code>, that could be used must be filled. However for <strong>memoization</strong>, the value might not exist in the dp table because you can directly provide it in the return value of <code>solve(mem, i, j)</code>.</li>
<li>It is easy to convert recursion to memoization. For tabulation, draw graph to see clearly how the dp table is filled up(Lower rows to higher rows, or reverse? Left to right, or reverse? Upper left to lower right, or reverse?). The direction of filling up the dp table affects the values of the loop variables used in tabulation. A common error occurs when the for loop does not conform to the way in which the dp table is filled.</li>
</ul>
<h3 id="Two-styles-of-dp-table"><a href="#Two-styles-of-dp-table" class="headerlink" title="Two styles of dp table"></a>Two styles of dp table</h3><p>Quite commonly, dp tables are built such that <code>dp[m][n]</code> is the ultimate solution. However, there are also a number of DP problems where a variable is updated when building the dp table and the variables contains the final answer(e.g., 647).</p>
<p>Last note: keeps practicing! I think I would review those problems for several rounds in the coming weeks, just to keep my self comfortable with DP. When practicing, try to solve with recursive, memoization, tabulation, and even optimize the space when possible.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/Algorithms-interviews-theory-vs-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/12/Algorithms-interviews-theory-vs-practice/" class="post-title-link" itemprop="url">Algorithms interviews theory vs practice</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-12 22:52:23" itemprop="dateCreated datePublished" datetime="2020-01-12T22:52:23-05:00">2020-01-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>When I ask people at trendy big tech companies why algorithms quizzes are mandatory, the most common answer I get is something like “we have so much scale, we can’t afford to have someone accidentally write an <code>O(n^2)</code> algorithm and bring the site down”. One thing I find funny about this is, even though a decent fraction of the value I’ve provided for companies has been solving phone-screen level algorithms problems on the job, I can’t pass algorithms interviews! When I say that, people often think I mean that I fail half my interviews or something. It’s more than half.</p>
<p>When I wrote a draft blog post of my interview experiences, draft readers panned it as too boring and repetitive because I’d failed too many interviews. I should summarize my failures as a table because no one’s going to want to read a 10k word blog post that’s just a series of failures, they said (which is good advice; I’m working on a version with a table). I’ve done maybe 40-ish “real” software interviews and passed maybe one or two of them (arguably zero).</p>
<p>Let’s look at a few examples to make it clear what I mean by “phone-screen level algorithms problem”, above.</p>
<p>At one big company I worked for, a team wrote a core library that implemented a resizable array for its own purposes. On each resize that overflowed the array’s backing store, the implementation added a constant number of elements and then copied the old array to the newly allocated, slightly larger, array. This is a classic example of how not to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dynamic_array">implement a resizable array</a> since it results in linear time resizing instead of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized constant time</a> resizing. It’s such a classic example that it’s often used as the canonical example when demonstrating amortized analysis.</p>
<p>For people who aren’t used to big tech company phone screens, typical phone screens that I’ve received are one of:</p>
<ul>
<li>an “easy” coding/algorithms question, maybe with a “very easy” warm-up question in front.</li>
<li>a series of “very easy” coding/algorithms questions,</li>
<li>a bunch of trivia (rare for generalist roles, but not uncommon for low-level or performance-related roles)</li>
</ul>
<p>This array implementation problem is considered to be so easy that it falls into the “very easy” category and is either a warm-up for the “real” phone screen question or is bundled up with a bunch of similarly easy questions. And yet, this resizable array was responsible for roughly 1% of all GC pressure across all JVM code at the company (it was the second largest source of allocations across all code) as well as a significant fraction of CPU. Luckily, the resizable array implementation wasn’t used as a generic resizable array and it was only instantiated by a semi-special-purpose wrapper, which is what allowed this to “only” be responsible for 1% of all GC pressure at the company. If asked as an interview question, it’s overwhelmingly likely that most members of the team would’ve implemented this correctly in an interview. My fixing this made my employer more money annually than I’ve made in my life.</p>
<p>That was the second largest source of allocations, the number one largest source was converting a pair of <code>long</code> values to byte arrays in the same core library. It appears that this was done because someone wrote or copy pasted a hash function that took a byte array as input, then modified it to take two inputs by taking two byte arrays and operating on them in sequence, which left the hash function interface as <code>(byte[], byte[])</code>. In order to call this function on two longs, they used a handy <code>long</code> to <code>byte[]</code> conversion function in a widely used utility library. That function, in addition to allocating an <code>byte[]</code> and stuffing a <code>long</code> into it, also reverses the endianness of the long (the function appears to have been intended to convert <code>long</code> values to network byte order).</p>
<p>Unfortunately, switching to a more appropriate hash function would’ve been a major change, so my fix for this was to change the hash function interface to take a pair of longs instead of a pair of byte arrays and have the hash function do the endianness reversal instead of doing it as a separate step (since the hash function was already shuffling bytes around, this didn’t create additional work). Removing these unnecessary allocations made my employer more money annually than I’ve made in my life.</p>
<p>Finding a constant factor speedup isn’t technically an algorithms question, but it’s also something you see in algorithms interviews. As a follow-up to an algorithms question, I commonly get asked “can you make this faster?” The answer is to these often involves doing a simple optimization that will result in a constant factor improvement.</p>
<p>A concrete example that I’ve been asked twice in interviews is: you’re storing IDs as ints, but you already have some context in the question that lets you know that the IDs are densely packed, so you can store them as a bitfield instead. The difference between the bitfield interview question and the real-world superfluous array is that the real-world existing solution is so far afield from the expected answer that you probably wouldn’t be asked to find a constant factor speedup. More likely, you would’ve failed the interview at that point.</p>
<p>To pick an example from another company, the configuration for BitFunnel, a search index used in Bing, is another example of an interview-level algorithms question.</p>
<p>The full context necessary to describe the solution is a bit much for this blog post, but basically, there’s a set of bloom filters that needs to be configured. One way to do this (which I’m told was being done) is to write a black-box optimization function that uses gradient descent to try to find an optimal solution. I’m told this always resulted in some strange properties and the output configuration always resulted in non-idealities which were worked around by making the backing bloom filters less dense, i.e. throwing more resources (and therefore money) at the problem.</p>
<p>To create a more optimized solution, you can observe that the fundamental operation in BitFunnel is equivalent to multiplying probabilities together, so, for any particular configuration, you can just multiply some probabilities together to determine how a configuration will perform. Since the configuration space isn’t all that large, you can then put this inside a few for loops and iterate over the space of possible configurations and then pick out the best set of configurations. This isn’t quite right because multiplying probabilities assumes a kind of independence that doesn’t hold in reality, but that seems to work ok for the same reason that <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Naive_Bayes_spam_filtering">naive Bayesian spam filtering</a> worked pretty well when it was introduced even though it incorrectly assumes the probability of any two words appearing in an email are independent. And if you want the full solution, you can work out the non-independent details, although that’s probably beyond the scope of an interview.</p>
<p>Those are just three examples that came to mind, I run into this kind of thing all the time and could come up with tens of examples off the top of my head, perhaps more than a hundred if I sat down and tried to list every example I’ve worked on, certainly more than a hundred if I list examples I know of that someone else (or no one) has worked on. Both the examples in this post as well as the ones I haven’t included have these properties:</p>
<ul>
<li>The example could be phrased as an interview question</li>
<li>If phrased as an interview question, you’d expect most (and probably) all people on the relevant team to get the right answer in the timeframe of an interview</li>
<li>The cost savings from fixing the example is worth more annually than my lifetime earnings to date</li>
<li>The example persisted for long enough that it’s reasonable to assume that it wouldn’t have been discovered otherwise</li>
</ul>
<p>At the start of this post, we noted that people at big tech companies commonly claim that they have to do algorithms interviews since it’s so costly to have inefficiencies at scale. My experience is that these examples are legion at every company I’ve worked for that does algorithms interviews. Trying to get people to solve algorithms problems on the job by asking algorithms questions in interviews doesn’t work.</p>
<p>One reason is that even though big companies try to make sure that the people they hire can solve algorithms puzzles they also incentivize many or most developers to avoid deploying that kind of reasoning to make money.</p>
<p>Of the three solutions for the examples above, two are in production and one isn’t. That’s about my normal hit rate if I go to a random team with a diff and don’t persistently follow up (as opposed to a team that I have reason to believe will be receptive, or a team that’s asked for help, or if I keep pestering a team until the fix gets taken).</p>
<p>If you’re very cynical, you could argue that it’s surprising the success rate is that high. If I go to a random team, it’s overwhelmingly likely that efficiency is in neither the team’s objectives or their org’s objectives. The company is likely to have spent a decent amount of effort incentivizing teams to hit their objectives – what’s the point of having objectives otherwise? Accepting my diff will require them to test, integrate, deploy the change and will create risk (because all deployments have non-zero risk). Basically, I’m asking teams to do some work and take on some risk to do something that’s worthless to them. Despite incentives, people will usually take the diff, but they’re not very likely to spend a lot of their own spare time trying to find efficiency improvements(and their normal work time will be spent on things that are aligned with the team’s objectives)<a target="_blank" rel="noopener" href="https://danluu.com/algorithms-interviews/#fn:E">4</a>.</p>
<p>Hypothetically, let’s say a company didn’t try to ensure that its developers could pass algorithms quizzes but did incentivize developers to use relatively efficient algorithms. I don’t think any of the three examples above could have survived, undiscovered, for years nor could they have remained unfixed. Some hypothetical developer working at a company where people profile their code would likely have looked at the hottest items in the profile for the most computationally intensive library at the company. The “trick” for both isn’t any kind of algorithms wizardry, it’s just looking at all, which is something incentives can fix. The third example is less inevitable since there isn’t a standard tool that will tell you to look at the problem. It would also be easy to try to spin the result as some kind of wizardry – that example formed the core part of a paper that won “best paper award” at the top conference in its field (IR), but the reality is that the “trick” was applying high school math, which means the real trick was having enough time to look at places where high school math might be applicable to find one.</p>
<p>I actually worked at a company that used the strategy of “don’t ask algorithms questions in interviews, but do incentivize things that are globally good for the company”. During my time there, I only found one single fix that nearly meets the criteria for the examples above (if the company had more scale, it would’ve met all of the criteria, but due to the company’s size, increases in efficiency were worth much less than at big companies – much more than I was making at the time, but the annual return was still less than my total lifetime earnings to date).</p>
<p>I think the main reason that I only found one near-example is that enough people viewed making the company better as their job, so straightforward high-value fixes tended not exist because systems were usually designed such that they didn’t really have easy to spot improvements in the first place. In the rare instances where that wasn’t the case, there were enough people who were trying to do the right thing for the company (instead of being forced into obeying local incentives that are quite different from what’s globally beneficial to the company) that someone else was probably going to fix the issue before I ever ran into it.</p>
<p>The algorithms/coding part of that company’s interview (initial screen plus onsite combined) was easier than the phone screen at major tech companies and we basically didn’t do a system design interview.</p>
<p>For a while, we tried an algorithmic onsite interview question that was on the hard side but in the normal range of what you might see in a BigCo phone screen (but still easier than you’d expect to see at an onsite interview). We stopped asking the question because every new grad we interviewed failed the question (we didn’t give experienced candidates that kind of question). We simply weren’t prestigious enough to get candidates who can easily answer those questions, so it was impossible to hire using the same trendy hiring filters that everybody else had. In contemporary discussions on interviews, what we did is often called “lowering the bar”, but it’s unclear to me why we should care how high of a bar someone can jump over when little (and in some cases none) of the job they’re being hired to do involves jumping over bars. And, in the cases where you do want them to jump over bars, they’re maybe 2” high and can easily be walked over.</p>
<p>When measured on actual productivity, that was the most productive company I’ve worked for. I believe the reasons for that are cultural and too complex to fully explore in this post, but I think it helped that we didn’t filter out perfectly good candidates with algorithms quizzes and assumed people could pick that stuff up on the job if we had a culture of people generally doing the right thing instead of focusing on local objectives.</p>
<p>If other companies want people to solve interview-level algorithms problems on the job perhaps they could try incentivizing people to solve algorithms problems (when relevant). That could be done in addition to or even instead of filtering for people who can whiteboard algorithms problems.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/11/%E9%87%91%E8%9E%8D%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/11/%E9%87%91%E8%9E%8D%E6%88%98/" class="post-title-link" itemprop="url">金融战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-11 22:30:19" itemprop="dateCreated datePublished" datetime="2020-01-11T22:30:19-05:00">2020-01-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="索罗斯"><a href="#索罗斯" class="headerlink" title="索罗斯"></a>索罗斯</h3><p>第一，本期资本战争发生在外汇、期货、股票甚至房地产市场，又按照时间线发生在不同国家——这些战局互有牵连，推进也是由浅入深。</p>
<p>第二，问不到亲历过的人，信息源全靠自己挖。</p>
<p>中西方媒体的倾向性都很明显——双方都不客观，因此本期对于任何数据和资料，我必须找到第三方来佐证，信息源除了新闻、市场数据、采访和交易公告，还包括索罗斯的《改革全球资本主义》，《金融炼金术》，《索罗斯论全球化》，沈联涛的《十年轮回-从亚洲到全球的金融危机》，港府救市基金和量子基金数据，金融四十人论坛论文，《全球资本主义危机》以及《朱镕基讲话实录》，我不是推荐这些书啊，只为四个字：以我为准。</p>
<p>言归正传，这场战争发起者索罗斯，大家都多少对他有些偏见，虽然是犹太人，但他家庭并不富裕，索罗斯早期是个不折不扣的屌丝。</p>
<p>不过他生性高调且富有冒险精神，所以其发家史也是充满了各种投机和豪赌，虽然我们都说是索罗斯血洗东南亚、索罗斯狙击香港，但其实干这些事儿的是国际游资，索罗斯只是代表了其中的一小部分，之所以他来扛大旗，是因为他本人喜欢到媒体上高谈阔论，频频发表讲话或者接受采访，所以久而久之名气大了就成了一面旗帜，至于为什么在金融界他的名字让人闻风丧胆，那得看看他在狙击香港之前都干了什么，也让我们探究一下索罗斯带领的国际游资特有的战术战略。 </p>
<h3 id="欧洲"><a href="#欧洲" class="headerlink" title="欧洲"></a>欧洲</h3><p>时间回到那个风起云涌的时代，在经历了二战后，世界格局被一位坐在轮椅上的伟人重新定义，曾经的日不落眼睁睁看着霸权易主。英法式微，两德分裂，欧洲大国政治地位严重下滑，以至于在五十年代沦为冷战的马前卒。因此欧洲各国希望联合。摆脱美国制约。同时建立一个跨国家联盟，稀释各国主权缓解欧洲各国千年以来的冲突，同时强调经济合作，专注发展 欧共体也就是现在欧盟就是这个诉求的产物，在欧盟实行单一货币前，也就是还没有欧元这个货币前，欧洲国家制定了欧洲汇率机制（ERM），说白了就是把各国货币的汇率锁在一起，ERM就是英国金融市场的弱点，并且很快被国际游资察觉，当时欧洲的具体做法是，加入ERM的欧洲国家要把自己的货币跟德国马克挂钩，使自己的货币兑马克的汇率仅在小范围内波动，这样的操作造成只要马克贬值，欧洲其他货币一起贬值，马克升值，其他货币一起升值，这样你在欧洲经商的话，反正大家一起升或者一起贬，商人就不用太考虑汇率的影响了，这样才能推进欧洲经济一体化，当然这是政策制定者美好的初衷，但是汇率上的统一进退，就得保证利率上的统一进退，为什么呢，幼儿园化的讲，利率你们可以理解为把钱换成对应国家的货币后存起来的利息，如果英国利率是10%，德国利率5%，那你们肯定把钱换成英镑，都存到英国赚10%的利息啊，这样大家都把德国马克换成英镑，那英镑就会快速升值，而德国马克就会快速贬值，那这个欧洲汇率机制就维持不下去了，所以要想汇率统一进退，那利率也得统一进退。</p>
<p>这就是当时的背景 然而1989年柏林墙倒塌后，东德人大量涌入西德。德国的政府福利及社保开销大幅上升，因此德国政府财政赤字飙升，为了应对亏空，德国开始印钱，加剧通货膨胀，通胀压力迫使中央银行提高利率，这儿还得幼儿园化一下，通胀就是市面上的钱太多了，钱本身不值钱了，那怎么回收一下呢，就用提高利率的办法，利息高了，大家就会把钱用于投资或者直接存起来赚取利息，这样市面上流通的钱就减少了，当时德国被迫提高利率。而此时的英国经济正在衰退，通货紧缩，英国反而需要提高通胀，所以英国需要降低利率来刺激自己经济的复苏。但英国政府却受到欧洲汇率体系的限制，就因为德国的高利率政策，自己也得维系着高汇率和高利率，但是根据蒙代尔三角也称三元悖论：一国的经济目标有三种：</p>
<p>①各国货币政策的独立性；</p>
<p>②汇率的稳定性；</p>
<p>③资本的完全流动性。 </p>
<p>这三者，一国只能三选其二，而不可能三者兼得。但英国想三个都占，在维持汇率稳定和自由的资本流动前提下，英国还要维持高利率。这就是饮鸩止渴。索罗斯也正是在赌英国无法同时维持这三者，而必须放弃汇率稳定，退出欧洲汇率机制。到时候被高估的英镑就会崩盘式下跌。</p>
<p>所以闻到了血腥的味的索罗斯开始为狙击英镑作准备。</p>
<p>虽然英国首相和财政大臣在各种公开场合一再重申坚持现有政策不变，英国有能力将英镑留在欧洲汇率体系内，翻译成人话就是，我们英国政府依旧会维持英镑和马克的汇率，那些投机者抛售的英镑我们政府全给他买回来，力挺英镑汇价，但索罗斯的判断是——英国政府是在虚张声势，所以开始大举做空英镑，做空是什么意思不做赘述，没做笔记的参考保时捷那期，索罗斯开始用各种方法借入英镑，一边在市场上抛售砸盘一边在媒体上制造恐慌情绪 在这段时间里，市场对于英镑的不信任开始发酵，英镑对马克的比价在不断地下跌，从2．95跌至2．8，英国政府为了对抗索罗斯代表的国际空军，从市场上大举买入33亿英镑来干预市场。于是当时就是一边索罗斯在抛，一边英国央行在接，虽然英镑汇率有所小涨，但很快又回到了下行通道，这使索罗斯为代表的国际游资更加坚信自己的判断，国际游资从1992年7月开始就从各大金融机构手中借走大量英镑和里拉，然后9月在外汇市场卖掉换成德国马克，大规模的抛售英镑和意大利里拉使得市场陷入恐慌，这些国家的央行尤其是英国央行——英格兰银行不得不拆巨资来购买各自的货币来维持原汇率，索罗斯在做空各国货币的同时，他还预测各国为了对抗自己，未来一定会短期内提高利率，因此在欧洲各国的利率期货的多头市场上做了埋伏，多头就是涨了赚钱空头就是跌了赚钱啊，随着国际游资的持续抛盘，市场上出现了恐慌情绪，加之索罗斯利用欧洲媒体散布不利于英国的消息，英镑持续下跌，空头渐渐压过了多头，英国政府为了扳回局势，从国际银行组织借入资金继续买入英镑，企图阻止英镑继续贬值，但此时市场看空英镑的趋势已经形成，以索罗斯代表的国际游资势头正猛，连很多英国本土机构加入了做空英镑的行列，所以虽然政府在市场上不断承接这些空军抛售的英镑，但国际游资也不断加大抛盘力度，仅索罗斯一人就抛售了120亿美元的英镑，大量基金、小银行甚至英国百姓都受到当时气氛的影响，恐慌的情绪造成大家争先恐后的抛售英镑，空军形成碾压之势，1992年9月15日，英镑对马克的比价已跌至欧洲汇率体系规定的下限。英镑已处于退出欧洲汇率体系的边缘。英国只好殊死一搏，之后的一天内，英格兰银行为了吸引资金回流，拉升英镑汇率，歇斯底里的将利率提升了两次，由10%分两次提高到了15%，现在咱们听说利率提高了0.5%就如同听到了大新闻一样转发，所以能想象当时英国一天就提升了5%是多么绝望的一个操作了吧。但没想到收效甚微，欧洲资本市场根本不买英国央行的账，再加上空头继续倾泻式的抛盘，英镑的汇率最终跌穿2．778的最低限。至此，英国政府已经动用了价值269亿美元的外汇储备，但最终还是惨败，当天晚上被迫宣布退出欧洲汇率体系。这样英镑汇率就不会维持在一个固定的区间内了，英镑犹如脱缰野马开始贬值，之后的几天里疯狂跳水，英镑兑马克贬值16%。英镑兑美元贬值26%，英国人史称黑色星期三。</p>
<p>索罗斯也被经济学家杂志称为打垮了英格兰银行的人。索罗斯曾在书中透露，当时准备了超过150亿美元的英镑筹码，然而在投入120亿的时候英国就投降了，索罗斯从英镑空头交易中获利近10亿美元，而索罗斯也早就预测到了各国在应对危机时的利率政策，在英国、法国和德国的利率期货上埋伏的多头也帮他赚了不少，再加上做空英镑的大获全胜，当年他的总利润高达20亿美元，在这一年里，索罗斯的基金增长了67.5％ 这次战役的大捷让索罗斯尝到了甜头，以他为代表的国际游资也总结出了一套手术刀式的做空战术，既然我用这种方法能打败英国，那其他国家呢？</p>
<h3 id="东南亚"><a href="#东南亚" class="headerlink" title="东南亚"></a>东南亚</h3><p>之后他的目光瞄准了东南亚，90年代初期，当西方国家正处于经济衰退中，东南亚国家的经济却出现奇迹般的增长，当时由于广场协议，日本的制造业成本高得离谱，所以日本企业都把工厂迁往东南亚，尤其是泰国，随着时间的推移，泰国经济过热的迹象更加突出，泰国央行不断提高利率来降低通货膨胀。这个画面是不是似曾相识，高利率吸引了大量国际游资进入泰国，加之当时泰国在东南亚各国金融市场的自由化程度最高。这样泰国就被架到了一个很危险的高位，索罗斯闻到了猎物的味道，在 1995 年 1 月中旬泰国的房地产价格开始下跌时，索罗斯就对泰铢进行了试探性进攻——在即期外汇市场大量抛售泰铢。但泰国央行直接入市干预，此次进攻并未酿成危机。这里科普一下泰国的汇率制度，由于泰国实行盯住“一篮子货币”的固定汇率制度，而篮子中的主要货币——美元的权重占80%至82%；所以说白了泰国就是盯住美元的固定汇率，泰铢对美元的汇率长期维持在25∶1，这段时间由于美元汇率持续走低，泰铢跟随美元一起贬值，这就导致泰国出口持续增长，这也得幼儿园化一下，为什么货币贬值就能刺激出口，比如我是生产玩具的，一件玩具卖25泰铢我就能有不错的利润，如果泰铢对美元的汇率为25泰铢换1美元，那我玩具在美国就卖1美元，但现在泰铢贬值了，变成25泰铢换0.8美元了，那我的玩具在美国只用卖0.8美元我就能赚，相较于其他玩具，我的玩具就明显具备价格优势——又便宜又没有牺牲质量，大家都来买我的性价比高的玩具，这个玩具市场就慢慢被我占领了，因此当时泰国生产卖到了全世界，泰铢跟随美元贬值强力的刺激了泰国的出口，导致泰国经济快速发展。1986~1994年，年平均出口增长率达到22%，经济增长率达9.5%，成为“亚洲四小龙”之一。这个场景对于看过我经济崛起那期的同学，是不是觉得和我们加入世贸之后有点像？ 但是自1993年起，美国计算机互联网产业崭露头角，美国经济迎来新的一轮增长，所以国际汇率有所变化，美元对主要货币由贬值转为升值，所以泰铢又跟着美元一起升值，刚才说货币贬值可以让我的东西卖的更实惠抢占市场，但这一升值，东西就变贵了，慢慢的卖不出去了，这就对泰国出口和经济增长当头一棒。泰国慢慢发现以前我把东西卖到全世界躺着赚外汇，但现在卖不出去了，国库慢慢儿入不敷出了，在固定汇率制度下，就是刚才说的盯住美元汇率制度下，外汇市场失去了自我调节的功能，面对不断恶化的国际收支形势，泰国政府不得不快速放开资本市场，通过各种优惠政策和高利率，吸引国外资本流入，弥补国际收支赤字，当时泰国政府走了两步棋，简直让国际游资开心到爆炸，一是开放离岸金融业务，凡获批准的商业银行均可从国外吸收存款和借款，并在泰国境内发放外币贷款。二是企业可以自由对外借款，非居民在国内和国外可自由开立泰铢账户，进行存款、借款和自由汇兑。听不懂没关系，你只要知道这两组政策直接给外国投机者打开了镣铐，来吧，来我们这儿随便玩儿。刚才说到泰国出口遭受打击，因此泰国制造业利润率下降，但资本都去回报率高的地方啊，你出口和实业不赚钱了，大量资本就流入房地产和股市，形成严重泡沫。1993到1996年仅3年多，泰国的房地产均价上涨了近4倍。 好了，现在万事俱备只欠索罗斯，到了1996年，泰国的资本账户已经完全开放，外资可以随意进入，1997年2月，索罗斯代表的国际游资开始行动了，他们与泰国央行签订远期合约，利用抵押当地资产的方式，借入大量泰铢然后在外汇市场抛售泰铢换成美元。关于期货、期权和收益互换我不赘述了，在保时捷和爱马仕LV那期都解释过，2 月 14 日，由于索罗斯大量抛售泰铢，泰国央行发现不妙开始反击，在外汇市场上大量购入泰铢，同时提高短期利率，就是索罗斯他们做空泰铢，总得先借到泰铢才能卖掉砸盘啊，但是借泰铢也得给别人利息，泰铢短期利率的提高就是为了打击这些国际投机分子的，我把借泰铢的利息定的巨高，看你们还借不借，这两板斧用出来之后，泰铢即期汇率很快得到稳定，第一轮做空失败，但泰国的外汇储备被大量消耗。索罗斯为首的国际游资并没有放弃，老子是干过英格兰银行的人，泰国我也势在必得，当年的一些新闻和采访非常有意思，索罗斯为首的国际对冲基金在各种国际媒体上，包括泰国当地媒体疯狂叫嚣，在舆论上形成了泰国这边是大刀加步枪，而我索罗斯是核弹加特林的局面，国际资本又一次站到了索罗斯的空军这一边，我在查阅资料的时候发现甚至一些泰国自己的银行和投资机构也在做空自己，发国难财，空头对多头的碾压之势形成，这一切都那么似曾相识，三个月之后，索罗斯为首的空头卷土重来，开始有计划有组织的在市场上抛售泰铢，手术刀式的砸盘开始了，至1997年5月底，泰铢从25：1下跌到26.6:1。而这时泰国央行才开始反击：直接动用100亿美元接盘空军抛出来的泰铢；同时禁止银行借泰铢给国际游资。而且泰国政府开始打击放出不利言论的媒体，出动警察进入交易所和监管机构进行调查，追踪抓捕空头账户的控制人，泰国政府的绝地反击并没能阻止大势，反而自己的公信力进一步下降，市场上消极的情绪弥漫，连泰国百姓都认为泰铢的价格就要崩溃了，于是老百姓就跟风用泰铢换美元。形成了全民泰国危机大逃亡，这导致本来要用外汇储备和国际游资搏杀的政府不得不把美元外汇储备换给这些恐慌的百姓，进一步加速了外汇储备的消耗，到1997年6月底，泰国外汇储备下降300亿美元，外汇池基本干涸，没有了外汇储备就等于没有了弹药，眼睁睁的看着国际游资继续砸盘。而此时泰铢对美元的汇率已经跌破28∶1。1997年7月2日，弹尽粮绝的泰国政府被迫宣布放弃固定汇率制度，当天泰铢对美元的汇率直接崩盘，跳水30%。之后的25天内，泰铢汇率继续疯狂跳水60%。泰铢如同废纸一般被大家唾弃，国际游资血赚40亿美元，泰国人的财富也被彻底洗劫一空，泰铢大幅度贬值迅速波及包括菲律宾、马来西亚、新加坡、韩国和印度尼西亚在内的整个东南亚地区，最终形成了亚洲金融危机，当然亚洲金融危机的形成也不只是因为泰铢崩盘，泰铢崩盘只是导火索之一，金融危机背后的原因非常复杂也很有意思以后会单做一期，在击破泰铢之后，索罗斯并不满足，他决定席卷整个东南亚，索罗斯的空头飓风很快就扫荡了印度尼西亚、菲律宾、缅甸、马来西亚等国家。国际游资用着同样的招数和套路，似曾相识的场景不断上演，印尼盾、菲律宾比索、缅元、马来西亚林吉特都不是国际游资的对手，一开战就直接拉闸，汇率集体跳水，导致这些国家的工厂倒闭，银行破产，物价上涨，百姓失业，东南亚一片鬼狐狼嚎，惨不忍睹。这场扫荡东南亚的空头飓风一举刮去了百亿美元的财富，使这些国家人民辛辛苦苦积累的几十年经济增长化为灰烬。人民的财富被国际游资洗劫一空。</p>
<h3 id="香港"><a href="#香港" class="headerlink" title="香港"></a>香港</h3><p>索罗斯再次笑到了最后，这时这位空军领袖的资金实力也因几场大捷变的空前强大，野心进一步膨胀 好了，现在进入本期最高能的环节，这个披荆斩棘的空军魔王目光盯上了我们的金融中心——香港，这回，他想把相同的手术刀套路用在香港。</p>
<p>香港和泰国也有一些相似之处，</p>
<p>第一是香港享有国际自由金融中心的美誉，国际资本在港流动相对自由，</p>
<p>第二，香港的联系汇率制度和泰国最早的固定汇率制度神似，关于汇率制度做一下科普，固定汇率就是泰铢那种盯住一篮子货币的制度，联系汇率是指将港币与某特定外币的汇率固定下来，并严格按照兑换比例使货币发行量随外汇存储量联动的货币制度。</p>
<p>解释一下，就是香港有三家发钞银行：汇丰银行、渣打银行和中国银行。它们每发行7.8港币必须向香港的金融管理局交纳1美元，以此来保证港币背后有美元作为支撑，维持汇率稳定。这就是联系汇率，而浮动汇率就是字面意思，泰国的固定汇率被国际游资玩烂了就只好实行有管理的浮动汇率了，汇率制度是理解国际资本战争、国际贸易甚至国际经济局势的基础，再幼儿园化一点可以把港币当成美元的代金券，合7.8港币代表1美元。代金券理论确实好记但我还是要扩展一下，2005年开始，香港联系汇率制度增加了强方兑换保证（1美元兑7.75港币）和弱方兑换保证（1美元兑7.85港币），并承诺只要触及区间的任何一边，香港金管局会入市干预，让汇率在1美元兑7.75-7.85港币之间浮动，回到1997年，国际游资认为香港和英国泰国差不多，没能力维持汇率稳定。自己的老套路可以用起来，所以开始着手狙击香港，但空军没有直接攻击外汇市场，而是进行手术似的慢条斯理的布局，开始提前低调借入港币，囤积筹码，等机会砸盘，这个跟做空泰铢和英镑的方法类似，但当局及时发现了有人在大量借入港币。香港金管局的总裁任志刚应对策略也很简单，听说你们要借港币？那我就提高香港银行同行业拆借利率，使借港币的利息成本大幅上升，看你们还借不借，而因为每次索罗斯大举借港币，任志刚就用这一招，同一招被用了三次，因此任志刚被圈内人笑称任一招。但这招却上了索罗斯的当，具体是怎么操作的呢， 1997 年 10月索罗斯为首的空军开始了进攻。空军在货币市场大量抛售港币，港币汇率下跌。到了10月底，许多银行在金管局结算账户上的港币已经没有足够结余，而金管局为了进一步提高国际游资借港币的成本，不仅没有注入港币流动性，反而发出通知，要对反复通过流动性机制向金管局借港币的银行收取惩罚性的高息。一时间港币难求，同业隔夜拆借利率一度飙升至 300%。这里肯定有人听晕了，降维说，就是当时港府把所有在市场上借港币的人都怀疑是索罗斯那边儿的空军，在市场上本来流通的港币就不多的情况下，还在大量回收流动性，市场上流通的港币就更少了，到处都借不到港币，大家没有了流动性（港币），市场上又借不到，怎么办，卖资产换钱呗，本来担心联系汇率不保的香港居民和外国投资者就更加大量抛售港币资产，尤其是港股，再加上银根的突然收紧，任一招的提高短期利率，使股市雪上加霜，股票开始暴跌，恒生指数一路向下。原来索罗斯在这等着呢，索罗斯早在几个月前就已经布局好了空头头寸，你让我借不到港币，但你的代价是楼市股市承压，我就做空股市，我的空军从股市下跌就可以大量获利。1997年10月，恒生指数因为这一波趋势持续下跌，这也引起了小规模的恐慌导致大量跟风抛盘，再加上国际游资的空军砸盘和舆论上的煽风点火，恒生指数从1997年10月3日的15000多点，一路倾泻至10月28日的9060点，引用人民网对当时的一段报道：1997年10月20日，香港市民苏顶明永远不会忘记这一天。苏顶明是一名普通的出租车司机，此前他到内地玩了6天。等回到香港时他却发现，原本价值30多万元的股票就只剩下不足4万元 在股票空头成功获利后，索罗斯为首的国际游资士气大振，又玩起了老一套舆论战术，频繁出现在各大媒体，发表各种不利于香港的言论，并且叫嚣着要像当年席卷东南亚一样，完全击溃港币，这一连串的舆论引导，马上又吸引了大量的空军秃鹫加入索罗斯的阵营，香港如临大敌，黑云压城城欲摧，1998 年起，空军开始连续对香港发动攻击。此时香港节节败退，已经开始有中文媒体和金融机构预言香港将要全面崩盘。路边小报八卦杂志都在担心香港的未来，恐慌的情绪一直在蔓延，1998 年 8 月，港币到了最危险的时候。国际游资的攻击变本加厉，大肆卖空港币。从 1998 年年初到 8 月中旬，每当港币利率稳定就借入港币，8 月港币空头规模已经超过了300 亿港币。同时空军大量积累股票和股指期货的空头头寸。根据当时官方新闻和数据，截至 1998年 8 月，国际游资大约有 8 万份空头合约。恒生指数每下跌 1000 点，国际游资便可获利40 亿港币。这些秃鹫在静静地等待时机 8 月 5 日，蓄谋已久的空军开始了新一轮猛烈轰炸，砸盘开始，即期外汇市场出现 300 多亿港币的卖盘，远期外汇市场也出现 116 亿港币的卖盘。8 月 6 日，香港和伦敦市场又出现 155 亿港币的卖盘。8 月 7 日，市场再出现 78亿港币的卖盘。随着汇率承压，股市也一路狂泻，空军同时在股票市场砸盘。空头的双线操作导致当日恒生指数收报 7018 点下跌 3.5%，5 个交易日累计跌去 917 点，2500 亿港币市值化为乌有 我们确实醒悟的太晚了，还没等我们做出反应，空军乘胜追击，1998年8月13日香港恒生指数跌穿6600点，从1997年8月16000多点的高位下跌将近10000点至6600点，这是香港的至暗时刻，中产阶级的财富惨遭洗劫，难道我们也要像英国泰国一样，被掠夺几十年的发展成果？此时离8月28日的恒指交割日时间已近，眼看这些国际游资马上可以血赚一笔。甚至还想试图想引起恐慌一举击溃港币的联系汇率制度，港府在这个存亡之秋，顶着巨大的压力做出了艰难的决策——政府入市干预，有人这时就会问了：做个决策怎么就艰难了，这样的决策，其实就是拿着人民的钱去和空军搏杀，而且要一定程度牺牲自由港的声誉，如果做了这个决策结局还是负面的，那个决策者很容易成为历史罪人甚至留下千古骂名，这段由于涉及国家领导人，为了能在国内发出，我不细说了，总之拍板是个很复杂的过程。而同一时期，港府也获得了来自中央的承诺，这里要强调一下，国内很多文章和视频都说眼看香港支撑不下去了，北京就支援香港大量的外汇储备，对于热血而充满期待的看客，我知道，如果这时候加上这样一个桥段，中央如救世主一般踩着祥云，闪现到被打的奄奄一息的港府身后，万丈光芒，伸出援手，绝地反击，那节目效果就太好了，但你们是了解我的，要对得起以我为准这四个字，还是要谨慎，所以我在这块进行了大量的挖掘，在各种回忆录、新闻、采访和人物传记中都没有找到明确的证据证明直接给了外储，所以这个热血的场景可能只是营销号为了迎合大家情绪的一厢情愿，既然没有证据，我们就不能说直接给外汇了，而且港府当年本身也有约980亿美元的外汇储备，虽然没直接给，但中央政府确实公开承诺过，以下是当时朱镕基答记者问的珍贵画面，朱总理当时这段话的力度非常大，这段我看了好几遍，在我写作的时候还有点激动的 1998年8 月 14 日是这场战役的转折点，此前被痛打的香港金融市场，弥漫的硝烟中突然杀出一只训练有素的军队，政府入市搏杀绝地反击。政府开始有序的购买恒生指数中 33 种成分股，拉动指数攀升，当天恒生指数上升 564 点，报收 7244 点，国际游资受到初步打击。同时港府在远期外汇市场上承接国际游资的卖盘并要求各券商不要向国际游资借出股票，切断空军的“弹药”供应。局势开始逆转，空军接连遭受打击，三市场开始呈现上扬趋势，空军开始慌了，他们没想到中央会公开承诺也没想到港府会入市，那既然这样，我就要把你们一波全带走，歇斯底里的空军准备玩一票大的，他们认为，在结算日8月28日前，凭借手中还有大量筹码，可以一举击溃整个香港 1998年8月27日，也就是结算日8月28日前一天。上午10点股市开盘。一开始，空军的卖盘就如排山倒海一般扑来。在第一个15分钟内，成交额就达19亿港币；在第二个15分钟内，成交额为10亿港币。而在收市前的15分钟，战斗进入白热化状态，全天交易之惨烈，令场上所有交易员都目瞪口呆。这一天，香港政府动用了200亿港币，委托10家经纪行在33家恒指成分股上围追堵截。恒生指数报收7922点，比上一个交易日上扬88点，这是自97年11月4日以来的最高点。 对于即将来临的8月28日结算日，国际游资的空头和港府的多头，当晚无人入眠 时间最终来到了决战之日， 8 月 28 日这一天香港街道熙熙攘攘，这座城市依旧像往常一样运转，风平浪静的表象下是金融市场的风起云涌，有一点要提前科普一下，恒指期货的结算价格为这一天每五分钟恒生指数的平均值，因此，要抬高结算价，就必须保证恒生指数走势平稳且一直保持在高位，要达此目的，我们必须得竭尽全力，寸土必争，换句话说，索罗斯代表的空军砸多少，我们就得接多少，8 月 28 日上午10点整开市后，仅5分钟，股市的成交额就超过了39亿港币。半小时后，成交金额就突破了100亿港币，到上午收盘，成交额已经达到400亿港币，下午开盘后抛售有增无减，成交量一路攀升，但国家队的围追堵截一直让恒指和期指始终维持在7800点以上，随着下午4点的收盘钟声响起，显示屏上不断跳动的恒指、期指、成交金额最终分别锁定在7829点、7851点和790亿港币上。根据还能找到的且有第三方佐证的资料和报道，当时空军约在7500点卖空恒指8月合约，而结算点位收在7851点，空军在做空恒指8月合约上巨亏，在这一天，港府动用了几乎所有可以动用的外汇储备，全盘吃下国际卖盘，平均每分钟就有价值3.5亿的股票易手。全天成交额达到了香港股市有史以来的最高纪录——790亿港币。2005年3月17日出版的《南方周末》曾以这样一段文字记述当年的那一幕:“许多香港人攥紧了矿泉水瓶，在炎热的天气里挤在一起，看着证券交易所的显示牌目瞪口呆。” 1998年9月7日，香港金融管理局颁布了外汇、证券交易和结算的新规定，使国际游资的投机大受限制。当日恒生指数飙升588点，以8076点报收。加上日元升值、东南亚金融市场趋稳等因素，空军的资金、换汇成本大幅上升，不得不败退离场：9月8日，9月合约价格升到8220点。8月底转仓的期指合约要平仓退场，每张合约又要亏损4万港币。至此，国际游资见大势已去，纷纷丢盔弃甲，落荒而逃 回顾整场战役，虽然空军在最后阶段的空单巨亏，但是很多在早期就布局做空港股的投机者还是赚的，有人就要问了，为什么港府只拉到7851点，而不是想尽办法拉到10000点甚至更多呢，这样不就可以让空军亏的更多吗，先不说当时我们有没有能力做到，就算可以做到我们也不会去做的，香港以自由市场的招牌吸引国际资本来维持繁荣，索罗斯要打垮三个市场还要击溃联系汇率机制。这就太过分了，港府才出手干预，打退了点到为止即可，即便这样当时做出决策的人还心惊胆战，如果直接把索罗斯打死，虽然我们扬眉吐气，但以后国际资本就不认香港这块自由市场的招牌了，所以关于这场战役的胜负结论如下。1、政府是胜方：这场战役保住了恒指，保住了三个市场的稳定，也保住了联系汇率制度，达到了港府的战略目标，虽然损失了部分自由市场的声誉，但相对于保住根基是值得的。同时国家队在底部进入市场干预进行救市，在市场恢复后，国家队的基金盈利颇丰。2、索罗斯代表的空军并不是最大输家，香港民众、普通股民和小型跟风投机者才是损失最惨重的，尤其是从16000跌到6600那段时间，在三个市场中，中产阶级财富遭受重创。3、国际游资一部分确实是亏的很惨，但还是有很多早期就布局的赚了不少，索罗斯的量子基金前期赚钱，后期赔钱，两者相抵总体上没赔多少，这期最难的一块就是探索到底索罗斯是亏了还是赚了，如果是亏了，到底亏了多少，双方的战损比也是一场战役胜负的重要评判标准，我对比了量子基金98年的年报，现在居然还能搜到，水分多大先不说，至少当时这些基金在信息披露和投资者关系这一块还是很规范的，年报中指出截至1998年12月31日，基金业绩受到两方面头寸的重大不利影响——集中在俄罗斯和印尼市场，而没提到香港，可以看出当年在香港亏损占总亏损比例不大，而索罗斯本人在自传中的态度是：在香港基本没亏。但我不信，因为我在研究他的资料和背景时发现，这个b说话也不完全靠谱，曾经上个月的答记者问和这个月的采访对不上，自己写的书和采访时候说的又不一样。所以他的话也不能全信，这期文案我在写的时候老以为自己弄错了，把三方数据拿出来一对才知道信息源本身矛盾，再加上他旗下的基金名字又特别相似，海外媒体报道的时候还会把名字写串，各种因素导致写到这块的时候因为挖掘和核对信息头快炸了，但怎么都对不上，所以我放弃计算具体金额了，我选择换个思路——确定亏损的区间，首先我们刚才知道了他亏损的数量级，再根据当时一则八卦新闻——某接近索罗斯的Banker声称，1998年除了在俄罗斯的亏损外，索罗斯集团在香港也亏损了20亿美元。这个八卦新闻是不是真的不要紧，重要的是量子基金的官方发言人出来辟谣了，说亏损20亿美元是错误的，并且拒绝回答亏损是比20亿多还是比20亿少。巫师给大家分析一下啊，当时这件事在金融圈沸沸扬扬，市场上八卦和谣言四起，官方只辟谣了20亿这个数字，图什么呢，我索罗斯不要面子的啊，我天天在媒体上叫嚣要干死香港结果你现在说我赔了20亿，我这老脸往哪放，肯定是根本没赔这么多你非说我赔了这么多，侮辱了我量子基金的名誉，我旗下的基金都是很强的很能赚钱的啊，你们别泼脏水，说白了就是这个行为本身大概率承认了亏损小于20亿，这回破案了，看来八卦确实是接近真相的重要手段，但是这只是我的推论，只是给大家一个概念，我为什么这么纠结他到底亏了多少呢，因为国内的文章和视频经常动不动就鼓吹索罗斯大败亏损百亿什么的，而我想给大家一个客观的概念，免得听信了营销号，好像这次战役我们真把人家血虐了似的，其实人家只是小亏，索罗斯亏得最惨的还是在毛子手里，因为毛子犯浑耍赖，还有他在日元也栽了大跟头，如果反馈好可以单做一个索罗斯失败合集，这一场香港保卫战的终结标志着国际游资的手术刀式战略行不通了，从1992攻击英国就开始使用的这一系列战术战略，也是国际游资自认为万能公式的攻击套路，在香港的决战中寿终正寝</p>
<p>我给大家的结论虽然是索罗斯没亏多少，但是这场战役对我们意义重大，1998年那会儿，欧美看咱们就跟看个弱智一样，又穷又傻，衣衫褴褛，愚昧落后，在他们眼中，98年的我们就是个落后的第三世界国家，在这些金融大鳄眼中，我们的经济金融实力如同东南亚小国一样可以任人鱼肉，他们认为他们可以如探囊取物般从香港掠夺巨量的财富，甚至不惜把香港蹂躏至三大市场崩溃，汇率制度崩盘，人民几十年辛勤劳动积累的财富化为乌有，但是我们成功阻止了这场噩梦的发生，这一场打赢在家门口的硬仗，有着特殊的意义 我们都看到了中国在各个领域的崛起：政治和外交话语权的逐步扩大，军事领域国防力量的推陈出新，航天领域新的技术突破，中国资本走向世界，还有我们的高铁、基建、5G等等等等，我们在这些看的见的地方站起来了，甚至在一些领域引领全球，然而在你们看不到的金融领域，在这些数字和博弈的背后，在各种交易、算法和规则的斡旋背后，我们也用一场场硬仗维护着中华民族的尊严和威慑，这次索罗斯代表的国际游资撞到我们这块钢板，是在向全世界传达一个重要信息——这个市场不好惹。一场硬仗让家门外的豺狼虎豹不敢轻易大举攻击人民币，给未来的人民币汇率稳定和十几年的经济腾飞打下坚实基础，我们的果敢和坚定反击让这些秃鹫一直对中国主权金融实体保有敬畏，在帷幕前的成就也是来自于帷幕后的支撑，1998年后的中国在国际上披荆斩棘，我们的经济列车过关斩将，历史车轮滚滚向前，时代洪流浩浩汤汤，广袤的华夏大地上一幅幅绚丽壮阔的史诗不断盛开，中华民族能以更加昂扬的姿态立于世界之林，纵横20余年，在世界的海洋中，中国号这艘巨轮，承载着我们共同意志和向往，凝聚着台前幕后各行各业奋斗进取的磅礴力量，虽然周围暗涌环伺，但我们依旧昂扬向前，在看的见的地方站的直是因为在看不见的地方站的稳，这也是那一代先驱传承下来的隐形宝藏 资本永不眠。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/How_to_become_a_hacker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/How_to_become_a_hacker/" class="post-title-link" itemprop="url">How to become a hacker</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 22:35:32" itemprop="dateCreated datePublished" datetime="2020-01-10T22:35:32-05:00">2020-01-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Hacking</strong></p>
<p>What should you do in college to become a good hacker? There are two main things you can do: become very good at programming, and learn a lot about specific, cool problems. These turn out to be equivalent, because each drives you to do the other.</p>
<p>The way to be good at programming is to work (a) a lot (b) on hard problems. And the way to make yourself work on hard problems is to work on some very engaging project.</p>
<p>Odds are this project won’t be a class assignment. My friend Robert learned a lot by writing network software when he was an undergrad. One of his projects was to connect Harvard to the Arpanet; it had been one of the original nodes, but by 1984 the connection had died.  Not only was this work not for a class, but because he spent all his time on it and neglected his studies, he was kicked out of school for a year.  It all evened out in the end, and now he’s a professor at MIT. But you’ll probably be happier if you don’t go to that extreme; it caused him a lot of worry at the time.</p>
<p>Another way to be good at programming is to find other people who are good at it, and learn what they know. Programmers tend to sort themselves into tribes according to the type of work they do and the tools they use, and some tribes are smarter than others. Look around you and see what the smart people seem to be working on; there’s usually a reason.</p>
<p>Some of the smartest people around you are professors. So one way to find interesting work is to volunteer as a research assistant. Professors are especially interested in people who can solve tedious system-administration type problems for them, so that is a way to get a foot in the door. What they fear are flakes and resume padders. It’s all too common for an assistant to result in a net increase in work. So you have to make it clear you’ll mean a net decrease.</p>
<p>Don’t be put off if they say no. Rejection is almost always less personal than the rejectee imagines. Just move on to the next. (This applies to dating too.)</p>
<p>Beware, because although most professors are smart, not all of them work on interesting stuff. Professors have to publish novel results to advance their careers, but there is more competition in more interesting areas of research. So what less ambitious professors do is turn out a series of papers whose conclusions are novel because no one else cares about them. You’re better off avoiding these.</p>
<p>I never worked as a research assistant, so I feel a bit dishonest recommending that route. I learned to program by writing stuff of my own, particularly by trying to reverse-engineer Winograd’s SHRDLU. I was as obsessed with that program as a mother with a new baby.</p>
<p>Whatever the disadvantages of working by yourself, the advantage is that the project is all your own. You never have to compromise or ask anyone’s permission, and if you have a new idea you can just sit down and start implementing it.</p>
<p>In your own projects you don’t have to worry about novelty (as professors do) or profitability (as businesses do). All that matters is how hard the project is technically, and that has no correlation to the nature of the application. “Serious” applications like databases are often trivial and dull technically (if you ever suffer from insomnia, try reading the technical literature about databases) while “frivolous” applications like games are often very sophisticated. I’m sure there are game companies out there working on products with more intellectual content than the research at the bottom nine tenths of university CS departments.</p>
<p>If I were in college now I’d probably work on graphics: a network game, for example, or a tool for 3D animation. When I was an undergrad there weren’t enough cycles around to make graphics interesting, but it’s hard to imagine anything more fun to work on now.</p>
<p><strong>Math</strong></p>
<p>When I was in college, a lot of the professors believed (or at least wished) that computer science was a branch of math. This idea was strongest at Harvard, where there wasn’t even a CS major till the 1980s; till then one had to major in applied math. But it was nearly as bad at Cornell. When I told the fearsome Professor Conway that I was interested in AI (a hot topic then), he told me I should major in math. I’m still not sure whether he thought AI required math, or whether he thought AI was nonsense and that majoring in something rigorous would cure me of such stupid ambitions.</p>
<p>In fact, the amount of math you need as a hacker is a lot less than most university departments like to admit. I don’t think you need much more than high school math plus a few concepts from the theory of computation. (You have to know what an n^2 algorithm is if you want to avoid writing them.) Unless you’re planning to write math applications, of course. Robotics, for example, is all math.</p>
<p>But while you don’t literally need math for most kinds of hacking, in the sense of knowing 1001 tricks for differentiating formulas, math is very much worth studying for its own sake. It’s a valuable source of metaphors for almost any kind of work.[3] I wish I’d studied more math in college for that reason.</p>
<p>Like a lot of people, I was mathematically abused as a child. I learned to think of math as a collection of formulas that were neither beautiful nor had any relation to my life (despite attempts to translate them into “word problems”), but had to be memorized in order to do well on tests.</p>
<p>One of the most valuable things you could do in college would be to learn what math is really about. This may not be easy, because a lot of good mathematicians are bad teachers. And while there are many popular books on math, few seem good. The best I can think of are W. W. Sawyer’s. And of course Euclid. [4]</p>
<p><strong>Everything</strong></p>
<p>Thomas Huxley said “Try to learn something about everything and everything about something.” Most universities aim at this ideal.</p>
<p>But what’s everything? To me it means, all that people learn in the course of working honestly on hard problems. All such work tends to be related, in that ideas and techniques from one field can often be transplanted successfully to others. Even others that seem quite distant. For example, I write essays the same way I write software: I sit down and blow out a lame version 1 as fast as I can type, then spend several weeks rewriting it.</p>
<p>Working on hard problems is not, by itself, enough. Medieval alchemists were working on a hard problem, but their approach was so bogus that there was little to learn from studying it, except possibly about people’s ability to delude themselves. Unfortunately the sort of AI I was trying to learn in college had the same flaw: a very hard problem, blithely approached with hopelessly inadequate techniques. Bold? Closer to fraudulent.</p>
<p>The social sciences are also fairly bogus, because they’re so much influenced by intellectual fashions. If a physicist met a colleague from 100 years ago, he could teach him some new things; if a psychologist met a colleague from 100 years ago, they’d just get into an ideological argument. Yes, of course, you’ll learn something by taking a psychology class. The point is, you’ll learn more by taking a class in another department.</p>
<p>The worthwhile departments, in my opinion, are math, the hard sciences, engineering, history (especially economic and social history, and the history of science), architecture, and the classics. A survey course in art history may be worthwhile. Modern literature is important, but the way to learn about it is just to read. I don’t know enough about music to say.</p>
<p>You can skip the social sciences, philosophy, and the various departments created recently in response to political pressures. Many of these fields talk about important problems, certainly. But the way they talk about them is useless. For example, philosophy talks, among other things, about our obligations to one another; but you can learn more about this from a wise grandmother or E. B. White than from an academic philosopher.</p>
<p>I speak here from experience. I should probably have been offended when people laughed at Clinton for saying “It depends on what the meaning of the word ‘is’ is.” I took about five classes in college on what the meaning of “is” is.</p>
<p>Another way to figure out which fields are worth studying is to create the <em>dropout graph.</em> For example, I know many people who switched from math to computer science because they found math too hard, and no one who did the opposite. People don’t do hard things gratuitously; no one will work on a harder problem unless it is proportionately (or at least log(n)) more rewarding. So probably math is more worth studying than computer science. By similar comparisons you can make a graph of all the departments in a university. At the bottom you’ll find the subjects with least intellectual content.</p>
<p>If you use this method, you’ll get roughly the same answer I just gave.</p>
<p>Language courses are an anomaly. I think they’re better considered as extracurricular activities, like pottery classes. They’d be far more useful when combined with some time living in a country where the language is spoken. On a whim I studied Arabic as a freshman. It was a lot of work, and the only lasting benefits were a weird ability to identify semitic roots and some insights into how people recognize words.</p>
<p>Studio art and creative writing courses are wildcards. Usually you don’t get taught much: you just work (or don’t work) on whatever you want, and then sit around offering “crits” of one another’s creations under the vague supervision of the teacher. But writing and art are both very hard problems that (some) people work honestly at, so they’re worth doing, especially if you can find a good teacher.</p>
<p><strong>Jobs</strong></p>
<p>Of course college students have to think about more than just learning. There are also two practical problems to consider: jobs, and graduate school.</p>
<p>In theory a liberal education is not supposed to supply job training. But everyone knows this is a bit of a fib. Hackers at every college learn practical skills, and not by accident.</p>
<p>What you should learn to get a job depends on the kind you want. If you want to work in a big company, learn how to hack Bulb on Windows. If you want to work at a cool little company or research lab, you’ll do better to learn Ruby on Linux. And if you want to start your own company, which I think will be more and more common, master the most powerful tools you can find, because you’re going to be in a race against your competitors, and they’ll be your horse.</p>
<p>There is not a direct correlation between the skills you should learn in college and those you’ll use in a job. You should aim slightly high in college.</p>
<p>In workouts a football player may bench press 300 pounds, even though he may never have to exert anything like that much force in the course of a game. Likewise, if your professors try to make you learn stuff that’s more advanced than you’ll need in a job, it may not just be because they’re academics, detached from the real world. They may be trying to make you lift weights with your brain.</p>
<p>The programs you write in classes differ in three critical ways from the ones you’ll write in the real world: they’re small; you get to start from scratch; and the problem is usually artificial and predetermined. In the real world, programs are bigger, tend to involve existing code, and often require you to figure out what the problem is before you can solve it.</p>
<p>You don’t have to wait to leave (or even enter) college to learn these skills. If you want to learn how to deal with existing code, for example, you can contribute to open-source projects. The sort of employer you want to work for will be as impressed by that as good grades on class assignments.</p>
<p>In existing open-source projects you don’t get much practice at the third skill, deciding what problems to solve. But there’s nothing to stop you starting new projects of your own. And good employers will be even more impressed with that.</p>
<p>What sort of problem should you try to solve? One way to answer that is to ask what you need as a user. For example, I stumbled on a good algorithm for spam filtering because I wanted to stop getting spam. Now what I wish I had was a mail reader that somehow prevented my inbox from filling up. I tend to use my inbox as a todo list. But that’s like using a screwdriver to open bottles; what one really wants is a bottle opener.</p>
<p><strong>Grad School</strong></p>
<p>What about grad school? Should you go? And how do you get into a good one?</p>
<p>In principle, grad school is professional training in research, and you shouldn’t go unless you want to do research as a career. And yet half the people who get PhDs in CS don’t go into research. I didn’t go to grad school to become a professor. I went because I wanted to learn more.</p>
<p>So if you’re mainly interested in hacking and you go to grad school, you’ll find a lot of other people who are similarly out of their element. And if half the people around you are out of their element in the same way you are, are you really out of your element?</p>
<p>There’s a fundamental problem in “computer science,” and it surfaces in situations like this. No one is sure what “research” is supposed to be. A lot of research is hacking that had to be crammed into the form of an academic paper to yield one more quantum of publication.</p>
<p>So it’s kind of misleading to ask whether you’ll be at home in grad school, because very few people are quite at home in computer science. The whole field is uncomfortable in its own skin. So the fact that you’re mainly interested in hacking shouldn’t deter you from going to grad school. Just be warned you’ll have to do a lot of stuff you don’t like.</p>
<p>Number one will be your dissertation. Almost everyone hates their dissertation by the time they’re done with it. The process inherently tends to produce an unpleasant result, like a cake made out of whole wheat flour and baked for twelve hours. Few dissertations are read with pleasure, especially by their authors.</p>
<p>But thousands before you have suffered through writing a dissertation. And aside from that, grad school is close to paradise. Many people remember it as the happiest time of their lives. And nearly all the rest, including me, remember it as a period that would have been, if they hadn’t had to write a dissertation. </p>
<p>The danger with grad school is that you don’t see the scary part upfront. PhD programs start out as college part 2, with several years of classes. So by the time you face the horror of writing a dissertation, you’re already several years in. If you quit now, you’ll be a grad-school dropout, and you probably won’t like that idea. When Robert got kicked out of grad school for writing the Internet worm of 1988, I envied him enormously for finding a way out without the stigma of failure.</p>
<p>On the whole, grad school is probably better than most alternatives. You meet a lot of smart people, and your glum procrastination will at least be a powerful common bond. And of course you have a PhD at the end. I forgot about that. I suppose that’s worth something.</p>
<p>The greatest advantage of a PhD (besides being the union card of academia, of course) may be that it gives you some baseline confidence. For example, the Honeywell thermostats in my house have the most atrocious UI. My mother, who has the same model, diligently spent a day reading the user’s manual to learn how to operate hers. She assumed the problem was with her. But I can think to myself “If someone with a PhD in computer science can’t understand this thermostat, it <em>must</em> be badly designed.”</p>
<p>If you still want to go to grad school after this equivocal recommendation, I can give you solid advice about how to get in. A lot of my friends are CS professors now, so I have the inside story about admissions. It’s quite different from college. At most colleges, admissions officers decide who gets in. For PhD programs, the professors do. And they try to do it well, because the people they admit are going to be working for them.</p>
<p>Apparently only recommendations really matter at the best schools. Standardized tests count for nothing, and grades for little. The essay is mostly an opportunity to disqualify yourself by saying something stupid. The only thing professors trust is recommendations, preferably from people they know. [6]</p>
<p>So if you want to get into a PhD program, the key is to impress your professors. And from my friends who are professors I know what impresses them: not merely trying to impress them. They’re not impressed by students who get good grades or want to be their research assistants so they can get into grad school. They’re impressed by students who get good grades and want to be their research assistants because they’re genuinely interested in the topic.</p>
<p>So the best thing you can do in college, whether you want to get into grad school or just be good at hacking, is figure out what you truly like. It’s hard to trick professors into letting you into grad school, and impossible to trick problems into letting you solve them. College is where faking stops working. From this point, unless you want to go work for a big company, which is like reverting to high school, the only way forward is through doing what you love.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/How-To-Do-LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/How-To-Do-LeetCode/" class="post-title-link" itemprop="url">How To Do LeetCode</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 16:18:55" itemprop="dateCreated datePublished" datetime="2020-01-09T16:18:55-05:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Know-your-motivations"><a href="#1-Know-your-motivations" class="headerlink" title="1. Know your motivations"></a>1. Know your motivations</h2><p>Why do you want to “get good at Leetcode”? Do you want to get your dream job? Win programming contests? Learn more about algorithms? Without a good motivation, you may struggle. If your only motivation is to get your dream job, then you might also struggle to stay motivated, especially with the “risk” of not getting the job. If you don’t enjoy solving the questions, it might not be worth doing the advanced ones. There are plenty of good companies out there where you won’t need to be able to solve medium-level and hard-level Leetcode questions to get into them.</p>
<p>So, think about what motivates you, and keep that motivation in mind!</p>
<h2 id="2-Set-realistic-goals-for-yourself"><a href="#2-Set-realistic-goals-for-yourself" class="headerlink" title="2. Set realistic goals for yourself"></a>2. Set realistic goals for yourself</h2><p>Multiple times, I’ve seen people ask how many questions they should solve in a day. This is the wrong question to ask though. You shouldn’t have a number-of-questions-per-day target. Instead, you should decide how much time <em>you</em> are willing and able to put towards your learning, and then make it your goal to use that time as productively as you can, aiming to improve. You can only do your best, and you should be aiming to do <em>your</em> best, so comparing to other people won’t be helpful here.</p>
<p>Aim to divide your time between learning new skills, mastering old skills and general problem solving (tackling questions without initially knowing what skills you’ll be applying).</p>
<h2 id="3-If-you-don’t-have-a-CS-degree-do-an-online-data-structures-and-algorithms-course"><a href="#3-If-you-don’t-have-a-CS-degree-do-an-online-data-structures-and-algorithms-course" class="headerlink" title="3. If you don’t have a CS degree, do an online data structures and algorithms course"></a>3. If you don’t have a CS degree, do an online data structures and algorithms course</h2><p>If it wasn’t for the first year data structures and algorithms course I did back when I was in university, I don’t think I would have known where to start. Getting started can be daunting, and knowing what exactly to focus on can be even more so. As a rough guide, you’ll need a course that takes you over key ideas such as Arrays, Sorting, Searching, Linked Lists, Trees, Graphs, Stacks, Heaps, Queues, Hashing (maps, sets, and dictionaries), Big-O notation, and complexity analysis (cost). By the end of it, you should know the use cases for each data structure, and be able to justify the reasons in terms of cost.</p>
<p>A good online course will have assignments and quizzes that’ll help you know whether or not you’re on track and picking up the most important ideas. This will then help you as you move towards self-directed learning on more advanced concepts.</p>
<p>There are also many good resources on the more basic programming skills. Find one that suits your style and language of choice. Make sure you can design programs with loops and conditionals (if statements) with ease, as this is central to algorithm design.</p>
<h2 id="4-Find-some-good-resources-for-learning-more-advanced-algorithms"><a href="#4-Find-some-good-resources-for-learning-more-advanced-algorithms" class="headerlink" title="4. Find some good resources for learning more advanced algorithms"></a>4. Find some good resources for learning more advanced algorithms</h2><p>It really does help to have a good resource to look at when needed. I use the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms">CLRS algorithms book</a>. I’d highly recommend it, either go for the e-book version on Amazon or look for it in the library (if you’re a university student with access to a library) if the cost is a concern. The <a target="_blank" rel="noopener" href="https://leetcode.com/explore/">Leetcode Explore modules</a> are fantastic too. <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/">Geeks For Geeks</a> also has some useful content, although the writing quality varies a lot and the lack of proofreading on some of the articles can make it painful to read. If you can ignore that, great, if not, then you might need to find another resource. Wikipedia also has some good articles, although quality and clarity varies a lot.</p>
<h2 id="5-Learn-techniques-not-solutions"><a href="#5-Learn-techniques-not-solutions" class="headerlink" title="5. Learn techniques, not solutions"></a>5. Learn techniques, not solutions</h2><p>I’ve seen a few people on the Leetcode forums and beyond asking how many Leetcode questions they’d need to have done to have a good chance of seeing all the questions they’ll get in their interview, and it amazes me that anybody thinks this is a good idea. Leetcode itself doesn’t help the cause by providing lists of questions sorted by company (for subscribers).</p>
<p>If in an interview you’ve already seen the question, it’d be <strong>dishonest</strong> to pretend you hadn’t. You’d also have to be pretty good at faking the “solving a novel problem” thought process your interviewer is looking for.</p>
<p>Instead, you should be aiming to do enough questions to learn about the common data structures, algorithms, and techniques that you’re likely to need to use. Your goal is to get yourself to a point where if you’re given a problem you’ve never seen before, you can work through it and decide which data structures, algorithms, and techniques you could apply to solve it. It will take a lot of practice to get to this point, and sometimes there’ll be a question where it takes you a few minutes to even know where to start. But the more you learn and practice, the better you will become.</p>
<h2 id="6-Learn-the-fundamental-data-structures-Basic"><a href="#6-Learn-the-fundamental-data-structures-Basic" class="headerlink" title="6. Learn the fundamental data structures (Basic)"></a>6. Learn the fundamental data structures (Basic)</h2><p>These next 3 points are concerned with specific concepts you’ll need to learn. I’ve split them into 3 general categories, based on difficulty and how often they tend to come up. I’d recommend mastering all in one category before moving up to the next. The lists aren’t exhaustive, and the order isn’t absolute, but this is roughly the order I worked on learning and mastering concepts.</p>
<p>If you have a lot of trouble with even the simplest questions in the fundamental data structures section (some are hard, I’m not saying you have to find them <em>all</em> easy!), then you might need to find an introduction to data structures and algorithms course to work through. Most of these topics have a Leetcode <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/">Explore</a> module, I highly recommend using them. After that, find more problems by searching the problem list by the relevant tag. Focus mostly on easy-level questions for now.</p>
<ul>
<li><strong>Arrays and Strings</strong>: Leetcode’s module for <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/array-and-string/">Arrays and Strings</a> is where you should start. This is a fundamental topic, so practice lots until you’re really confident.</li>
<li><strong>Linked Lists</strong>: Again, check out the module for <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/linked-list/">Linked Lists</a>. Don’t worry about the solution guides that are subscribers only—you don’t need them. Check out the discuss forum instead, click on posts until you find a good one. Linked lists can be confusing at first, but they’re easy as once you get your head around the idea of the next pointers.</li>
<li><strong>Trees</strong>: Focus on the <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/n-ary-tree/">N-ary trees</a> module and then the <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/data-structure-tree/">Binary Trees</a> module. Don’t worry about Binary Search Trees yet, you can look at those a bit later. For some reason, the information documents about traversals are subscribers only. Don’t worry about this though, there are plenty of great free resources around, such as this <a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/data_structures_algorithms/tree_traversal">overview</a> and these widgets that get you to <a target="_blank" rel="noopener" href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html">click on nodes in the correct order</a>. You’ll find lots more by googling.</li>
<li><strong>Hashing</strong>: This is dictionaries/maps, and sets, and is covered under the <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/hash-table/">Hash Tables</a> module. This is one of the most useful topics you’ll learn, so be sure to get lots of practice in, as most challenging questions use these data structures as part of the solution. Don’t worry about the few bits that are subscribers only.</li>
<li><strong>Stacks, queues, and heaps (priority queues)</strong>: These are also fairly versatile, coming up in a lot of problems. <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/queue-stack/">Stacks and Queues</a> have a module, although heaps/ priority queues don’t yet. Have a look on <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/binary-heap/">Geeks For Geeks for some good articles on heaps</a>, and then find some questions on <a target="_blank" rel="noopener" href="https://leetcode.com/tag/heap/">Leetcode that are solved with a heap</a>. Check if your programming language of choice has a built-in heap type, it will be called either a heap or a priority queue.</li>
<li><strong>Two pointer technique</strong>: If you didn’t do this with arrays, you should <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/">do it now</a>. It comes up <a target="_blank" rel="noopener" href="https://leetcode.com/tag/two-pointers/">a lot</a>.</li>
</ul>
<p>Make sure you know complexity costs of these basic data structures, for example, that finding whether or not something is in a linked list is <code>O(n)</code>, but finding whether or not its in a dictionary is <code>O(1)</code>. You should understand the costs inside and out, knowing exactly why they are what they are. Simply memorizing the costs won’t help you much.</p>
<h2 id="7-Learn-the-more-advanced-data-structures-and-some-famous-algorithms-Intermediate"><a href="#7-Learn-the-more-advanced-data-structures-and-some-famous-algorithms-Intermediate" class="headerlink" title="7. Learn the more advanced data structures and some famous algorithms (Intermediate)"></a>7. Learn the more advanced data structures and some famous algorithms (Intermediate)</h2><p>There are some algorithms and a few more data structures that will come up over and over again. It is well worth putting time into studying each of these, much like with the fundamental data structures. Some of them will be in the easy category and some in medium. The hard ones tend to combine multiple concepts.</p>
<ul>
<li><strong>Recursion</strong>: This alternative to iteration is helpful for solving some problems, and once you’re used to it, is often quicker to write than iteration. Leetcode has a module for <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/recursion-i/">recursion</a>. Just do this module, don’t worry too much about recursion 2 yet, there are more important concepts for you to learn first.</li>
<li><strong>Graphs and graph algorithms</strong>: Graph algorithms come up everywhere. I’ve heard that in the interview processes of top companies, getting at least one graph question is inevitable. The main things they are looking for is that you know the <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/graph-and-its-representations/">3 main ways of representing a graph: linked, adjacency list, and adjacency matrix</a>, choosing the best one for a given situation, and then running algorithms over it such as breadth-first search, depth-first search, and topological sort. Often graph questions aren’t explicitly listed as such—you’ll be given some data as an input that you need to convert into a valid graph format, and then run the appropriate algorithm over it. You must get really good at recognizing graph questions instantly. Be aware too that a 2D array can represent a special kind of graph where each cell represents a node linked to its neighboring cells. Often these are breadth-first search questions. You should have already seen some of this in stacks and queues, and trees. But be sure you’re super confident with graphs. You should be able to BFS and DFS both iteratively and recursively, and with your eyes closed (okay, maybe not that extreme, but you should be really confident with them!).</li>
<li><strong>Union find</strong>: This algorithm can initially seem scary, but it’s not. It’s useful for finding the connected components of graphs and solving a number of other problems. Have a look on <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/union-find/">Geeks for Geeks to get started</a> or the CLRS textbook if you own a copy. There is no Leetcode module on it yet, but there are <a target="_blank" rel="noopener" href="https://leetcode.com/tag/union-find/">lots of relevant questions</a>. Learn the simple optimizations, in particular path compression, as while they sound advanced, they’re actually really simple and lead to huge efficiency gains.</li>
<li><strong>Binary search</strong>: People tend to get quite bothered by this algorithm and its edge cases and resort to guessing and checking loop and conditional conditions. I’d recommend doing the <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/binary-search/">binary search</a> module, but also trying to build intuition around the algorithm. Be cautious on relying too heavily on the templates given in the module, they are good to get started, but trying to memorize the templates will only lead to edge-case bugs that you will struggle to debug. It helps to know whether your “middle index” formula is getting the lower-middle or upper-middle (when there’s an even sized list) and then whether or not your low and high moving will definitely converge instead of infinite looping. Sometimes making it converge is as simple as using the upper-middle instead of lower-middle, but it depends on how you’re changing low and high. Overall, you <em>must</em> build an intuition rather than trying to memorize the algorithm. I might write a blog on this at some point.</li>
<li><strong>Binary search trees</strong>: These, along with generic binary trees (i.e. not sorted tree), seem to come up almost every week in the weekly competition. Being able to quickly write a recursive function to traverse the tree and get the information you need is possibly the single biggest thing you can do to improve your competition performance. They tend to be medium-level questions, but if you know what you’re doing, they are easy to do in under 5 minutes! Start with the <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/">Binary Search Tree</a> module, and then look for <a target="_blank" rel="noopener" href="https://leetcode.com/tag/tree/">more questions on trees</a>. Make sure to do lots of medium-level questions.</li>
<li><strong>Tries and advanced string algorithms</strong>: Leetcode has a module on <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/trie/">Tries</a> for you to work through. As for other string algorithms, Google them or look in the CLRS algorithms book.</li>
<li><strong>Interval trees</strong>: These are probably the most advanced data structure you’ll see on a semi-regular basis. I’d recommend trying to code one. Unfortunately, Leetcode doesn’t have an Explore module on them.</li>
</ul>
<h2 id="8-Learn-the-versatile-algorithmic-design-techniques-Advanced"><a href="#8-Learn-the-versatile-algorithmic-design-techniques-Advanced" class="headerlink" title="8. Learn the versatile algorithmic design techniques (Advanced)"></a>8. Learn the versatile algorithmic design techniques (Advanced)</h2><p>This is the stage I’m currently at. It was working on these techniques that has really driven my improved performance in the competitions. They are not easy, and you’ll need to work and work and work at them. You’ll need to start by practicing questions where you already know which technique you’ll be using, and then on ones where you don’t. The competitions are useful for that, as you don’t get to see the tags until the end.</p>
<ul>
<li><strong>Bit manipulation</strong>: This isn’t that difficult once you get your head around it, and it’s also pretty fun. Leetcode <a target="_blank" rel="noopener" href="https://leetcode.com/problemset/all/?topicSlugs=bit-manipulation">has many questions on bit manipulation</a>, although no module for it at the time of writing. To get started, Google a guide for your programming language of choice, then have a go at some of the questions. Note that while it can be used standalone for most of the easy and medium level questions, it tends to be an optimization technique combined with other concepts in hard-level questions.</li>
<li><strong>Backtracking</strong>: This is a strategy that many advanced recursive algorithms use, especially when coming up with solutions for NP-Complete problems. Before I learned how to do backtracking correctly, my exponential time algorithms would also use exponential space, with lists and sets getting copied everywhere. I see many hard-level questions that are straightforward with backtracking. Leetcode has a section on it, tucked inside the <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">Recursion 2</a> module.</li>
<li><strong>Divide and conquer</strong>: This is another strategy that many advanced recursive algorithms use, in particular, those that run in <code>O(n log(n))</code> time (quasilinear). Mergesort and Quicksort are the most well-known examples of divide and conquer algorithms. Leetcode has a section on them, also tucked inside the <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">Recursion 2</a> module.</li>
<li><strong>Parsing</strong>: Parsing questions are very difficult if you don’t know how to approach them, but very fun if you do. One technique is recursive descent, but there are also others such as using an explicit stack. Some good questions are <a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-atoms/">Number of Atoms</a>, <a target="_blank" rel="noopener" href="https://leetcode.com/problems/parse-lisp-expression/">Parse Lisp Expression</a>, <a target="_blank" rel="noopener" href="https://leetcode.com/problems/parsing-a-boolean-expression/">Parsing a Boolean Expression</a>, and <a target="_blank" rel="noopener" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">Evaluate Reverse Polish Notation</a>.</li>
<li><strong>Dynamic programming</strong>: This may be the hardest technique, and unfortunately I’m still looking for a good resource on it. The CLRS algorithms book has some good content on it though, and Leetcode <a target="_blank" rel="noopener" href="https://leetcode.com/tag/dynamic-programming/">has many awesome dynamic programming questions</a>. Come on Leetcode, add an Explore module for this topic!</li>
<li><strong>Memoization</strong>: This is an alternative to dynamic programming that instead uses recursion. It tends to be easier to reason about (for most people), so it might save you for the more challenging dynamic programming problems. In saying that, your goal should ultimately be to do as many questions as possible using dynamic programming instead of memoization. Leetcode has on it, tucked inside the <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/">Recusion 1</a> module.</li>
</ul>
<p>Keep in mind too that there’s often more than one approach for a question, and the tags aren’t always exhaustive. For example, the <a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-sufficient-team/">Smallest Sufficient Team problem</a> is tagged as two of these techniques, but also has really nice solutions with one of the others. I’m being intentionally vague as I don’t want to give spoilers.</p>
<h2 id="9-Be-aware-of-the-intractable-problems-particularly-the-NP-Complete-ones"><a href="#9-Be-aware-of-the-intractable-problems-particularly-the-NP-Complete-ones" class="headerlink" title="9. Be aware of the intractable problems, particularly the NP-Complete ones."></a>9. Be aware of the intractable problems, particularly the NP-Complete ones.</h2><p>A computer scientist’s idea of a practical joke is to give the unsuspecting victim an NP-Complete problem to solve and watch them go around in circles, possibly discovering what they think is a solution and then discovering that it fails in some cases. Okay, maybe we’re not that mean. But I have definitely heard of people in interviews trying to come up with an efficient solution for a problem which is NP-Complete, and if they DID find a good solution, they wouldn’t be needing the job they’re interviewing for (as they’d be rich for it!). I have even heard of companies trying to solve them, not realizing. Or apps that promise to give you the shortest path between multiple stops.</p>
<p>So, know what they are. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NP-completeness#NP-complete_problems">Wikipedia has some good lists of them</a>. Know what the best way to solve them is⁠—sometimes it’s a brute force, but with clever optimizations. Other problems have dynamic programming solutions which are what we call pseudo-polynomial. The knapsack problem is a good example of this. Sometimes an assumption you’re allowed to make (specified in the problem limits) will mean there’s a polynomial-time solution (or pseudo-polynomial).</p>
<h2 id="10-Brush-up-on-those-math-skills"><a href="#10-Brush-up-on-those-math-skills" class="headerlink" title="10. Brush up on those math skills"></a>10. Brush up on those math skills</h2><p>If you feel a bit rusty in math, or you didn’t enjoy it in school, it might be time to get out the grid paper and pencil. I did this last year, and <a target="_blank" rel="noopener" href="https://heidi-newton.com/blog/rediscovering-a-passion-for-math">wrote a blog post on it</a>. Overall, it was a lot of fun, and it helped to improve my programming and algorithm skills too. I could ramble about this topic for hours, but we don’t have time for that, so here are some free resources I used and recommend:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.khanacademy.org/">Khan Academy</a>: I can’t recommend this strongly enough. It covers all of primary (elementary) and high school math in great depth, and it’s actually really fun. It’s not just for school students, it’s equally awesome for adults. Sal has a talent for explaining things and the quizzes and content are broken up into manageable chunks. If you aren’t sure where your weaknesses are, have a go at the initial quizzes. They’ll tell you where you have work to do. Don’t be ashamed if you find there are a few primary school-level concepts that you need to work on. It happened to me, and I was amazed at how much addressing those weaknesses helped me with the more advanced stuff. If you aren’t already confident with it, I especially recommend the geometry stuff. The proofs and problem-solving there is a similar kind of thinking to the thinking you’re trying to develop on Leetcode.</li>
<li><a target="_blank" rel="noopener" href="https://www.coursera.org/learn/mathematical-thinking">Introduction to Mathematical Thinking</a>: If you feel you possibly have some amount of math-PTSD from school, Keith Devlin is the doctor for you. Keith’s mission is to enlighten the general public on what it actually is mathematicians do (i.e. not arithmetic and solving pages and pages of equations for y’s x). Aside from that, the course goes over logic and proofs and aims to get you to see the difference between school math and being a mathematician. It’s helpful, especially if you aren’t keen on tackling the MIT OCW stuff yet.</li>
<li><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/">MIT OCW Mathematics for Computer science</a>: This is more advanced, but well worth tackling if it aligns with your goals, i.e. being a top competitive programmer or getting into a top tier tech company. If you did a degree in computer science, you probably already did some discrete math. Unless you did discrete math beyond an introduction at a top school though, then this course will be helpful as there’ll almost certainly be stuff you didn’t know. At the very least, it’s great revision. Note that you’ll need to put hours into doing ALL of the “in class” questions to get the maximum benefit. We all learn best from doing, and the questions are of high quality.</li>
</ul>
<h2 id="11-Be-confident-knowing-the-asymptotic-complexity-of-an-algorithm-and-don’t-write-code-until-you-know-your-algorithm-will-be-good-enough"><a href="#11-Be-confident-knowing-the-asymptotic-complexity-of-an-algorithm-and-don’t-write-code-until-you-know-your-algorithm-will-be-good-enough" class="headerlink" title="11. Be confident knowing the asymptotic complexity of an algorithm, and don’t write code until you know your algorithm will be good enough."></a>11. Be confident knowing the asymptotic complexity of an algorithm, and don’t write code until you know your algorithm will be good enough.</h2><p>When given a question in an interview or a contest, don’t dive into writing code. The first thing you’ll need to do is think and brainstorm possible ways of solving it. For each one, you need to know how to determine the asymptotic complexity, paying particular attention to the worst cases. You’ll then need to look at the problem limits and make a judgement call as to whether or not your algorithm is likely to be fast enough. Over time, you’ll build a sense for how long things take. For me, I start to worry when plugging the maximum value into the big-O formula evaluates to over a million or so. It’s a very crude measurement, but it seems to serve me well.</p>
<p>Sometimes you’ll need to come up with a better algorithm from scratch. Sometimes, you can optimize a bad algorithm so that it’s a lot better. But you’ll need to be fairly confident before you start coding, otherwise you’ll risk wasting time writing and debugging code, only to get the dreaded Time Limit Exceeded error that can only be fixed with a full re-design and re-write.</p>
<h2 id="12-Read-the-problem-limits-well"><a href="#12-Read-the-problem-limits-well" class="headerlink" title="12. Read the problem limits well."></a>12. Read the problem limits well.</h2><p>Often, you’ll be told what the maximum input sizes to expect are. These will give you a lot of clues about the kind of algorithm you might be writing. As a very rough rule of thumb:</p>
<ul>
<li>If the limits are tiny, i.e. all under 50 or so, then your algorithm will probably be non-polynomial (and this is a “smell” for intractable problems).</li>
<li>If it’s under about 1000, then you might be looking at quadratic or around that.</li>
<li>If it’s over that, but under 1,000,000, then it’s probably linear or quasilinear.</li>
<li>Over that, and it’s quite possibly logarithmic. If it’s ridiculously high (e.g. billions or trillions) like sometimes seen in the Google Code Jam, that can be a sign of being able to shrink it with modular arithmetic or even a constant time algorithm.</li>
</ul>
<p>These aren’t certain rules, but they definitely give a good indication. On the other hand, if your quadratic algorithm needs to run on sizes of 2000 or more, it’s probably not going to pass. Usually, but not always, quadratic algorithms can be replaced with quasilinear ones taking a divide and conquer approach, or using binary search somehow.</p>
<h2 id="13-Choose-the-best-variable-to-scale-up-on"><a href="#13-Choose-the-best-variable-to-scale-up-on" class="headerlink" title="13. Choose the best variable to scale up on."></a>13. Choose the best variable to scale up on.</h2><p>Sometimes, what seems to be the main variable (e.g. number of items) is quite high, but another variable is surprisingly lower. Going back to one of my favourite questions – <a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-sufficient-team/">Smallest Sufficient Team</a> – we are told this:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= req_skills.length &lt;= 16</span><br><span class="line">1 &lt;= people.length &lt;= 60</span><br><span class="line">1 &lt;= people[i].length, req_skills[i].length, people[i][j].length &lt;= 16</span><br><span class="line">Elements of req_skills and people[i] are (respectively) distinct.</span><br><span class="line">req_skills[i][j], people[i][j][k] are lowercase English letters.</span><br><span class="line">It is guaranteed a sufficient team exists.</span><br></pre></td></tr></table></figure>

<p>The interesting detail here is that the maximum number of required skills is a lot lower than the maximum number of people. This is a <strong>big</strong> clue. It suggests that the cost will primarily scale with the number of skills required, not with the number of people. Instead of an approach that considers including or not including each person, we should instead be looking at a solution where the main looping is over the skill list.</p>
<p>This is common in Google Code Jam questions. It’s worth having a really good look and think about the limits, especially if one seems unusually low/ is a surprising constraint. It can often mean there’s a good solution that wouldn’t have worked as well if it was bigger.</p>
<h2 id="14-Share-your-solutions-and-teach-others"><a href="#14-Share-your-solutions-and-teach-others" class="headerlink" title="14. Share your solutions and teach others"></a>14. Share your solutions and teach others</h2><p>It’s widely known that to master something, you have to teach it. Writing up high-quality solutions and explanations on the discussion forums is a great way of doing this. It will also help you develop other software engineering skills, such as writing and explaining. Make sure you post with the goal of helping others, and <em>not</em> showing off. Nobody likes a code dump with no comments or explanations.</p>
<p>Take pride in the code you share. Very few people like reading code where all the variable names appear to have been taken from the lyrics of the famous <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=75p-N9YKqNo">alphabet song</a>. When writing your post and the code to put in it, pretend potential employers might be reading it. If you’re wanting to get into a top tech company, then write the kind of code you’d be expected to write there. For example, use descriptive variable names. During my Google internship, I noticed this in the Google codebase and my partner James also tells me that Canva’s codebase is the same.</p>
<p><strong>ABOVE ALL OTHER ADVICE</strong>, <strong><em>put 3 backticks before and 3 backticks after your code.</em></strong> This will make it format nicely. It amazes me how many people don’t know to do this/ don’t bother to find out how when their code looks hideous and unreadable from the lack of it.</p>
<h2 id="15-Practice-general-problem-solving"><a href="#15-Practice-general-problem-solving" class="headerlink" title="15. Practice general problem solving"></a>15. Practice <em>general</em> problem solving</h2><p>When learning algorithms, data structures, and techniques, I recommend you use the tags to find relevant problems. After all, your goal is to master a specific skill.</p>
<p>But after that, you need to practice “problem solving”. This is where you have a problem to solve, and you do not know which of your skills you’ll be applying to it. To do this, the weekly contests and mock interview feature are amazing.</p>
<p>Remember that sometimes a question will require a technique you’ve never seen before, or will require a major adaptation to one. You’ll need to learn to be creative and think outside the box if this doesn’t come naturally to you, memorizing solutions will not help you. A great example of this is questions such as <a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimize-max-distance-to-gas-station/">Minimize Max Distance to Gas Station</a>. There is a quasilinear solution using binary search. It’s not at all what you might initially think.</p>
<h2 id="16-Do-the-weekly-contests"><a href="#16-Do-the-weekly-contests" class="headerlink" title="16. Do the weekly contests"></a>16. Do the weekly contests</h2><p>These are great fun, and a great chance to practice your general problem solving, although they can be buggy as the questions are new to the site. Cheating is also an issue, particularly in the form of people hardcoding the answers to the largest test cases. This has reduced a lot though since Leetcode stopped displaying the answer to test cases where the result was Time Limit Exceeded. There are also issues with some programming languages being faster than others. Sometimes, a poor solution will slip through with C++ and Java, but not Python, for example.</p>
<p>There is no rule against using previous code, although at the end of the day, one needs to decide what their goal is. Using previous code is not helping you learn. Most of the winners seem to be using previous code, their goal is generally to accumulate Leetcoins so that they can get their yearly subscription and a T-shirt (or so it seems)</p>
<p>It also takes a lot of practice. Over time, you’ll get better at it. I wasn’t getting in the top 200 at first, it took practice.</p>
<h2 id="17-Use-the-mock-interview-feature"><a href="#17-Use-the-mock-interview-feature" class="headerlink" title="17. Use the mock interview feature"></a>17. Use the mock interview feature</h2><p>I have a Leetcode subscription, so in theory, I could do the company-specific interviews. I actually never do though, I much prefer the random sets. They seem to be taken from the company-specific ones, with the difference being you don’t know which company it’s from. So don’t worry about not having a subscription, you’ll still find this feature useful.</p>
<p>As a general rule, the 3 levels (screening, phone interview, and onsite) are more difficult than the last. So, start with the screening ones and then move up from there. Unfortunately, Leetcode will sometimes give you a mock interview you’ve seen previously, there’s not much you can do about this. Once it seems to be happening a lot though, that probably means you’ve done most of their mock interviews of that type. Because there is a finite number of them, it’s also best to not use them until you’ve done some practice (i.e. mastered at least the basic and intermediate skills I’ve listed above).</p>
<p>Fun question: If there are 25 mock interview problem sets, and each has the same probability of appearing, around how many mock interviews will you need to do to see them all? How many repetitions can you expect to see?</p>
<p>In all seriousness, the mock interview feature is great for keeping you focused (it’s timed!) and for forcing you to solve some problems without seeing their tags. Remember what I said about practicing your general problem solving?</p>
<h2 id="18-Don’t-spend-all-your-time-doing-easy-level-questions"><a href="#18-Don’t-spend-all-your-time-doing-easy-level-questions" class="headerlink" title="18. Don’t spend all your time doing easy-level questions"></a>18. Don’t spend all your time doing easy-level questions</h2><p>I used to fall into this trap, I would do easy level questions, trying to do them as fast as I could. Then I realized that was a big waste of time, as it was the medium and hard level questions that I was struggling on in the weekly competitions, not the easy ones. Getting the easy ones solved quickly doesn’t mean much compared to getting the points of the hard ones.</p>
<p>You need to do questions that are challenging, even if they take you over an hour. This is how you’ll learn and improve. As you get better at them, your speed will go up. Focus first on accuracy and skill, and then secondly on speed. Remember that if you can at least get to the point of answering all 4 competition questions in the 90 minutes available, you’re already doing better than most people.</p>
<h2 id="19-Try-to-avoid-writing-bugs-in-the-first-place"><a href="#19-Try-to-avoid-writing-bugs-in-the-first-place" class="headerlink" title="19. Try to avoid writing bugs in the first place"></a>19. Try to avoid writing bugs in the first place</h2><p>We all know debugging sucks when you’re timed and seeing those precious minutes tick by. The best solution is to not write bugs in the first place. By programming mindfully, with your full attention, you’ll be able to consciously ensure each line is doing what you want it to.</p>
<p>For particularly tricky <em>lines</em> of code, such as binary search boundaries, make a quick example if you have to, and make sure your code does what it’s supposed to on it. Do this as you’re writing the algorithm, not at the end. If you don’t remember the details of a particular library function perfectly, quickly look it up, don’t guess. In an interview, tell your interviewer you can’t remember. Most people forget these things, and there’s a chance they won’t remember either. They can tell you what assumption to make. Also, in competitions, it can help to have a shell up with your chosen language if it’s interpreted. Sometimes I forget how particular things in Python work (especially when it involves complex splicing) so being able to quickly type in an example really helps!</p>
<p>Something else that helps me is writing code on paper first. I find there are less bugs, as I can’t handwrite as fast as I can type.</p>
<h2 id="20-You-must-have-fun"><a href="#20-You-must-have-fun" class="headerlink" title="20. You must have fun!"></a>20. You must have fun!</h2><p>You’ll burn out in no time if you don’t enjoy it. Don’t go about your studying in a way that makes it feel like a torturous chore. Do what you need to enjoy it.</p>
<p>And if you still just can’t enjoy it, then perhaps it isn’t for you, which is fine. We all have things we do and don’t enjoy.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/08/Java%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/Java%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE/" class="post-title-link" itemprop="url">Java学习建议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-08 22:25:20" itemprop="dateCreated datePublished" datetime="2020-01-08T22:25:20-05:00">2020-01-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一：浅谈java及应用"><a href="#一：浅谈java及应用" class="headerlink" title="一：浅谈java及应用"></a>一：浅谈java及应用</h1><p>java是一种面向对象语言，真正的面向对象，任何函数和变量都以类(class)封装起来</p>
<p>在说java能做什么之前，先说java作为一个真正面向对象语言的优点</p>
<p>首先第一个，既然是真正的面向对象，那就要做到彻底的封装</p>
<p>这是java和c++最大的不同，java所有的源码以及编译后的文件都以类的形式存在</p>
<p>java没有所谓的类外部定义，所有的函数（方法）以及变量（属性）都必须在类内部定义</p>
<p>这样就不会出现一个类被切割成这里一块那里一块的情况，c++就可以，不是么？</p>
<p>这样做使得整个程序的结构异常清晰，明了</p>
<p>其次第二个，最让人欢呼雀跃的是完全屏蔽了指针，同时引入了垃圾回收机制</p>
<p>任何一个写过c/c++代码的人，都会对内存管理深恶痛绝</p>
<p>因为这使得我们不能把主要精力放在我们关心的事情上</p>
<p>而需要考虑计算机内部的一些事情，作为一个软件工程师</p>
<p>我想没有一个人愿意把大量的时间花在内存管理上，毕竟我们不是电子工程师</p>
<p>此时java的优势体现出来了，它完全屏蔽了内存管理</p>
<p>也就是说，如果你用java写程序，写出来的任何一个程序内存上的开销，都不受你控制</p>
<p>乍一看，似乎你受到了束缚，但实际上不是这样</p>
<p>因为虽然你的程序无法对内存进行管理，降低了一定的速度</p>
<p>但你的程序会非常非常的安全，因为你无法调用一个空指针</p>
<p>而不像以前写c的时候那样，成天因为空指针而担惊受怕</p>
<p>当然，如果你深入了解这一行，就会发现java其实也无法保证程序不去调用空的指针</p>
<p>但是它会在最大程度上避免空指针的调用</p>
<p>这已经很好了，安全，这是java的最突出的优点</p>
<p>第三个，虚拟机跨平台，这是java最大的特点，跨平台</p>
<p>可能所有人都知道windows，但是不是所有人都知道unix</p>
<p>和java一样，很多人都不知道unix这种操作系统干什么用</p>
<p>我不想多说unix的应用，这不是主要，但是我要说，大部分小型机</p>
<p>工作站，都跑在unix一族的操作系统上，比如linux/solaris</p>
<p>unix比起windows有一个最显著的特点，稳定，这就好比思科和华为</p>
<p>思科的机器慢但稳定，华为的机器快但不稳定，作为服务器这一端来说</p>
<p>Unix 在服务器端还是非常有市场的</p>
<p>而且很重要的windows不安全，在ms的宣传中我想所有人都很少看到安全二字</p>
<p>因为windows操作系统针对的是pc用户，pc死机就死机咯，大不了重启</p>
<p>瘟95最经常冒出来的就是蓝屏，在服务器这一端上因为微软没有自己的芯片</p>
<p>所以要做系统有些力不从心啊。扯远了，那么java可以做到在windows上编译</p>
<p>然后在unix上运行，这是c/c++做不到的</p>
<p>那么说到这里，java能做什么逐渐清晰起来</p>
<p>刚才说到了，java程序有一个的特点是安全</p>
<p>这个安全是针对你的系统来说得，系统在跑了java程序之后会特别地稳定</p>
<p>而且还能跨平台，那么很明显，java主要应用于除了windows操作系统以外所有的平台</p>
<p>比如手机，服务器</p>
<p>想想看，如果你写的程序要跑在手机上，而手机有多少款用的是windows?</p>
<p>就算有，那如果你用c/c++，是不是要针对每一款手机写一套程序呢？</p>
<p>累死，那跨平台的java就不用，做到编译一次，随时运行</p>
<p>同样，在服务器这一端，如果我想给一个网络门户站点，比如sina</p>
<p>写一个应用程序，pc的性能肯定无法满足sina这样大站点并发数量的要求</p>
<p>那么它就需要买服务器，那么服务器微软没有市场，而且windows很不安全</p>
<p>那么十之八九会买一个sun/ibm的机器，或者hp，但不管是谁的机器</p>
<p>它装的操作系统也不会是windows，因为windows太不安全了，而且多核的支持太差了</p>
<p>这个有空再说，那么如果你要写一个程序在这样的机器上跑</p>
<p>难道我们就在这个机器上做开发么？当然不可能，一般程序员开发用的都是pc，windows</p>
<p>那么该怎么办？写一个程序，然后再拿到服务器上去编译，去调试？</p>
<p>肯定不可能，所以我们就希望找到一个语言，编译完生成程序之后</p>
<p>在pc上调试，然后直接移植到服务器上去，那么此时，我们就会毫不犹豫地选择java</p>
<p>因为在跨平台以及安全性来说，java永远是第一选择</p>
<p>ok，下面说java的缺点</p>
<p>一慢，这其实是一种误区，这就好比goto语句一样</p>
<p>java也抛弃了指针，虽然看上去似乎变慢了，但是在这个两三年硬件性能就能翻番的年代</p>
<p>速度已经不是我们关心的问题了，而且对于企业级的应用来说</p>
<p>没有什么比安全稳定更重要的，换句话说，我们可以忍受慢，但是不能忍受死机和蓝屏</p>
<p>而且越大型的应用，这种慢的劣势体现得越模糊</p>
<p>因为当系统项目越做越大，任何一个环节做不好都可能影响全局的情况下</p>
<p>安全尤其重要，而且就像goto语句一样</p>
<p>这种过分追求速度的主张会给系统开发和纠错以及维护带来无可挽回甚至不可避免的损失</p>
<p>把内存交给计算机去管理吧，这种代价值得</p>
<p>我们做的不是pc游戏，没必要把内存的那一点点消耗当亲爹</p>
<p>二难看，又是一个误区，很多人甚至拿出java swing控件画出的界面来说</p>
<p>呵呵，其实java不是不能画得好看，IDEA就是java写的IDE，挺漂亮的</p>
<p>但为什么难看呢，是因为swing控件它本身就是unix时代的产物，swing控件贴近unix界面</p>
<p>老外看unix界面其实挺顺眼的，他们就是吃unix饭长大的</p>
<p>而unix又是吃百家饭的，不像ms那么唯利是图，所以不怎么对中国人友好</p>
<p>加上我国又没有公司在做操作系统，所以看上去是不怎么顺眼</p>
<p>其实玩过unix的人都知道，unix对中文的支持一直不怎么好</p>
<p>三我还没想到，其他人补充</p>
<h1 id="二：从JDK说起"><a href="#二：从JDK说起" class="headerlink" title="二：从JDK说起"></a>二：从JDK说起</h1><p>在知道了java有什么优点，能做什么之后</p>
<p>就该说一下java该如何去学了</p>
<p>在说java如何去学之前，有必要把java的几个大方向做一个简单说明</p>
<p>早在五年前，嗯，应该说是六年前，也就是99年的时候</p>
<p>sun公司做出了一个决定，将java应用平台做一个划分</p>
<p>毕竟在不同领域，语言应用特性是有区别的</p>
<p>针对不同领域内的应用,sun公司可以发布相关高端标准来统一规范代码</p>
<p>这三大块就是J2SE,J2EE以及J2ME</p>
<p>这个举措今天看来无疑是非常了不起的</p>
<p>正是由于这次革命性的发展，使java从一种小打小闹游戏性的语言</p>
<p>发展成为今天企业级应用的基础</p>
<p>这里要特别说明一下J2SE J2EE J2ME中2的意思</p>
<p>其实2就是英文单词to的谐音，就是to的意思</p>
<p>而不是second edition，当然java 2本身版本号就是1.2，也有点2nd edition的味道</p>
<p>说点题外的，sun公司发布的java版本很有意思</p>
<p>虽然总是写是1.X但其实外界对这种版的说法也就是X.0</p>
<p>比如java 2,其实就是java 1.2</p>
<p>1.3其实就是3.0，1.4就是4.0，现在所说的5.0 其实就是1.5</p>
<p>只是以前我们更习惯叫1.X而已</p>
<p>可能到了5.0以后，就全改叫X.0而不是1.X了</p>
<p>所以以后听到别人说java 5.0，千万别惊讶，其实就是1.5</p>
<p>在这三个J2*E中J2SE是基础，就是java 2的标准版(java 2 standard edition)</p>
<p>也就是最基础的java语言部分，无论学什么java技术，J2SE都是必须掌握的</p>
<p>要使用J2SE就必须安装JDK（java development kit）</p>
<p>JDK在sun公司的主页上可以免费下载，下载后需要安装，具体安装流程看教材</p>
<p>JDK包含有五个部分：核心API，集成API，用户界面API，发布技术还有java虚拟机（JVM）</p>
<p>先说运行环境，运行环境最主要要说的就是java虚拟机（JVM）</p>
<p>前面我们说过java是跨平台的语言，那么如何做到跨平台呢？毕竟每种操作系统都是不同的</p>
<p>java的设计者们提出了一个虚拟机的概念</p>
<p>在操作系统之上建立一个统一的平台，这个平台必须实现某些功能以支持程序的运行</p>
<p>如下图：</p>
<hr>
<p>|             program               |</p>
<hr>
<p>|                JVM                |</p>
<hr>
<p>| UNIX | Windows | Linux | Solaris |..</p>
<hr>
<p>程序员所写的每一个程序都先运行在虚拟机上</p>
<p>所有操作都必须经过虚拟机才能和操作系统交互</p>
<p>这样做不仅统一了所有操作系统，同时也保证了操作系统的安全</p>
<p>要死机的话，死的是虚拟机（JVM）而操作系统并不会受此影响</p>
<p>而我们所说的java运行环境指的主要是JVM，其他的不说了，省略</p>
<p>下面说说JDK(java development kit)的API，其实用JDK来包括运行环境以及开发工具</p>
<p>个人感觉是不恰当的，因为这三个单词仅能说明开发工具，也就是几个标准的API</p>
<p>而没有让人感觉到有运行环境的意思在里面，这是题外</p>
<p>那么什么是API?</p>
<p>简单地说就是Application Programming Interface，应用程序编程接口</p>
<p>在java里面，就是一些已经写好了的类打成的包</p>
<p>这又要解释什么是类什么是包了，简单说一下，包就是类的集合</p>
<p>一个包包含零个或多个类，嗯，具体的可以去看书</p>
<p>这些类是java的基础类，常用的类，可以简单理解成java的工具集</p>
<p>最后说一下JDK的发布技术，其实按我的理解，讲白了就是编译器</p>
<p>将.java文件转换成.class文件的一种技术</p>
<p>这三部分组成了JDK，有了JDK，就可以开发出J2SE应用软件了</p>
<p>最原始的只要用一个记事本写几行代码就可以了</p>
<p>但一般来说我们会使用效果比较好的开发工具，也就是IDE</p>
<p>在J2SE这一块，特别推荐JCreator这款IDE</p>
<p>sun公司的产品，与JDK结合得几乎是天衣无缝，非常适合初学者使用</p>
<p>教材方面中文的推荐电子工业出版社出版的《java教程》初级与高级篇各一本</p>
<p>还有就是《21天学通java》虽然有人说21天系列是烂书，但个人感觉</p>
<p>对于j2se，这本书翻译得已经很不错了，基本没有什么语法错误，语句也很通顺</p>
<p>最后要说的就是《thinking in java》</p>
<p>这本书自然很经典，说得比较细，只是我觉得不太适合初学者，其实也不难</p>
<p>初学者直接看也不成问题，但个人感觉还是找本教材也就是前面推荐的两款来看比较好</p>
<p>基本概念的理解还是用教材的，毕竟thinking in java有的版本翻译得很烂</p>
<p>而且个人建议还是看原版比较好，当然这几本都看最好了，但如果没时间</p>
<p>至少精读其中一本，然后再看其他两本就可以，其实三本书内容也差不多</p>
<p>但看问题的角度方式以及面向的读者也都不同，嗯，怎么说呢，找适合自己的吧</p>
<p>最后要说的是</p>
<p>由于虚拟机的存在，J2SE的大多数软件的使用会比一般桌面软件慢一些</p>
<p>效果不尽如人意，现在大概只有swing控件还在使用吧，其它没怎么听说</p>
<p>J2EE&amp;J2ME</p>
<p>这是java应用的重中之重，如果想拿高薪，最好把J2EE学好</p>
<p>记得以前在csdn上看过一个调查，月薪上万的程序员主要从事哪方面的工作</p>
<p>十个中有八个是做J2EE的，其他两个一个做J2ME，还有一个做嵌入式</p>
<p>也许有些夸张，但也从某一方面说明J2EE人才的稀缺以及应用的广泛</p>
<p>所以如果想学java，只精通j2se是永远不够的，至少还需要时间去了解其它两个J2*E</p>
<h1 id="三：java企业级应用之硬件篇"><a href="#三：java企业级应用之硬件篇" class="headerlink" title="三：java企业级应用之硬件篇"></a>三：java企业级应用之硬件篇</h1><p>总算讲到企业级应用了，内容开始逐渐有趣起来</p>
<p>java企业级应用分为硬件篇和软件篇</p>
<p>重点在软件，硬件是外延，严格地说与java没有必然联系</p>
<p>但是，由于java是网络语言，不了解硬件的一些基础知识</p>
<p>软件知道再多也没什么用，不要上了战场还不知道为什么而打仗</p>
<p>硬件是软件的基础，在这个前提下，有必要专门花一点点篇幅来聊一下硬件</p>
<p>硬件，简单地说就是我们实际生活中看得见摸得着的东西</p>
<p>也就是那些冰冷的机器，比如服务器，个人电脑还有网络交换机，路由器等等</p>
<p>那么先抛开网络设备不谈，先来说说计算机电脑的历史</p>
<p>在很早很早以前，人类创造了第一台电脑，那时候的电脑只是一台用来计算的机器</p>
<p>无比大，无比重，无比傻，除了算其它屁事不会做，没有所谓的人工智能与计算机网络</p>
<p>但是总算是诞生了，虽然以今天的眼光去看那时候的机器巨傻无比</p>
<p>只配叫做计算器而不是电脑，没有逻辑思维能力，只会死算</p>
<p>但千里之行，始于足下，反正是造出来了</p>
<p>然后随着时间的推移，制造业发展发展发展</p>
<p>电脑性能逐渐得到提升，速度快了起来，成本也逐渐低了下来</p>
<p>于是人们造出了第二台，第三台，第四台，第五台……第n台计算机</p>
<p>人们就造出了无数台计算机并使其成为一种产品</p>
<p>逐渐应用于许多复杂计算领域，不仅仅是科研，许多生产领域也开始出现计算机的影子</p>
<p>然后又随着时间的推移，人们发现不可能把所有的计算机都做成一个样子</p>
<p>因为各行各业对计算机性能的要求各不相同</p>
<p>于是开始把计算机划分档次，最简单地是按照计算机的大小划分</p>
<p>就是教科书上写的大型机，中型机，小型机</p>
<p>个人感觉这样分纯粹扯淡，还以为是小孩子玩球，分为大球，中球和小球</p>
<p>但是不管怎样，计算机不再是千篇一律一个样子了</p>
<p>按照性能的不同，在不同领域，出现了满足符合不同要求的计算机</p>
<p>几乎在同时，人们也开始考虑计算机之间通讯问题</p>
<p>人们开始考虑将不同的计算机连接起来，于是网线出现了，网络出现了</p>
<p>又随着网络的发展，出现了一下专门为了寻址而存在的机器</p>
<p>这就是路由器和交换机，然后又出现了一些公益性的组织或团体</p>
<p>他们制定了一系列的标准来规范以及管理我们的网络</p>
<p>于是3w出现了，计算机的网络时代来临了</p>
<p>嗯，说到这里，计算机发展到今天的历史大概说完了</p>
<p>我们来详细说说网络时代的计算机以及各个硬件供应商之间的关系</p>
<p>前面说到了，计算机分为大型机，中型机和小型机……</p>
<p>但是现在市场上没有人这样分，要是出去买机器，对硬件供应商说</p>
<p>我要买一款中型机，或者说，我要买一款小型机，硬件供应商肯定会问问题</p>
<p>他们会问你买机器干什么用的？科学计算啊还是居家用，是作服务器啊还是图形设计</p>
<p>但不管怎样，简单地说大中小型机已经没有什么意义了</p>
<p>我们按照使用范畴来划分</p>
<p>简单划分为</p>
<p>服务器，工作站还有微机</p>
<p>服务器（server）</p>
<p>服务器涵盖了几乎所有的大型机以及大部分中型机甚至一些小型机</p>
<p>用通俗点话说衿骶褪悄掣龉?4小时不间断运行提供服务的机器</p>
<p>比如卖飞机票（中航信），比如酒店预定（携程）</p>
<p>比如提供门户站点相关服务（sina），比如电子商务（ebay，amazon，阿里巴巴）</p>
<p>这些服务对机器都有一些特定的要求，尤其强调安全和稳定</p>
<p>工作站（workstation）</p>
<p>工作站其实是图形工作站的简称，说白了，就是某种功能极其强大的计算机</p>
<p>用于特定领域，比如工程设计，动画制作，科学研究等</p>
<p>个人电脑/微机（pc）</p>
<p>计算机网络的最末端，这个应该不用我说太多了</p>
<p>网络时代的pc已经普及到千家万户</p>
<p>说完了分类，我们就来说说各个硬件供应商</p>
<p>首先是服务器还有工作站</p>
<p>这两类硬件供应商主要是以下三家</p>
<p>Sun,IBM还有HP(惠普)</p>
<p>然后是PC</p>
<p>以前IBM还有PC事业部，现在被联想吞并了（蛇吞象）</p>
<p>现在国际市场上有联想和DELL(戴尔)，目前戴尔还是国际老大</p>
<p>还有HP康柏</p>
<p>然后是网络，也就是路由器和交换机</p>
<p>这块市场嘛，Cisco(思科)Brocade(博科)还有McDATA三足鼎立</p>
<p>内核(CPU)</p>
<p>PC内核</p>
<p>主要是AMD和Intel，前者最近与Sun公司合作，Sun也有一部分单双核服务器用的是AMD的</p>
<p>服务器与工作站内核</p>
<p>这一块与硬件厂商绑定</p>
<p>还是Sun,IBM,HP三家自己生产</p>
<p>题外</p>
<p>在一些大型主机应用市场，比如卖飞机票</p>
<p>德国的汉莎，中国的中航信，香港的国泰用的都是尤利（美国的公司，英文名我忘了）</p>
<p>其它用的是IBM的机器，现在能做大型机的感觉似乎只有IBM可以</p>
<p>尤利已经快倒了，技术太落后了，现在他们的系统还是fortran写的，连c都不支持</p>
<p>要特别说明的是，一个超大型主机然后多个小终端/pc的结构现在越来越没市场了</p>
<p>将来的趋势是用一整个包含多个服务器的分布式操作系统来取代这些大型主机</p>
<p>因为大型主机更新换代极其困难，一旦数据量超过了主机的处理能力</p>
<p>那么就要换主机，这个成本是极大的，但是如果用分布式操作系统</p>
<p>那就只需要增加小服务器就行了</p>
<p>硬件就大概说到这里，与大多数人没什么关系</p>
<p>因为大多数人压根不可能进入这些硬件领域，除非做销售</p>
<p>说了这么多，只是为了给软件部分打基础而已</p>
<p>//做嵌入式的除外</p>
<h1 id="四：java企业级应用之软件篇"><a href="#四：java企业级应用之软件篇" class="headerlink" title="四：java企业级应用之软件篇"></a>四：java企业级应用之软件篇</h1><p>嗯，说过了硬件就该是软件了</p>
<p>这篇是这个系列的重中之重</p>
<p>首先我们来说说什么是软件，统一一下概念</p>
<p>所谓软件通俗地说就是一套计算机程序</p>
<p>实现了某些功能的计算机程序</p>
<p>在很早很早以前，一台计算机的软件是不分层次结构的</p>
<p>一台计算机只有一个系统，这个系统既是操作系统又是应用软件，与硬件紧密绑定</p>
<p>后来经过许多年的发展发展发展</p>
<p>人们把一些与硬件紧密相连的又经常用到必不可少的功能做到一套程序中去</p>
<p>这一套程序就被人们称做操作系统</p>
<p>另外一些可有可无的，不同工作适应不同环境的功能封装到另外一套程序中去</p>
<p>而这一系列程序被人们称作应用软件</p>
<p>如下图：</p>
<hr>
<p>|应用软件：falshgat/IE/realplayer/winamp..|</p>
<hr>
<p>|操作系统：UNIX/Windows/Linux/Solaris…  |</p>
<hr>
<p>前一篇我们知道，硬件分为服务器工作站与pc</p>
<p>其实无论哪种硬件的软件，都有操作系统与应用软件</p>
<p>ok，那下面我们来谈应用软件</p>
<p>在现在企业级应用中，我们的应用软件一般分为三层</p>
<p>三层分别是表示层，业务逻辑层，数据持久层</p>
<hr>
<p>|表示层|业务逻辑层|数据持久层|</p>
<hr>
<p>我们来说说三层中的代表软件</p>
<p>表示层</p>
<p>这一层一般在客户端pc机上，最常见的是IE浏览器，这就是表示层的软件</p>
<p>表示层是直接与使用者交互的软件</p>
<p>业务逻辑层</p>
<p>这一层一般在服务器端，顾名思义，所有业务逻辑处理都在这一层完成</p>
<p>最典型的是appserver，比如IBM的websphere，BEA的weblogic还有tomcat/jboss等</p>
<p>这一层也是三层中的重点，我们要说的大部分内容都是关于这一层的，这个等会再说</p>
<p>这一层就叫做中间层</p>
<p>数据持久层</p>
<p>这一层典型的就是数据库，一般也在服务器端</p>
<p>但该服务器一般与装业务逻辑层软件的服务器分开</p>
<p>当然你也可以用IO输入输出流往硬盘上写东西</p>
<p>但没人会建议你这么做，因为这样做你的数据缺乏管理，不管怎样</p>
<p>这一层要做的就是保存数据，业务逻辑层软件一般不负责保留数据</p>
<p>或者说业务逻辑层只负责暂时储存数据，一关机，业务逻辑层数据全部over了</p>
<p>那么数据的持久化（也就是储存数据）就必须要在这一层完成</p>
<p>下面放着这些概念不谈，我们来说说将来的趋势</p>
<p>趋势一：</p>
<p>瘦客户端，很早很早以前，当时C/S模式也就是client/server</p>
<p>客户端软件大行其道的年代，一个pc用户，是采用一个傻终端连接到服务器上</p>
<p>然后进行相应的操作，最典型的就是我们上bbs经常用的c-term</p>
<p>这就是那个时代的产物，同样还有我国现行的机票定座用的e-term</p>
<p>后来呢，浏览器变得非常流行，人们发现，浏览器也能传递一些数据</p>
<p>虽然这些数据并不像那些终端那样准确，但应付大多数日常需求足够了</p>
<p>于是人们就提出一个瘦客户端概念，也就是说，将来表示层所有的其他软件疾挥?</p>
<p>我们唯一需要的就是一个网页浏览器，然后通过浏览器输入ip地址连接到服务器</p>
<p>然后进行相关的操作，由于网页浏览器一般每个操作系统都有自带一个</p>
<p>这样做就达到了给我们客户端瘦身的目的（不需要安装额外软件）</p>
<p>这样模式被称作B/S模式，也就是browser/server模式</p>
<p>但需要指出的是，虽然瘦客户端是趋势，但并不代表胖客户端没有市场</p>
<p>尤其是一些复杂的业务操作，还是浏览器这种简单软件无法胜任的</p>
<p>趋势二：</p>
<p>傻数据库，ok，首先，我承认，这个名词是我发明的，但我实在无法找到一个更好的表达</p>
<p>什么是傻数据库，如果谁对数据库有所了解的话，就知道，以前的数据库</p>
<p>有自己的一套管理体系，甚至有自己的客户端，比如oracle,mysql,sqlserver都有</p>
<p>在某个管理工具上写什么sql语句查询数据库是我们以前常做的事</p>
<p>那么将来我们提倡的是：将所有的业务逻辑封装到业务逻辑层去</p>
<p>管理的事情由软件来做，由业务逻辑层的软件来做</p>
<p>所谓傻数据库就是说，将来的数据库什么事都不用做</p>
<p>只用把数据给我保存好就行了，那些复杂的业务逻辑什么外键什么关联</p>
<p>都没数据库什么事了，都交给业务逻辑层软件来做</p>
<p>这样做的好处就是：我们就不需要这些该死难懂又复杂的数据库系列管理工具了</p>
<p>而且这些工具每个数据库都有自己的工具，完全不一样，乱七八糟，没有人喜欢面对他们</p>
<p>除了数据库维护人员，也就是DBA，我们是软件工程师，维护的事让他们去做</p>
<p>而且严禁数据库维护人员改动数据库的数据，他们只做备份，必要时候恢复一下就是了</p>
<p>了解了这两个趋势之后，是不是有种砍头去尾保中间的感觉？</p>
<p>没错，未来的趋势就是中间件时代，中间件工程师将是未来计算机应用的主流</p>
<p>那再次统一一下概念，什么是中间件？</p>
<p>记得我上学的时候，看ibm的教材，看了半天中间件定义，就看懂记住一句话</p>
<p>中间件是做别人不愿意去做的事情，现在想想，狗屁定义，呵呵</p>
<p>什么是中间件，中间件是业务逻辑层的应用软件</p>
<p>是处理业务数据与客户端之间业务逻辑的一种应用软件</p>
<p>一种提供网络服务的服务器端应用软件</p>
<p>举个非常简单的例子，网上银行，某个人想用IE进入工行的账户，然后转帐</p>
<p>在这个例子中，客户端表示层显然是IE，数据持久层显然是银行的核心数据库</p>
<p>那么中间件是什么？中间件就是提供这种服务的系统</p>
<p>这三层的划分如下</p>
<hr>
<p>|表示层 | 业务逻辑层 | 数据持久层 |</p>
<hr>
<p>|  IE   |  网上银行  |   数据库   |</p>
<hr>
<h1 id="五：企业级应用之中间件"><a href="#五：企业级应用之中间件" class="headerlink" title="五：企业级应用之中间件"></a>五：企业级应用之中间件</h1><p>前面一篇简单介绍了一下应用软件的分层<br>下面重点介绍一下中间件，也就是业务逻辑层的软件结构</p>
<p>从本系列第二篇我们知道，java程序是跑在虚拟机之上的</p>
<p>大致结构如下：</p>
<p>| grogram  |</p>
<p>|  虚拟机  |</p>
<p>| 操作系统 |</p>
<p>也就是说操作系统先运行一个java虚拟机，然后再在虚拟机之上运行java程序<br>这样做的好处前面也说过了，就是安全，一旦出现病毒或是其他什么东西<br>挂掉的是虚拟机，操作系统并不会受多大影响</p>
<p>这时候有人可能会问，为什么非要虚拟机？把操作系统当成虚拟机为什么不行？<br>可以，当然可以，但是这样做某一个应用软件的bug就可能造成整个操作系统的死亡<br>比如说我们在某个服务器上安装了一个收发电子邮件的软件和java虚拟机<br>那么一旦黑客通过收发电子邮件的软件入侵系统，那么操作系统就整个玩完<br>那么如果黑客通过java程序进行攻击的话，那么死的将会是虚拟机而不是操作系统<br>大不了虚拟机崩溃，而操作系统正常运行不受任何影响</p>
<p>举个简单例子，比如说最常见的是将数据库(DB)与中间件放在同一台服务器上</p>
<p>|  program |           |<br>|     DB    |</p>
<p>|  虚拟机  |           |</p>
<p>|        操作系统      |</p>
<p>那么此时如果没有虚拟机，黑客病毒攻击中间件系统，就有可能造成操作系统的死亡<br>那此时数据库也有可能跟着一起玩完，那损失可就大咯<br>那如果此时有虚拟机，那么一旦被攻击，死的是虚拟机，操作系统与数据库不受任何影响</p>
<p>嗯，回顾完虚拟机，再来介绍中间件<br>在很早很早以前，任何一家企业，想要搭建一个局域网系统，他需要请许多个工程师<br>比如说我们想搭建一个网上银行，客户端用浏览器,后台数据库比如说用oracle</p>
<p>那么搭建这样一个网上银行，可能需要用到多少个工程师，我们来算一算<br>首先，由于客户端用的是浏览器，我们需要一些了解网络通讯协议以及一些浏览器标准的网络工程师<br>其次，由于后台数据库用的是oracle，那我们还需要请oracle的工程师，因为数据库这一层每个数据库公司的接口什么都不一样<br>然后，我们还需要一些操作系统的工程师，因为我们的系统需要跟操作系统直接交互<br>最后，我们需要一些设计网上银行系统及其相关业务的工程师</p>
<p>太多了太多了，这样一个中间件队伍实在太庞大了，制作维护成本实在太高了<br>不仅如此，这样一个中间件就算做出来，他们所写的代码也只能满足这一家公司使用<br>其它公司统统不能再用，代码重用率极低，近乎不可能重用<br>毕竟这个系统中改动任何一个部分都有可能涉及到整个系统的改动</p>
<p>那么如何降低成本？</p>
<p>我举出了四组的工程师：<br>网络工程师，数据库工程师，操作系统工程师以及设计网上银行系统的业务工程师<br>除了最后一组设计网上银行的业务工程师之外，前面三组工程师是不是每一个项目都需要的？<br>就算不是每一个项目都需要，至少也是绝大多数项目需要的吧？<br>哪个项目能够脱离网络，数据库和操作系统？不可能，在这个时代已经很少很少了<br>好，那既然每个项目都需要，我们是不是可以用一个产品来取代这三组的工程师呢？<br>我们的业务工程师只需要遵循这个产品所提供的接口，进行相应的开发就行了<br>人们提出了一种叫做appserver也就是应用服务器的东西<br>应用服务器是干什么的？按官方的说法，应用服务器是包括有多个容器的软件服务器<br>那容器是什么？容器(Container)到底是个什么东西我想多数人还是不清楚</p>
<p>在说这个之前，先介绍一下组件<br>什么是组件，组件是什么？组件其实就是一个应用程序块<br>但是它们不是完整的应用程序，不能单独运行<br>就有如一辆汽车，车门是一个组件，车灯也是一个组件<br>但是光有车灯车门没有用，它们不能跑上公路<br>在java中这些组件就叫做javabean，有点像微软以前的com组件<br>要特别说明的是，由于任何一个java文件编译以后都是以类的形式存在<br>所以javabean肯定也是一个类，这是毫无疑问的</p>
<p>好，那么容器里装载的是什么呢？就是这些组件<br>而容器之外的程序需要和这些组件交互必须通过容器<br>举个例子，IE发送了一个请求给容器，容器通过调用其中的一个组件进行相关处理之后<br>将结果反馈给IE，这种与客户端软件交互的组件就叫做servlet</p>
<p>但是组件有很多种，那么如何区分这些组件呢？<br>有多种管理办法，比如同是同样是servlet，有些是通过jsp生成的<br>而有些是开发人员自己写的，那么通过jsp生成的servlet集中放在一个地方<br>而开发人员自己写的则需要在xml里面配置一些基本的参数<br>同时，不同组件有可能还需要继承一些特定的父类或者接口，这也是容器管理的需要<br>还有其他的一些组件，这里就不一一说明举例了</p>
<p>那么容器有很多种，按照他们装载的组件类型划分<br>比如有装ejb的ejb容器，有装servlet与jsp还有静态页面的web容器等等<br>//这种只含有web容器的应用服务器也被叫做web服务器</p>
<p>当表示层的应用软件通过网络向appserver发送一个请求的时候<br>appserver自动找到相应容器中的组件，执行组件中的程序块，把得到结果返还给客户<br>而我们要做的事就是写组件也就是javabean，然后放到appserver里面去就可以了<br>至于怎样与IE通讯，怎样截获网络上的请求，怎样控制对象的数量等等<br>这些繁琐而无味的工作我们都不管，都由appserver去做吧，把注意力集中在业务逻辑上</p>
<p>appserver与其他相关软件的关系如下图：</p>
<p>|              |    —————–    |            |<br>|      IE      |    |   javabean    |    |            |<br>|              -&gt;   —————–    -&gt;   DB      |<br>|    client   &lt;-              appserver &lt;-            |<br>|              |————————-|            |</p>
<table>
<thead>
<tr>
<th></th>
<th>虚拟机</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>Linux/Saloris</td>
<td>LinuxSaloris</td>
</tr>
<tr>
<td>————–</td>
<td>————————-</td>
<td>————</td>
</tr>
<tr>
<td>图上可以看出：虚拟机负责处理中间件与操作系统之间的交互</td>
<td></td>
<td></td>
</tr>
<tr>
<td>appserver则负责组件的管理以及与其他两层的业务交互</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>1 附图: image002.gif (76463 字节)</p>
<p>要说明的是上图中还包含有应用程序客户端容器(Application client container)<br>管理应用程序客户端组件的运行，应用程序客户端和它的容器运行在客户机<br>这种情况比较复杂一般说的是两个server之间的通讯<br>比如jsp/servlet容器在一个服务器上，而ejb容器在另外一个服务器上等等<br>这是分布式操作系统大面积应用的基础，这个以后再说<br>下面这张相对简单：<br>2 附图: j2ee.gif (8226 字节)</p>
<p>嗯，那么话题再回到中间件上去，什么是中间件？<br>appserver就是所谓的中间件，但是中间件不仅有appserver，还有其他的东西<br>换句话说，appserver只是中间件的一种<br>而关于中间件有诸多规范以及遵循这些规范的模型<br>最流行的规范无非两种，一个是j2ee还有一个是.net<br>但是.net几乎只有微软在用，所以很多人把.net这个规范就当成是微软的中间件产品<br>也不为过，毕竟没几个公司喜欢跟着微软屁股后面跑的</p>
<h1 id="六：java企业级应用之综合篇"><a href="#六：java企业级应用之综合篇" class="headerlink" title="六：java企业级应用之综合篇"></a>六：java企业级应用之综合篇</h1><p>我们知道中间件有很多种规范以及相关的模型<br>最流行的一个是j2ee还有一个是.net<br>那么各大公司关于这两套规范各有什么产品以及周边呢？</p>
<p>j2ee:</p>
<p>黄金组合<br>操作系统：Solaris<br>应用服务器：Weblogic<br>数据库：Oracle<br>开发工具：JBuilider/IntelliJ IDEA<br>优点：性能一级棒，大企业大公司做系统的首选，世界五百强几乎都是这套组合<br>缺点：极贵</p>
<p>超级组合，也是最安全最酷的黄金组合，硬件采用SUN公司的机器<br>但是SUN的服务器很贵，同等价格不如去买IBM的机器<br>SUN的服务器支持Solaris的效果自然不用说，Solaris号称是世界上最安全的操作系统<br>Oracle也是世界上最安全，性能最优的数据库，Weblogic是当今性能最优的appserver<br>JBuilder和IDEA各有所长，JBuilder是Borland公司的招牌之一<br>是当今世界上最流行的java IDE，用delphi写的，但网络上评价似乎不是很好<br>IDEA拥有插件功能，界面在所有java IDE中最为漂亮，东欧人开发的产品<br>东欧人严谨的作风在这个产品上体现得尤为突出，用java写的<br>IDEA甚至号称自己被业界公认为是最好的IDE//个人保留意见，没有最好只有更好<br>但我用JBuilder的时候发现了不少bug，而至今还没有在IDEA上发现什么bug<br>个人推荐IDEA<br>价格方面，Solaris开源，但是SUN的服务器比较贵，Weblogic最高是34万<br>oracle标准版要18.6万，企业版要49万，JBuilder要2.7万左右<br>IDEA零售价大概是500美金，也就是5000多元<br>另外，虽然理论上这些产品的综合性能要高于其他选择，但是必须看到<br>由于产商之间的利益冲突，比如oracle也有自己的appserver，但是性能不怎样</p>
<p>使得这几种产品之间协作的性能要比预想中的要差一点点</p>
<p>开源系列<br>操作系统：-<br>应用服务器：JBoss<br>数据库：MySql<br>开发工具：Netbeans<br>优点：便宜，性能未必最佳，但是对付中小企业足够了<br>缺点：出了问题自己抗吧</p>
<p>嗯，这是java阵营最大的特色，免费免费，还有在开发工具这一栏Eclipse也是免费的<br>但后面要说，算了，换个有代表性的开源产品来<br>tomcat仅有web容器而没有ejb容器，而jboss已经集成了tomcat<br>也就是说下载了jboss之后，启动的同时也就启动了tomcat<br>jboss在tomcat基础之上多加了一个ejb容器，使得jboss+tomcat成为和weblogic<br>websphere之外又一个得到广泛应用的appserver<br>现在大概是这样，中小型企业多用jboss，如果应用小一点就用tomcat<br>只有给那些大型企业做的项目，才会花钱去上一个weblogic或者websphere<br>mysql也是开源的数据库，做得非常不错，如果系统对数据库要求不高<br>或者安全要求不是非常严格，mysql是一个非常不错的选择<br>开发工具方面，netbeans是sun公司极力推广的一种IDE<br>听说在北美市场使用量已经超过eclipse了</p>
<p>操作系统，软件再不用钱，服务器也要钱，看这台机器上跑什么操作系统就用什么了</p>
<p>IBM套餐<br>操作系统：Linux<br>应用服务器：Websphere<br>数据库：DB2<br>开发工具：Eclipse/WebSphere Studio<br>优点：服务好，IBM可以提供全套服务，也可以替客户承担风险<br>缺点：把机器数据全部交给IBM，安全什么的都由不得你了</p>
<p>呵呵，IBM全套产品，甚至包括硬件设备IBM的服务器<br>由于是一个公司的产品，各产品之间的协作自然不错<br>价格方面，Linux，DB2，Eclipse都是开源产品，Websphere目前零售价是33.8万人民币</p>
<p>IBM服务器不错，可以考虑</p>
<p>.net：</p>
<p>微软阵营<br>操作系统：Windows<br>应用服务器：.net应用服务器(好像叫IIS)<br>数据库：SqlServer<br>开发工具：MS Visual Studio<br>优点：客户端的用户体验良好，和客户端诸多微软产品的兼容性强<br>缺点：离开了微软，寸步难行，和其他任何一家公司的产品都不兼容</p>
<p>微软的东西，怎么说呢，太专横了<br>微软所有的东西都是围绕着windows来做的<br>.net其实已经可以实现跨平台了，但是微软出于自身商业考虑<br>在其应用服务器跨平台的实现上设置了种种障碍<br>而且针对windows，微软做了大量的优化，可以这么看<br>.net就是与windows捆绑的一套产品<br>所以有些人说，微软的产品离开了windows，就是渣<br>而且.net开源选择也少，安全性方面考虑，windows本身就有一堆补丁要打了<br>sqlserver也不安全，至于.net到底安全不安全我不清楚，毕竟我没怎么用过<br>但整体考虑，感觉.net不是大企业的首选，鉴于其浓厚的商业背景<br>也不是中小企业的首选，但是必须看到<br>客户端也就是微机pc市场已经完全被windows所垄断<br>所以在一些快速开发，还有和微软产品兼容性要求较高的领域，.net还是比较有市场的<br>最后一个visual studio对它之前的版本兼容，且支持c,c++,c#,vb等语言</p>
<p>在其传统领域，比如写一些桌面软件等客户端应用上，.net还是第一选择</p>
<p>最后要说明的是<br>这些组合不是固定不变的<br>由于J2EE得到了绝大多数IT企业的支持以及JAVA跨平台的特性<br>我们可以自由地定制个性化的组合<br>比如我可以选择windows+jboss+eclipse+oracle<br>也可以选择solaris+websphere+IDEA+mysql<br>等等，这些自由组合都是可以的，但是有一点必须说明<br>微软的东西，一般来说离开了windows就不能用<br>比如你选择了.net应用服务器，那操作系统就必须是windows<br>你选择了sqlserver，那就必须在windows上用<br>还有就是遵循j2ee规范的所有的组件都可以在不同的应用服务器上互相移植<br>比如你可以在测试的时候用jboss<br>而在正式投产上线的时候使用websphere，只需要在配置文件中作相应改动即可</p>
<h1 id="七：java企业级应用之术语篇"><a href="#七：java企业级应用之术语篇" class="headerlink" title="七：java企业级应用之术语篇"></a>七：java企业级应用之术语篇</h1><p>在了解完J2ee的相关周边产品之后需要深入J2ee规范内部去了解一下到底这些规范<br>这里介绍几个最常用的规范<br>再继续说下去之前有必要说几个常识</p>
<p>Java的诞生<br>Java之父James Gosling早年从cmu毕业之后<br>从事了一段时间的开发工作，后来意外碰到一个项目<br>这个项目要求他用C++开发，但可爱的JG是天才，凡是天才在某方面特别突出的同时<br>必然有一些天生的缺陷，恩，或说共性，比如说懒，急躁和傲慢<br>JG既然是天才，那就必然具备这些共性，JG懒，以至于他学不好C++<br>不仅他学不好，当年开发出Java的那个团队也都学不好C++<br>他们急噪，以至于他们中有人甚至威胁以辞职的方式离开这个需要使用CPP开发的项目<br>他们傲慢，所以他们决定开发出一种新的语言来取代那个该死的CPP<br>更可爱的是，他们一开始居然给这门语言起名C++++–//没错，我没敲错<br>叫什么C加加 加加减减，意思是加上一些好东西，减去一些坏东西<br>天才的设定，有时候你会发现天才和傻瓜真的只有一线之隔<br>还好这个可爱的名字没有被继承下来，这些天才们给他们的产物起名叫Oak//橡树<br>只是后来当他们去注册这个名字的时候，发现这个名字已经被注册了<br>于是在Sun公司的一个女职员//mm就是心细，这个说法也是我们公司mm告诉我的<br>的提议下，把这个可爱的语言起名为Java，就是他们当时喝的咖啡的名字<br>所以我们看到Java的标志就是一杯冒着热气的咖啡</p>
<p>JavaBean 了解完Java之后，再来说说什么是JavaBean//华为面试题<br>JavaBean是什么？ 咖啡豆<br>ja，更为科学点的解释是<br>用java语言编写的可重用的软件组件//组件的定义前面说过了，不再重复<br>很形象不是么？ 将javabean放入杯子//容器，还记得容器的概念么？web容器，ejb容器<br>就可以冲泡//编译 成咖啡，供客人们品尝//运行<br>完美的服务</p>
<p>下面进入正题 再谈容器<br>前面介绍过容器，我觉得有必要再补充一点<br>容器从某种意义上说其实就是一个可运行的java写的应用程序<br>犹如c++/c编译后生成的.exe文件<br>不同的是java编译后的文件需要用命令行或者脚本启动执行<br>由于容器是由java写的，所以容器都能够跨平台<br>虽说如此，似乎大部分容器都针对不同的操作系统提供了不同的版本<br>但可以肯定的一点是，相同容器间的移植组件不需要重新编译</p>
<p>Servlet web容器组件<br>Servlet确切地说，就是web容器运行的java组件<br>与普通javabean不同的是，Servlet定义了一系列方法//比如init()和destroy()<br>供容器调用，调用的主要目的是为了管理<br>当一个request请求被web容器截获之后，容器分析该请求地址<br>然后通过一个配置文件中的映射表//web.xml<br>调用相应的Servlet组件处理后将结果返还给客户端</p>
<p>JSP//Java Server Page<br>web容器组件<br>Servlet出现了之后，人们发现几乎没有办法用一个非常直观的方式去编写页面<br>毕竟页面是html语言编写的<br>而让我们用一种流程式的处理方式去逐行教计算机如何写html代码太困难<br>在这种情况下JSP应运而生，JSP将java代码嵌入html代码内部<br>然后存成.jsp文件，再由计算机编译生成Servlet储存起来//注意这个过程<br>所以JSP和Servlet对于web容器来说其实是一种东西，虽然它们编写遵循的标准有所不同<br>极大地简化了代码同时增加了代码的可读性，生产维护成本下降<br>值得一提的是，在制定JSP规范的过程中，借鉴了ASP的很多规范<br>写过ASP并熟悉Java语言的人应该能很快掌握JSP</p>
<p>EJB//Enterprise JavaBean<br>ejb容器组件<br>随着时间的推移，人们发现普通的JavaBean似乎并不能满足企业级应用的需要<br>最典型的就是虚拟机提供的垃圾回收收集机制也就是GC不够完善<br>可以优化的余地极大，在这种情况下，EJB应运而生<br>EJB和其它组件一样，不过遵循了某些规范而已<br>但是这些规范更多的是为充分利用机器并提高性能为主要目的的<br>举个简单例子<br>比如某个web服务器有100个用户同时连接上<br>由于网络连接是瞬时连接，所以很多时候并发数并没有100那么大<br>前一秒有可能有30个请求被发送过来并被处理<br>后一秒可以只有10个请求被发送过来并被处理<br>只有在非常非常极端的情况下才有可能发生100个请求同时被发送过来并被处理的情况<br>那么我们是否需要保留100个那么多个对象在服务器的内存里面去处理这些请求呢？<br>很显然，不需要，大多数时候//甚至可以说是所有时候，我不相信有那么极端的情况<br>我们只需要保存其中的10-30%就够了，那么什么时候需要20%，什么时候需要50%<br>甚至100%，这个过程就交给容器去管理，这就是ejb容器每天在干的事<br>管理内存中活跃的对象</p>
<p>恩，必须强调的一点是，由于使用的不成熟<br>我们经常把规范以及具体的应用两个名词混用<br>举个简单例子，我们说Servlet，极有可能说的是Servlet规范<br>也有可能说的是一个具体的Servlet，这个就要看情况而定了<br>EJB，JSP也是如此</p>
<p>JDBC<br>和数据库的连接<br>这个严格说来是数据库产商需要关心的事<br>关于AppServer如何与数据库的连接<br>但是也需要开发人员做一点事，因为AppServer不知道什么时候组件需要用到数据库<br>同时也需要开发人员告诉AppServer他们使用的是什么数据库，ip地址等等<br>JDBC就是关于这一套东东的规范<br>包括数据库的产商应提供什么样的接口<br>AppServer应用服务器应该如何去连接<br>开发人员应该如何去配置这些连接等等<br>还有一些数据源，连接池等概念参考相关数据在此就不再赘述<br>其它的规范比如JMX等确切地说与开发人员关联并不大了<br>这类高级应用只对AppServer应用服务器产商重要<br>也不再罗嗦了</p>
<p>记得听说过这样一种说法<br>大一时候不知道自己不知道 大二时候知道自己不知道 大三时候不知道自己知道 大四时候知道自己知道 为什么呢，因为大一时候刚进大学，什么都不懂，很正常，大家都一样<br>大二或者大三时候开始接触知识，虽然还是不懂，但慢慢地开始学习，开始积累<br>过了一段时间，知道自己知道了//也就是前一种说法的大四，后一种说法的大三<br>开始屁癫，开始拽得不得了，觉得自己怀才不遇，千里马难寻伯乐的那种感觉<br>有些人是大四毕业了以后开始拽，悟性高一点的，大三就开始拽，因人而异<br>这几乎是每一个初学者经过一段时间学习后的必然阶段<br>不管如何，总之开始入门了，这也不是坏事<br>但最后每个人都会知道自己不知道的，也就是后一种说法的大四阶段<br>//前一种说法里面的那些家伙估计要到工作以后才能明白<br>因为任何一门学科都博大精深，要是能在两三年之内就统统搞懂<br>那不是在吹牛就是坐井观天，java如此，c如此，c++也是如此</p>
<p>那么到了本系列的第七集，可爱的读者应该处在什么阶段呢？<br>恭喜，在看完这篇文章之后，你就基本处于知道自己不知道的那种阶段<br>离拽起来还有那么一段距离，因为你们毕竟还没有学习和积累一定的基础知识<br>但是骗骗外行，蒙蒙国企那些吃闲饭的管理人员问题不大</p>
<h1 id="八：java高级应用之框架篇"><a href="#八：java高级应用之框架篇" class="headerlink" title="八：java高级应用之框架篇"></a>八：java高级应用之框架篇</h1><p>没错，我没敲错<br>之所以不再声称是企业级应用而称之为高级应用 是因为下面要讲的东西属于纯民间性质<br>是java具体应用的上层建筑，可用可不用，没有人强迫你用</p>
<p>首先给框架//framework 下一个定义<br>我想读者你可能听说过.net framework这个概念<br>没错，我们将要说的framework也和这个framework差不多<br>所不同的是.net framework的竞争对象是j2ee那一系列标准<br>而我们将要说到的几个框架则应用在j2ee的不同层面<br>单就单个框架而言，没有.net framework管得那么多<br>但是却要比它精专多了，而且总量加起来，也远比微软那一套框架要广泛得多<br>回到正题，框架是什么？<br>软件工程之所以被叫做软件工程就是因为有那么一批人觉得可以用工程学里面<br>那些管理Project的方法来管理软件从开发到维护这一系列流程<br>那么在建筑工程里面框架是什么？<br>现在建筑多采用钢筋混凝土结构，注意里面一个很重要的词汇：钢筋<br>托福阅读中曾有一题听力就是关于钢筋结构的诞生，在美国<br>恩，现代建筑中多在建筑起来之前，先用钢筋搭建出一个框架出来<br>然后往钢筋中间填入混凝土，从而形成一个完成的建筑<br>而今天要说到的框架就是这么一个东西在每一个软件中间的实现<br>框架就是那么一个通过预先写好代码从而帮我们建立起一个软件结构的这么一个东西</p>
<p>这里提一下框架与规范//主要指J2ee规范也就是官方标准的区别<br>从某种意义上说，J2ee规范本身就是一个框架<br>无论是web容器也好，还是ejb容器也好，它们都开发了一部分通用的代码<br>并且帮助我们搭建起来了一个软件结构，我们要做的就是往里面填入组件<br>比如ejb/servlet/jsp等等<br>没错，要这么理解也没错，但是为了避免混乱，我们还是严格区分开来<br>本文中将要提到的框架如无特别说明，就是指的是非官方标准的框架<br>规范是规范，而框架是建立在规范之上的一种东西<br>可以说是标准的延续，或者说是民间的尝试，总之是这么一个非官方的东西<br>说到这里顺便提一下JCP组织也就是Java Community Process/Java社区<br>当初Sun公司在java发布之初，为了提倡开源和共项<br>同时也出于一个提出合理的标准的目的，而让广大的开发者参与标准的制定<br>而成立了这样一个社区，现在还健在，网址是jcp.org<br>每一个新的规范发布之前都会在这个社区广泛讨论，最终对规范的制定产生巨大的影响<br>其中就包括企业级的参与者，相当有名的JBoss以及我国的金碟公司都是其中的成员</p>
<p>下面介绍一下几个相当著名的框架，必须要指出的是，虽然框架大多开源 但并不代表所有的框架都开源，比如.net framework，但是java框架大多数开源<br>言归正传<br>Struts<br>表示层框架，名字来源于飞机的金属框架<br>可能有读者会提问了<br>表示层不是客户端么？<br>没错，但是语言这东西，众口烁金，别人都这么说你就不好不这么说了<br>最早表示层说的是客户端，后来随着时间的发展<br>人们也把服务器端直接与客户端//比如IE<br>打交道的那部分也称为表示层//JSP+Servlet<br>那么表示层框架是干什么的呢？<br>早先大规模应用JSP的时候，人们发现，JSP里面充斥着逻辑代码与数据<br>可读性极差，于是人们借用很早很早以前的MVC模式的思想<br>把表示层组件分为V-Viewer，也就是JSP<br>M-Model模型，一般来说是一个JavaBean<br>C-Controller控制器，一般来说是一个Servlet<br>所有人通过JSP和服务器打交道，发送请求，Viewer把这个请求转发给Controller<br>Controller通过调用一个Model来处理该请求，然后返回数据到Viewer<br>这么一个过程，从而达到数据与逻辑的剥离，增强代码可读性，降低维护成本<br>而帮助人们实现这一系列东西的就是Struts框架，就是这么一个东西<br>Struts的竞争对手主要是产商们极力倡导的JSF也就是Java Server Faces<br>但是由于Struts出道时间早，所以应用比较多<br>JSF则是产商们大力支持，前景看好<br>对于这一层来说，在JSP的html代码中出现的java语句越少越好<br>因为java代码越少说明页面处理的业务逻辑越少，也越合理<br>这也是Struts最初的目的，记住这话</p>
<p>Spring 大名鼎鼎的Spring框架<br>有人曾说2005年一片叫春之声，指的就是该框架<br>Spring起源于Rod Johnson的《Expert One-on-One J2EE Design and Development》一书<br>Rod Johnson认为，J2ee里面的那一套//尤其是ejb<br>太重了，对于单机的系统来说，没有必要使用那么复杂的东西<br>于是就开始设计并引导Spring小组开发出这样一个构架<br>不能不说他是个天才，因为的的确确不是所有的系统都是跨多服务器的<br>没有必要把一个简单的系统设计得那么复杂//天才的那几个共性又体现出来了<br>Spring从诞生之日起就是针对EJB的，力争在不少应用上取代EJB<br>而它也确实达到了这个目的<br>现在包括WebLogic等主流应用服务器还有主流IDE都开始逐渐接受该框架<br>并提供相应支持<br>提到Spring就不能不说控制反转Ioc//Inversion of Control<br>和依赖注射DI//Dependency Injection<br>什么叫控制反转呢？<br>套用好莱坞的一句名言就是：你呆着别动，到时我会找你。<br>什么意思呢？就好比一个皇帝和太监<br>有一天皇帝想幸某个美女，于是跟太监说，今夜我要宠幸美女<br>皇帝往往不会告诉太监，今晚几点会回宫，会回哪张龙床，他只会告诉太监他要哪位美女<br>其它一切都交由太监去安排，到了晚上皇帝回宫时，自然会有美女出现在皇帝的龙床上<br>这就是控制反转，而把美女送到皇帝的寝宫里面去就是注射<br>太监就是是框架里面的注射控制器类BeanFactory，负责找到美女并送到龙床上去<br>整个后宫可以看成是Spring框架，美女就是Spring控制下的JavaBean<br>而传统的模式就是一个饥渴男去找小姐出台<br>找领班，帮助给介绍一个云云，于是领班就开始给他张罗<br>介绍一个合适的给他，完事后，再把小姐还给领班，下次再来<br>这个过程中，领班就是查询上下文Context，领班的一个职能就是给客户找到他们所要的小姐<br>这就是lookup()方法，领班手中的小姐名录就是JNDI//Java Naming and Directory Interface<br>小姐就是EJB，饥渴男是客户端，青楼是EJB容器<br>看到区别了么？饥渴男去找小姐出台很麻烦，不仅得找，用完后还得把小姐给还回去<br>而皇帝爽翻了，什么都不用管，交给太监去处理，控制权转移到太监手中去了<br>而不是皇帝，必要时候由太监给注射进去就可以了<br>看到Spring的美妙了吧，Spring还提供了与多个主流框架的支持<br>可以和其它开源框架集成<br>Hibernate<br>名字取材自ORM最早的一句玩笑话//ORM就是OR-Mapping<br>说用了ORM之后，程序员就可以去冬眠了，而不需要操心那么多事<br>这里不得不说的是，该框架由于做得太好，以至于被J2ee招安，成为EJB3.0的一部分<br>替代原有EJB2.X里面关于Entity Bean而成为EJB ORM的工具<br>这里解释一下ORM//OR-Mapping<br>中文名对象关系映射<br>什么意思呢？我们知道传统的数据库都是关系型的<br>一条条记录以表格的形式储存，而表与表之间充斥着是关系/关联<br>比如说一个人，名字zhaoce，性别男，年龄23那么数据库中是这么储存的<br>姓名 性别 年龄 zhaoce m  23 某女   f  22<br>而实际应用服务器中的实体都是以对象的形式存在，一个个对象<br>zhaoce是以这种形式存在的<br>Human human=new Human();<br>human.setName(“zhaoce”)<br>human.setSex(“m”);<br>human.setAge(23);<br>这样的，那么我们知道，传统的JDBC是通过一个二维字符串将数据取出<br>需要我们自己将其包装成对象，在存入的时候，我们还需要将对象拆开<br>放入sql语句中//Insert into Huamn values(‘zhaoce’,’m’,23)<br>然后执行该sql语句<br>太麻烦太麻烦，ORM理念的提出改变了这一切，ORM认为，这些东西应该由框架来做<br>而不是程序员，程序员做他该做的，不要为这种破事分心，还测试半天<br>于是就出现了Hibernate，JDO，TopLink等等，甚至.net里面也有ADO.net<br>过去一段时间是Hibernate和JDO争风，现在看来Hibernate逐渐成为主流并被官方接纳<br>成为规范标准之一，替代掉原来EJB2.X的ORM EntityBean<br>TopLink则是Oracle公司推出和Oracle数据库结合的一种ORM<br>商业用软件，贵且复杂，不过正在逐渐开放<br>而象表示层一样，这一种专门面对数据层的代码也被称为数据持久层<br>所以数据持久层这一概念有时不仅仅指代数据库<br>关于ORM，最高的境界应该是在java代码中不出现任何一句的sql语句<br>注意，是不包括sql语句，Hibernate的hql以及ejb的ejb-ql不算在内<br>至于出现不出现hql/ejb-ql等替代ql，这要视具体情况而定，不过最好也是不出现<br>当然最后所说的过分理想的情况往往不现实，总之一句话<br>以sql为代表的ql/<em>还有hql,ejbql等</em>/语句在代码中出现得越少越好<br>记住这话，现在未必能够理解，学了以后就懂了</p>
<p>这三个是目前最为常用的框架 而目前光已公布的框架就&gt;500<br>还在不停增加中，不可能一一列举，有兴趣的可以去看相应文档 要指出的是框架不是应用程序<br>只是一堆组件的有序复合，应用时不能脱离于应用服务器单独存在</p>
<h1 id="九：收尾"><a href="#九：收尾" class="headerlink" title="九：收尾"></a>九：收尾</h1><p>最后一篇介绍几个常见的概念</p>
<p>设计模式<br>这可不仅是java独有<br>我看的书就是c++和smalltalk例子的<br>先说说什么是设计模式<br>模式是什么？模式是经验的总结，潜规则的抽象<br>什么意思呢？比如说我们坐飞机，上飞机前需要经过几个步骤<br>什么安检领取登机牌之类的，这一套流程能不能改呢？<br>可以，但为什么几乎全世界的航空公司登机前都是这一套流程呢？<br>因为航空公司经过长期实践之后得出了一堆结论和经验<br>并认为这样做才是最安全，或说是最有效率的<br>这就是模式，模式是编程高手之间交流的桥梁<br>两个编程高手通过统一命名的模式了解对方的思想<br>当然不借助模式可不可以？当然可以，只是模式无处不在，你不知道而已<br>又比如吃饭，每吃一口饭，我们要先端碗，拿筷子，张嘴，塞饭入口，咀嚼最后吞咽<br>这就是一套模式，我们给这套模式命名为吃饭<br>那么当老爸叫吃饭的时候，我们就能明白什么意思<br>而不用老爸进来呓呓啊啊并比画上半天，哑语也不是这么用的<br>这就是模式，已知的模式有400多种//好象更多，不记得了<br>比如数据库有数据库的设计模式，编程有编程的模式等等<br>面向对象有常用的21种模式，需要掌握，主要分为创建，行为，结构三类<br>J2ee有J2ee的模式，Sun公司出了一本书叫《J2EE核心模式》可以拿来看看<br>必需要指明的是，模式不是规范，比如吃饭模式<br>没有人规定你吃饭非得要那么吃，你可以端碗，上抛，张嘴在下落后连碗一起吞咽<br>这也可以，只要你愿意，同样，只要你愿意，你就可以不遵循模式<br>模式之外还有反模式，学模式不可定势，不要学死，活学活用，无招胜有招才是最高境界</p>
<p>JavaDoc<br>文档工具，极其好用<br>可以根据注释自动生成HTML文档</p>
<p>Ant<br>98年，有一位程序员在从欧洲飞回美国的飞机上想到了这么一个东西<br>从而改变了整个世界，他的名字叫James Duncan Davidson<br>组织管理工具，可以这么描述它<br>比如你想在编译之后自动再次生成JavaDoc<br>那么你只需要编辑Ant脚本//对，就像Windows脚本那样<br>然后批处理就可以了，不过现在Ant已经广泛集成到IDE中去<br>不需要自己手动编写，不过如果想要炫炫，据说此招百试不爽</p>
<p>JUnit<br>测试工具，Unit家族可不只有JUnit<br>还有其它版本的，这个不细说，具体实践一下就明白了</p>
<p>POJO<br>//Plain Old Java Object<br>就是传统的Java对象，也就是一个JavaBean<br>由虚拟机来掌握其生死<br>常用的两个管理构架/规范是Spring和EJB容器<br>命名由来是某人//名字我忘了<br>觉得我们使用了太多的规范，以至于我们都忘记了纯粹的java对象<br>以至于我们都忽略了它的存在，所以叫了这么一个名字<br>以唤醒人们的记忆，这个意义上来说EJB其实不能算是POJO<br>毕竟遵循了一堆的接口，但是不管怎样，接口归接口，还是没有继承类<br>没有被强加什么//遵循可以写空方法假遵循<br>所以说还是POJO也对<br>但是由于这种东西缺乏管理，不象Servlet有专门的容器管理并继承了一定的类<br>而没有管理的对象在虚拟机中是很危险的，因为垃圾回收机制各个虚拟机不同<br>而且也不怎样，极有可能长时间不回收，这样在企业级的应用中呢<br>就有可能造成内存大量被占用从而死机，毫无疑问，这种机制需要优化<br>这种优化就是通过EJB容器或者Spring构架来实现<br>这么做还有一个好处就是迫使程序员对每一个类做封装<br>强迫他做管理，以达到防止内存泄露的目的，内存泄露最经常出现的错误就是<br>引用未释放，引用最典型体现在new这个关键字上，new得越多引用得越多<br>随着时间地增长，有可能导致循环，不停new new new new new…..<br>其中哪怕只要有一个new处理不当，虚拟机无法回收内存<br>那就极有可能完蛋，而且这种小bug越是在大的项目越是难以找到<br>有可能因为一个人而影响整个项目组，所以不妨记住我的一条经验<br>好的系统框架不应该在业务逻辑流程中出现new关键字<br>现在不理解也无所谓，将来有一天会明白的</p>
<p>SOA<br>面向服务的构架<br>不说太多，这个属于上上层建筑<br>不过不妨记住我的一句话，可以帮助理解这个概念<br>面向什么就是对什么做封装<br>面向对象就是对对象做封装<br>面向服务类似，剩下的靠悟性</p>
<p>反射<br>1.4新增功能，非常强大<br>通过反射，程序可以解析出类本身的属性也就是变量<br>//注意这里说的属性不是.net里面的属性，我不喜欢微软造的新名词，乱<br>还有行为也就是方法，然后通过invoke()方法调用该方法<br>甚至可以新增对象等，java首创，本是其它语言所没有的<br>后来被微软抄了去，利用该功能，开源框架广泛受益并大量采用，近乎疯狂地使用<br>具体就不说了，最后要指出的是，有一种说法是利用反射会降低效率<br>在早期的时候，的确是，现在不会了，放心使用</p>
<p>容器<br>5.0以后的版本在J2SE中都出现了容器<br>各位甚至可以自己尝试用标准库去使用容器</p>
<p>推荐网站<br><a target="_blank" rel="noopener" href="http://www.javaeye.com">www.javaeye.com</a> //java视线论坛，Hibernate国内的权威<br>dev2dev.bea.com //bea的dev2dev社区，用WebLogic首选的好去处<br>www-128.ibm.com/developerworks //ibm developer works社区，ibm产品的老家<br><a target="_blank" rel="noopener" href="http://www.jdon.com">www.jdon.com</a> //j道，Jboss国内相对讨论会多一点的地方，有自己的框架<br><a target="_blank" rel="noopener" href="http://www.matrix.org.cn">www.matrix.org.cn</a> //matrix，有自己的框架，很清新的论坛<br>jcp.org //JCP，前面说到过了<br>sourceforge.net //开源的东西几乎这里都可以找到，除java外还有游戏共享等<br>saloon.javaranch.com //我常去，人气不错<br><a target="_blank" rel="noopener" href="http://www.apache.org">www.apache.org</a> //阿帕奇老家<br><a target="_blank" rel="noopener" href="http://www.jboss.com">www.jboss.com</a> //Jboss和Hibernate老家<br><a target="_blank" rel="noopener" href="http://www.springframework.org">www.springframework.org</a> //Spring老家<br><a target="_blank" rel="noopener" href="http://www.wiki.org">www.wiki.org</a> //非常好的百科站点，可惜国内被封，创始人加入了Eclipse zone<br><a target="_blank" rel="noopener" href="http://www.google.com">www.google.com</a> //你要的这里有，不信？输入关键字再按一下那个靠左的白色按钮试试</p>
<p>书籍<br>《Thinking in Java》 //实话说，一般，尤其是翻译后的版本，原版还行<br>《Java教程》 //电子工业出版社出版的那本，上下册，很厚，但翻译得不错<br>《21天学通Java》 //入门极好，但是《21天学通j2ee》极烂，不要买<br>《Mastering EJB》 //翻译过的书质量我不清楚，估计不怎样，请看原版书籍<br>《精通Hibernate》 //看清楚作者，孙卫琴，其它人的别买</p>
<p>其它的可以不用了，网络上的远比书上来得多，来得好，虽然也来得杂</p>
<p>最后的建议<br>一，不要做一个浮躁的人<br>二，学好英语，很重要<br>三，阅读源代码和文档<br>四，共享源代码，不要做一个功利的人<br>五，热爱Java</p>
<hr>
<p>版权声明：本文为CSDN博主「phphot」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/phphot/article/details/2171421">https://blog.csdn.net/phphot/article/details/2171421</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=432430716&auto=1&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Aaron</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aaron</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
