<!DOCTYPE html>


<html lang="en">
	

		<head>
			<meta charset="utf-8" />
			 
			<meta name="keywords" content="life,think,work,blog,code" />
			 
			<meta name="description" content="a place holder" />
			
			<meta
				name="viewport"
				content="width=device-width, initial-scale=1, maximum-scale=1"
			/>
			<meta
				name="google-site-verification"
				content="Xe5wkkWgdmMwA81kCWOHLlJSlYSRE47NKPlVzl8ynK8"
			/>
			<title> Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
			
			<link rel="shortcut icon" href="/favicon.ico" />
			 
<link rel="stylesheet" href="/dist/main.css">

			<link
				rel="stylesheet"
				href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
			/>
			
<link rel="stylesheet" href="/css/custom.css">
 
			<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
			 
 

		<link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>
	</html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
	<div class="cover-frame">
		<div class="bg-box">
			<img src="/images/cover3.jpg" alt="image frame" />
		</div>
		<div class="cover-inner text-center text-white">
			<h1><a href="/">Blog</a></h1>
			<div id="subtitle-box">
				
				<span id="subtitle"></span>
				
			</div>
			<div>
				
			</div>
		</div>
	</div>
	<div class="cover-learn-more">
		<a href="javascript:void(0)" class="anchor"
			><i class="ri-arrow-down-line"></i
		></a>
	</div>
</section>
 
<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

<script>
	try {
	  var typed = new Typed("#subtitle", {
	    strings: ['It doesn&#39;t work...... why?', 'It works...... why?', 'I used to have a life... But Now I&#39;m a programmer.'],
	    startDelay: 100,
	    typeSpeed: 50,
	    loop: false,
	    backSpeed: 20,
	    showCursor: true
	  });
	} catch (err) {
	  console.log(err)
	}
</script>


<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-如何评价Clojure"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/11/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7Clojure/"
    >如何评价Clojure</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/11/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7Clojure/" class="article-date">
  <time datetime="2020-04-11T22:36:40.000Z" itemprop="datePublished">2020-04-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1-Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。"><a href="#1-Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。" class="headerlink" title="1.Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键。"></a><strong>1.Clojure能够吸引人的很重要一点是它是JVM之上的语言，这个决定非常关键</strong>。</h4><p>首先，因为根植于JVM之上，并且做到了跟Java语言的相互调用，它能吸引很多成熟的Java开发者。其次，它可以使用Java社区丰富的开源软件，不需要从头去构建一个社区，你可以看到很多Clojure开源代码都是简单地包装Java的开源包，但是通过Clojure高度抽象简单的语法提供更便利的使用的方式；<br>第三，由于JVM平台本身的高度成熟和优化，clojure的编译器生成的byte code跟Java编译器生成的byte code并无二致（不完全是），它的性能和稳定性也能马上得到保证，这比从头构建一个新平台成本低得多。</p>
<p>构建于JVM之上，Clojure就是一门“严肃”的语言，而非很多人眼中的Lisp“玩具”语言，你学习后可以马上使用并且实践。但是Clojure又是Lisp方言，Lisp的神奇能力它还都保留，这样兼具美学和实用的语言如何让人不爱？我相信很多熟悉Scheme之类方言的童鞋，并且有Java背景的，都会对Clojure有相见恨晚的感觉。</p>
<h4 id="2-Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The-joy-of-clojure》概括的。"><a href="#2-Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The-joy-of-clojure》概括的。" class="headerlink" title="2.Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The joy of clojure》概括的。"></a><strong>2.Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The joy of clojure》概括的。</strong></h4><p>（1）简单： 鼓励纯函数，极简的语法（少数special form），个人也认为clojure不能算是多范式的语言（有部分OO特性），为了支持多范式引入的复杂度，我们在C++和Scala身上都看到了。<br>（2）专注：前缀运算符不需要去考虑优先级，也没有什么菱形继承的问题，动态类型系统（有利有弊），REPL提供的探索式编程方法（告别修改/编译/运行的死循环，所见即所得）。<br>（3）实用：前面提到，构建在JVM之上，跟Java语言的互操作非常容易。直接调用Java方法，不去发明一套新的调用语法，努力规避Java语言中繁琐的地方(doto,箭头宏等等）。<br>（4）清晰：纯函数（前面提到），immutable var，immutable数据结构，STM避免锁问题。不可变减少了心智的负担，降低了多线程编程的难度，纯函数也更利于测试和调试。<br>（5）一致：语法的一致性：例如doseq和for宏类似，都支持destructring,支持相同的guard语句（when,while）。数据结构的一致性：sequence抽象之上的各种高阶函数。</p>
<p>具体到STM，我个人认为这个特性在日常编程中，其实你用到的机会不多。在web编程里，你的并发模型Web Container已经帮你处理（tomcat,jetty），事务也是数据库帮你处理，几乎找不到场合去使用STM。这个特性在做一些中间件或者底层framework的时候才可能用到。这个特性的设计上面已经提到，跟clojure的设计目标是紧密相关的，跟immutable数据结构也是密不可分，同时它也不是没有代价，事务历史记录和慢事务频繁回滚的代价，有时候你还是需要退回去使用Java那套锁机制，庆幸的是Clojure不阻止你去使用，并且提供了类似locking这样的宏来方便你使用。</p>
<h4 id="3-Scheme我对它的了解也就是做过SICP的习题。"><a href="#3-Scheme我对它的了解也就是做过SICP的习题。" class="headerlink" title="3.Scheme我对它的了解也就是做过SICP的习题。"></a>3.Scheme我对它的了解也就是做过SICP的习题。</h4><p>粗粗看过《Programming Scheme》，两者对比的优缺点似乎谈不上来。需要对Scheme更熟悉的专家来做个对比。</p>
<p><strong>Clojure的设计缺陷不能说是缺陷，这是由于它设计的目标决定的，有得必有失</strong>。</p>
<p>首先还是JVM，基于JVM有种种好处，但是JVM的启动速度实在悲剧，因此用Clojure写一些小的script处理日常事务，显得还是不够得心应手，这样的工作我还是用Ruby，Python的脚本语言来搞定更便捷。不过目前Clojure有一些其他语言之上的实现，比如<a href="https://link.zhihu.com/?target=https%3A//github.com/rouge-lang/rouge">rouge-lang/rouge · GitHub</a> 和 <a href="https://link.zhihu.com/?target=https%3A//github.com/halgari/clojure-py">halgari/clojure-py 路 GitHub</a>  这些实现应该会比JVM的启动快很多（抱歉，我没测试过）。</p>
<p>不仅如此，因为Clojure跟JVM平台的绑定如此之深，并且为了真正发挥Clojure的威力，你还需要去熟悉Java平台的东西，熟悉Java语言、类库、内存模型、GC优化、多线程和网络编程、开源类库等等。可以这样认为：<strong>想成为一个好的Clojure程序员，首先需要是一名好的Java程序员</strong>。这也一定程度上阻碍了Clojure的推广，提高了学习成本。</p>
<p>其次，Clojure的API设计上，有时候不符合你的直觉，而是符合Clojure的哲学，比如contains?函数对vector等数组型集合的调用上。关于这一点，Rich的回答是“<strong>Elegance and familiarity are orthogonal.</strong>”，也就是优雅和熟悉是正交关系的。保持API内在的一致性，比直觉的“熟悉”更重要。Clojure不妥协于你的“直觉”。</p>
<p>第三，弱类型的好处足够多，灵活，减少声明代码，适合探索式编程；同样，坏处也不是没有，没有类型保障，错误可能要等到运行时才能发现，静态代码检查工具也没有办法帮你发现，这就需要你一定程度的测试代码来保证运行时行为。</p>
<p>第四，性能上，虽然clojure生成的字节码已经很高效，也有type hint这样的技术来帮助提升性能，但是会有不少的转型(checkcast)、装箱和拆箱（boxing and unboxing）以及类型判断分支跳转的多余指令，这在一些性能敏感的应用里可能会暴露出来。尽管我认为大多数网站型的应用瓶颈都会落在IO上。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何看待检察日报称『禁食猫狗肉』立法有破冰意义"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%A3%80%E5%AF%9F%E6%97%A5%E6%8A%A5%E7%A7%B0%E3%80%8E%E7%A6%81%E9%A3%9F%E7%8C%AB%E7%8B%97%E8%82%89%E3%80%8F%E7%AB%8B%E6%B3%95%E6%9C%89%E7%A0%B4%E5%86%B0%E6%84%8F%E4%B9%89/"
    >如何看待检察日报称『禁食猫狗肉』立法有破冰意义</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%A3%80%E5%AF%9F%E6%97%A5%E6%8A%A5%E7%A7%B0%E3%80%8E%E7%A6%81%E9%A3%9F%E7%8C%AB%E7%8B%97%E8%82%89%E3%80%8F%E7%AB%8B%E6%B3%95%E6%9C%89%E7%A0%B4%E5%86%B0%E6%84%8F%E4%B9%89/" class="article-date">
  <time datetime="2020-04-11T04:31:15.000Z" itemprop="datePublished">2020-04-10</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="../images/image-20200410233222992.png" alt="image-20200410233222992"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何看待基辛格的《新冠病毒大流行将永远改变世界秩序》"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%9F%BA%E8%BE%9B%E6%A0%BC%E7%9A%84%E3%80%8A%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92%E5%A4%A7%E6%B5%81%E8%A1%8C%E5%B0%86%E6%B0%B8%E8%BF%9C%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F%E3%80%8B/"
    >如何看待基辛格的《新冠病毒大流行将永远改变世界秩序》</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%9F%BA%E8%BE%9B%E6%A0%BC%E7%9A%84%E3%80%8A%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92%E5%A4%A7%E6%B5%81%E8%A1%8C%E5%B0%86%E6%B0%B8%E8%BF%9C%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F%E3%80%8B/" class="article-date">
  <time datetime="2020-04-10T02:02:19.000Z" itemprop="datePublished">2020-04-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="新冠疫情会永远改变世界秩序-全文翻译"><a href="#新冠疫情会永远改变世界秩序-全文翻译" class="headerlink" title="新冠疫情会永远改变世界秩序-全文翻译"></a>新冠疫情会永远改变世界秩序-全文翻译</h2><p>基辛格</p>
<p>新冠疫情的这种超现实氛围，让我想起当年突出部战役时，我在84步兵师作为一名年轻人的感受。现在，正如1944年后期，能感觉到一种未成形的危险，不盯着任何具体的人，而是随意打击并毁灭。但老黄历和当下有个重要区别：美国能扛过那时候，是因为被一种终极的国家目的武装了起来。现在，在一个分裂的国家里，要去克服一个在深度和全球广度上都前所未见的困难，高效和有远见的政府是必需的。维持公众信任对社会团结来说至关重要，在各个社会群体之间的关系上、在国际和平与稳定上，也是如此。</p>
<p>国家们能团结、繁荣，是基于一个信念：他们的体制可以<strong>预见灾难、控制其冲击、并恢复稳定</strong>。当新冠疫情结束后，很多国家的体制会被认为是<strong>失败的</strong>。这个论断是否客观公平，已经不重要。现实是，世界将不会再和疫情前一样。在现在去争辩过去，只会让<strong>必须要去做的事</strong>更难做。</p>
<p>新冠病毒打击的范围和严重程度前所未有。病毒呈指数传播，每五天美国的病例翻一倍。就在我写的时候，依然没有解药。医疗供给不足以应对正在扩大的病例波次，重症护理资源濒临极限，有些超出极限，有些已经过载崩溃。测试进度仍然不足以完成确认传染范围的工作，离扭转病毒传播还很远。一个有效的疫苗可能要12到18个月后。</p>
<p>美国政府已经做了扎实的工作来避免迫在眉睫的灾难。终极考验是： 遏制并扭转病毒传播的手段和效果范围，能否维系公众对美国人<strong>自我管理能力的认可</strong>。危机中的工作，不管多么繁重与必不可少，都不能挤压一个<strong>紧急任务</strong>：同时应对疫情后<strong>秩序转变</strong>的努力。</p>
<p>领导人们正在处理几乎牵扯全国的危机，但病毒瓦解社会的效果没有边界。在伤害人类健康（希望是暂时的）的同时，病毒所导致的政治与经济剧变可能会<strong>持续数代人</strong>。没有国家——包括美国在内——可以仅靠自身国家的努力来克服病毒。要应对当下的种种挑战，必须要形成全球合作思维和执行计划的结合。如果我们无法并行做到，那么我们将面对互相之间<strong>最糟糕的一面</strong>。</p>
<p>从<strong>马歇尔计划和曼哈顿计划</strong>的发展中吸取经验，美国有必要在三大方向采取重要行动：</p>
<p>首先，加强全球对传染性疾病的抵抗能力。小儿麻痹症疫苗和消灭天花这样的医学胜利，或者人工智能依据大数据进行医疗诊断的新兴奇迹，使得我们放松警惕，进入一种危险的自满。我们需要发展新方法和新技术，能够在大规模人口数量级上实现传染病的控制和疫苗研发生产。城市、国家和地区必须始终如一地准备，用现有的、合作计划并开发的前沿科学来保护自己的人民远离疫病大流行。</p>
<p>其次，努力去治愈世界经济的伤口。全球领导人已经从2008金融危机中学到重要教训。现有经济危机则更复杂：从速度和全球规模来看，新冠病毒的传染进程在历史上从未有过。所有必要的公共卫生手段，例如保持社交距离、关闭学校和商业场所，都会加重经济创伤。世界上最脆弱的人群面对即将到来的混乱，也要有减轻对他们影响的措施。</p>
<p>最后，<strong>捍卫自由世界秩序的原则</strong>。有个建立现代政府的<strong>古老概念</strong>：一个<strong>筑有高墙的城市</strong>，被<strong>强大</strong>的统治者所保护。他们有些暴虐，有些仁慈，但总能为人民远离<strong>外部</strong>敌人提供有力保护。启蒙思想家们<strong>改造</strong>了这个概念，认为<strong>正当国家</strong>的目标是要为人民提供基本所需：安全、秩序、良好的经济，还有公正。个体无法单凭自己确保这些事情的实现。疫情刺激了一个<strong>错误</strong>：一个繁荣依赖于全球贸易和人口流动的时代里，<strong>筑有高墙的城市将要复兴</strong>，。</p>
<p>世界的民主国家需要<strong>捍卫并维系启蒙思想的价值观</strong>。<strong>拥有合法性的制衡力量</strong>在全球衰减，将会造成国内与国际上社会交流的解体。当然，合法性与力量这个千年问题，不会仅靠克服新冠疫情的努力就能同时解决。因此<strong>全面的制约</strong>是必要的，不管是国内政治还是国际外交，<strong>优先级</strong>必须得到确定。</p>
<p>我们从突出部战役，走进了繁荣发展和人类尊严得以巩固的的世界。现在，我们生活在一个时代节点。对领导人们的历史性挑战，是要在处理危机的同时建立未来。<strong>失败会让世界陷入火海</strong>。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>国家的性格，很大程度上是由这个国家的平均年龄决定的。二战和冷战早期的各主要国家就像是几个二十多岁的壮小伙子，一言不合就要杀人全家。冷战中后期的美苏就像是三十多岁的成年人，也会发怒，但会考虑后果，如果能背后捅刀，绝对不会当面硬碰硬。而如今的各主要国家，宛如一群四五十岁的油腻中年，生活的主要矛盾已经从升官发财转移成了自己经常闹意见的前列腺，走两步都要喘半天，打完人一巴掌，第一件事就是去医院治手。</p>
<p>社会需要平衡，左了右了都不行。传统上，除了极特殊的年代外，决策层往往是中老年人把持，这确实有一定的科学性，毕竟年轻人太过鲁莽，容易坏事；但执行层，好歹一直都还是年轻人的天下，这就形成了某种制衡，倒逼上面进行改革。可是随着社会整体的老龄化和固化，各国的执行层也开始逐渐老去，年轻人就只能被逐渐挤到国家机器的边缘甚至外部。再发展下去，变成日本那样，就连体制外大大小小的岗位也都被老年人填满，这个国家连一个不老土的网页都已经做不出来，你还指望它能在国家决策上有什么改革的冲劲儿？</p>
<p>基辛格就像是一个老去的少年，用他所熟悉的少年思维去考量这个世界，把高楼幻化成古堡，把磨坊理解成巨龙，用他独特的方式去警告世界，宛如一个白发少年提醒着一群童颜老人，充满了魔幻的不真实感。</p>
<p><strong>可是，世界老了</strong>。</p>
<p>世界就像一个摇摇欲坠的老国企。欧洲早已开始了自己的退休生活，他们所关心的是在尽可能少费力气的基础上拿到尽可能多的退休金，那些明争暗斗仿佛发生在一亿年前。美国就像一个跃跃欲试的老领导，沉浸在自己当年的荣光里，就像那个笑话讲的，“坐在电梯里面上了18楼，过程中一直在做俯卧撑，于是就跟人吹嘘是因为自己努力做俯卧撑上到的18楼”。中国则像这个老国企里的顶梁柱，很努力地听话出活，但却因为一群老人占据着大大小小的岗位不肯退，混到快四十岁了也得不到晋升。是啊，就连这个全单位最年富力强的小伙子，也快四十岁了。官瘾，当然还是有的；可你让他为了当官去和所长斗一斗，把所长斗倒了他来当？开什么玩笑，要恰饭的，老婆要买包，孩子要上钢琴课。</p>
<p>现在，流感来了，这群大腹便便的老爷子全部病倒，你惊奇地发现，除了这个四十来岁的“小伙子”还算勉强坚持住了以外，竟然没有任何一个人的免疫力足以抵抗这场传染病。没病的时候，老干部们或许还下下象棋；病来了，病就是老干部们最要命的事儿。单位那档子事儿，哎……我上次去上班，是几月份了啊……</p>
<p>年轻人总是幻想不同。这是最好的时代，这是最坏的时代。无论好还是坏，年轻人都是喜欢的。</p>
<p>可恐怕事实不能如愿。这不是最好的时代，也不是最坏的时代。我宁可相信基辛格，甚至宁可相信亨廷顿。可惜世界不会那样。</p>
<p>这只是个衰老的时代。</p>
<p>大病过后，老人还会继续老下去。没有人会死去，他们只是在轮椅上继续默默衰老。老所长不会退休，四十岁的“小伙子”也不会接班，只是老领导的呓语越来越没人愿意听，每个人都在消磨着漫长的人生。留给未来的，只是这个效益越来越差的老厂子，和大同小异的冬去春来。</p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p><strong>巴菲特一辈子看了五次熔断，基辛格一辈子看到两次铁幕</strong></p>
<p>说到制裁，我的答复是“制裁有核国家，结果不过是中国俄罗斯东盟中亚一起，剩下的一起，铁幕徐徐落下罢了”百年未有之变局，最差也不过如此只不过上次是丘吉尔+杜鲁门与斯大林对垒，而现在的政坛，除了KGB出身的普京，全加起来也未必有丘吉尔一半够分量</p>
<p><strong>这次疫情根本性的改变了我们与西方世界之间的相互认知</strong></p>
<p>过去我们因为长期在科技、军事、经济上处于弱势，于是被灌输制度和主义需要抉择和进化，认为西式皿煮滋油是真正的解放，甚至把肤色当做一种耻辱急于强调“我虽然是黄种人，但我是美国人”。将舶来品奉为圭臬的代价是，在别人跑过的路上，你永远追不上他，越是在对方的语境里对话，你的话语权越低下西方看我们也是，我们是愚昧、肮脏、野蛮的代名词，同种同文的4V尚且认为我们极度落后吃不起茶叶蛋，却完全不知道我们已经发展到5分钟手机充值不到账就要砸营业厅。所以，大洋彼岸从来没到过中国的红脖子对我们的误解，该有多深呢？“这不文明”中“文明”的含义并非形容词，而是的名词，“这不是西方文明”。</p>
<p><strong>一次疫情把各自的老底全晾出来看清楚</strong></p>
<p>我们看他们，低效政府、无耻政客、堕落媒体、愚昧民众，这距离我们高呼媒体是第四权利的日子没过去多久他们看我们，爆表级别的工业能力和物资投放，为战争准备的社会结构，特别是经此一疫14亿令行禁止的民众怕的是，我们认为他们蠢却忽略了他们近百年来积累下在科技、经济、军事上的巨大优势更怕的是，他们从今往后会全方位铁腕对待中国</p>
<p><strong>东西方的隔阂真的是因为制度吗？</strong>当然不是，若是因为制度，沙特早就不是今天的沙特，朝鲜也断不能具备玩弄六方会谈的能力，普京也不值得英美各国如此的恐惧和排挤隔阂在于，地球的资源，不够14亿人过上美式生活，中国越发展，他们的话语权越小，中国人过上好日子，他们就得降低生活水平，中国在产业链上爬上去一环，就得有人从上面掉下来还记得贸易战吗？要求中国放弃2025中国智造计划，这种无耻条件等于是给中国发射一枚“智子”，你就踏踏实实吃糠咽菜，用资源和环境为代价给他们生产低端制造品才好如果中国放弃发展，相信我们会是人家最好的战略盟友，谁不希望有14亿跪着的韭菜呢？然而现在，所有对中国报以落后幻想的国家，无论承认与否，都不得不接受14亿站着也要把钱挣了的人民这才是隔阂，才是铁幕的根源</p>
<p><strong>未来会打仗吗？最差到什么地步？</strong></p>
<p>拥核国家正面刚的概率基本不存在，真的刚起来，劝架的比打架的多经济上提高门槛，产业链回流，去全球化，甚至可以叫做封锁的态势势不可挡，别迷信咱们好了他们还要很久才能缓过来，救股市不要人命在政客眼里，都不过是决策，甚至是更救命的决策最差莫过于国内产能积压严重，梧桐一把，出师有名还把东盟搞到手，一带一路和东盟，一个在手就足够全球化的推手是美国，目的在于收割财富，有11个航母编队推进这个事情，中国没那么强大的海军，两三只航母编队，维持东盟和一带一路中，已经可以保证国家继续发展</p>
<p><strong>该以什么心态面对？</strong></p>
<p>最可笑的莫过圣母心泛滥，千万别有，好似多读了几本书，就该对全人类负有责任。你所关心和体贴的，在大洋对岸的底层美国人，在政客的眼中，是不配拥有检测权的韭菜。最宣传善良博爱大国责任的美国都准备对疫情中的委内瑞拉动手了，性命攸关，你当他是程心？还是逼自己做程心？也别慌，接下来会有失业、断供等等各种艰难的事情需要面对，但仅仅疫情中国家不惜代价救命的操作，绝对可以放宽心，工业链条完整，粮食充足，过过苦日子也总比把刀把子交给别人好的多</p>
<p><strong>丢掉幻想，准备战斗</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-曾国藩攻陷天京后为何要屠城"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/08/%E6%9B%BE%E5%9B%BD%E8%97%A9%E6%94%BB%E9%99%B7%E5%A4%A9%E4%BA%AC%E5%90%8E%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B1%A0%E5%9F%8E/"
    >曾国藩攻陷天京后为何要屠城</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/08/%E6%9B%BE%E5%9B%BD%E8%97%A9%E6%94%BB%E9%99%B7%E5%A4%A9%E4%BA%AC%E5%90%8E%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B1%A0%E5%9F%8E/" class="article-date">
  <time datetime="2020-04-09T01:29:07.000Z" itemprop="datePublished">2020-04-08</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>中国历史上就没几支不屠城的军队，抛开近现代的国军共军不谈，历史上以军纪好而著名的军队我第一时间能想起来的只有岳家军和戚家军，前者尤为知名。这种军队有什么特点呢？第一，中央军，虽然冠名岳家军和戚家军，但士兵正儿八经的效忠于帝国，并非将领私兵；第二，兵员质量较高，没有大量的囚犯少年犯之类的社会渣滓；第三，最根本的原因，有稳定的军饷供给。<br>所以归根结底还是经济问题啊！</p>
<p>第一个原因，举个例子，东汉末年那会儿的西凉军，效忠皇帝么？当然不，这是董卓的私兵，他们砍起关中和关东的百姓会觉得是在砍自己人么？人家压根没有什么国家观念好么，董大大说砍谁，就砍谁。同样，湘军本来就是曾国藩自己练出来的团练私兵，名义上效忠清帝国而已，大清的子民又与湘军何干？<br>第二个原因，战争年代当兵是件高风险的事情，安分守己的老百姓有几个愿意从军的？汉武帝为了征西域连“七科谪”都用上了，即商人、商人的子女孙子、商人的侄儿、原本有“市籍”者、罪吏、亡徒、赘婿这七种没有社会地位的人都拖上战场，类似黑五类。这种人本来就没啥社会地位，和囚犯一起干着炮灰的活，打下城池你猜他们会干什么？汉武拓边时期，那可是结结实实把四夷给屠了个爽。 同样，湘军的组成也是不敢恭维，特别是曾国藩前期第一波就打输了（靖港兵败），所训练的新兵损失惨重，这种情况下再招兵什么人会来？流氓无产者啊。<br>最后一个原因，清廷养不起湘军，没有钱粮，又要士兵玩命砍人，曾国藩除了放任士兵劫掠，还真没有啥好办法，后来他的一个老乡想出了一个办法缓解了这一矛盾——加入红军可以分到土地！当然，玩笑归玩笑，共军的组织体系比湘军这种封建军队强太多了，也高效的多。从农民手中收粮食不必被假手于地主，给士兵发饷也不必假手于将领，这两点极大的提高了效率，没有了中间环节抽油水，共军才能用非常低的成本养活一支庞大的军队，而湘军若想从后方的老乡手中获得粮饷，便要让地主们对老乡更加的敲骨吸髓，权衡之下，杀人劫财才是最高效的选择。至于什么太平天国是邪教之类的话就不用拿来给湘军洗地了，太平天国就算信了飞面教也是逃不过这一劫的，抢劫这么纯粹的事情，别用剿匪给玷污了。<br>这个世界还真是™的无情啊。</p>
<p>综合来看，这件事给我们一个启示，想要建立一支军纪严明的军队，第一件事就要解决经济问题。国家能直接给每一个士兵发饷，士兵才能效忠国家，反过来，国家不给钱了，让军队自己想办法，军队便不得不采用一些灰色的手段为士兵们或者军队的其他人员赚得粮饷，这样的军队还会想着去为国家杀敌么？活下去都成问题就别谈理想了吧，军人不是圣人，只要有一个军官为了利益出卖理想，他迟早会拉下水一群人，最后形成休戚与共的小团体，军队会逐渐变成军官的私兵。当他们的利益和国家的利益发生冲突的时候，卖国的时候到了。归根结底，军队是要像姨太太一样养起来的，千万不能让军队自己赚钱，放在现在就叫：军队一律不得经商！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-新冠病毒-2020黑天鹅"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/08/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92-2020%E9%BB%91%E5%A4%A9%E9%B9%85/"
    >新冠病毒_2020黑天鹅</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/08/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92-2020%E9%BB%91%E5%A4%A9%E9%B9%85/" class="article-date">
  <time datetime="2020-04-08T04:31:43.000Z" itemprop="datePublished">2020-04-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>以下是给红杉创始人和CEO们发来的一份说明，希望能给大家提供一些指导，让大家在应对冠状病毒蔓延带来的潜在业务后果的同时，也能保证企业的健康。</p>
<p>尊敬的创始人和CEO们</p>
<p>冠状病毒是2020年的黑天鹅。你们中的一些人（也是我们中的一些人）已经受到了病毒的亲身影响。我们知道你们所承受的压力，并在这里提供帮助。人命关天，我们希望条件尽快改善。在此期间，我们应该居安思危，对可能出现的情况要有心理准备。</p>
<p>在座的各位都收到了很多关于COVID-19附近的预防措施的建议，以保护您、您的员工和您的家人的健康和福利。和许多人一样，我们也研究了现有的信息，并很乐意分享我们的观点–如果您有兴趣，请告诉我们。本说明是关于其他方面的内容：确保您的企业健康，同时应对病毒传播的潜在商业后果。</p>
<p>不幸的是，由于红杉在全球许多地区都有分布，我们正在获得冠状病毒对全球业务影响的第一手资料。与所有危机一样，有一些企业可以从中受益。然而，许多一线国家的企业因病毒的爆发而面临着挑战，包括。</p>
<p>业务活动的下降。一些公司的增长率在12月至2月间急剧下降。随着病毒的影响波及范围的扩大，一些原本按部就班的公司现在有可能错过第一季度至2020年的计划。</p>
<p>供应链中断。中国前所未有的封锁，直接影响到了全球供应链。硬件企业、直销企业和零售企业可能需要寻找替代供应商。纯软件公司受供应链中断的影响较小，但由于级联经济影响，仍面临风险。</p>
<p>缩减旅行和取消会议。许多公司已经禁止所有的 “非必要 “旅行，有些公司已经禁止所有的国际旅行。虽然旅游公司受到直接影响，但所有依赖面谈会议进行销售、业务发展或合作讨论的公司都受到影响。</p>
<p>我们需要相当长的时间–也许需要几个季度–才能确信病毒已经被控制住。全球经济要想恢复健康，还需要更长的时间。你们中的一些人可能会经历需求疲软，一些人可能会面临供应方面的挑战。虽然美联储和其他央行可以降息，但货币政策可能是缓解全球健康危机对经济影响的钝器。</p>
<p>我们建议你质疑关于你的企业的每一个假设，包括。</p>
<p>现金跑路。你真的有你认为的那么多的跑道吗？如果经济不景气，你能承受几个糟糕的季度吗？你是否已经制定了应急计划？你在哪里可以在不从根本上损害业务的情况下削减开支？现在就问这些问题，避免未来可能带来的痛苦后果。</p>
<p>筹款。私人融资可能会大幅减弱，就像2001年和2009年发生的那样。如果在2020年和2021年以有吸引力的条件筹集资金证明很难，你会怎么做？你能不能把充满挑战的局面变成一个机会，让自己获得持久的成功？许多最具代表性的公司都是在困难时期锻造和塑造的。1987年黑色星期一后不久，我们就与思科公司合作。谷歌和PayPal在互联网公司的大萧条之后艰难地渡过了难关。最近，Airbnb、Square和Stripe都是在全球金融危机中成立的。约束力使人的思维集中，为创造力提供了沃土。</p>
<p>销售预测。即使你没有看到你的公司有任何直接或直接的曝光，也要预测你的客户可能会改变他们的消费习惯。看似已经确定的交易可能不会成交。关键是不要被动挨打。</p>
<p>营销。随着销售疲软，你可能会发现你的客户终生价值下降，这反过来表明你需要控制客户获取支出，以保持营销支出的稳定回报。随着经济和筹资的不确定性增加，你甚至可能需要考虑提高营销支出的投资回报率。<br>人头数。考虑到上述所有的财务压力点，现在可能是时候对你的财务进行批判性的评估了，你是否能以更少的投入做更多的事情，提高生产力。</p>
<p>资本支出。在你制定了财务独立的路线之前，请检查你的资本支出计划在更不确定的环境下是否合理。也许你没有理由改变计划，而且据你所知，环境的变化甚至可能会带来加速的机会。但这些都是应该深思熟虑的决定。</p>
<p>在经历了近五十年来的每一次商业衰退之后，我们学到了一个重要的教训–没有人会后悔根据环境的变化做出快速果断的调整。在经济不景气时，收入和现金水平的下降速度总是快于支出。在某些方面，商业反映了生物学。正如达尔文所推测的那样，生存下来的人 “不是最强壮的人，也不是最聪明的人，而是最能适应变化的人。”</p>
<p>经久不衰的公司的一个显著特点是他们的领导人对这样的时刻的反应方式。你的员工们都知道COVID-19，都在想你会有什么反应，对他们意味着什么。错误的乐观情绪很容易将你带入歧途，使你无法制定应急计划或采取大胆的行动。要避免这个陷阱，要以现实的态度对待，当情况发生变化时果断地采取行动。在这个紧张的时刻，展现出您的团队所需要的领导力。</p>
<p>以下是我们的合作伙伴Alfred Lin的一些观点，他作为一名运营主管，经历了另一个黑天鹅时刻。</p>
<blockquote>
<p>2008年金融危机爆发前，我是Zappos公司的首席运营官/首席财务官，当时我被传唤到红杉的办公室，参加著名的<a target="_blank" rel="noopener" href="https://www.sequoiacap.com/article/rip-good-times">R.I.P. Good Times演讲</a>。我们当时不知道，就像我们现在不知道，我们将面临多长时间或多尖锐或浅薄的经济衰退。我可以确认的是，这次演讲让我们的团队和业务变得更加强大。Zappos从金融危机中走出来，在我们的竞争对手被打得遍体鳞伤之后，我们已经做好了抓住机遇的准备。”</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Coronavirus/" rel="tag">Coronavirus</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-入关学导论"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/06/%E5%85%A5%E5%85%B3%E5%AD%A6%E5%AF%BC%E8%AE%BA/"
    >入关学导论</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/06/%E5%85%A5%E5%85%B3%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="article-date">
  <time datetime="2020-04-07T03:43:46.000Z" itemprop="datePublished">2020-04-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>当今知乎有无数的人从事或从事过键政学研究,号称是键政的文章和回答充满了专栏、热榜和各个回答。</p>
<p>与之相随,“蛮夷入关学”作为键政学学科体系下的一门具有独特魅力的分支，逐渐显露头角。目前世面上正在初步形成了以山高县语录为基础，以七十二贤冲塔言论为补充的理论体系，即“蛮夷入关学”（以下简称为入关学）。与之伴随的问题就是蛮夷入关学已经普及到只要学点皮毛就能研究的程度。以至于“入关，入关“的言论充斥了知乎。</p>
<p>我们提出的问题或许不合时宜,但面对目前知乎上各色各样的入关学研究,大多不以根本目的为导向和结构的入关学回答、文章、专栏时,我们不能不说,入关学若想继续发展。入关学需要明确研究什么、为什么研究。笔者在借鉴知乎显学六学的理论建设的基础上，对入关学进行了一次梳理总结：[1]。</p>
<h2 id="一、什么是入关学"><a href="#一、什么是入关学" class="headerlink" title="一、什么是入关学"></a>一、什么是入关学</h2><p>入关学（THE Science Of Enter The Gate），是一门研究山高县相关入关言论及其所代表的思想的新兴学科，其基础载体是山高县相关语录，以七十二贤冲塔言论为补充，以历史上的现实例子为渊源。从学科划分角度上来说，入关学是一门交叉学科，其覆盖领域包括政治学、军事学、地缘政治学、经济学、政治经济学、历史学等等，是一门相当前沿的综合性学科，并且还有很多发展的空间，值得研究者们去不断探索。 但随着近日入关学在人民群众中的普及，它也暴露出了许多问题：入关学的研究对象究竟是什么？入关学的使命是什么？入关学对人类社会有什么积极的意义？</p>
<p>入关学的研究对象和方法<br>目前知乎上的疑问主要是，入关学的研究对象到底是山高县的回答？还是评论区的精彩（献祭）言论？还是地缘政治学、军事学、经济学、明清易代史？ 笔者认为，其实三者一个密不可分的整体，缺少哪个都不能独立存活。山高县的回答基础来源于地缘政治学和军事学，为了使国人更清晰的理解而创造性地发明了将之粗略地投射到明清易代史的语境中，以此使得更多人方便理解学习。在入关学领域中，评论区的言论是山高县回答与键政研究者的结合体，经过知乎上各大学者（粉丝）的研究（冲塔），评论区的言论已经成为入关学丰富的增长点，是入关学理论知识在各个学者研究中不断突破、优化、细化的基础，被大批入关学学者应用于入关学研究中;然而，评论区言论在入关学教育中的应用尚浅，尚未得到应有的重视，但评论区言论对入关学领域的重要性决定了其在入关学教育中应用的必要，应用在入关学教育中是必然的。</p>
<p>入关学的主要内容<br>目前入关学的主要内容分3类：</p>
<p>（1）通过历史研究，以明亡清兴的历史教训论证了身为一个蛮子的正确自我认知[2]：</p>
<p>即入关的必要性 1.入关是女真团结的唯一途径，是女真求活的唯一选择，是女真崛起的唯一道路。 2. 扫帚不到，灰尘不会自己走掉。大明再烂，没有女真步步紧逼，一时半会儿也完不了。 3.蹲鹰和挖参固然能挣一些钱，然而改变不了摸鱼是绝大多数女真年轻人唯一出路的现实。 4. 摸鱼的命，不要操天朝的心。靠蹲鹰挖参和摸鱼，不仅买不来洪承畴，连范文程都买不来。 5.与其在关外吃敕书，不如到京城印敕书。 6.没了大明的敕书，女真也没饿死。 7. 靠同胞之情，同种之谊，既不可能让叶赫归顺，也不可能让朝鲜归降。 8. 在赫图阿拉再怎么读半吊子圣贤书，也改变不了摸鱼的现实。 9. 入关前不要搬着圣贤书胡思乱想，入关后自有正统儒学大师为我所用。</p>
<p>（2）通过对M国的研究，论证了M国治球不义不利，丧失人心、天道更易，而应有德之人居之：</p>
<p>具体又分为三方面论证：</p>
<p>1.M国崛起史、得球史寡廉鲜耻、不仁不义，实在人神共愤：</p>
<p>1.1</p>
<p>1845年，M国悍然吞并墨西哥领土德克萨斯后。仍不知足，得陇望蜀，竟恬不知耻的向墨西哥购买加利福尼亚和新墨西哥的广袤领土。[3]</p>
<p>1.2</p>
<p>英国在1807年就禁止贩奴，1833年就全面解放奴隶。而M国政权，直到1862年才解放奴隶，死不悔改、落后反动。[4]</p>
<p>1.3</p>
<p>M国是近现代极权迫害的极致，暴行不义，违反人权。</p>
<p>具体有以下方面：第一是政治迫害，比如独立战争时期，各个殖民地成立委员会，迫使每一个人宣誓效忠于合众国，胆敢不宣誓者，一律关进大牢，没收一切财产。第二是没收财产，比如1777年11月，国会建议各州没收变卖效忠派的财产。这个提议迅速得到支持。第三是人格侮辱，典型例子是托马斯布朗事件：乔治亚洲的著名效忠派托马斯·布朗，此人是一个富有的种植园主，1774年才来到殖民地。1775年一群独立派来到他家中，要求他向独立事业宣誓效忠的，他拒绝了，于是其他人打破了布朗头盖骨，剥下了他的部分头皮，并把他吊到他家门前的树上，又来了一出“涂沥青，粘羽毛”的戏码。而后他们又架上一堆火烤他，最终他的两个脚趾头被烧掉。第四则是互杀俘虏。[5]</p>
<p>爱国群众对效忠派M奸粘羽毛，涂沥青</p>
<p>由上诉例子可得结论：M国是近现代极权迫害的祖宗，违反人权，暴行不义。</p>
<p>（3）通过对M国治理全球方式的研究，论证了M国全球治理的不可持续性和必然衰亡性：</p>
<p>3.1 M国全球治理的不可持续性：</p>
<p>M国对世界经济的统治，宛如蒙古对中亚的统治。原本收税就行了，结果还是蒙古那一套——抢，没事就去抢劫自己治下的百姓来维持生活。例如索罗斯之流说白了就是蒙古抢劫大队长[6]。</p>
<p>而目前全世界最大的危机正是全球性的财政危机，连用货币政策和财政政策辗转腾挪的空间都很小的情况下，天降伟人特朗普还在全世界不停的火上浇油。俗话说国无完国，但会完蛋，饿虎不择食，蝼蚁且贪生。完蛋预期面前，这个世界要出多少幺蛾子，实难想象[7]。</p>
<p>3.2 M国全球治理的必然衰亡性：</p>
<p>M国是一个世界性的帝国，对一个世界性帝国来说，逆全球化四个字意味着什么？ 天子失德，诸侯离心，蛮夷崛起，四方扰攘之时。苏松二府的繁华，秦淮河畔的纸醉金迷，东林书院里的风声雨声读书声，又能代表什么呢？ 分析M国，要以其全球统治体系的运行状况为出发点，光盯着M国这个南直隶，是看不出什么的。[8]</p>
<p>但是全球化是其致命漏洞的，Dani Rodrik在2000年就指出，尽管全球化（在当时看来）势不可挡，但内在地蕴含着危机，根源在于全球经济一体化与全球政治上层建筑之间不可调和的矛盾。 Rodrik这篇文章[9]提出了一个“全球化三元悖论”，即经济一体化（或者说全球化）、民主政治和民族国家难以同时兼得，最多保证其二。</p>
<p>简而言之，经济全球化要求各国采取削减贸易壁垒，统一税制与监管，开放资本流动等一体化措施，这会对国家主权造成威胁；如果要在保证各国主权完整的情况下强行推进全球化，当国内部分群体利益受损时，只能牺牲这部分人的利益，而这又违背了民主原则；保证民主与主权完整必然会使全球化放缓[10]。</p>
<p>综上所述，M国的全球治理体系存在重大缺陷，必然走向衰亡。</p>
<p>入关学的历史渊源</p>
<p>许多研究者认为入关学是最近才出现的，这其实是不对的，因为通过文献研究，笔者发现，其实入关学的历史比一般意义上久远的多。广义上讲应该有两千余年的悠远历史。 理论依据：吾入关，秋毫不敢有所近，籍吏民，封府库，而待将军。(《史记·项羽本纪》)</p>
<p>根据史记的记载，刘邦其实才是入关学的第一位创始人、第一位研究者。刘项之争，刘弱项强，项羽分封刘邦于偏僻、资源贫瘠的蜀地（华夏文明当时的边缘地带），而自己占据华夏文明当时的中心地带，并挟制义帝作为大义，妄图通过资源封锁刘邦，通过占据道德的制高地谴责刘邦，通过占据文明的解释权将刘邦蛮夷化，这样的处境不能不说是很相似的阿！</p>
<p>在这样的困境面前，刘邦通过潜心研究入关学，采用张良、韩信的计策，暗度（入）陈仓（关），进入到肥沃、发达、人力资源丰富的关中平原，以此获得了和项羽争霸的资本，最终夺取天下。这正是刘邦研究入关学的证据和成果！</p>
<p>此外，入关学还经过了历代各位大家的不断补充，在不同的历史时期里，入关学的表现形式包括并展现为：北伐、南下、东征等。</p>
<p>例如：</p>
<p>前1046年：武王伐纣，入关学萌芽 前206年：刘邦暗度陈仓、还定三秦，诞生了第一为入关学家</p>
<p>227年：诸葛亮上出师表，被誉为千古奇文，这是入关学的第一次高峰</p>
<p>1644年，清军入关，这是入关学第一次进行朝代更替规模的应用</p>
<p>1941年12月，日军偷袭珍珠港，南下南洋，最终失败，昭（招）和（核）名副其实，这表明了入关学仍存在的缺陷，即如果研究不当、理解偏差，将一定灭亡</p>
<p>2019年，山高县于知乎开讲入关学，一时云从者众，成为知乎键政一大显学，与曹学等并列知乎键政奇学</p>
<h2 id="二、入关学的两大理论"><a href="#二、入关学的两大理论" class="headerlink" title="二、入关学的两大理论"></a>二、入关学的两大理论</h2><p>建州的发展与大明的治理的现状不可共存理论</p>
<p>海东青和高丽参确实是建州经济的支柱，007式的蹲鹰和挖参虽然苦，但在建州也是让绝大多数摸鱼诸申羡慕的好工作。然而蹲鹰和挖参，改变不了摸鱼是绝大多数女真年轻人唯一出路的现实。建州固然不可能靠摸鱼崛起，更不可能靠蹲海边抓海东青和钻长白山挖高丽参而崛起啊。[11]</p>
<p>所以，建州如果在现状下要想赢得尊重，只有一条路可走，就是——剃发易服。 蛮夷干什么都是错的，想解决挨骂问题，当然只能靠留头不留发，留发不留头（手动狗头）。 所以，从而明确了入关学研究的意义：即建州想解决尊重问题。首先，得入关，入关就是一切，一切为了入关，不入关，一切免谈。 你不入关，大M以抢劫治天下且有无数砖家穴者论述其合理性与合法性。在这种人类历史上空前无耻的舆论氛围面前，不入关消灭大M，绝其社稷，谈何赢得尊重？ 至于入关之后，山高认为应该做两件事（剃发易服笑笑就好）： 1：剿兵安民，彻底消灭与清算大M的金融铁骑及其走狗。 2：闯王来了不纳粮，不利用国际贸易与结算体系为自己牟利。 当昭告天下： ——今我华起义军，行天诛。非图一家一姓之荣华，实为五洲苍生之乞活![12]</p>
<p>从经济学角度讲，垄断资本主义规则下，自由资本主义是侵蚀垄断利润的规则破坏者（所谓发达国家粉碎机）。M国既然以垄断资本主义逻辑运行，那么它就必然要打击自由资本主义，以维持市场秩序。 而建州由于人口太多，发不起垄断资本主义阶段失业无产阶级的奶头乐，是很难向垄断资本主义转型的，除非有世界范畴内的垄断利润可吃（甚至哪怕入了关，也不过996变成986）。 所以说中国对M国而言，既是规则破坏者，又是地位挑战者。 所以M苏在经济上是可以共存的（M苏在没有核武器的时代也没有打热战），建州和M国之间则不一样。[13]</p>
<p>明确蛮夷的地位及入关是唯一的解决方法理论</p>
<p>入关学家逗比南波万 @逗比南波万 认为，当下我们面临的重要困惑是：</p>
<p>为何我们政治文化地位跟经济军事地位不符合？ 为何全世界都不待见建州人？ 为何舆论的高地我们没法占领？ 为何英M一张表单，能让我们投入千亿真金白银，再吸收一大群洋垃圾？ 为何？一句话，因为你是蛮夷。 华夏文明，如烈日当空，五千年来都是棋手，一直以天朝上国自居，何来蛮夷之说？因为现代化是英M开创，全世界的现代化都不可避免混入西化。你说现代化是你自己的，那是胡扯。你警察，西装咋回事？我们是天朝上国，划分出：南蛮、北狄、东夷、西戎。欧M是现代化正统，我们就是东夷。不想承认，也没办法。 综上，逗比南波万通过研究入关学理论，认为解决方案是： 入关！入关是让我们早饭M国。蛮夷灭了正统，自有衍圣公带头来跪。成了，我们就是真命天子，是罗马正统，是天道正义之剑。[14]</p>
<h2 id="三、入关学的具体应用"><a href="#三、入关学的具体应用" class="headerlink" title="三、入关学的具体应用"></a>三、入关学的具体应用</h2><p>键政一向被视作咸吃萝卜淡操心，甚至有观点认为键政是“地沟油的命，ZNH的心”，故很多人认为入关学也是如此。 笔者认为这有失偏颇。笔者经过总结发现，其实入关学理论能帮助我们正确认知世界，占领舆论高地和积极应对生活。从而帮助我们更积极、更向上、更正能量。</p>
<p>正确认知世界，占领舆论高地<br>入关学理论是山高县键政理论体系的基础，为学生认识和理解山高县键政理论体系提供渠道，训练并培养学生的键政思维，为培养键政方面人才提供了方法。入关学理论也是知乎键政体系扩展和发展的重要动力，通过重视入关学理论的研究，我们就可以借助入关学理论理解和认知当今世界体系的由来和发展，从思维和实践中培养更加优秀、专业的键政人才。只有认知世界正确了，我们才能形成良好的思维，将理论知识灵活运用于既定事实之中，占领舆论的高地、提升爱国主义教育。因此，入关学的研究可以更好培养出爱国主义正能量知乎键政体系的人才。</p>
<p>培养积极心态<br>作为当今重压之下浮躁内卷佛系的青年，入关学倡导的思想更能让人乐观向上、充满希望。 学习入关学后将明白面包会有的，楼上楼下，电灯电话也会有的。我们将在有生之年，用铁与火，在冲绳海沟，将日本人的舰队埋葬；在安达曼海与孟加拉湾，将印度人的舰队，变成一堆废铁；在北大西洋和南赤道，在密克罗尼西亚，在所罗门群岛，将美国人的所有航母舰队，变成一具又一具的海底铁棺材。</p>
<p>俗话说，白白胖胖，充满希望，人最怕的就是失去希望，变成一具行尸走肉，只要还有希望，就还拥有一切。</p>
<p>四、结论与展望 本文首次以理论的高度总结了入关学的定义、渊源及其应用，是对当今入关学发展的一次大一统性工作。不过限于作者水平，观点上难免会有疏漏，甚至存在争议，但态度是端正的，毕竟摸鱼是女真年轻人唯一的出路，可是谁不想念四书五经呢？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Bash入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/05/Bash%E5%85%A5%E9%97%A8/"
    >Bash入门</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/05/Bash%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2020-04-05T19:10:02.000Z" itemprop="datePublished">2020-04-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Shell是Linux下经典的文本互动方式，而Bash是现在最常用的一种Shell。我在这里总结了Bash的要点知识。</p>
<h2 id="1-Shell综述"><a href="#1-Shell综述" class="headerlink" title="1. Shell综述"></a>1. Shell综述</h2><p>Linux图形化桌面算不上精美。幸好，Linux提供了更好的与树莓派互动的方式：Shell。打开终端（Terminal），桌面上就会出现一个黑色背景的窗口，里面就运行着一个Shell。如果你敲击键盘，会发现字符会显示在$提示符的后面，形成一串文本形式的命令。所谓的Shell，就是运行在终端中的文本互动程序。Shell分析你的文本输入，然后把文本转换成相应的计算机动作。</p>
<p>在后面的内容中，我将用$来表示Linux系统Shell的命令提示符。比如说输入date命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$date</span></span><br></pre></td></tr></table></figure>

<p>date用于日期时间的相关功能。敲击回车键Enter后，Shell会显示出系统当前的时间。</p>
<p>Shell看起来简陋，但实际上比图形化桌面强大得多。它是Unix体系下的文本交互界面。你只需要用键盘来输入文本，就可以和操作系统交互。但这还是不够具体。说到底，Shell其实是一个运行着的程序。这个程序接收到你按下回车键之间的输入，就会对输入的文本进行分析。比如下面这个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$free</span> -h</span><br></pre></td></tr></table></figure>

<p>包括空格在内总共7个字符。Shell程序会通过空格，区分出命令的不同部分。第一个部分是命令名。剩下的部分是选项和参数。在这个例子中，Shell会进一步分析第二个部分，发现这一部分的开头是”-“字符，从而知道它是一个选项。</p>
<p>有了命令名，Shell下一步就要执行该命令名对应的动作。这听起来就像是在戏剧舞台上，演员按照脚本演戏。Shell命令可以分为如下三类：</p>
<ul>
<li>Shell内建函数（built-in function）</li>
<li>可执行文件（executable file）</li>
<li>别名（alias）</li>
</ul>
<p>Shell的内建函数是Shell自带的功能，而可执行文件是保存在Shell之外的脚本，提供了额外的功能。Shell必须在系统中找到对应命令名的可执行文件，才能正确执行。我们可以用绝对路径来告诉Shell可执行文件所在的位置。如果用户只是给出了命令名，而没有给出准确的位置，那么Shell必须自行搜索一些特殊的位置，也就是所谓的默认路径。Shell会执行第一个名字和命令名相同的可执行文件。这就相当于，Shell帮我们自动补齐了可执行文件的位置信息。我们可以通过which命令，来确定命令名对应的是哪个可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$which</span> date</span><br></pre></td></tr></table></figure>



<p>别名是给某个命令一个简称，以后在Shell中就可以通过这个简称来调用对应的命令。在Shell中，我们可以用alias来定义别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$alias</span> freak=<span class="string">&quot;free -h&quot;</span></span><br></pre></td></tr></table></figure>

<p>Shell会记住我们的别名定义。以后我在这个Shell中输入命令freak时，都将等价于输入free -h。</p>
<p>在Shell中，我们可以通过type命令来了解命令的类型。如果一个命令是可执行文件，那么type将打印出文件的路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$type</span> date</span><br><span class="line"><span class="variable">$type</span> <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<p>总的来说，Shell就是根据空格和其他特殊符号，来让电脑理解并执行用户要求的动作。到了后面，我们还将看到Shell中其他的特殊符号。</p>
<h2 id="2-Shell的选择"><a href="#2-Shell的选择" class="headerlink" title="2. Shell的选择"></a>2. Shell的选择</h2><p>Shell是文本解释器程序的统称，所以包括了不止一种Shell。常见的Shell有sh、bash、ksh、rsh、csh等。在树莓派中，就安装了sh和bash两个Shell解释器。sh的全名是Bourne Shell。名字中的玻恩就是这个Shell的作者。而bash的全名是Bourne Again Shell。最开始在Unix系统中流行的是sh，而bash作为sh的改进版本，提供了更加丰富的功能。一般来说，都推荐使用bash作为默认的Shell。树莓派，以及其他Linux系统中广泛安装sh，都是出于兼容历史程序的目的。</p>
<p>我们可以通过下面的命令来查看当前的Shell类型：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$echo $SHELL</span><br></pre></td></tr></table></figure>

<p>echo用于在终端打印出文本。而$是一个新的Shell特殊符号。它提示Shell，后面跟随的不是一般的文本，而是用于存储数据的变量。Shell会根据变量名找到真正的文本，替换到变量所在的位置。SHELL变量存储了当前使用的Shell的信息你可以在bash中用sh命令启动sh，并可以用exit命令从中退出。</p>
<h2 id="3-命令的选项和参数"><a href="#3-命令的选项和参数" class="headerlink" title="3. 命令的选项和参数"></a>3. 命令的选项和参数</h2><p>我们已经看到，一行命令里还可以包含着选项和参数。总的来说，选项用于控制命令的行为，而参数说明了命令的作用对象。比如说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$uname</span> -m</span><br></pre></td></tr></table></figure>

<p>在上面的命令中，选项-m影响了命令uname的行为，导致uname输出了树莓派的CPU型号。如果不是该选项的影响，uname输出的将是”Linux”。我们不妨把每个命令看做多功能的瑞士军刀，而选项让命令在不同的功能间切换。由一个”-“引领一个英文字母，这成为短选项。多个短选项的字母可以合在一起，跟在同一个”-“后面。比如，下面的两个命令就等价：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$uname</span> -m -r</span><br><span class="line"><span class="variable">$uname</span> -mr</span><br></pre></td></tr></table></figure>



<p>此外还有一种长选项，是用”–”引领一整个英文单词，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$date</span> --version</span><br></pre></td></tr></table></figure>

<p>上面的命令将输出date程序的版本信息。</p>
<p>如果说选项控制了瑞士军刀的行为，那么参数就提供了瑞士军刀发挥用场的原材料。就拿echo这个命令来说，它能把字符打印到终端。它选择打印的对象，正是它的参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> hello</span><br></pre></td></tr></table></figure>



<p>有的时候，选项也会携带变量，以便来说明选项行为的原材料。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> date --<span class="built_in">set</span>=<span class="string">&quot;1999-01-01 08:00:00&quot;</span></span><br></pre></td></tr></table></figure>

<p>选项”–set”用于设置时间，用等号连接的，就是它的参数。date会把日期设置成这一变量所代表的日期。如果用短选项，那么就要用空格取代等号了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> date -s <span class="string">&quot;1999-01-01 08:00:00&quot;</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，Shell对空格敏感。当一整个参数信息中包含了空格时，我们需要用引号把参数包裹起来，以便Shell能识别出这是一个整体。</p>
<p>所谓的选项和参数提供给命令的附加信息。因此，命令最终会拿这些字符串做什么，是由命令自己决定的。因此，有时会发现一些特异的选项或参数用法。这个时候，你就要从文档中寻找答案。</p>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><p>我们可以在Bash中输入一行的命令。Bash会把输入的命令转化为特定的动作。从这一节起，我们将看到Bash的可编程性。Bash提供了某些类似于C语言那样的编程语法，从而允许你用编程的方式，来组合使用Linux系统。我们首先看Bash用变量存储数据的能力。正如我们在C语言中看到的，变量是内存中的一块儿空间，可以用于存储数据。我们可以通过变量名来引用变量中保持的数据。借助变量，程序员可以复用出现过的数据。Bash中也有变量，但Bash的变量只能存储文本。</p>
<p><strong>1）变量赋值</strong></p>
<p>Bash和C类似，同样用“=”来表示赋值。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=World</span><br></pre></td></tr></table></figure>

<p>就是把文本World存入名为var的变量，即赋值。根据Bash的语法，赋值符号“=”的前后不留空格。赋值号右边的文本内容会存入赋值号左边的变量。</p>
<p>如果文本中包含空格，那么你可以用单引号或双引号来包裹文本。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=<span class="string">&#x27;abc bcd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=<span class="string">&quot;abc bcd&quot;</span></span><br></pre></td></tr></table></figure>



<p>在Bash中，我们可以把一个命令输出的文本直接赋予给一个变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$now</span>=`date`</span><br></pre></td></tr></table></figure>

<p>借助``符号，date命令的输出存入了变量now。</p>
<p>我们还可以把一个变量中的数据赋值给另一个变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$another</span>=<span class="variable">$var</span></span><br></pre></td></tr></table></figure>



<p><strong>2）引用变量</strong></p>
<p>我们可以用$var的方式来引用变量。在Bash中，所谓的引用变量就是把变量翻译成变量中存储的文本。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=World</span><br><span class="line"><span class="variable">$echo</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>就会打印出World，即变量中保存的文本。</p>
<p>在Bash中，你还可以在一段文本中嵌入变量。Bash也会把变量替换成变量中保存的文本。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> Hello<span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>文本将打印出HelloWorld。</p>
<p>为了避免变量名和尾随的普通文本混淆，我们也可以换用${}的方式来标识变量。比如说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="variable">$varIsGood</span></span><br></pre></td></tr></table></figure>

<p>由于Bash中并没有varIsGood这个变量，所以Bash将打印空白行。但如果将命令改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="variable">$&#123;var&#125;</span>IsGood</span><br></pre></td></tr></table></figure>

<p>Bash通过${}识别出变量var，并把它替换成数据。最终echo命令打印出WorldIsGood。</p>
<p>在Bash中，为了把一段包含空格的文本当做单一参数，就需要用到单引号或双引号。你可以在双引号中使用变量。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="string">&quot;Hello <span class="variable">$var</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>将打印Hello World。与此相对，Bash会忽视单引号中的变量引用，所以单引号中的变量名只会被当做普通文本，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> <span class="string">&#x27;Hello $var&#x27;</span></span><br></pre></td></tr></table></figure>

<p>将打印Hello $var。</p>
<h2 id="5-数学运算"><a href="#5-数学运算" class="headerlink" title="5. 数学运算"></a>5. 数学运算</h2><p>在Bash中，数字和运算符都被当做普通文本。所以你无法像C语言一样便捷地进行数学运算。比如执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$result</span>=1+2</span><br><span class="line"><span class="variable">$echo</span> <span class="variable">$result</span></span><br></pre></td></tr></table></figure>

<p>Bash并不会进行任何运算。它只会打印文本“1+2”。</p>
<p>在Bash中，你还可以通过$(())语法来进行数值运算。在双括号中你可以放入整数的加减乘除表达式。Bash会对其中的内容进行数值运算。比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> $((<span class="number">2</span> + (<span class="number">5</span>*<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>

<p>将打印运算结果12。此外，在$(())中，你也可以使用变量。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=1</span><br><span class="line"><span class="variable">$echo</span> $((<span class="variable">$var</span> + (<span class="number">5</span>*<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>

<p>将打印运算结果11。</p>
<p>你可以用Bash实现多种整数运算：</p>
<ul>
<li>加法：$(( 1 + 6 ))。结果为7。</li>
<li>减法：$(( 5 – 3 ))。结果为2。</li>
<li>乘法：$(( 2*2 ))。结果为4。</li>
<li>除法：$(( 9/3 ))。结果为3。</li>
<li>求余：$(( 5%3 ))。结果为2。</li>
<li>乘方：$(( 2**3 ))。结果为8。</li>
</ul>
<p>现在，你就可以把数学运算结果存入变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$result</span>=$(( <span class="number">1</span> + <span class="number">2</span> ))</span><br></pre></td></tr></table></figure>



<h2 id="6-返回代码"><a href="#6-返回代码" class="headerlink" title="6. 返回代码"></a>6. 返回代码</h2><p>在Linux中，每个可执行程序会有一个整数的返回代码。按照Linux惯例，当程序正常运行完毕并返回时，将返回整数0。因此，C程序中返回0的语句，都出现在C程序中main函数的最后一句。例如下面的foo.c程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">  a = <span class="number">6</span>;</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">  c = <span class="number">6</span>/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序可以正常运行。因此，它将在最后一句执行return语句，程序的返回代码是0。在Shell中，我们运行了程序后，可以通过$?变量来获知返回码。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gcc</span> foo.c</span><br><span class="line">$./a.out</span><br><span class="line"><span class="variable">$echo</span> $?</span><br></pre></td></tr></table></figure>



<p>如果一个程序运行异常，那么这个程序将返回非0的返回代码。比如删除一个不存在的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> none_exist.file</span><br><span class="line"><span class="variable">$echo</span> $?</span><br></pre></td></tr></table></figure>



<p>在Linux中，可以在一个行命令中执行多个程序。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$touch</span> demo.file; ls;</span><br></pre></td></tr></table></figure>



<p>在执行多个程序时，我们可以让后一个程序的运行参考前一个程序的返回代码。比如说，只有前一个程序返回成功代码0，才让后一个程序运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> demo.file &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;rm succeed&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果rm命令顺利运行，那么第二个echo命令将执行。</p>
<p>还有一种情况，是等到前一个程序失败了，才运行后一个程序，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> demo.file || <span class="built_in">echo</span> <span class="string">&quot;rm fail&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果rm命令失败，第二个echo命令才会执行。</p>
<h2 id="7-Bash脚本"><a href="#7-Bash脚本" class="headerlink" title="7. Bash脚本"></a>7. Bash脚本</h2><p>你还可以把多行的Bash命令写入一个文件，成为所谓的Bash脚本。当Bash脚本执行时，Shell将逐行执行脚本中的命令。编写Bash脚本，是我们开始实现Bash代码复用的第一步。</p>
<p><strong>1）脚本的例子</strong></p>
<p>用文本编辑器编写一个Bash脚本hello_world.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Hello</span><br><span class="line"><span class="built_in">echo</span> World</span><br></pre></td></tr></table></figure>

<p>脚本的第一行说明了该脚本使用的Shell，即/bin/bash路径的Bash程序。脚本正文是两行echo命令。运行脚本的方式和运行可执行程序的方式类似，都是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./hello_world.bash</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果用户不具有执行Bash脚本文件的权限，那么他将无法执行Bash脚本。此时，用户必须更换文件权限，或者以其他身份登录，才能执行脚本。当脚本运行时，两行命令将按照由上至下的顺序依次执行。Shell将打印两行文本：</p>
<blockquote>
<p>Hello<br>World</p>
</blockquote>
<p>Bash脚本是一种复用代码的方式。我们可以用Bash脚本实现特定的功能。由于该功能记录在脚本中，因此我可以反复地运行同一个文件来实现相同的功能，而不是每次想用的时候都要重新敲一遍命令。我们看一个简单的Bash脚本hw_info.bash，它将计算机的信息存入到名为log的文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Information of yc&#x27;s computer:&quot;</span> &gt; <span class="built_in">log</span></span><br><span class="line">lscpu &gt;&gt; <span class="built_in">log</span></span><br><span class="line">uname –a &gt;&gt; <span class="built_in">log</span></span><br><span class="line">free –h &gt;&gt; <span class="built_in">log</span></span><br></pre></td></tr></table></figure>



<p><strong>2）脚本参数</strong></p>
<p>和可执行程序类似，Bash脚本运行时，也可以携带参数。这些参数可以在Bash脚本中以变量的形式使用。比如test_arg.bash:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span></span><br></pre></td></tr></table></figure>

<p>在Bash中，你可以用$0、$1、$2……的方式，来获得Bash脚本运行时的参数。我们用下面的方式运行Bash脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./test_arg.bash hello world</span><br></pre></td></tr></table></figure>

<p>$0是命令的第一部分，也就是./test_arg.bash。$1代表了参数hello，而$2代表了参数world。因此，上面程序将打印：</p>
<blockquote>
<p>./test_arg.bash<br>hello<br>world</p>
</blockquote>
<p>如果变更参数，同一段脚本将有不同的行为。这大大提高了Bash脚本的灵活性。上面的hw_info.bash脚本中，我们把输出文件名写死成log。我们也可以修改脚本，用参数作为输出文件的文件名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Information of yc&#x27;s computer:&quot;</span> &gt; <span class="variable">$1</span></span><br><span class="line">lscpu &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">uname –a &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">free –h &gt;&gt; <span class="variable">$1</span></span><br></pre></td></tr></table></figure>



<p>借助参数，我们就可以自由地设置输出文件的名字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./hw_info.bash output.file</span><br></pre></td></tr></table></figure>



<p><strong>3）脚本的返回代码</strong></p>
<p>和可执行程序类似，脚本也可以有返回代码。还是按照惯例，脚本正常退出时返回代码0。在脚本的末尾，我们可以用exit命令来设置脚本的返回代码。我们修改hello_world.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Hello</span><br><span class="line"><span class="built_in">echo</span> World</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>其实在脚本的末尾加一句exit 0并不必要。一个脚本如果正常运行完最后一句，会自动的返回代码0。在脚本运行后，我们可以通过$?变量查询脚本的返回代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$./hello_world.bash</span><br><span class="line"><span class="variable">$echo</span> $?</span><br></pre></td></tr></table></figure>



<p>如果在脚本中部出现exit命令，脚本会直接在这一行停止，并返回该exit命令给出的返回代码。比如下面的demo_exit.bash:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> hello</span><br><span class="line"><span class="built_in">exit</span> 1 <span class="built_in">echo</span> world</span><br></pre></td></tr></table></figure>

<p>你可以运行该脚本，检查其输出结果，并查看其返回代码。</p>
<h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><p>在Bash中，脚本和函数有很多相似的地方。脚本实现了一整个脚本文件的程序复用，而函数复用了脚本内部的部分程序。一个函数可以像脚本一个包含多个指令，用于说明该函数如果被调用会执行哪些活动。在定义函数时，我们需要花括号来标识函数包括的部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_info</span></span> ()&#123;</span><br><span class="line">  lscpu &gt;&gt; <span class="built_in">log</span></span><br><span class="line">  uname –a &gt;&gt; <span class="built_in">log</span></span><br><span class="line">  free –h &gt;&gt; <span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_info</span><br></pre></td></tr></table></figure>

<p>脚本一开始定义了函数my_info，my_info是函数名。关键字function和花括号都提示了该部分是函数定义。因此，function关键字并不是必须的。上面的脚本等效于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_info</span></span> ()&#123;</span><br><span class="line">  lscpu &gt;&gt; <span class="built_in">log</span></span><br><span class="line">  uname –a &gt;&gt; <span class="built_in">log</span></span><br><span class="line">  free –h &gt;&gt; <span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_info</span><br></pre></td></tr></table></figure>

<p>花括号中的三行命令，就说明了函数执行时需要执行的命令。需要强调的是，函数定义只是食谱，并没有转化成具体的动作。脚本的最后一行是在调用函数。只有通过函数调用，函数内包含的命令才能真正执行。调用函数时，只需要一个函数名就可以了。</p>
<p>像脚本一样，函数调用时还可以携带参数。在函数内部，我们同样可以用$1、$2这种形式的变量来使用参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_info</span></span> ()&#123;</span><br><span class="line">  lscpu &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">  uname –a &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">  free –h &gt;&gt; <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_info output.file</span><br><span class="line">my_info another_output.file</span><br></pre></td></tr></table></figure>

<p>在上面的脚本中，进行了两次函数调用。函数调用时，分别携带了参数output.file和another_output.file。</p>
<h2 id="9-跨脚本调用"><a href="#9-跨脚本调用" class="headerlink" title="9. 跨脚本调用"></a>9. 跨脚本调用</h2><p>在Bash中使用source命令，可以实现函数的跨脚本调用。命令source的作用是在同一个进程中执行另一个文件中的Bash脚本。比如说，有两个脚本，my_info.bash和app.bash。脚本my_info.sh中的内容是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_info</span></span> ()&#123;</span><br><span class="line">  lscpu &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">  uname –a &gt;&gt; <span class="variable">$1</span> </span><br><span class="line">  free –h &gt;&gt; <span class="variable">$1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>脚本app.bash中的内容是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> my_info.bash</span><br><span class="line">my_info output.file</span><br></pre></td></tr></table></figure>

<p>运行app.bash时，执行到source命令那一行时，就会执行my_info.bash脚本。在app.bash的后续部分，就可以使用my_info.bash中的my_info函数。</p>
<h2 id="10-逻辑判断"><a href="#10-逻辑判断" class="headerlink" title="10. 逻辑判断"></a>10. 逻辑判断</h2><p>我们已经介绍了函数和脚本两种组合命令的方式。这两种方式都可以把多行命令合并起来，组成一个功能单元。函数和脚本都实现了一定程度的代码复用。从这一节起，我们将看到选择和循环两种语法结构，这两种语法结构可以改变脚本的运行顺序，从而编写出更加灵活的程序。Bash除了可以进行数值运算，还可以进行逻辑判断。逻辑判断是决定某个说法的真假。我们在生活中很自然地进行各种各样的逻辑判断。比如“3大于2”这个说法，我们会说它是真的。逻辑判断就是对一个说法判断真假。在Bash中，我们可以用test命令来进行逻辑判断：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span> 3 -gt 2; <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>命令test后面跟有一个判断表达式，其中的-gt表示大于，即greater than。由于“3大于2”这一表达式为真，所以命令的返回代码将是0。如果表达式为1，那么命令的返回代码是1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span> 3 -lt 2; <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>表达式中的-lt表示小于，即less than。</p>
<p>数值大小和相等关系的判断，是最常见的逻辑判断。除了上面的大于和小于判断，我们还可以进行以下的数值判断：</p>
<ul>
<li>等于： $test 3 -eq 3; echo $?</li>
<li>不等于： $test 3 -ne 1; echo $?</li>
<li>大于等于： $test 5 -ge 2; echo $?</li>
<li>小于等于： $test 3 -le 1; echo $?</li>
</ul>
<p>Bash中最常见的数据形式是文本，因此也提供了很多关于文本的判断：</p>
<ul>
<li>文本相同: $test abc = abx; echo $?</li>
<li>文本不同： $test abc != abx; echo $?</li>
<li>按照词典顺序，一个文本在另一个文本之前： $test apple &gt; tea; echo $?</li>
<li>按照词典顺序，一个文本在另一个文本之后： $test apple &lt; tea; echo $?</li>
</ul>
<p>Bash还可以对文件的状态进行逻辑判断：</p>
<ul>
<li>检查一个文件是否存在： $test –e a.out; echo $?</li>
<li>检查一个文件是否存在，而且是普通文件： $test –f file.txt; echo $?</li>
<li>检查一个文件是否存在，而且是目录文件： $test –d myfiles; echo $?</li>
<li>检查一个文件是否存在，而且是软连接： $test –L a.out; echo $?</li>
<li>检查一个文件是否可读： $test –r file.txt; echo $?</li>
<li>检查一个文件是否可写： $test –w file.txt; echo $?</li>
<li>检查一个文件是否可执行： $test –x file.txt; echo $?</li>
</ul>
<p>在做逻辑判断时，可以把多个逻辑判断条件用“与、或、非”的关系组合起来，形成复合的逻辑判断。</p>
<ul>
<li>非，与expression的真假相反：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! expression</span><br></pre></td></tr></table></figure>

<ul>
<li>与，必须expression1和expression2都为真时，结果才为真：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 –a expression2</span><br></pre></td></tr></table></figure>

<ul>
<li>或，只要expression1和expression2的一个为真时，结果就为真：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 –o expression2</span><br></pre></td></tr></table></figure>





<h2 id="11-选择结构"><a href="#11-选择结构" class="headerlink" title="11. 选择结构"></a>11. 选择结构</h2><p>逻辑判断可以获得计算机和进程的状态。进一步，Bash可以根据逻辑判断，让程序有条件地运行，这也就是所谓的选择结构。选择结构是一种语法结构，可以让程序根据条件决定执行哪一部分的指令。最早的程序都是按照指令顺序依次执行。选择结构打破了这一顺序，给程序带来更高的灵活性。最简单的，我们可以根据条件来决定是否执行某一部分程序，比如下面的demo_if.bash脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var=`whoami`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> = <span class="string">&quot;root&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span>   </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are root&quot;</span>   </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are my God.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这个脚本中使用了最简单的if结构。关键字if后面跟着[]，里面是一个逻辑表达式。这个逻辑表达式就是if结构的条件。如果条件成立，那么if将执行then到fi之间包含的语句，我们称之为隶属于then的代码块。如果条件不成立，那么then的代码块不执行。这个例子的条件是判断用户是否为root。因此，如果是非root用户执行该脚本，那么Shell不会打印任何内容。</p>
<p>我们还可以通过if…then…else…结构，让Bash脚本从两个代码块中选择一个执行。该选择结构同样有一个条件。如果条件成立，那么将执行then附属的代码块，否则执行else附属的代码块。下面的demo_if_else.bash脚本是一个小例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">filename=<span class="variable">$1</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$filename</span> ]</span><br><span class="line"><span class="keyword">then</span>   </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$filename</span> exists&quot;</span> </span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$filename</span> NOT exists&quot;</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The End&quot;</span></span><br></pre></td></tr></table></figure>



<p>if后面的“-e $filename”作为判断条件。如果条件成立，即文件存在，那么执行then部分的代码块。如果文件不存在，那么脚本将执行else语句中的echo命令。末尾的fi结束整个语法结构。脚本继续以顺序的方式执行剩余内容。运行脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./demo_if_else.bash a.out</span><br></pre></td></tr></table></figure>

<p>脚本会根据a.out是否存在，打印出不同的内容。</p>
<p>我们看到，在使用if…then…else…结构时，我们可以实现两部分代码块的选择执行。而在then代码块和else代码块内部，我们可以继续嵌套选择结构，从而实现更多个代码块的选择执行。比如脚本demo_nest.bash:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var=`whoami`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You are <span class="variable">$var</span>&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> = <span class="string">&quot;root&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;You are my God.&quot;</span> </span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$var</span> = <span class="string">&quot;yc&quot;</span> ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;You are a happy user.&quot;</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;You are the Others.&quot;</span></span><br><span class="line">   <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>



<p>在Bash下，我们还可以用case语法来实现多程序块的选择执行。比如下面的脚本demo_case.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var=`whoami`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You are <span class="variable">$var</span>&quot;</span> </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$var</span> <span class="keyword">in</span></span><br><span class="line">root)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are God.&quot;</span></span><br><span class="line">;;</span><br><span class="line">yc)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are a happy user.&quot;</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are the Others.&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>这个脚本和上面的demo_nest.bash功能完全相同。可以看到case结构与if结构的区别。关键字case后面不再是逻辑表达式，而是一个作为条件的文本。后面的代码块分为三个部分，都以文本标签)的形式开始，以;;结束。在case结构运行时，会逐个检查文本标签。当条件文本和文本标签可以对应上时，Bash就会执行隶属于该文本标签的代码块。如果是用户yc执行该Bash脚本，那么条件文本和yc标签对应上，脚本就会打印：</p>
<blockquote>
<p>You are a happy user.</p>
</blockquote>
<p>文本标签除了是一串具体的文本，还可以包含文本通配符。结构case中常用的通配符包括：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
<th>文本标签例子</th>
<th>符合条件的文本</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>任意文本</td>
<td>*</td>
<td>Xyz, 12a3, …</td>
</tr>
<tr>
<td>？</td>
<td>任意一个字符</td>
<td>a?c</td>
<td>abc, axc, …</td>
</tr>
<tr>
<td>[]</td>
<td>范围内一个</td>
<td>[1-5] [b-d]</td>
<td>2b, 3d, …</td>
</tr>
</tbody></table>
<p>上面的程序中最后一个文本标签是通配符*，即表示任意条件文本都可以触发此段代码块的运行。当然，前提是前面的几个文本标签都没有“截胡”。</p>
<h2 id="12-循环结构"><a href="#12-循环结构" class="headerlink" title="12. 循环结构"></a>12. 循环结构</h2><p>循环结构是编程语言中另一种常见的语法结构。循环结构的功能是重复执行某一段代码，直到计算机的状态符合某一条件。在while语法中，Bash会循环执行隶属于while的代码块，直到逻辑表达式不成立。比如下面的demo_while.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">now=`date +<span class="string">&#x27;%Y%m%d%H%M&#x27;</span>`</span><br><span class="line">deadline=`date --date=<span class="string">&#x27;1 hour&#x27;</span> +<span class="string">&#x27;%Y%m%d%H%M&#x27;</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$now</span> -lt <span class="variable">$deadline</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   date</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;not yet&quot;</span></span><br><span class="line">   sleep 10</span><br><span class="line">   now=`date +<span class="string">&#x27;%Y%m%d%H%M&#x27;</span>`</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;now, deadline reached&quot;</span></span><br></pre></td></tr></table></figure>

<p>关键字do和done之间的代码是隶属于该循环结构的代码块。在while后面跟着条件，该条件决定了代码块是否重复执行下去。这个条件是用当前的时间与目标时间对比。如果当前时间小于目标时间，那么代码块就会重复执行下去。否则，Bash将跳出循环，继续执行后面的语句。</p>
<p>如果while的条件始终是真，那么循环会一直进行下去。下面的程序就是以无限循环的形式，不断播报时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  date</span><br><span class="line">  sleep 1 </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>语法while的终止条件是一个逻辑判断。如果在循环过程中改变逻辑判断的内容，那么我们很难在程序执行之前预判循环进行的次数。正如我们之前在demo_while.bash中看到的，我们在循环进行过程中改变着作为条件的逻辑表达式，不断地更新参与逻辑判断的当前时间。与while语法对应的是for循环。这种语法会在程序进行前确定好循环进行的次数，比如demo_for.bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> `ls <span class="built_in">log</span>*`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  rm <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>在这个例子中，命令ls log*将返回所有以log开头的文件名。这些文件名之间由空格分隔。循环进行时，Bash会依次取出一个文件名，赋值给变量var，并执行do和done之间隶属于for结构的程序块。由于ls命令返回的内容在是确定的，因此for循环进行的次数也会在一开始确定下来。</p>
<p>在for语法中，我们也可以使用自己构建一个由空格分隔的文本。由空格区分出来的每个子文本会在循环中赋值给变量。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> yc anna yutian</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$user</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>此外，for循环还可以和seq命令配合使用。命令seq用于生成一个等差的整数序列。命令后面可以跟3个参数，第一个参数表示整数序列的开始数字，第二个参数表示每次增加多少，最后一个参数表示序列的终点。因此，下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$seq</span> 1 2 10</span><br></pre></td></tr></table></figure>

<p>将返回：</p>
<blockquote>
<p>1 3 5 7 9</p>
</blockquote>
<p>可以看到，seq返回的也是由空格分隔开的文本。因此，seq的返回结果也可用于for循环。</p>
<p>结合for循环和seq命令，我们可以解一些有趣的数学问题。比如高斯求和，是要计算从1到100的所有整数的和。我们可以用Bash解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">total=0 </span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> `seq 1 1 100`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  total=$(( <span class="variable">$total</span> + <span class="variable">$number</span> ))</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$total</span></span><br></pre></td></tr></table></figure>



<p>这个问题还可以用do while循环来求解：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">total=0</span><br><span class="line">number=1 </span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$number</span> -gt 100 ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  total=$(( <span class="variable">$total</span> + <span class="variable">$number</span> ))</span><br><span class="line">  number=$((<span class="variable">$number</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$total</span></span><br></pre></td></tr></table></figure>

<p>这里break语句的作用是在满足条件时跳出循环。</p>
<p>如果想计算1到100所有不被3整数的和，则可以使用continue语句，跳过所有被3整数的数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">total=0 </span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> `seq 1 1 100`</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">if</span> (( <span class="variable">$number</span> % 3 == 0 )) </span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  total=$(( <span class="variable">$total</span> + <span class="variable">$number</span> ))</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$total</span></span><br></pre></td></tr></table></figure>



<h2 id="13-Bash与C语言"><a href="#13-Bash与C语言" class="headerlink" title="13. Bash与C语言"></a>13. Bash与C语言</h2><p>到了这里，我们已经介绍完Bash语言的基本语法。Bash语言和C语言都是Linux下的常用语言。它们都能通过特定的语法来编写程序，而程序运行后都能实现某些功能。尽管在语法细节上存在差异，但两种语言都有以下语法：</p>
<ul>
<li>变量：在内存中储存数据</li>
<li>循环结构：重复执行代码块</li>
<li>选择结构：根据条件执行代码块</li>
<li>函数：复用代码块</li>
</ul>
<p>编程语言的作者在设计语言时，往往会借鉴已有编程语言的优点。这是编程语言之间相似性的一大原因。程序员往往要掌握不止一套编程语言。相似的语法特征，会让程序员在学习新语言时感到亲切，从而促进语言的推广。</p>
<p>Bash和C的相似性，也来自于它们共同遵守的编程范式——面向过程编程。支持面向过程编程的语言，一般都会提供类似于函数的代码封装方式。函数把多行指令包装成一个功能。只要知道了函数名，程序可以通过调用函数来使用函数功能，最终实现代码复用。除了面向过程编程，还有面向对象和函数式的编程范式。每种编程范式都提供了特定的代码封装方式，并达到代码复用的目的。值得注意的是，近年来出现的新语言往往会支持不止一种编程范式。</p>
<p>除了相似性，我们还应该注意到Bash和C程序的区别。Bash的变量只能是文本类型，C的变量却可以有整数、浮点数、字符等类型。Bash的很多功能，如加减乘除运算，都是调用其他程序实现的。而C直接就可以进行加减乘除运算。可以说，C语言是一门真正的编程语言。C程序最终会编译成二进制的可执行文件。CPU可以直接理解这些文件中的指令。</p>
<p>另一方面，Bash是一个Shell。它本质上是一个命令解释器程序，而不是编程语言。用户可以通过命令行的方式，来调用该程序的某些功能。所谓的Bash编程，只是命令解释器程序提供的一种互动方法。Bash脚本只能和Bash进程互动。它不能像C语言一样，直接调用CPU的功能。因此，Bash能实现的功能会受限，运行速度上也比不上可执行文件。</p>
<p>但另一反面，Bash脚本也有它的好处。 C语言能接触到很底层的东西，但使用起来也很复杂。有时候，即使你已经知道如何用C实现一个功能，写代码依然是一个很繁琐的过程。Bash正相反。由于Bash可以便捷地调用已有的程序，因此很多工作可以用数行的脚本解决。此外，Bash脚本不需要编辑，就可以由Bash进程理解并执行。因此，开发Bash脚本比写C程序要快很多。Linux的系统运维工作，如定期备份、文件系统管理等，就经常使用到Bash脚本。总之，Bash编程知识是晋级为资深Linux用户的必要条件。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bash/" rel="tag">Bash</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-微服务和服务网格架构概念整理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"
    >微服务和服务网格架构概念整理</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-04-05T01:15:00.000Z" itemprop="datePublished">2020-04-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="微服务（Microservices）"><a href="#微服务（Microservices）" class="headerlink" title="微服务（Microservices）"></a>微服务（Microservices）</h2><p>在过去的 2016 年和 2017 年，微服务技术迅猛普及，和容器技术一起成为这两年中最吸引眼球的技术热点。而以 Spring Cloud 为代表的传统侵入式开发框架，占据着微服务市场的主流地位。</p>
<p><strong>微服务（Microservices）是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</strong></p>
<p>形像一点来说，微服务架构就像搭积木，每个微服务都是一个零件，并使用这些零件组装出不同的形状。通俗来说，微服务架构就是把一个大系统按业务功能分解成多个职责单一的小系统，并利用简单的方法使多个小系统相互协作，组合成一个大系统。</p>
<p>如果学科派一点，微服务架构就是把因相同原因而变化的功能聚合到一起，而把因不同原因而变化的功能分离开，并利用轻量化机制（通常为 HTTP RESTful API）实现通信。</p>
<p><strong>微服务架构 ≈ 模块化开发 + 分布式计算。</strong></p>
<p>需要注意的是“<strong>微服务</strong>”与“<strong>微服务架构</strong>”是有本质区别的。“微服务”强调的是服务的大小，它关注的是某一个点。而“微服务架构”则是一种架构思想，需要从整体上对软件系统进行通盘的考虑。</p>
<p>微服务架构示意图：</p>
<p><img src="../images/435188-20180320111937567-207132112.jpg" alt="img"></p>
<p>常见的微服务组件及概念：</p>
<ul>
<li><strong>服务注册</strong>：服务提供方将自己调用地址注册到服务注册中心，让服务调用方能够方便地找到自己。</li>
<li><strong>服务发现</strong>：服务调用方从服务注册中心找到自己需要调用的服务的地址。</li>
<li><strong>负载均衡</strong>：服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，节点选择的工作对服务调用方来说是透明的。</li>
<li><strong>服务网关</strong>：服务网关是服务调用的唯一入口，可以在这个组件是实现用户鉴权、动态路由、灰度发布、A/B 测试、负载限流等功能。</li>
<li><strong>配置中心</strong>：将本地化的配置信息（properties, xml, yaml 等）注册到配置中心，实现程序包在开发、测试、生产环境的无差别性，方便程序包的迁移。</li>
<li><strong>API 管理</strong>：以方便的形式编写及更新 API 文档，并以方便的形式供调用者查看和测试。</li>
<li><strong>集成框架</strong>：微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形式将所有微服务组件（特别是管理端组件）集成到统一的界面框架下，让用户能够在统一的界面中使用系统。</li>
<li><strong>分布式事务</strong>：对于重要的业务，需要通过分布式事务技术（TCC、高可用消息服务、最大努力通知）保证数据的一致性。</li>
<li><strong>调用链</strong>：记录完成一个业务逻辑时调用到的微服务，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。</li>
<li><strong>支撑平台</strong>：系统微服务化后，系统变得更加碎片化，系统的部署、运维、监控等都比单体架构更加复杂，那么，就需要将大部分的工作自动化。现在，可以通过 Docker 等工具来中和这些微服务架构带来的弊端。 例如持续集成、蓝绿发布、健康检查、性能健康等等。严重点，以我们两年的实践经验，可以这么说，如果没有合适的支撑平台或工具，就不要使用微服务架构。</li>
</ul>
<p>微服务架构的优点：</p>
<ul>
<li><strong>降低系统复杂度</strong>：每个服务都比较简单，只关注于一个业务功能。</li>
<li><strong>松耦合</strong>：微服务架构方式是松耦合的，每个微服务可由不同团队独立开发，互不影响。</li>
<li><strong>跨语言</strong>：只要符合服务 API 契约，开发人员可以自由选择开发技术。这就意味着开发人员可以采用新技术编写或重构服务，由于服务相对较小，所以这并不会对整体应用造成太大影响。</li>
<li><strong>独立部署</strong>：微服务架构可以使每个微服务独立部署。开发人员无需协调对服务升级或更改的部署。这些更改可以在测试通过后立即部署。所以微服务架构也使得 CI／CD 成为可能。</li>
<li><strong>Docker 容器</strong>：和 Docker 容器结合的更好。</li>
<li><strong>DDD 领域驱动设计</strong>：和 DDD 的概念契合，结合开发会更好。</li>
</ul>
<p>微服务架构的缺点：</p>
<ul>
<li><strong>微服务强调了服务大小，但实际上这并没有一个统一的标准</strong>：业务逻辑应该按照什么规则划分为微服务，这本身就是一个经验工程。有些开发者主张 10-100 行代码就应该建立一个微服务。虽然建立小型服务是微服务架构崇尚的，但要记住，微服务是达到目的的手段，而不是目标。微服务的目标是充分分解应用程序，以促进敏捷开发和持续集成部署。</li>
<li><strong>微服务的分布式特点带来的复杂性</strong>：开发人员需要基于 RPC 或者消息实现微服务之间的调用和通信，而这就使得服务之间的发现、服务调用链的跟踪和质量问题变得的相当棘手。</li>
<li><strong>分区的数据库体系和分布式事务</strong>：更新多个业务实体的业务交易相当普遍，不同服务可能拥有不同的数据库。CAP 原理的约束，使得我们不得不放弃传统的强一致性，而转而追求最终一致性，这个对开发人员来说是一个挑战。</li>
<li><strong>测试挑战</strong>：传统的单体WEB应用只需测试单一的 REST API 即可，而对微服务进行测试，需要启动它依赖的所有其他服务。这种复杂性不可低估。</li>
<li><strong>跨多个服务的更改</strong>：比如在传统单体应用中，若有 A、B、C 三个服务需要更改，A 依赖 B，B 依赖 C。我们只需更改相应的模块，然后一次性部署即可。但是在微服务架构中，我们需要仔细规划和协调每个服务的变更部署。我们需要先更新 C，然后更新 B，最后更新 A。</li>
<li><strong>部署复杂</strong>：微服务由不同的大量服务构成。每种服务可能拥有自己的配置、应用实例数量以及基础服务地址。这里就需要不同的配置、部署、扩展和监控组件。此外，我们还需要服务发现机制，以便服务可以发现与其通信的其他服务的地址。因此，成功部署微服务应用需要开发人员有更好地部署策略和高度自动化的水平。</li>
<li><strong>总的来说（问题和挑战）</strong>：API Gateway、服务间调用、服务发现、服务容错、服务部署、数据调用。</li>
</ul>
<p>不过，现在很多微服务的框架（比如 Spring Cloud、Dubbo）已经很好的解决了上面的问题。</p>
<p>资料来源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iteye.com/news/32932">微服务架构初探</a>（<strong>很赞，推荐</strong>）</li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c/entry/解析微服务架构_一_什么是微服务?lang=en">解析微服务架构(一)：什么是微服务</a></li>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/micro-service-architecture-from-zero">从0开始的微服务架构：（一）重识微服务架构</a></li>
</ul>
<h2 id="服务网格（Service-Mesh）"><a href="#服务网格（Service-Mesh）" class="headerlink" title="服务网格（Service Mesh）"></a>服务网格（Service Mesh）</h2><p>2017 年底，非侵入式的 Service Mesh 技术从萌芽到走向了成熟。</p>
<p>Service Mesh 又译作“服务网格”，作为<strong>服务间通信的基础设施层</strong>。</p>
<p>如果用一句话来解释什么是 Service Mesh，可以将它比作是<strong>应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控</strong>。对于编写应用程序来说一般无须关心 TCP/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交给 Service Mesh 就可以了。</p>
<p>Service Mesh 的来龙去脉：</p>
<ol>
<li>从最原始的主机之间直接使用网线相连</li>
<li>网络层的出现</li>
<li>集成到应用程序内部的控制流</li>
<li>分解到应用程序外部的控制流</li>
<li>应用程序的中集成服务发现和断路器</li>
<li>出现了专门用于服务发现和断路器的软件包/库，如 Twitter 的 Finagle 和 Facebook 的 Proxygen，这时候还是集成在应用程序内部</li>
<li>出现了专门用于服务发现和断路器的开源软件，如 Netflix OSS、Airbnb 的 synapse 和 nerve</li>
<li>最后作为微服务的中间层 Service Mesh 出现</li>
</ol>
<p>Service Mesh 有如下几个特点：</p>
<ul>
<li><strong>应用程序间通讯的中间层</strong></li>
<li><strong>轻量级网络代理</strong></li>
<li><strong>应用程序无感知</strong></li>
<li><strong>解耦应用程序的重试/超时、监控、追踪和服务发现</strong></li>
</ul>
<p>Service Mesh 架构图：</p>
<p><img src="../images/435188-20180320161422174-1610333563.png" alt="img"></p>
<p>目前流行的 Service Mesh 开源软件有 Linkerd、Envoy 和 Istio，而最近 Buoyant（开源 Linkerd 的公司）又发布了基于 Kubernetes 的 Service Mesh 开源项目 Conduit。</p>
<p>Service Mesh 开源项目简介：</p>
<ul>
<li><strong>Linkerd</strong>（<a target="_blank" rel="noopener" href="https://github.com/linkerd/linkerd）：第一代">https://github.com/linkerd/linkerd）：第一代</a> Service Mesh，2016 年 1 月 15 日首发布，业界第一个 Service Mesh 项目，由 Buoyant 创业小公司开发（前 Twitter 工程师），2017 年 7 月 11 日，宣布和 Istio 集成，成为 Istio 的数据面板。</li>
<li><strong>Envoy</strong>（<a target="_blank" rel="noopener" href="https://github.com/envoyproxy/envoy）：第一代">https://github.com/envoyproxy/envoy）：第一代</a> Service Mesh，2016 年 9 月 13 日首发布，由 Matt Klein 个人开发（Lyft 工程师），之后默默发展，版本较稳定。</li>
<li><strong>Istio</strong>（<a target="_blank" rel="noopener" href="https://github.com/istio/istio）：第二代">https://github.com/istio/istio）：第二代</a> Service Mesh，2017 年 5 月 24 日首发布，由 Google、IBM 和 Lyft 联合开发，只支持 Kubernetes 平台，2017 年 11 月 30 日发布 0.3 版本，开始支持非 Kubernetes 平台，之后稳定的开发和发布。</li>
<li><strong>Conduit</strong>（<a target="_blank" rel="noopener" href="https://github.com/runconduit/conduit）：第二代">https://github.com/runconduit/conduit）：第二代</a> Service Mesh，2017 年 12 月 5 日首发布，由 Buoyant 公司开发（借鉴 Istio 整体架构，部分进行了优化），对抗 Istio 压力山大，也期待 Buoyant 公司的毅力。</li>
<li><strong>nginMesh</strong>（<a target="_blank" rel="noopener" href="https://github.com/nginmesh/nginmesh）：2017">https://github.com/nginmesh/nginmesh）：2017</a> 年 9 月首发布，由 Nginx 开发，定位是作为 Istio 的服务代理，也就是替代 Envoy，思路跟 Linkerd 之前和 Istio 集成很相似，极度低调，GitHub 上的 star 也只有不到 100。</li>
<li><strong>Kong</strong>（<a target="_blank" rel="noopener" href="https://github.com/Kong/kong）：比">https://github.com/Kong/kong）：比</a> nginMesh 更加低调，默默发展中</li>
</ul>
<p>关于微服务和服务网格的区别，我的一些理解：<strong>微服务更像是一个服务之间的生态，专注于服务治理等方面，而服务网格更专注于服务之间的通信，以及和 DevOps 更好的结合</strong>。</p>
<p>资料来源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/pattern-service-mesh">模式之服务网格</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iteye.com/news/32932">微服务架构初探</a></li>
<li><a target="_blank" rel="noopener" href="https://jimmysong.io/posts/what-is-a-service-mesh/">什么是 Service Mesh（服务网格）</a>（<strong>很赞，推荐</strong>）</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ur3PmLZ6VjP5L5FatIYYmg">解读2017之Service Mesh：群雄逐鹿烽烟起</a>（<strong>很赞，推荐</strong>）</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-How-to-type-Pinyin-with-Tone"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/04/How-to-type-Pinyin-with-Tone/"
    >How-to-type-Pinyin-with-Tone</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/04/How-to-type-Pinyin-with-Tone/" class="article-date">
  <time datetime="2020-04-04T22:40:01.000Z" itemprop="datePublished">2020-04-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="How-to-type-Pinyin-with-Tone"><a href="#How-to-type-Pinyin-with-Tone" class="headerlink" title="How to type Pinyin with Tone"></a>How to type Pinyin with Tone</h1><h2 id="Add-the-‘ABC-Extended’-Keyboard"><a href="#Add-the-‘ABC-Extended’-Keyboard" class="headerlink" title="Add the ‘ABC Extended’ Keyboard"></a>Add the ‘ABC Extended’ Keyboard</h2><ul>
<li>option a     ā    ē    ī    ō    ū</li>
<li>option e    á    é    í    ó    ú</li>
<li>option v     ǎ    ě    ǐ    ǒ    ǔ</li>
<li>option `       à    è    ì    ò    ù</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/English/" rel="tag">English</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-体能训练方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/04/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E6%96%B9%E6%B3%95/"
    >体能训练方法</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/04/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2020-04-04T16:26:58.000Z" itemprop="datePublished">2020-04-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ul>
<li>早上，五公里，四百米，三个五十，一顿障碍</li>
<li>中午，n次障碍，折返跑，千米冲，三个一百</li>
<li>下午，十公里，n次障碍，种田，三个一百×5</li>
<li>晚上，三公里，三个一百×20</li>
<li>熄灯后，三个一百×70+…</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">prev page</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/14/">next page</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Aaron
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">🏡</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">🏛</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">📚</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">🏷</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>