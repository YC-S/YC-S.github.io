<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E7%97%85%E6%AF%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/18/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E7%97%85%E6%AF%92/" class="post-title-link" itemprop="url">如何看待所谓中国病毒</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-18 13:07:58 / Modified: 14:08:51" itemprop="dateCreated datePublished" datetime="2020-03-18T13:07:58-04:00">2020-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>川皇这不是不合适，是不要脸。</p>
<p>美股三次熔断，按他老人家当年的言论，他是要装进大炮发射到月球上的。三次，地月之间三个来回都够了，人肉阿波罗。</p>
<p><strong>别人说得一点都没错，你莫乱发表言论好吗？多看的专业知识，把工作做好争取早点考个中高级职称，莫管闲事好吗</strong></p>
<p><strong>没上进心，整天混日子迟早会被淘汰的</strong></p>
<p>现在问题来了：人家不要脸，你咋办？</p>
<p>CGTN？</p>
<p>某性感主编在线叼盘？</p>
<p>观察者网国内整几个视频批判一下来波流量？</p>
<p>真特么内卷。</p>
<p>出门干啊！现在一通操作管下来，费拉不堪。忘了我们帝吧当年多么武德充沛么？</p>
<p>推特转发个几万条就全球热搜了，帝吧老哥分分钟能让你被骂上全球热搜，也能分分钟让你主动关闭评论区。</p>
<p>从当年红客留下来的口嗨传统，愣是给自我阉割了。现在川皇一口水洗脸，想起义和团了？</p>
<p>无事关闸，有事开闸？当人狗呢？连央行降准的闸都没整明白，指望你会在舆论的闸上开关自如？</p>
<p>疫情的舆论战争到底算不算人民战争？</p>
<p>川皇今日说中国病毒，明日就是中国造成的损失，后天欧洲一帮右翼党派喜滋滋点赞。</p>
<p>你之前的一切努力，近乎乌有。</p>
<p>b站一堆营销号可以艰难地在油管评论区找几句好听的，然后剪下来糊弄b站小孩，自欺欺人营造一种“我们好受欢迎鸭”的幻觉。</p>
<p>你不能这么干吧？</p>
<p>凭啥代表我们唾面自干？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/%E5%8D%B1%E6%9C%BA%E4%B8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/%E5%8D%B1%E6%9C%BA%E4%B8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%BA/" class="post-title-link" itemprop="url">危机下的四种人</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-17 16:34:18" itemprop="dateCreated datePublished" datetime="2020-03-17T16:34:18-04:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-18 09:17:00" itemprop="dateModified" datetime="2020-03-18T09:17:00-04:00">2020-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天讲一点点政治经济学。原理是重要的，特别是当你被市场经济搞的生活不能自理的时候。</p>
<p>第一个案例是小黄车。小黄车是什么问题呢？现象上的小黄车是一个遍地垃圾的问题，质量上的小黄车是一个刚好满足成本最低又不会骑着骑着就散架的二次函<br>数最大值的初中数学问题，政治经济学的小黄车是一个你在1929年就学会的资本<br>主义的生产过剩问题。</p>
<p>创业不是一个政治经济学概念，创业是一个文学概念，创业用政治经济学的说法叫资本主义再生产。是资本家的钱躺在账户里就相当于亏本，必须拿出来钱滚钱，小黄车只是钱滚钱的工具，而依附于这个工具上的一切美名其曰创业的活动都是对这个原理的修辞。</p>
<p>第二个案例叫做瑞幸咖啡。这个案例的修辞是据说要改变中国人的生活习惯。修辞背后的原理是一样的，我们决定讲一讲这个原理，即资本主义再生产的必然性是什么，即为什么资本家的钱不能躺在账户里。</p>
<p>因为资本主义从诞生开始就是冲着毁灭封建生产关系去的。封建生产关系是一种怎样的生产关系呢？是你知道你的土地是有限的，你知道人口涨到一定程度就必须战争，你知道君子之泽五世而斩，在有了这种稳定的预期之下诞生了一系列以宗教或者礼教为工具的社会生产约束。</p>
<p>然后资本主义来了，资本主义用创新和效率证明过去的约束条件统统不存在，我只要比你更快地生产，消费，投资，再生产，封建关系就会瓦解，你就要找我借钱。在这个游戏里，非但地主阶级抵抗不了这一套，小资产阶级和法西斯同样抵抗不了这一套，我只要比你快就好，冒险只要成功一次，就能覆盖之前的所有损失，这是资本主义出现后，西方资本家发现世界无限大后的本能反应。</p>
<p>当世界不再无限大的时候，就会发生帝国主义和帝国主义战争，如果核武器让帝国主义战争打不起来，帝国主义内部就会发生革命，资本家就会绞死自己，然后新一轮的科技创新，新一轮的速度游戏，历史周而复始。如果核武器让帝国主义战争打不起来，帝国主义内部就会发生革命，最后，革命未必会让你变得更好，说不定会让你变成俄罗斯和乌克兰。</p>
<p>明白了这一点，你才能理解为什么在中国的全要素生产率提升速度突然慢下来的时候，会出现小黄车和瑞幸咖啡这种东西。小黄车和瑞幸咖啡的投资者非但不是愚蠢的，反而是理性的。主要的创投扔出去的并不是自己的钱，但是没有项目投是不行的。自由市场发展到后期不但不会提升社会的生产率，反而会导致社会资源的浪费，因为浪费资本家的钱对职业经理人反而是有好处的，而资本家也必须允许这种浪费，你亲眼目睹了政治书里发生的一切。</p>
<p>那么怎么办呢？</p>
<p>接下来我们开始阅读新闻。</p>
<p>社科院蓝皮书：制造业就业需求萎缩，结构性失业和招工难并存。</p>
<p>这个新闻是什么意思呢？这个新闻是直接指向去年10月各个大企业内部开始压缩就业名额的措施的。具体讲，战略新兴产业人才不够，传统的就业大户现在不需要这么多人。</p>
<p>什么是传统的就业大户所不需要的人呢？我们再看下一个新闻。</p>
<p>京东坚决淘汰三类人。</p>
<p>某茶卸任重庆嫩绿茶艺董事。</p>
<p>显然，当然是互联网引发的服务业扩张所新容纳的就业人口。</p>
<p>这些人为什么要被挤出呢？因为你越要压低成本，你就越要996，你越996，你就越没有时间消费，你越没时间消费，就导致就必须进一步压低成本才能吸引你消费。循环几次你就可以自闭了。</p>
<p>这个现象和主题有什么关系呢？让我们回到政治经济学。</p>
<p>政治经济学明确了，生产过剩就是泡沫，泡沫就是生产危机（达里奥这种反复从经济周期中获益的大佬也直言不讳这一套对百分之八十的美国人毫无用处，因为他发现美国小孩的社会平均福利在不断下降，同样，我们讲过，09年信贷扩张之后中国小孩所享受到福利的质量问题），就在互联网服务业引发了巨大的创业泡沫的时候，工人阶级的先锋队当然是洞察了这一切，那么不好意思，只能以抬高上游企业生产成本的方式直接刺破泡沫，走好不送。</p>
<p>为了进一步巩固这件事的效果，下一步的思路自然是扫黑除恶，打掉高利贷分子的社会基础。至于你问我为什么先锋队为什么要这个时候刺破泡沫，我只能说这是历史的进程。</p>
<p>接下来会怎么样呢？我们回到社科院的报告提到的随着经济结构的调整所必然出<br>现的结构性失业问题。过度扩张的互联网服务业收缩时，最终挤出的人口要怎么<br>办呢？</p>
<p>以美国为例，苏联解体后，美国进一步将制造业转移到海外，国内傻的可爱高呼苏联解体万岁的白人工人阶级被这一套瓦解（搞垮苏东就是为了东欧世界的廉价劳动力啊哥哥，最后你不但当不了工人阶级，你连权贵的仆从都当不好，众所周知，美国人没有东欧人长得细腻），在不存在中产阶级这个阶级之后，他们应该怎么办呢？</p>
<p>最普遍的方式就不提了。有一句话说得好，no country for white men.</p>
<p>稍微好一点的方式是嗑药，滥交，环游世界，散步阴谋论，成立自己的右派网站，并且鼓动自己的粉丝给特朗普投票，宣称美国已经被犹太人篡夺。</p>
<p>进阶一点的方式是参军，改掉坏毛病，一边打工一边考上耶鲁大学法学院，却发现自己完全不知道怎么在有三把叉子和七个瓶瓶罐罐的餐馆吃饭，毕业后看着自己的同学飞黄腾达，一腔悲愤写出一本《乡下人的悲歌》。</p>
<p>高阶一点的方式是完全把自己与同样阶层的人隔绝开来，去图书馆猛看曾国藩传<br>和列宁全集，参加海军，去高盛搞清楚资本主义那一套，然后辞职，创办布莱巴<br>特网站，送特朗普进入白宫，再次辞职去欧洲发动群众，发誓干死索罗斯，深藏<br>功与名。</p>
<p>最后让我们阅读一份文件。</p>
<p>超大特大城市要立足城市功能定位、防止无序蔓延，合理疏解中心城区非核心功能，推动产业和人口向一小时交通圈地区扩散。大城市要提高精细化管理水平，增强要素集聚、高端服务和科技创新能力，发挥规模效应和辐射带动作用。中小城市发展要分类施策，都市圈内和潜力型中小城市要提高产业支撑能力、公共服务品质，促进人口就地就近城镇化；收缩型中小城市要瘦身强体，转变惯性的增量规划思维，严控增量、盘活存量，引导人口和公共资源向城区集中。</p>
<p>什么意思呢？很简单，结束了，回去吧。指望用市场经济去冲破一切，最终无非是一场梦呓。我还是那句话，关心你自己，关心你的过去，关心你身边的人。</p>
<p>我们将在下一期谈一谈如何预防黄马甲的问题。今天的任务就到这里。</p>
<p>现在是吐槽时间。</p>
<p>当生产过剩的时候，企业主采取裁员和关闭工厂的方式来躲避危机，把工厂看作是自己的一己之私，而不是社会大生产中不可或缺的一部分，自大革命开始，企业主就把这种残忍的生活方式当做了面对历史之神露出笑容时的唯一办法，他们总是有一种错觉，觉得自己已经是世界的主人了。这种错觉逼迫着他们种植一些因为假故事而昂贵起来的橙子，再卖给那些连一个工人都雇不起却非要感同身受的好孩子们。</p>
<p>比起这些，我还是更愿意听一听杜金同志的故事，起码他在意识到苏联续不上的时候没有选择背叛灵魂，而只是留起了胡须。但是更多的人毕竟是背叛了灵魂，并且宣称自己这样的背叛是有好处的，是为了国家，自己和父辈们好，希望他们的这种不正确的自我感觉良好能够在海南岛的医疗条件下逐渐康复。</p>
<p>第三个问题，就个人而言，围绕创新我们可以做些什么？我想借此机会对在座每一位毕业生同学谈谈对你们的希望，权当对你们的临行嘱托。</p>
<p>这里，我主要谈六个方面。</p>
<p>第一，养成并保持学习的能力。我在每一次开学典礼上都要谈一个话题：上大学是为了什么？我认为两件事情最为重要：一是掌握学习的能力，二是养成合作的习惯。掌握了学习的能力和拥有合作的习惯，才能事业顺利，缺一不成。</p>
<p>在我看来，学习的能力不是指掌握知识和技能，而是指认知世界、理解世界的能力。我们已经知道“知识越多越反动”这句话是错误的，我还要说培根的“知识就力量”这句话也是有时代局限的。在今天信息爆炸的时代，信息和技能永远在过时的道路上。人的一生只有不断掌握并增强自身的学习能力才能不落后于时代。这也是真正的大学教育的宗旨。</p>
<p>耶鲁大学的前校长理查德.莱文曾经说过一句话：如果一个学生从耶鲁大学毕业之后居然掌握了某种很专业的知识和技能，那是耶鲁教育的失败。学习的能力不仅仅来自阅读，更多的还有走出去看世界、观察世界、思考世界、品味世界，只有这样才能够拥有开阔的视野，体会、了解人类的诸多不同，这会使人更加宽容。宽容是人类最高的智慧之一，它会使人类增进幸福。</p>
<p>第二，独立思考的能力。没有独立思考的个人，不会产生创新性社会。我们都看过电影《阿凡达》，导演卡梅隆70多岁时拍了这部电影，我看后曾说过一句话：这是基于人类的想象达到了人类想象的边界。为什么他可以拍出这部片子？是由于他幼年时代的幻想、对世界的好奇心到了70多岁依然如故，没有被泯灭。</p>
<p>好奇心、想象力在今天的中国，在座各位还剩下多少？我真的不敢恭维。大家从幼儿园走到今天，基本上是做着标准答案走过来的。在毕业典礼上，本应对大家说些鼓励的话，但是我还是想严肃地跟大家说，在各位今后的生活当中，如果没有好奇心和想象力的话，将是人生的悲剧。好奇心和想象力塑造着一个人的偏好和喜好，没有自身喜好的人生或者说有自己的喜好却被父母和其他人强行改变的人生是非常恐怖的。这样的人多了，这样的人组成的社会也一定是恐怖的。所以，学习能力加上独立思考，是形成创新性社会的基本条件。</p>
<p>第三，自主选择的能力。经济学是一门研究资源稀缺条件下行为主体如何选择的学问。在计划经济条件下，我们基本上是不需要选择的。我上小学、中学的时候，感到自己没有什么选择，因为组织上已经替我选好了，不是上山下乡，就是到工厂接班。其实那时也没有什么痛苦，想起来很快乐。</p>
<p>今天，同学们的选择非常多。早晨起来你会选择是到A食堂还是B食堂或C食堂吃早餐，要选择上李老师的课、赵老师的课还是张老师的课。选择是有成本的，起码有机会成本，但不论怎样，市场经济条件下自主选择的成本再多也是必要的，市场经济就是由无数的选择组成的。</p>
<p>今天，在应试教育体制下大家还有多少自主选择能力？近几年经常遇到大学同学、朋友打来电话，说我孩子或者亲属今年要高考了，请你跟我说说哪个专业更好？我问他们孩子自己喜欢什么？经常的回答是“不知道”。在座的各位家长，你们可能更清楚是不是这样。这是很悲哀的一件事情。在我上课提问时，很多同学不敢正视我的眼睛，目光所到之处他们基本上都是放下眼帘，好像他不看我我就看不到他一样。没有问题意识，提不出问题，也自然缺乏自主选择能力，这是个恶性循环。具有学习能力的人，能够独立思考的人，也一定是拥有自主选择能力的人，自然是创新能力很强的人。</p>
<p>谈及自主选择能力，我想谈一点个人体会。现在大家都已基本上选择好了职业，未来还可能有许多新的选择，今天谈这些体会还不晚，也许对你们有参考。经济学强调发挥比较优势，但在做出人生选择的时候，应该注重自己的比较劣势。就是说，你要知道自己的缺点和不足。什么是理性？理性就是知道自己是无知的，或者说知道自己的不足。当你深入了解这些之后，比如在选择职业的时候，就要尽力回避因自身缺陷或不足难以胜任的领域。</p>
<p>这样做，不仅避开了自己的不足，实际上也是选择了你的比较优势，而且会使自己更加快乐、宽容。你不会见到某同学去金融机构做的很好，便产生凭啥我不能去金融机构、大学时我金融学成绩比他好之类的不正常心态。冷静地了解自己的比较劣势会让你有一个健康心态，你会认为那个同学成功是因为他确实很优秀，而在他很优秀的那个方面，我却是不足的。所以，了解自己的不足却不回避，一味地同他人比较，盲目跟风，无异于人生的铤而走险。</p>
<p>第四，审美能力。如果展开一幅世界经济地图，你会发现每个国家都有自己的比较优势，如美国出口的是金融服务，日本出口的是制造业技术，中国人出口的是劳动力，欧洲人出口的是古老的贵族文明积淀下来的审美，几乎所有的奢侈品都来自欧洲。</p>
<p>审美是一种历史积淀，前提是一个国家历史、文化的连续性。这个话题其实是很沉重的，在此我只想谈谈自己的体会。对个人而言，审美是一种品质和修养。一个审美能力低下的民族不仅素养、品格不高，道德水准也会有问题。迄今为止，大家的审美能力基本上都是从父母那里熏陶出来的，问题是在座的各位父母都是“文革”后的一代，这在很大程度上是问题所在。</p>
<p>我非常高兴地看到，在今天的毕业典礼上，大家都穿着皮鞋，穿着带领子的正装，我跟赵勇书记提出过毕业典礼上同学们的着装要求。为什么？看看我们的校园里，许多男同学穿着一条大短裤，露着带毛的双腿，穿一双拖鞋，身披庄严的毕业礼服满校园逛。你们觉得美吗？</p>
<p>今天，走在世界上任何地方，判断一个人是否是中国人的标准，基本上就是服饰与行为。针对个体，主要看服饰，相对于其他亚洲人，中国人的服装搭配比如衣裤、鞋帽、鞋袜等的搭配基本是不合体的，远远一看便知道是中国人，在亚洲人里韩国人喜欢穿着鲜艳，穿的素雅且搭配合理的多半是日本人。如果是团体，看到一个人在说，几乎所有人在听是日本人；一个人在讲，一半人在听，一半人乱乱哄哄的是韩国人；一个人在说，少数人在听，多数人各干各的，大多是中国人。</p>
<p>审美是一种尊严意识，是一种自我尊重也是对别人的尊重。在庄重的场合，一个没有仪式感的人、着装随意的人既是对自己的贬低，也是对他人的极大不敬。在更大意义上讲，审美可以让人知晓世界上的美好与丑恶，它告诉每一个人，人类的行为应当是有底线的，知道有些事情是绝对不可以去碰的、不可以去做的，而不是为达目的不择手段。这样，我们社会的道德水准才会有所提升。</p>
<p>第五，战胜困难的能力。人生中困难是常态，幸福是短暂的，海明威说“勇气就是优雅地面对压力”，人的一生中能成为优雅的人太难了，这也是我自己经常苦恼的问题。有时候，我跟同事说话时会忘乎所以，事后会反思自己的不优雅。但是优雅地面对压力真的是很难的一件事情，一个人在压力面前如果能做到优雅的话，这本身就说明你真的能够把困境作为常态。这一点对大家未来的人生、工作非常重要，会增进你的幸福感。</p>
<p>最后一点，要做一个具有使命感的人。我不想在这里空谈使命感，不要把它看作离我们很遥远的神圣之物。一个人做好自己每一个人生阶段中应该做好的事情，把自己喜欢做的事情尽可能地做到极致甚至像清教徒那样对待自己喜欢的职业并愿意为此努力一生，你就是一个具有使命感的人。所谓工匠精神，本质上与这种对职业的敬畏和使命感的理解与坚守密不可分。工匠精神与功利主义无缘。</p>
<p>在此我还想强调的是，今天的中国已经不是国土沦丧、家破人亡的民族危亡状态，而是处在快速崛起的进程当中，过去的“为中华崛起而读书”不应当是现在大家读书、学习的目标。</p>
<p>今天的中国面对着前所未有的经济全球化的大环境、面对着如何成为创新性国家的重任，只有我们每一个人、在座的每一位毕业生同学成为真正的人，即成为具有学习能力、独立思考能力、自主选择能力、审美能力、战胜困难能力和有使命感的人，你自己的一生才会幸福，我们这个社会才能不断进步，中华民族才真的有希望。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/16/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%8B%B1%E5%9B%BD%E7%9A%84%E7%96%AB%E6%83%85%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%8B%B1%E5%9B%BD%E7%9A%84%E7%96%AB%E6%83%85%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">如何看待英国的疫情操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 23:09:58" itemprop="dateCreated datePublished" datetime="2020-03-16T23:09:58-04:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-17 00:10:47" itemprop="dateModified" datetime="2020-03-17T00:10:47-04:00">2020-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天也在油管上看了Channel 4的这档新闻，印象最深的就是那哥们在强调herd immunity时，另外一个主张强力介入的嘉宾的表情。</p>
<p>当时我狂笑了快一分钟。</p>
<p>不过，我对腹黑的英国人充满不信任。美国和英国在阴谋诡计上对比，美国就是个弟弟。所以我有个不成熟的猜想：</p>
<p>英国同样想实施强力介入的措施，快一千例了，意大利啥样子都看到了。</p>
<p>打了两次世界大战又不是不懂什么叫战时体制，加上NHS又是英国特色社会主义的经典体现，有经验有工具干嘛不搞？</p>
<p>一是钱算谁的，二是要做的好看。</p>
<p>小特朗普鲍里斯为了上位，除了脱欧之外，还大力支持增加NHS的预算。所以他胜选后宣布的第一优先都不是脱欧，而是搞定NHS的预算。</p>
<p>这6600万人真是能花，我国基本医保总支出18年也就18000亿人民币。</p>
<p>强力介入必然要花大钱，这是当务之急。</p>
<p>所以怎么把花钱的事做的好听？</p>
<p>你传染一发生就大张旗鼓严格介入，直接的防疫费用不用说；伦敦以金融业旅游业交通业地产业为主，哪个行业不是严重依赖人的流动？这因防疫所导致的经济停转成本就吓死人。</p>
<p>老老实实按照WHO那套去隔离去封锁，控制不住鲍里斯死定了；就算控制住了，经济停转的亏空也足以让万年陪跑科尔宾在议院里轰上一年。</p>
<p>加上今年经济形势明显下滑，已经进入准危机状态，怕是防疫成功经济也没救。鲍里斯一直主张脱欧有助于经济，稍有不慎，疫情+经济下滑，普通民众和留欧派肯定会让科尔宾刷新战绩。</p>
<p>不行，肯定不行。</p>
<p>其次，英国一直暗搓搓地阻挠欧洲和中国的联手。英国自明确脱欧后，一直的战略思路是反对欧洲与中国直接走近，并引导中国选择英国，作为中国在欧洲整个大洲的利益支点。</p>
<p>这样，脱欧后的英国就能在传统英美关系下又获得与中国的特殊关系，反向加强自身在五眼联盟中的地位，平衡美帝独大的压力。</p>
<p>所以说老阴比嘛。</p>
<p>因此英国在对中国宣传上一直在夹私货，尝试用自己的影响力来缓阻欧洲的转向速度。这次疫情我们有好的一面，但烂的那面也不少，自然成为英国宣传战略里的绝佳素材。</p>
<p>现在开嘲讽开了快两个月，中国之前的一切被喷的手段突然要用到自己身上，不找个好点的借口，不仅英国民众要闹，欧洲回头也要炸锅。</p>
<p>所以要换过来，让民众觉得是他们自己要花钱。</p>
<p>怎么让民众心甘情愿掏钱？恐吓他们。</p>
<p>“中国那套玩法我们是搞不了的，体制不同，我们无法支付那样的成本，民众也不会同意”；</p>
<p>“出行自由我们是尊重的，税金的使用我们要严格根据法律规定来办，这是我国的价值观”；</p>
<p>“因此我们根据国民和国情，总结出一套资源内可行的方案，你们资辞不资辞呀”。</p>
<p>民众一看昏古去，醒过来骂声震天。</p>
<p>然后下周下议院一上班，科尔宾必然要开火：</p>
<p>听说你们要herd immunity，你们是不是打算置普通英国民众，特别是the old and the weak的生死于不顾！</p>
<p>表情一定要义正言辞。</p>
<p>鲍里斯一捋金发，怒目圆睁：</p>
<p>谁说的？没看到NHS和政府正在全力为英国人民对抗疫情吗？政府何时说要放弃民众？你你你你们工党不要听风是雨，天真简单！</p>
<p>然后抽一出一个本本：</p>
<p>我们现在正在竭尽全力，但是困难时刻需要我们英国人民的支持，这是临时增加的预算大家康康。</p>
<p>估计还会念几句丘吉尔。</p>
<p>科尔宾和鲍里斯几个来回互表对英国人民的忠心，夹杂在对英国人民坚韧性格的回顾和赞美声中，要多花钱这句话就过去了。然后是大英上下一心，共抗疫情，医护辛苦，巴拉巴拉。</p>
<p>这样就很漂亮。</p>
<p>第一，不是我们主动花钱抗疫、亏钱防疫，是应民众之呼唤，朝野之悲声，是救水火解倒悬的大义。</p>
<p>第二，万一钱花了效果还不行，你们骂中国去，丫的过度防疫引起恐慌欺骗他国混乱WHO，BBC出来干活啦。</p>
<p>你看，这样虽然英国本质上和美帝一样漠视疫情滞后反应，但是鲍里斯哪要像特朗普一样承担CNN7x24小时的反攻倒算？</p>
<p>疫情成为特朗普本来毫无悬念胜选的最大黑马事件，但操作得当，却会成为我鲍里斯继脱欧后的又一大功。脱欧与NHS，押宝全中，鲍中堂可列大英名相之位咯。</p>
<p>所以说美国人啊，真的是最年轻的帝国主义，太实诚。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%E5%8D%B1%E6%9C%BA%E9%83%BD%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%A7%E5%9F%BA%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%E5%8D%B1%E6%9C%BA%E9%83%BD%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%A7%E5%9F%BA%E5%BB%BA/" class="post-title-link" itemprop="url">为什么出现危机都要启动大基建</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 12:54:48 / Modified: 13:55:45" itemprop="dateCreated datePublished" datetime="2020-03-15T12:54:48-04:00">2020-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.本质上来说，凯恩斯主义的核心，就是通过财政扩张来解决经济周期问题，搞基建只是最常见的一种。但这里要提醒一下，旧凯恩斯主义已经失败被淘汰了（这里不展开了，有兴趣的人去看看当年的滞涨时期出现后，旧凯恩斯主义是如何因为无法解释这一原因导致整个学派崩溃的，至于几个高票答案，显然不知道这段历史）。</p>
<p>2.中国现在搞基建，边际收益还勉强是正的。对于其他发达国家来说，因为基建已经较为完备，再搞基建边际收益可能就是负数了。过一段时间以后中国也会是如此。这一轮之所以强调新基建，因为公路铁路这些旧基建的边际收益很可能已经是负数了。旧基建从业人员前景堪忧，以后可能只能去非洲中亚找饭吃（曹学上线）。</p>
<p>1，2是宏观经济学里最基本的常识。</p>
<p>说不好听一点，满嘴基建狂魔的人，见识档次欠佳。基建狂魔其实是发达国家上世纪和上上世纪玩剩下的。现在发达国家要是继续搞下去，只能和日本政府一样债台高筑了。</p>
<p>现在搞基建＝扶贫，以工代赈，顺便洗钱。这事你我知道就好，说出来很多人接受不了。</p>
<p>老板吃肉，下面才有汤</p>
<p>从《美国货币史》来看，新政的效果其实没有那么好。当时经济危机发生的原因也和中学教材说的完全不一样。彼时没有存款保险法，银行倒闭储户存款也会完蛋。所以危机出现后很快出现了遍及全美的银行挤兑。银行体系处于半瘫痪状态，这个过程里基础货币从银行体系搬家到了家庭床底下。引发了严重的通缩和危机。</p>
<p>本币债务能通过通胀消化，魏玛德国、德三帝国时期主要有大量的外币债务（一战失败的战争赔款），货币政策受到掣肘（蒙代尔不可能三角）。最终大概率铤而走险对外扩张，吞并法国直接消灭了对法外债。</p>
<p>我看网上有一个大佬写的。为什么相同的方法，瘸子被后世吹捧，元首被人唾骂。因为元首先憋不住了，决定改卖货为抢货。为什么呢？第一市场销售环境不同，美国在美洲基本没有竞争对手，产品销路稳定，在东亚，日本在上升期，消费胃口大，肯烧钱搞海军陆军，美国钢铁的销售行情一路看涨，德国不一样，它主要做中欧和巴尔干市场，这里都是小国，消费能力本就有限，而且面临法国的竞争，例如德国卖一批军火给保加利亚，小协约国，捷罗南之类马上会像巴黎下单。第二农业危机，纳粹本质是小农小业主的代表，既不像苏俄一样可以搞集体农奴制，也不像美国一样幅员辽阔，有搞农庄的基础，小农的底子不能触动，又要供应大工业城镇的市场需求，怎么办？于是西进是为了工商业者和英法争夺欧洲大陆的市场，东进是为了小农们的土地需求。</p>
<p>我的观点从来就没有变化：一切力量都可以为国家利益服务，从金融到军事。</p>
<p>这不是说有些人天生就爱杀人爱流血爱尸骸成堆，这是在阐述一个系统，一种万有引力：它的目的不受个人的意志而转移。</p>
<p>金融对美帝的重要性不用说了吧？外号就叫金融帝国主义，高度发达的虚拟经济，使得国民和政府的大量利益——从养老金到五角大楼——都由华尔街来交易、变现、流通。</p>
<p>不夸张地说，美帝这个国家已经证券化了。</p>
<p>所以千万不要用国内看A股洗脚婢的心态来看美股。A股从属于我朝，美帝从属于华尔街。不是华尔街的人真的吊到天天对总统耳提面命（其实是有的，例如高盛提携里根的那位），而是华尔街象征着一种系统，系统的意志高于它的零部件。</p>
<p>所以，当美帝的虚拟经济遭到承重压力，政府、国民、资本方的利益都被捆绑时，他们必然会寻找解决方案。不需要什么阴谋，不用像电影里奏起诡谲的BGM，他们会自发诞生答案，如同蜂群。</p>
<p>因此，思考的重点不在于美帝想做什么，而是他还能做什么。</p>
<p>虚拟经济收益畸高，必然会在一个拐点上开始回归实体经济。这个回归多数就是泡沫要炸了。</p>
<p>泡沫要炸了无外乎三种：</p>
<p>一是任你炸，躺平任艹。日本广场协议那波非常类似，但更经典的就是2933大危机。</p>
<p>任你炸的后果现在大家都知道了。恐慌无限放大人的非理性部分，市场严重震荡，资产价格跳崖，全行业现金流奔崩裂，国家直接动乱。</p>
<p>现在不是非洲那种捞一把就去迪拜巴黎养老的军阀，没有政府会在还有的选的时候来这个。</p>
<p>二是冻住不许走，时停系列。典型的就是我朝在几次房价要飙时的操作。</p>
<p>冻住不许走需要你有一套备用系统，可以在冻结泡沫的同时保证国家系统的基础运营。我们从来都是双轨制，所以但凡某个领域泡沫要炸，就用文件把泡沫冻住：</p>
<p>北上广深泡沫要炸，冻住之后成都武汉开始抢人了；成都武汉房价要炸，冻住之后还有高铁经济带；万一高铁经济带的房价也过了，还有鹤岗呢。</p>
<p>鹤岗的房子是谁建的？城投城建；城投城建是谁？是国开行。这就是两套系统。</p>
<p>冻住不许走除了我们，还有一个国家也很溜，就是大家平日口嗨的印度。（想不到吧.jpg）</p>
<p>印度还有一大批半封建半现代的小农自治体，这是印度每次在貌似要总崩盘的时候都能奇妙苟过来的重要底牌。不愧是把社会主义写入宪法的国家。</p>
<p>三是改变气压。</p>
<p>是不是突然以为在上物理课？</p>
<p>泡沫为什么炸？因为你吹了太多气在泡沫里，内部压力高于外部，就炸了。</p>
<p>那我要是把外部压力搞得比我内部压力还大，那泡沫不就不炸了嘛！</p>
<p>恭喜你，格林斯潘今晚请你吃饭！</p>
<p>美国所掌握的实体经济基本上只有军工复合体、能源、农业和航天芯片高尖精工业。而这些加一块都不足以满足虚拟经济的收益要求，美帝的虚拟收益和实体收益之间存在巨大落差。</p>
<p>资本一旦发现虚拟经济无法兑现许诺的畸高收益，就会重回有较稳定收益的实体；本国没有实体来承载，资本就必然外逃。</p>
<p>这个回归的过程犹如自由落体（巧了，今天推特上最多的词就是free fall）。那怎么阻止free fall？</p>
<p>美帝已经掌握了全球的铸币权，全球资源的总定价权在他手里，他牢牢占据虚拟经济的高地。</p>
<p>那剩下来要做的，就是确保全球范围内，没有比他更优的实体经济，没有只进不出的貔貅。</p>
<p>因为历史上就有一只貔貅，给他造成大麻烦。</p>
<p>大萧条时，美帝这边资产跳水、工人和技术人员失业，那边苏联咬着牙用集体农庄饿死乌克兰人的外汇疯狂买美帝的设备和人，实现工业化猪突猛进。</p>
<p>这导致了美帝当时居然出现了一定程度的去工业化，而苏联留下了一票美国人移民后裔。</p>
<p>这就是貔貅。苏联的体制决定了美帝在低价位时出售的东西，没法做个更低价让苏联吐出来。而技术、工业设备、研发人才的流失，是真正的失血，特别是当你没有掌握铸币权的时候。</p>
<p>万幸的是二战把欧洲打烂了，最后苏联解体时也把当年得到的加了百倍利息吐回来。从此，美帝就再也没有真正纠结过金融危机。</p>
<p>99年欧元正式发行，我就去揍一顿南联盟，给你出生庆礼；没想到你还整挺好，03年再打一顿伊拉克。</p>
<p>不是法德俄欧洲三大国一致反对吗？不是说中东是你们的利益范围吗？照打。资本需要暴力来保证交易的顺利执行，美帝能展现暴力的可靠，资本就会稳定在美帝一方。</p>
<p>“哎哎哎王蜀黍，为什么美帝不能让自己的实体经济变得更好，用竞争超过其他人呢？”</p>
<p>傻孩子，有美军在手，打就完事了。老老实实开工厂做研发做优化多累啊。没事，等你将来大学读自动化，出来就业就理解了。</p>
<p>我朝现在最尴尬的地方，就是我们是貔貅。</p>
<p>我们的实体收益高吗？</p>
<p>不算高，但比美帝高。而且本身的内需市场和产品所覆盖的全球市场加总，还是挺高的；</p>
<p>我们的资本可以随意流动吗？</p>
<p>不能，一般进来了就出不去，换个美元要凑几十个人的身份证，反洗钱中心都快把留学生逼疯了；</p>
<p>我们的暴力可靠吗？</p>
<p>跟美帝打遍全球不能比，但是家门口这一圈，还是能保证有来无回的。</p>
<p>那你不就是貔貅嘛。</p>
<p>一个有独立经济权力和武力保证的制造国，就是天然貔貅。</p>
<p>制造国、金融国、资源国三者里，制造国最容易维系工业体系的运转，因为金融国和资源国都需要制造国的产品；</p>
<p>制造国也能较好保证科技的迭代，因为制造会产生大量现实的市场需求，并为科研提供基础的成本；</p>
<p>一个制造国一旦拥有独立的经济权力，可以把握自己的货币政策和金融监管。那在工业社会里，他就是一个半闭环。</p>
<p>弱的如越南，强的如德国，都是这种半闭环，能成为区域内的稳态社会，并逐步吸纳区域内的资源。引进原材料，加工制造，同时形成基础研发乃至高端研发能力，保留利润，卖出去。</p>
<p>如果这种技术能力最后出现代差，资源国和金融国看制造国就跟看黑盒子一样。</p>
<p>所以占据优位的金融国，必须时不时打破这种半闭环，夺走利润，保证制造国长期处于技术下游。</p>
<p>金融收割是常态，必要时武力打击也可以。而且不需要直接打击，太难看了。破坏制造国的市场，让他资金无法回来就行，例如老欧洲的中东，例如俄罗斯最后的境外工业品市场乌克兰。</p>
<p>把多数国家锁在资源国身份，少数锁在低端制造业，金融和高端制造牢牢握在自己手里，进而形成科技与军事的代差优势，这是金融国最美的梦。</p>
<p>但是有只貔貅出现了。</p>
<p>按照美帝正常的剧本，我们在改开之初，就应该一直老老实实做玩具衣服；等到美帝做了新能源汽车，我们再去做小摩托；等到美帝做了火星飞船，我们再去做飞机。</p>
<p>但是庞大的人口、完备的工业门类、高素质廉价劳动力、公费高等教育（对，就是公费）、政府产业规划、独立主权，等等等等因素汇总，使得我们没有按照既定剧本走下去。</p>
<p>一边是低端产业逐渐爬升中端，玩具变机电；一边是科研投入与留学形成的中高端雏形；再加上严格的资本政策。</p>
<p>你慢慢变得更好，收益率逐步提高，同时能突然打断你收益率的手段在快速减少。</p>
<p>一个稳定的不可控的高收益地区对美帝，这个金融帝国主义，意味着什么？</p>
<p>血在外流，经脉逆行。</p>
<p>人有意识形态，资本没有。斯大林管理的卢布和胡佛管理的美元，虽然限定在不同的意识形态里，但是卢布和美元一样，需要实际价值做支撑，需要交换，需要收益和增殖。</p>
<p>如果美元没有收益而人民币有，那美元也会变成人民币。</p>
<p>这是美帝绝不允许的。</p>
<p>所以从崩溃论、威胁论、共治论、敌国论，各路帽子如大雪纷飞，应接不暇。手段也从常规的贸易战上升到科技战，并且开始在尝试进一步越界。</p>
<p>然后突然，美帝的金融，好像有点崩。</p>
<p>预示着什么？</p>
<p>不知道。</p>
<p>我只知道虚拟收益总是要向实体收益回归，小冰河期总是要来，等降水线总是要南移。</p>
<p>要么进了长城种田，要么长城内变成草原。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/React%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/React%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">React总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-14 14:38:17 / Modified: 16:10:53" itemprop="dateCreated datePublished" datetime="2020-03-14T14:38:17-04:00">2020-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、什么是react"><a href="#1、什么是react" class="headerlink" title="1、什么是react"></a>1、什么是react</h2><p>React.js 是一个帮助你构建页面 UI 的库。<br> React.js 将帮助我们将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，就成了我们的页面。<br> <strong>React.js 中一切皆组件，用 React.js 写的其实就是 React.js 组件。</strong><br> React.js 不是一个框架，它只是一个库。它只提供 UI （view）层面的解决方案。在实际的项目当中，它并不能解决我们所有的问题，需要结合其它的库，例如 Redux、React-router 等来协助提供完整的解决方法。</p>
<h2 id="2、理解JSX"><a href="#2、理解JSX" class="headerlink" title="2、理解JSX"></a>2、理解JSX</h2><p>React.js 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构。<br> <strong>所谓的 JSX 其实就是 JavaScript 对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     React.createElement(</span><br><span class="line">        <span class="string">"div"</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        React.createElement(</span><br><span class="line">          <span class="string">"h1"</span>,</span><br><span class="line">          &#123; <span class="attr">className</span>: <span class="string">'title'</span> &#125;,</span><br><span class="line">          <span class="string">"React 小书"</span></span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="../images/image-20200314143949254.png" alt="image-20200314143949254" style="zoom:200%;" />

<p>有些同学可能会问，为什么不直接从 JSX 直接渲染构造 DOM 结构，而是要经过中间这么一层呢？</p>
<p>第一个原因是，当我们拿到一个表示 UI 的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能把这个结构渲染到 canvas 上，或者是手机 App 上。所以这也是为什么会要把 react-dom 单独抽离出来的原因，可以想象有一个叫 react-canvas 可以帮我们把 UI 渲染到 canvas 上，或者是有一个叫 react-app 可以帮我们把它转换成原生的 App（实际上这玩意叫 ReactNative）。</p>
<p>第二个原因是，有了这样一个对象。当数据变化，需要更新组件的时候，就可以用比较快的算法操作这个 JavaScript 对象，而不用直接操作页面上的 DOM，这样可以尽量少的减少浏览器重排，极大地优化性能。这个在以后的章节中我们会提到。</p>
<p><strong>总结</strong></p>
<p>要记住几个点：</p>
<ul>
<li>JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML。</li>
<li>React.js 可以用 JSX 来描述你的组件长什么样的。</li>
<li>JSX 在编译的时候会变成相应的 JavaScript 对象描述。</li>
<li>react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上。</li>
</ul>
<h2 id="3、组件的组合、嵌套和组件树"><a href="#3、组件的组合、嵌套和组件树" class="headerlink" title="3、组件的组合、嵌套和组件树"></a>3、组件的组合、嵌套和组件树</h2><p>组件可以和组件组合在一起，组件内部可以使用别的组件。就像普通的 HTML 标签一样使用就可以。这样的组合嵌套，最后构成一个所谓的组件树，就正如上面的例子那样，Index 用了 Header、Main、Footer，Header 又使用了 Title 。这样用这样的树状结构表示它们之间的关系：</p>
<p><img src="../images/image-20200314144040294.png" alt="image-20200314144040294"></p>
<p>当页面结构复杂起来，有许多不同的组件嵌套组合的话，组件树会相当的复杂和庞大。<strong>理解组件树的概念对后面理解数据是如何在组件树内自上往下流动过程很重要。</strong></p>
<h2 id="4、事件监听"><a href="#4、事件监听" class="headerlink" title="4、事件监听"></a>4、事件监听</h2><p><strong>关于事件中的 this</strong><br> 一般在某个类的实例方法里面的 this 指的是这个实例本身。<br> 但是 React.js 调用你所传给它的方法的时候，并不是通过对象方法的方式调用（this.handleClickOnTitle），而是直接通过函数调用 （handleClickOnTitle），<strong>所以事件监听函数内并不能通过 this 获取到实例。</strong><br> 如果你想在事件函数当中使用当前的实例，你需要手动地将实例方法 bind 到当前实例上再传入给 React.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClickOnTitle (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1 onClick=&#123;<span class="keyword">this</span>.handleClickOnTitle.bind(<span class="keyword">this</span>)&#125;&gt;React 小书&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>为 React 的组件添加事件监听是很简单的事情，你只需要使用 React.js 提供了一系列的 on* 方法即可。</li>
<li>React.js 会给每个事件监听传入一个 event 对象，这个对象提供的功能和浏览器提供的功能一致，而且它是兼容所有浏览器的。</li>
<li>React.js 的事件监听方法需要手动 bind 到当前实例，这种模式在 React.js 中非常常用。</li>
</ul>
<h2 id="5、组件的-state-和-setState"><a href="#5、组件的-state-和-setState" class="headerlink" title="5、组件的 state 和 setState"></a>5、组件的 state 和 setState</h2><p>setState 接受函数参数:<br> 这里还有要注意的是，当你调用 setState 的时候，<strong>React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。</strong>这一点要好好注意。可以体会一下下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.isLiked)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    isLiked: !<span class="keyword">this</span>.state.isLiked</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.isLiked)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现两次打印的都是 false，即使我们中间已经 setState 过一次了。这并不是什么 bug，只是 React.js 的 setState 把你的传进来的状态缓存起来，稍后才会帮你更新到 state 上，所以你获取到的还是原来的 isLiked。</p>
<p>所以如果你想在 setState 之后使用新的 state 来做后续运算就做不到了，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) <span class="comment">// =&gt; this.state.count 还是 undefined</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;) <span class="comment">// =&gt; undefined + 1 = NaN</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">2</span>&#125;) <span class="comment">// =&gt; NaN + 2 = NaN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码的运行结果并不能达到我们的预期，我们希望 count 运行结果是 3 ，可是最后得到的是 NaN。但是这种后续操作依赖前一个 setState 的结果的情况并不罕见。</p>
<p>这里就自然地引出了<strong>setState 的第二种使用方式:可以接受一个函数作为参数</strong>，。React.js 会把上一个 setState 的结果传入这个函数，你就可以使用该结果进行运算、操作，然后返回一个对象作为更新 state 的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: prevState.count + <span class="number">1</span> &#125; <span class="comment">// 上一个 setState 的返回是 count 为 0，当前返回 1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: prevState.count + <span class="number">2</span> &#125; <span class="comment">// 上一个 setState 的返回是 count 为 1，当前返回 3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后的结果是 this.state.count 为 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以达到上述的利用上一次 setState 结果进行运算的效果。</p>
<hr>
<p><strong>setState 合并</strong><br> 上面我们进行了三次 setState，但是实际上组件只会重新渲染一次，而不是三次；这是因为在 React.js 内部会把 JavaScript 事件循环中的消息队列的同一个消息中的 setState 都进行合并以后再重新渲染组件。</p>
<p>深层的原理并不需要过多纠结，你只需要记住的是：在使用 React.js 的时候，并不需要担心多次进行 setState 会带来性能问题。</p>
<h2 id="6、配置组件的-props"><a href="#6、配置组件的-props" class="headerlink" title="6、配置组件的 props"></a>6、配置组件的 props</h2><p>在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为 props 对象的键值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClickOnLikeButton () &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> wordings = <span class="keyword">this</span>.props.wordings || &#123; <span class="comment">//获取props</span></span><br><span class="line">      likedText: <span class="string">'取消'</span>,</span><br><span class="line">      unlikedText: <span class="string">'点赞'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClickOnLikeButton.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isLiked ? wordings.likedText : wordings.unlikedText&#125; 👍</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">---------</span></span><br><span class="line"><span class="regexp">class Index extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;LikeButton likedText='已赞' unlikedText='赞' /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>props 不可变</strong><br>props 一旦传入进来就不能改变。修改上面的例子中的 handleClickOnLikeButton:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.likedText = <span class="string">'取消'</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    isLiked: !<span class="keyword">this</span>.state.isLiked</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们尝试在用户点击按钮的时候改变 <code>this.props.likedText</code> ，然后你会看到控制台报错了。<br> <strong>你不能改变一个组件被渲染的时候传进来的 props</strong>。React.js 希望一个组件在输入确定的 props 的时候，能够输出确定的 UI 显示形态。<strong>如果 props 渲染过程中可以被修改，那么就会导致这个组件显示形态和行为变得不可预测，这样会可能会给组件使用者带来困惑。</strong></p>
<p>但这并不意味着由 props 决定的显示形态不能被修改。<strong>组件的使用者可以主动地通过重新渲染的方式把新的 props 传入组件当中</strong>，这样这个组件中由 props 决定的显示形态也会得到相应的改变。</p>
<hr>
<p><strong>总结</strong></p>
<ul>
<li>为了使得组件的可定制性更强，在使用组件的时候，可以在标签上加属性来传入配置参数。</li>
<li>组件可以在内部通过 this.props 获取到配置参数，组件可以根据 props 的不同来确定自己的显示形态，达到可配置的效果。</li>
<li>可以通过给组件添加类属性 defaultProps 来配置默认参数。<br> props 一旦传入，你就不可以在组件内部对它进行修改。但是你可以通过父组件主动重新渲染的方式来传入新的 props，从而达到更新的效果。</li>
</ul>
<h2 id="7、state-vs-props"><a href="#7、state-vs-props" class="headerlink" title="7、state vs props"></a>7、state vs props</h2><p>我们来一个关于 state 和 props 的总结。</p>
<p><strong>state</strong>:主要作用是用于组件保存、控制、修改<strong>自己</strong>的可变状态。state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。state 中状态可以通过 this.setState 方法进行更新，setState 会导致组件的重新渲染。</p>
<p><strong>props</strong>: 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props，否则组件的 props 永远保持不变。</p>
<p>state 和 props 有着千丝万缕的关系。它们都可以决定组件的行为和显示形态。一个组件的 state 中的数据可以通过 props 传给子组件，一个组件可以使用外部传入的 props 来初始化自己的 state。但是它们的职责其实非常明晰分明：<strong>state 是让组件控制自己的状态，props 是让外部对组件自己进行配置。</strong></p>
<p><strong>如果你觉得还是搞不清 state 和 props 的使用场景，那么请记住一个简单的规则：尽量少地用 state，尽量多地用 props。</strong></p>
<p><strong>没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）</strong>。</p>
<blockquote>
<p>因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。前端应用状态管理是一个复杂的问题，我们后续会继续讨论。</p>
</blockquote>
<p>React.js 非常鼓励无状态组件，在 0.14 版本引入了函数式组件——一种定义不能使用 state 组件，例如一个原来这样写的组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi () &#123;</span><br><span class="line">    alert(<span class="string">'Hello World'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.sayHi.bind(<span class="keyword">this</span>)&#125;&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>用函数式组件的编写方式就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HelloWorld = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sayHi = <span class="function">(<span class="params">event</span>) =&gt;</span> alert(<span class="string">'Hello World'</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onClick=&#123;sayHi&#125;&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以前一个组件是通过继承 Component 来构建，一个子类就是一个组件。而用函数式的组件编写方式是一个函数就是一个组件，你可以和以前一样通过 <HellWorld /> 使用该组件。不同的是，函数式组件只能接受 props 而无法像跟类组件一样可以在 constructor 里面初始化 state。你可以理解函数式组件就是一种只能接受 props 和提供 render 方法的类组件。</p>
<h2 id="8、渲染列表数据"><a href="#8、渲染列表数据" class="headerlink" title="8、渲染列表数据"></a>8、渲染列表数据</h2><p>列表数据在前端非常常见，我们经常要处理这种类型的数据，例如文章列表、评论列表、用户列表…一个前端工程师几乎每天都需要跟列表数据打交道。</p>
<p>React.js 当然也允许我们处理列表数据，但在使用 React.js 处理列表数据的时候，需要掌握一些规则。我们这一节会专门讨论这方面的知识。</p>
<h3 id="渲染存放-JSX-元素的数组"><a href="#渲染存放-JSX-元素的数组" class="headerlink" title="渲染存放 JSX 元素的数组"></a>渲染存放 JSX 元素的数组</h3><p>假设现在我们有这么一个用户列表数据，存放在一个数组当中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Jerry'</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Tomy'</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lily'</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lucy'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果现在要把这个数组里面的数据渲染页面上要怎么做？开始之前要补充一个知识。之前说过 JSX 的表达式插入 <code>{}</code> 里面可以放任何数据，如果我们往 <code>{}</code> 里面放一个存放 JSX 元素的数组会怎么样？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;[</span><br><span class="line">          &lt;span&gt;React.js &lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">          &lt;span&gt;is &lt;/</span>span&gt;,</span><br><span class="line">          &lt;span&gt;good&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        ]&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们往 JSX 里面塞了一个数组，这个数组里面放了一些 JSX 元素（其实就是 JavaScript 对象）。</p>
<p>React.js 把插入表达式数组里面的每一个 JSX 元素一个个罗列下来，渲染到页面上。所以这里有个关键点：<em>如果你往 <code>{}</code> 放一个数组，React.js 会帮你把数组里面一个个元素罗列并且渲染出来</em>。</p>
<h3 id="使用-map-渲染列表数据"><a href="#使用-map-渲染列表数据" class="headerlink" title="使用 map 渲染列表数据"></a>使用 map 渲染列表数据</h3><p>知道这一点以后你就可以知道怎么用循环把元素渲染到页面上：循环上面用户数组里面的每一个用户，为每个用户数据构建一个 JSX，然后把 JSX 放到一个新的数组里面，再把新的数组插入 <code>render</code> 方法的 JSX 里面。看看代码怎么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Jerry'</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Tomy'</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lily'</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lucy'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> usersElements = [] <span class="comment">// 保存每个用户渲染以后 JSX 的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) &#123;</span><br><span class="line">      usersElements.push( <span class="comment">// 循环每个用户，构建 JSX，push 到数组中</span></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div&gt;姓名：&#123;user.username&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;年龄：&#123;user.age&#125;&lt;/</span>div&gt;</span><br><span class="line">          &lt;div&gt;性别：&#123;user.gender&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;hr /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;usersElements&#125;&lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里用了一个新的数组 <code>usersElements</code>，然后循环 <code>users</code> 数组，为每个 <code>user</code> 构建一个 JSX 结构，然后 push 到 <code>usersElements</code> 中。然后直接用表达式插入，把这个 <code>userElements</code> 插到 return 的 JSX 当中。因为 React.js 会自动化帮我们把数组当中的 JSX 罗列渲染出来，所以可以看到页面上显示：</p>
<img src="../images/image-20200314144503017.png" alt="image-20200314144503017" style="zoom:200%;" />

<p>但我们一般不会手动写循环来构建列表的 JSX 结构，可以直接用 ES6 自带的 <code>map</code>（不了解 <code>map</code> 函数的同学可以先了解相关的知识再来回顾这里），代码可以简化成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;div&gt;姓名：&#123;user.username&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;div&gt;年龄：&#123;user.age&#125;&lt;/</span>div&gt;</span><br><span class="line">              &lt;div&gt;性别：&#123;user.gender&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;hr /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          )</span></span><br><span class="line"><span class="regexp">        &#125;)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的模式在 JavaScript 中非常常见，一般来说，在 React.js 处理列表就是用 <code>map</code> 来处理、渲染的。现在进一步把渲染单独一个用户的结构抽离出来作为一个组件，继续优化代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Jerry'</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Tomy'</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lily'</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'Lucy'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">'female'</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; user &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;姓名：&#123;user.username&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;年龄：&#123;user.age&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;性别：&#123;user.gender&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Index extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;users.map((user) =&gt; &lt;User user=&#123;user&#125; /</span>&gt;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Index /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里把负责展示用户数据的 JSX 结构抽离成一个组件 <code>User</code> ，并且通过 <code>props</code> 把 <code>user</code> 数据作为组件的配置参数传进去；这样改写 <code>Index</code> 就非常清晰了，看一眼就知道负责渲染 <code>users</code> 列表，而用的组件是 <code>User</code>。</p>
<h3 id="key-key-key"><a href="#key-key-key" class="headerlink" title="key! key! key!"></a>key! key! key!</h3><p>现在代码运作正常，好像没什么问题。打开控制台看看：</p>
<img src="../images/image-20200314144605558.png" alt="image-20200314144605558" style="zoom:200%;" />

<p>React.js 报错了。如果需要详细解释这里报错的原因，估计要单独写半本书。但可以简单解释一下。</p>
<p>React.js 的是非常高效的，它高效依赖于所谓的 Virtual-DOM 策略。简单来说，能复用的话 React.js 就会尽量复用，没有必要的话绝对不碰 DOM。对于列表元素来说也是这样，但是处理列表元素的复用性会有一个问题：元素可能会在一个列表中改变位置。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;a&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;b&lt;/</span>div&gt;</span><br><span class="line">&lt;div&gt;c&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设页面上有这么3个列表元素，现在改变一下位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;a&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;c&lt;/</span>div&gt;</span><br><span class="line">&lt;div&gt;b&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>c</code> 和 <code>b</code> 的位置互换了。但其实 React.js 只需要交换一下 DOM 位置就行了，但是它并不知道其实我们只是改变了元素的位置，所以它会重新渲染后面两个元素（再执行 Virtual-DOM 策略），这样会大大增加 DOM 操作。但如果给每个元素加上唯一的标识，React.js 就可以知道这两个元素只是交换了位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div key=<span class="string">'a'</span>&gt;a&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div key='b'&gt;b&lt;/</span>div&gt;</span><br><span class="line">&lt;div key=<span class="string">'c'</span>&gt;c&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样 React.js 就简单的通过 <code>key</code> 来判断出来，这两个列表元素只是交换了位置，可以尽量复用元素内部的结构。</p>
<p>这里没听懂没有关系，后面有机会会继续讲解这部分内容。现在只需要记住一个简单的规则：<em>对于用表达式套数组罗列到页面上的元素，都要为每个元素加上 <code>key</code> 属性，这个 <code>key</code> 必须是每个元素唯一的标识</em>。一般来说，<code>key</code> 的值可以直接后台数据返回的 <code>id</code>，因为后台的 <code>id</code> 都是唯一的。</p>
<p>在上面的例子当中，每个 <code>user</code> 没有 <code>id</code> 可以用，可以直接用循环计数器 <code>i</code> 作为 <code>key</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map(<span class="function">(<span class="params">user, i</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">User</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span></span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">...</span></span><br></pre></td></tr></table></figure>

<p>再看看，控制台已经没有错误信息了。但这是不好的做法，这只是掩耳盗铃（具体原因大家可以自己思考一下）。记住一点：在实际项目当中，如果你的数据顺序可能发生变化，标准做法是最好是后台数据返回的 <code>id</code> 作为列表元素的 <code>key</code>。</p>
<h2 id="9、前端应用状态管理-——-状态提升"><a href="#9、前端应用状态管理-——-状态提升" class="headerlink" title="9、前端应用状态管理 —— 状态提升"></a>9、前端应用状态管理 —— 状态提升</h2><p>我们在讲解 JSX 的章节中提到，下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line"> &lt;Header /&gt;, </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>会编译成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Header, <span class="literal">null</span>), </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其实我们把 <code>Header</code> 组件传给了 <code>React.createElement</code> 函数，又把函数返回结果传给了 <code>ReactDOM.render</code>。我们可以简单猜想一下它们会干什么事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.createElement 中实例化一个 Header</span></span><br><span class="line"><span class="keyword">const</span> header = <span class="keyword">new</span> Header(props, children)</span><br><span class="line"><span class="comment">// React.createElement 中调用 header.render 方法渲染组件的内容</span></span><br><span class="line"><span class="keyword">const</span> headerJsxObject = header.render()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM 用渲染后的 JavaScript 对象来来构建真正的 DOM 元素</span></span><br><span class="line"><span class="keyword">const</span> headerDOM = createDOMFromObject(headerJsxObject)</span><br><span class="line"><span class="comment">// ReactDOM 把 DOM 元素塞到页面上</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>).appendChild(headerDOM)</span><br></pre></td></tr></table></figure>

<p>上面过程其实很简单，看代码就能理解。</p>
<p>我们把 <em>React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载</em>（这个定义请好好记住）。其实 React.js 内部对待每个组件都有这么一个过程，也就是初始化组件 -&gt; 挂载到页面上的过程。所以你可以理解一个组件的方法调用是这么一个过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="keyword">constructor</span>()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br></pre></td></tr></table></figure>

<p>这当然是很好理解的。React.js 为了让我们能够更好的掌控组件的挂载过程，往上面插入了两个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="keyword">constructor</span>()</span><br><span class="line">-&gt; componentWillMount()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br><span class="line">-&gt; componentDidMount()</span><br></pre></td></tr></table></figure>

<p><code>componentWillMount</code> 和 <code>componentDidMount</code> 都是可以像 <code>render</code> 方法一样自定义在组件的内部。挂载的时候，React.js 会在组件的 <code>render</code> 之前调用 <code>componentWillMount</code>，在 DOM 元素塞入页面以后调用 <code>componentDidMount</code>。</p>
<p>我们给 <code>Header</code> 组件加上这两个方法，并且打一些 Log：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'construct'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'component will mount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'component did mount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1 className=<span class="string">'title'</span>&gt;React 小书&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台你可以看到依次输出：</p>
<img src="../images/image-20200314145149375.png" alt="image-20200314145149375" style="zoom:200%;" />

<p>可以看到，React.js 确实按照我们上面所说的那样调用了定义的两个方法 <code>componentWillMount</code> 和 <code>componentDidMount</code>。</p>
<p>机灵的同学可以想到，一个组件可以插入页面，当然也可以从页面中删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="keyword">constructor</span>()</span><br><span class="line">-&gt; componentWillMount()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br><span class="line">-&gt; componentDidMount()</span><br><span class="line">// ...</span><br><span class="line">// 从页面中删除</span><br></pre></td></tr></table></figure>

<p>React.js 也控制了这个组件的删除过程。在组件删除之前 React.js 会调用组件定义的 <code>componentWillUnmount</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="keyword">constructor</span>()</span><br><span class="line">-&gt; componentWillMount()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br><span class="line">-&gt; componentDidMount()</span><br><span class="line">// ...</span><br><span class="line">// 即将从页面中删除</span><br><span class="line">-&gt; componentWillUnmount()</span><br><span class="line">// 从页面中删除</span><br></pre></td></tr></table></figure>

<p>看看什么情况下会把组件从页面中删除，继续使用上面例子的代码，我们再定义一个 <code>Index</code> 组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isShowHeader: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleShowOrHide () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isShowHeader: !<span class="keyword">this</span>.state.isShowHeader</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isShowHeader ? <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleShowOrHide.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">          显示或者隐藏标题</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>Index</code> 组件使用了 <code>Header</code> 组件，并且有一个按钮，可以控制 <code>Header</code> 的显示或者隐藏。下面这行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...a</span><br><span class="line">&#123;<span class="keyword">this</span>.state.isShowHeader ? <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>相当于 <code>state.isShowHeader</code> 为 <code>true</code> 的时候把 <code>Header</code> 插入页面，<code>false</code> 的时候把 <code>Header</code> 从页面上删除。这时候我们给 <code>Header</code> 添加 <code>componentWillUnmount</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'component will unmount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时候点击页面上的按钮，你会看到页面的标题隐藏了，并且控制台打印出来下图的最后一行，说明 <code>componentWillUnmount</code> 确实被 React.js 所调用了：</p>
<img src="../images/image-20200314145348052.png" alt="image-20200314145348052" style="zoom:200%;" />

<p>你可以多次点击按钮，随着按钮的显示和隐藏，上面的内容会按顺序重复地打印出来，可以体会一下这几个方法的调用过程和顺序。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载。这一节我们学习了 React.js 控制组件在页面上挂载和删除过程里面几个方法：</p>
<ul>
<li><code>componentWillMount</code>：组件挂载开始之前，也就是在组件调用 <code>render</code> 方法之前调用。</li>
<li><code>componentDidMount</code>：组件挂载完成以后，也就是 DOM 元素已经插入页面后调用。</li>
<li><code>componentWillUnmount</code>：组件对应的 DOM 元素从页面中删除之前调用。</li>
</ul>
<p>但这一节并没有讲这几个方法到底在实际项目当中有什么作用，下一节我们通过例子来讲解一下这几个方法的用途。</p>
<h2 id="10、挂载阶段的组件生命周期"><a href="#10、挂载阶段的组件生命周期" class="headerlink" title="10、挂载阶段的组件生命周期"></a>10、挂载阶段的组件生命周期</h2><p>这一节我们来讨论一下对于一个组件来说，<code>constructor</code> 、<code>componentWillMount</code>、<code>componentDidMount</code>、<code>componentWillUnmount</code> 这几个方法在一个组件的出生到死亡的过程里面起了什么样的作用。</p>
<p>一般来说，所有关于组件自身的状态的初始化工作都会放在 <code>constructor</code> 里面去做。你会发现本书所有组件的 <code>state</code> 的初始化工作都是放在 <code>constructor</code> 里面的。假设我们现在在做一个时钟应用：</p>
<img src="../images/image-20200314145413595.png" alt="image-20200314145413595" style="zoom:200%;" />

<p>我们会在 <code>constructor</code> 里面初始化 <code>state.date</code>，当然现在页面还是静态的，等下一会让时间动起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">          &lt;p&gt;现在的时间是&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.date.toLocaleTimeString()&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>h1&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>一些组件启动的动作，包括像 Ajax 数据的拉取操作、一些定时器的启动等，就可以放在 <code>componentWillMount</code> 里面进行，例如 Ajax：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    ajax.get(<span class="string">'http://json-api.com/user'</span>, (userData) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; userData &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然在我们这个例子里面是定时器的启动，我们给 <code>Clock</code> 启动定时器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>componentWillMount</code> 中用 <code>setInterval</code> 启动了一个定时器：每隔 1 秒更新中的 <code>state.date</code>，这样页面就可以动起来了。我们用一个 <code>Index</code> 把它用起来，并且插入页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Clock /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Index /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>像上一节那样，我们修改这个 <code>Index</code> 让这个时钟可以隐藏或者显示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isShowClock</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleShowOrHide () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isShowClock: !<span class="keyword">this</span>.state.isShowClock</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isShowClock ? <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span> : <span class="literal">null</span> &#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleShowOrHide.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">          显示或隐藏时钟</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在页面上有个按钮可以显示或者隐藏时钟。你试一下显示或者隐藏时钟，虽然页面上看起来功能都正常，在控制台你会发现报错了：</p>
<img src="../images/image-20200314145616845.png" alt="image-20200314145616845" style="zoom:200%;" />

<p>这是因为，<em>当时钟隐藏的时候，我们并没有清除定时器</em>。时钟隐藏的时候，定时器的回调函数还在不停地尝试 <code>setState</code>，由于 <code>setState</code> 只能在已经挂载或者正在挂载的组件上调用，所以 React.js 开始疯狂报错。</p>
<p>多次的隐藏和显示会让 React.js 重新构造和销毁 <code>Clock</code> 组件，每次构造都会重新构建一个定时器。而销毁组件的时候没有清除定时器，所以你看到报错会越来越多。而且因为 JavaScript 的闭包特性，这样会导致严重的内存泄漏。</p>
<p>这时候<code>componentWillUnmount</code> 就可以派上用场了，它的作用就是在组件销毁的时候，做这种清场的工作。例如清除该组件的定时器和其他的数据清理工作。我们给 <code>Clock</code>添加 <code>componentWillUnmount</code>，在组件销毁的时候清除该组件的定时器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时候就没有错误了。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>我们一般会把组件的 <code>state</code> 的初始化工作放在 <code>constructor</code> 里面去做；在 <code>componentWillMount</code> 进行组件的启动工作，例如 Ajax 数据拉取、定时器的启动；组件从页面上销毁的时候，有时候需要一些数据的清理，例如定时器的清理，就会放在 <code>componentWillUnmount</code> 里面去做。</p>
<p>说一下本节没有提到的 <code>componentDidMount</code> 。一般来说，有些组件的启动工作是依赖 DOM 的，例如动画的启动，而 <code>componentWillMount</code> 的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在 <code>componentDidMount</code> 当中。<code>componentDidMount</code> 的具体使用我们会在接下来的章节当中结合 DOM 来讲。</p>
<h2 id="11、更新阶段的组件生命周期"><a href="#11、更新阶段的组件生命周期" class="headerlink" title="11、更新阶段的组件生命周期"></a>11、更新阶段的组件生命周期</h2><p>从之前的章节我们了解到，组件的挂载指的是将组件渲染并且构造 DOM 元素然后插入页面的过程。<em>这是一个从无到有的过程</em>，React.js 提供一些生命周期函数可以给我们在这个过程中做一些操作。</p>
<p>除了挂载阶段，还有一种“更新阶段”。说白了就是 <code>setState</code> 导致 React.js 重新渲染组件并且把组件的变化应用到 DOM 元素上的过程，<em>这是一个组件的变化过程</em>。而 React.js 也提供了一系列的生命周期函数可以让我们在这个组件更新的过程执行一些操作。</p>
<p>这些生命周期在深入项目开发阶段是非常重要的。而要完全理解更新阶段的组件生命周期是一个需要经验和知识积累的过程，你需要对 Virtual-DOM 策略有比较深入理解才能完全掌握，但这超出了本书的目的。<em>本书的目的是为了让大家快速掌握 React.js 核心的概念，快速上手项目进行实战</em>。所以对于组件更新阶段的组件生命周期，我们简单提及并且提供一些资料给大家。</p>
<p>这里为了知识的完整，补充关于更新阶段的组件生命周期：</p>
<ol>
<li><code>shouldComponentUpdate(nextProps, nextState)</code>：你可以通过这个方法控制组件是否重新渲染。如果返回 <code>false</code> 组件就不会重新渲染。这个生命周期在 React.js 性能优化上非常有用。</li>
<li><code>componentWillReceiveProps(nextProps)</code>：组件从父组件接收到新的 <code>props</code> 之前调用。</li>
<li><code>componentWillUpdate()</code>：组件开始重新渲染之前调用。</li>
<li><code>componentDidUpdate()</code>：组件重新渲染并且把更改变更到真实的 DOM 以后调用。</li>
</ol>
<p>大家对这更新阶段的生命周期比较感兴趣的话可以查看<a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">官网文档</a>。</p>
<p><em>但这里建议大家可以先简单了解 React.js 组件是有更新阶段的，并且有这么几个更新阶段的生命周期即可</em>。然后在深入项目实战的时候逐渐地掌握理解他们，现在并不需要对他们放过多的精力。</p>
<h2 id="12、ref-和-React-js-中的-DOM-操作"><a href="#12、ref-和-React-js-中的-DOM-操作" class="headerlink" title="12、ref 和 React.js 中的 DOM 操作"></a>12、ref 和 React.js 中的 DOM 操作</h2><p>在 React.js 当中你基本不需要和 DOM 直接打交道。React.js 提供了一系列的 on* 方法帮助我们进行事件监听，所以 React.js 当中不需要直接调用 addEventListener 的 DOM API；以前我们通过手动 DOM 操作进行页面更新（例如借助 jQuery），而在 React.js 当中可以直接通过 setState 的方式重新渲染组件，渲染的时候可以把新的 props 传递给子组件，从而达到页面更新的效果。</p>
<p>React.js 这种重新渲染的机制帮助我们免除了绝大部分的 DOM 更新操作，也让类似于 jQuery 这种以封装 DOM 操作为主的第三方的库从我们的开发工具链中删除。</p>
<p>但是 React.js 并不能完全满足所有 DOM 操作需求，有些时候我们还是需要和 DOM 打交道。比如说你想进入页面以后自动 focus 到某个输入框，你需要调用 input.focus() 的 DOM API，比如说你想动态获取某个 DOM 元素的尺寸来做后续的动画，等等。</p>
<p>React.js 当中提供了 ref 属性来帮助我们获取已经挂载的元素的 DOM 节点，你可以给某个 JSX 元素加上 ref属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.input.focus()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;AutoFocusInput /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以看到我们给 input 元素加了一个 ref 属性，这个属性值是一个函数。当 input 元素在页面上挂载完成以后，React.js 就会调用这个函数，并且把这个挂载以后的 DOM 节点传给这个函数。在函数中我们把这个 DOM 元素设置为组件实例的一个属性，这样以后我们就可以通过 this.input 获取到这个 DOM 元素。</p>
<p>然后我们就可以在 componentDidMount 中使用这个 DOM 元素，并且调用 this.input.focus() 的 DOM API。整体就达到了页面加载完成就自动 focus 到输入框的功能（大家可以注意到我们用上了 componentDidMount 这个组件生命周期）。</p>
<p>我们可以给任意代表 HTML 元素标签加上 ref 从而获取到它 DOM 元素然后调用 DOM API。但是记住一个原则：能不用 ref 就不用。特别是要避免用 ref 来做 React.js 本来就可以帮助你做到的页面自动更新的操作和事件监听。多余的 DOM 操作其实是代码里面的“噪音”，不利于我们理解和维护。</p>
<p>顺带一提的是，其实可以给组件标签也加上 ref ，例如：</p>
<p>&lt;Clock ref={(clock) =&gt; this.clock = clock} /&gt;<br> 这样你获取到的是这个 Clock 组件在 React.js 内部初始化的实例。但这并不是什么常用的做法，而且也并不建议这么做，所以这里就简单提及，有兴趣的朋友可以自己学习探索。</p>
<h2 id="13、props-children-和容器类组件"><a href="#13、props-children-和容器类组件" class="headerlink" title="13、props.children 和容器类组件"></a>13、props.children 和容器类组件</h2><p>有一类组件，充当了容器的作用，它定义了一种外层结构形式，然后你可以往里面塞任意的内容。这种结构在实际当中非常常见，例如这种带卡片组件：</p>
<p>组件本身是一个不带任何内容的方形的容器，我可以在用这个组件的时候给它传入任意内容：</p>
<p>基于我们目前的知识储备，可以迅速写出这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'card'</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">'card-content'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.content&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Card content=&#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;React.js 小书&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div&gt;开源、免费、专业、简单&lt;/</span>div&gt;</span><br><span class="line">      订阅：&lt;input /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &#125; /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们通过给 <code>Card</code> 组件传入一个 <code>content</code> 属性，这个属性可以传入任意的 JSX 结构。然后在 <code>Card</code> 内部会通过 <code>{this.props.content}</code> 把内容渲染到页面上。</p>
<p>这样明显太丑了，如果 <code>Card</code> 除了 <code>content</code> 以外还能传入其他属性的话，那么这些 JSX 和其他属性就会混在一起。很不好维护，如果能像下面的代码那样使用 <code>Card</code> 那想必也是极好的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Card&gt;</span><br><span class="line">    &lt;h2&gt;React.js 小书&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;开源、免费、专业、简单&lt;/</span>div&gt;</span><br><span class="line">    订阅：&lt;input /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Card&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<p>如果组件标签也能像普通的 HTML 标签那样编写内嵌的结构，那么就方便很多了。实际上，React.js 默认就支持这种写法，所有嵌套在组件中的 JSX 结构都可以在组件内部通过 <code>props.children</code> 获取到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'card'</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">'card-content'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>props.children</code> 打印出来，你可以看到它其实是个数组：</p>
<img src="../images/image-20200314145828931.png" alt="image-20200314145828931" style="zoom:200%;" />

<p>React.js 就是把我们嵌套的 JSX 元素一个个都放到数组当中，然后通过 <code>props.children</code> 传给了 <code>Card</code>。</p>
<p>由于 JSX 会把插入表达式里面数组中的 JSX 一个个罗列下来显示。所以其实就相当于在 <code>Card</code> 中嵌套了什么 JSX 结构，都会显示在 <code>Card</code> 的类名为 <code>card-content</code> 的 <code>div</code> 元素当中。</p>
<p>这种嵌套的内容成为了 <code>props.children</code> 数组的机制使得我们编写组件变得非常的灵活，我们甚至可以在组件内部把数组中的 JSX 元素安置在不同的地方：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'two-cols-layout'</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">'sidebar'</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children[<span class="number">0</span>]&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className='main'&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.props.children[1]&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这是一个两列布局组件，嵌套的 JSX 的第一个结构会成为侧边栏，第二个结构会成为内容栏，其余的结构都会被忽略。这样通过这个布局组件，就可以在各个地方高度复用我们的布局。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>使用自定义组件的时候，可以在其中嵌套 JSX 结构。嵌套的结构在组件内部都可以通过 <code>props.children</code> 获取到，这种组件编写方式在编写容器类型的组件当中非常有用。而在实际的 React.js 项目当中，我们几乎每天都需要用这种方式来编写组件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/google%E6%8A%80%E6%9C%AF%E5%86%99%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/google%E6%8A%80%E6%9C%AF%E5%86%99%E4%BD%9C/" class="post-title-link" itemprop="url">google技术写作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-14 10:57:18 / Modified: 15:27:43" itemprop="dateCreated datePublished" datetime="2020-03-14T10:57:18-04:00">2020-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Google 技术写作</p>
<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><table>
<thead>
<tr>
<th>词性</th>
<th>定义</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td>Noun 名词</td>
<td>人，地方，概念或事物</td>
<td><strong>Sam</strong> runs <strong>races</strong>. 山姆赛跑。</td>
</tr>
<tr>
<td>Pronoun 代词</td>
<td>替代另一个名词的名词</td>
<td>Sam runs races. <strong>He</strong> likes to compete. 山姆赛跑。他喜欢竞争。</td>
</tr>
<tr>
<td>Adjective 形容词</td>
<td>修饰名词的单词或短语</td>
<td>Sam wears <strong>blue</strong> shoes 山姆穿蓝色的鞋子。</td>
</tr>
<tr>
<td>Verb 动词</td>
<td>一个动作词或短语</td>
<td>Sam <strong>runs</strong> races.  山姆跑比赛。</td>
</tr>
<tr>
<td>Adverb 副词</td>
<td>修饰动词，形容词或其他副词的单词或短语</td>
<td>Sam runs <strong>slowly</strong>.  山姆跑得慢。</td>
</tr>
<tr>
<td>Preposition 介词</td>
<td>指定两个名词的位置关系的单词或短语</td>
<td>Sam’s sneakers are seldom <strong>on</strong> his shelf.  山姆的运动鞋很少在他的架子上。</td>
</tr>
<tr>
<td>Conjunction 连词</td>
<td>连接两个名词或短语的单词</td>
<td>Sam’s trophies <strong>and</strong> ribbons live only in his imagination.  山姆的奖杯和缎带只存在于他的想象中。</td>
</tr>
<tr>
<td>Transition 过渡</td>
<td>连接两个句子的单词或短语</td>
<td>Sam runs races weekly. <strong>However</strong>, he finishes races weakly. 山姆每周参加比赛。但是，他无力完成比赛。</td>
</tr>
</tbody></table>
<h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><p>名词代表人，地方或事物。<strong>朱迪（**</strong>Judy<strong>**）</strong>，<strong>南极洲（**</strong>Antarctica<strong>）和 <strong>锤子（</strong></strong>Hammer<strong>**）</strong>都是名词，无形的概念（例如<strong>健壮性</strong> <strong>robustness</strong> 和<strong>完美性</strong> <strong>perfection</strong> <strong>）</strong>也是如此。例如，我们在下面的示例中加粗了名词：</p>
<p>In the <strong>framework</strong>, an <strong>object</strong> must copy any underlying <strong>values</strong> that the <strong>object</strong> wants to change. The <strong>protos</strong> in the <strong>codebase</strong> are huge, so copying the <strong>protos</strong> is unacceptably expensive.</p>
<h3 id="代词"><a href="#代词" class="headerlink" title="代词"></a>代词</h3><p>代词是一个间接层，它指向或替代了其他名词或句子。例如：Janet writes great code. <strong>She</strong> is a senior staff engineer.  示例中，第一句话将Janet建立为名词。第二句用代词“ She”代替名词“Janet”。</p>
<p>在以下示例中，代词<strong>This</strong>代替了它前面的整个句子：</p>
<p>Most applications aren’t sufficiently tested. <strong>This</strong> is poor engineering.</p>
<h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><p>动词是一个动作词或短语。当您想要表示两个名词（一个行为者和一个目标）之间的关系时，该动词就起作用了。动词标识行为者对目标的作用。每个句子必须至少包含一个动词。例如，以下每个句子包含一个动词：</p>
<ul>
<li>Sakai <strong>prefers</strong> pasta.  酒井法子喜欢面食。</li>
<li>Rick <strong>likes</strong> the ocean.  瑞克喜欢大海。</li>
<li>Smurfs <strong>are</strong> blue.  蓝精灵是蓝色的。</li>
<li>Jess <strong>suffers</strong> from allergies.  杰西有过敏症。</li>
</ul>
<p>有些句子会包含多个动词，如：</p>
<ul>
<li>Nala <strong>suffers</strong> from allergies and <strong>sneezes</strong> constantly.<br> 娜娜过敏，经常打喷嚏。</li>
<li>Chung <strong>likes</strong> snacks <strong>to eat</strong> while <strong>riding</strong> the train.<br> Chung喜欢在火车上吃零食。</li>
</ul>
<p>根据时态和词缀变化，一个动词可以包含一个单词或多个单词。例如：</p>
<ul>
<li>Tina <strong>was eating</strong> breakfast a few hours ago.<br> 蒂娜几小时前正在吃早餐。</li>
<li>Tina <strong>is eating</strong> lunch right now.<br> 蒂娜现在在吃午餐。</li>
<li>Tina <strong>will eat</strong> dinner tonight at 7:00.<br> 蒂娜将在7点吃晚餐。</li>
</ul>
<h3 id="形容词和副词"><a href="#形容词和副词" class="headerlink" title="形容词和副词"></a>形容词和副词</h3><p>形容词修饰名词。例如，在下面的句子中，注意形容词如何修饰后面的名词：</p>
<p>Tom likes <strong>red</strong> balloons. He prepares <strong>delicious</strong> food. He fixed <strong>eight</strong> bugs at work.</p>
<p>大多数副词修饰动词。例如，注意下面句子中的副词是如何(有效地)修饰动词的：</p>
<p>Jane <strong>efficiently</strong> fixes bugs.</p>
<p>副词不一定紧挨着动词。例如，在下面的句子中，副词(effective)与动词(fixes)相距两个单词</p>
<p>Jane fixes bugs <strong>efficiently</strong>.</p>
<p>副词也可以修饰形容词或其他副词。</p>
<h3 id="连词和过渡"><a href="#连词和过渡" class="headerlink" title="连词和过渡"></a>连词和过渡</h3><p>连词连接句子中的短语或名词；过渡连接句子本身。最重要的连词如下：</p>
<ul>
<li>and</li>
<li>but</li>
<li>or</li>
</ul>
<p>例如，在下面的句子中，and连接了“code”和“documentation”，而but连接了句子的前半部分和后半部分。</p>
<p>Natasha writes great internal code <strong>and</strong> documentation <strong>but</strong> seldom works on open-source projects. </p>
<p>Natasha 编写了大量的内部代码和文档，但是很少在开源项目上工作。</p>
<p>技术写作中最重要的过度词如下：</p>
<ul>
<li>however</li>
<li>therefore</li>
<li>for example</li>
</ul>
<p>在下面的段落中，请注意过渡如何连接句子并使其上下文相关：</p>
<p>Juan is a wonderful coder. <strong>However</strong>, he rarely writes sufficient tests. <strong>For example</strong>, Juan coded a 5,000 line FFT package that contained only a single 10-line unit test.</p>
<p>Juan 是一个出色的程序员。然而，他很少编写足够的测试。例如，Juan编码了一个5000行的FFT包，却只包含一个10行的单元测试。</p>
<h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><h3 id="定义新术语或不熟悉的术语"><a href="#定义新术语或不熟悉的术语" class="headerlink" title="定义新术语或不熟悉的术语"></a>定义新术语或不熟悉的术语</h3><p>在写作或编辑时，识别那些目标受众可能不熟悉的术语。当您发现此类术语时，请采取以下两种策略之一：</p>
<ul>
<li>如果该术语已经存在，请链接到现有的具体解释。（不要重新发明轮子）</li>
<li>如果您的文档中引入了该术语，请定义该术语。如果您的文档引入了许多术语，请将定义收集到词汇表中。</li>
</ul>
<h3 id="始终使用术语"><a href="#始终使用术语" class="headerlink" title="始终使用术语"></a>始终使用术语</h3><p>如果在方法中途更改变量的名称，则代码将无法编译。同样，如果您在文档中间重命名术语，则您的想法将无法编译（在用户头脑中）。</p>
<p>修养：在整个文档中始终使用相同的明确词或术语。一旦你将某个组件命名为<strong>thingy</strong>之后，不要将其重命名为 <strong>thingamabob</strong>。例如，以下段落错误地将 <strong>Protocol Buffers</strong> 重命名为 <strong>protobufs</strong>：</p>
<p><strong>Protocol Buffer</strong> 提供了自己的定义语言。…………。这就是 <strong>protobufs</strong> 赢得如此众多县博览会的原因。</p>
<p>是的，技术写作是残酷和充满限制的，但是至少技术写作提供了一个很好的解决方法。即，当引入冗长的概念名称或产品名称时，您也可以指定该名称的缩写形式。然后，您可以在整个文档中使用该简称。例如，以下段落很好：</p>
<p><strong>Protocol Buffer</strong>（或简称 <strong>protobuf</strong>）提供了自己的定义语言。…… 这就是 <strong>protobuf</strong> 赢得如此众多县博览会的原因。</p>
<h3 id="正确使用首字母缩写词"><a href="#正确使用首字母缩写词" class="headerlink" title="正确使用首字母缩写词"></a>正确使用首字母缩写词</h3><p>在文档或章节中首次使用不熟悉的首字母缩写词时，请拼写完整的术语，然后将首字母缩写词放在括号中。拼写版本和首字母缩写用黑体字标出。例如：</p>
<p>本文档适用于<strong>远程触觉网络</strong> <strong>Telekinetic Tactile Network**</strong>（<strong><strong>TTN</strong></strong>）**的新手或需要了解如何通过手指运动订购TTN替换零件的工程师 。</p>
<p>然后可以使用首字母缩略词，如以下示例所示：</p>
<p>如果不存在缓存条目，则混合器将调用 <strong>OttoGroup Server</strong>（<strong>OGS</strong>）来为请求获取Ottos。OGS是一个存放所有可使用的Otto的存储库。OGS以逻辑树结构组织，具有一个根节点和两个级别的叶节点。OGS根将请求转发到叶子并收集响应。</p>
<p>另外，不要在同一文档中的首字母缩写词和扩展版本之间来回切换。</p>
<p>使用首字母缩写词还是完整术语？</p>
<p>当然，您可以正确地引入和使用首字母缩写词，但是您真的要使用首字母缩写词吗？好吧，首字母缩略词确实减少了句子的大小。例如，<em>TTN</em> 比<em>Telekinetic Tactile Network</em> 短很多。但是，首字母缩略词实际上只是抽象层。读者必须在头脑中将最近学到的首字母缩略词扩展到整个术语。例如，读者在脑海中将 <em>TTN</em> 转换为 <em>Telekinetic Tactile Network</em>，因此“较短”的首字母缩略词实际上要比整个术语花费更长的时间。</p>
<p>大量使用的首字母缩写词基本上会变成另外一个新词。在出现许多情况后，读者通常停止将首字母缩略词展开成具体的单词。例如，许多Web开发人员已经忘记了<em>HTML</em>这个术语展开后是什么。</p>
<p>这是首字母缩写词的准则：</p>
<ul>
<li><p>不要定义只会使用几次的首字母缩写词。</p>
</li>
<li><p>请定义同时满足以下两个条件的首字母缩写词：</p>
</li>
<li><ul>
<li>该首字母缩写词明显短于整个术语。</li>
<li>该首字母缩写词在文档中很多次出现。</li>
</ul>
</li>
</ul>
<h3 id="消除代词歧义"><a href="#消除代词歧义" class="headerlink" title="消除代词歧义"></a>消除代词歧义</h3><p>许多代词指向先前引入的名词。这种代词类似于编程中的指针。像编程中的指针一样，代词往往会引入错误。代词使用不当会就像程序中的 nullptr 空指针错误一样在读者的脑海中造成错误的认知 。在许多情况下，您应该简单地避免代词，而就直接重复使用该名词。但是，代词的效用有时会非常有用。</p>
<p>请考虑以下代词准则：</p>
<ul>
<li>引入名词后才使用代词；在介绍名词之前，切勿使用代词。</li>
<li>代词应尽可能靠近指称名词。根据经验，如果将名词与代词分隔开的单词超过五个，请考虑重复使用名词，而不要使用代词。</li>
<li>如果在名词和代词之间引入第二个名词，请重复使用名词，而不要使用代词。</li>
</ul>
<h4 id="it-和-they"><a href="#it-和-they" class="headerlink" title="it 和 they"></a>it 和 they</h4><p>以下代词在技术文档中引起最大的混乱：</p>
<ul>
<li>it</li>
<li>they，them 和 their</li>
</ul>
<p>例如，在下面的句子中，<strong>它</strong>是指Python还是C ++？</p>
<p>Python是解释型语言，而C ++是编译型语言。<strong>它</strong>具有几乎类似邪教的追随者。</p>
<p>再举一个例子，<strong>它们</strong> 在接下来的句子中指的是什么？</p>
<p>将 Frambus 或 Carambola 与 HoobyScooby 或 BoiseFram 一起使用时要小心，因为<strong>它们的</strong>核心可能会导致意外的大量脱机。</p>
<h4 id="this-和-that"><a href="#this-和-that" class="headerlink" title="this 和 that"></a>this 和 that</h4><p>考虑另外两个问题代词：</p>
<ul>
<li>this</li>
<li>that</li>
</ul>
<p>例如，在下面有歧义的句子中，“<strong>这**</strong>”** 可能是指Frambus，Foo或两者：</p>
<p>您可以使用 Frambus 或 Foo 来计算导数。<strong>这</strong> 不是最佳的。</p>
<p>使用以下的战术来消除歧义<strong>这个</strong>和<strong>那个</strong>：</p>
<ul>
<li>将 <strong>this</strong> 或 <strong>that</strong> 替换为相关的名词。</li>
<li>在 <strong>this</strong> 或 <strong>that</strong> 后马上使用那个名词。</li>
</ul>
<p>例如，以下两个句子中的任何一个都消除了前面的示例的歧义：</p>
<p><strong>Overlapping functionality</strong> is not optimal.</p>
<p><strong>This overlapping functionality</strong> is not optimal.</p>
<h3 id="主动语态与被动语态"><a href="#主动语态与被动语态" class="headerlink" title="主动语态与被动语态"></a>主动语态与被动语态</h3><p>技术写作中的绝大多数句子都应该是主动语态。本单元教您如何执行以下操作：</p>
<ul>
<li>区分被动语态和主动语态。</li>
<li>将被动语态转换为主动语态，因为主动语态通常更清晰。</li>
</ul>
<h4 id="用简单的句子区分主动语态和被动语态"><a href="#用简单的句子区分主动语态和被动语态" class="headerlink" title="用简单的句子区分主动语态和被动语态"></a>用简单的句子区分主动语态和被动语态</h4><p>在主动的语态句子中，主语作用于目标。也就是说，主动语态句子遵循以下公式：</p>
<p>主动语态句=主语+动词+目标</p>
<p>被动的语态句子则反过来。即，被动语态语句通常遵循以下公式：</p>
<p>被动语态句=目标+动词+主语</p>
<h5 id="主动语态示例"><a href="#主动语态示例" class="headerlink" title="主动语态示例"></a>主动语态示例</h5><p>例如，这是一个简短而主动语态句子：</p>
<p>The cat sat on the mat. 猫坐在垫子上。</p>
<ul>
<li>主语：The cat</li>
<li>动词：sat </li>
<li>目标：the mat</li>
</ul>
<h5 id="被动语态示例"><a href="#被动语态示例" class="headerlink" title="被动语态示例"></a>被动语态示例</h5><p>相比之下，这是被动语态中的同一句话：</p>
<p>The mat was sat on by the cat. 垫子被猫坐着。</p>
<ul>
<li>目标：The mat</li>
<li>被动动词：was sat</li>
<li>主语：the cat</li>
</ul>
<p>一些被动的语态句子省略了主语。例如：</p>
<p>The mat was sat on。</p>
<ul>
<li>主语：不明</li>
<li>被动动词：was sat</li>
<li>目标：the mat</li>
</ul>
<p>谁或什么坐在垫子上？一只猫？一只狗？霸王龙？读者只能猜测。技术文档中的好句子可以确定谁对谁做事。</p>
<h4 id="识别被动动词"><a href="#识别被动动词" class="headerlink" title="识别被动动词"></a>识别被动动词</h4><p>被动动词通常具有以下公式：</p>
<p>passive verb = be 的形式 + 动词过去分词</p>
<p>尽管上述公式令人生畏，但实际上非常简单：</p>
<ul>
<li><p><strong>be</strong> 在一个被动动词中通常是下列词语之一：</p>
</li>
<li><ul>
<li>is / are</li>
<li>was / were</li>
</ul>
</li>
<li><p><strong>past participle verb</strong> <strong>过去分词动词</strong> 通常是一个普通的动词加上过去式的后缀 ed。例如，以下是过去分词动词：</p>
</li>
<li><ul>
<li>interpreted</li>
<li>generated</li>
<li>formed</li>
</ul>
</li>
</ul>
<p>不幸的是，某些过去分词动词是不规则的；也就是说，过去分词形式不以后缀<em>ed</em>结尾。例如：</p>
<ul>
<li>sat</li>
<li>known</li>
<li>frozen</li>
</ul>
<p>将<em>be</em>和过去分词的形式放在一起会产生被动动词，例如：</p>
<ul>
<li>was interpreted</li>
<li>is generated</li>
<li>was formed</li>
<li>is frozen</li>
</ul>
<p>如果短语中包含一个主语，介词通常会跟在被动动词之后。(这个介词通常是帮助你辨别被动语态的关键线索)下面的例子结合了被动动词和介词：</p>
<ul>
<li>was interpreted as 被解释为</li>
<li>is generated by 由……生成</li>
<li>was formed by 由……形成</li>
<li>is frozen by 被……冻结</li>
</ul>
<h5 id="祈使动词通常是主动的"><a href="#祈使动词通常是主动的" class="headerlink" title="祈使动词通常是主动的"></a>祈使动词通常是主动的</h5><p>将祈使动词开头的句子很容易错误地归为被动。一个<strong>祈使动词</strong>是一个命令。编号列表中的许多项目都以祈使动词开头。例如，以下列表中的“ <em>Open”*和“ *Set</em> ”都是祈使动词：</p>
<ol>
<li>Open the configuration file.</li>
<li>Set the Frombus variable to False.</li>
</ol>
<p>以祈使动词开头的句子通常采用主动语态，即使它们没有明确提及主语。相反，以命令式动词开头的句子暗示一个主语。这个隐含的主语就是“<strong>你**</strong>”**。</p>
<h4 id="用更复杂的句子区分主动语态和被动语态"><a href="#用更复杂的句子区分主动语态和被动语态" class="headerlink" title="用更复杂的句子区分主动语态和被动语态"></a>用更复杂的句子区分主动语态和被动语态</h4><p>许多句子包含多个动词，其中有些是主动的，有些是被动的。例如，以下句子包含两个动词，两个动词均为被动语态：</p>
<img src="../images/image-20200314110029371.png" alt="image-20200314110029371" style="zoom:200%;" />

<p>完全转换为主动语态：</p>
<img src="../images/image-20200314110046383.png" alt="image-20200314110046383" style="zoom:200%;" />

<h4 id="首选主动语态而不是被动语态"><a href="#首选主动语态而不是被动语态" class="headerlink" title="首选主动语态而不是被动语态"></a>首选主动语态而不是被动语态</h4><p>大部分时间使用主动态。谨慎使用被动语态。主动语态具有以下优点：</p>
<ul>
<li>大多数读者会在心理上将被动语态转换为主动语态。为什么要使读者的处理时间更长？通过坚持主动语态，读者可以跳过预处理阶段，直接进入编译阶段。</li>
<li>被动语态会使您的想法模糊不清，使他们的句子变得无聊。被动语态间接报告操作。</li>
<li>一些被动语态的句子完全忽略了主语，这迫使读者猜测主语是谁。</li>
<li>主动语态通常比被动语态更短。</li>
</ul>
<p>Be bold—be active.</p>
<h3 id="清晰的句子"><a href="#清晰的句子" class="headerlink" title="清晰的句子"></a>清晰的句子</h3><p>喜剧作家寻求最有趣的结果，恐怖作家寻求最恐怖的结果，技术作家寻求最清晰的结果。在技术写作中，清晰度优先于所有其他规则。本单元提供了几种使句子清晰清晰的方法。</p>
<h4 id="选择强动词"><a href="#选择强动词" class="headerlink" title="选择强动词"></a>选择强动词</h4><p>许多技术写作者认为，动词是句子中最重要的部分。选择正确的动词，句子的其余部分都会顺理成章。不幸的是，有些写作者只重复使用了少量温和的动词，就像每天为客人提供千篇一律的饼干和生菜一样。选择正确的动词需要花费更多时间，但会产生更令人满意的结果。</p>
<p>为了吸引和教育读者，请选择精确，有力的特定动词。减少不精确，虚弱或通用的动词，例如：</p>
<ul>
<li><em>be</em>的形式：is，are，am，was，are等。</li>
<li>occur</li>
<li>happen</li>
</ul>
<p>例如，考虑以下句子中的弱动词如何增强有代入感的句子</p>
<table>
<thead>
<tr>
<th>弱动词</th>
<th>强动词</th>
</tr>
</thead>
<tbody><tr>
<td>The error <strong>occurs</strong> when clicking the Submit button.</td>
<td>Clicking the Submit button <strong>triggers</strong> the error.</td>
</tr>
<tr>
<td>This error message <strong>happens</strong> when…</td>
<td>The system <strong>generates</strong> this error message when…</td>
</tr>
<tr>
<td>We <strong>are</strong> very careful to ensure…</td>
<td>We carefully <strong>ensure</strong>…</td>
</tr>
</tbody></table>
<p>许多写作者都依赖于<em>be</em>的形式，好像它们是货架上唯一的香料。撒上不同的动词，能让自己的散文变得更开胃。也就是说，一种形式的<em>be</em>有时是动词的最佳选择，因此不必觉得您必须从写作中消除每种形式的<em>be</em>。</p>
<p>请注意，一般动词通常有病变的信号，例如：</p>
<ul>
<li>句子中不精确的主语或没有主语</li>
<li>被动语态句子</li>
</ul>
<p>示例一</p>
<p>When a variable declaration doesn’t have a data type, a compiler error happens.</p>
<p>被改写成下面的形式会更好：</p>
<ul>
<li>When a variable declaration doesn’t <strong>specify</strong> a data type, the compiler <strong>generates</strong> an error message.</li>
<li>If you <strong>declare</strong> a variable but don’t <strong>specify</strong> a data type, the compiler <strong>generates</strong> an error message.</li>
</ul>
<p>示例二</p>
<p>Compiler errors occur when you leave off a semicolon at the end of a statement.</p>
<p>被改成下面的形式会更好：</p>
<ul>
<li>Compilers <strong>issue</strong> errors when you <strong>omit</strong> a semicolon at the end of a statement.</li>
<li>A missing semicolon at the end of a statement <strong>triggers</strong> compiler errors.</li>
</ul>
<h4 id="减少使用-there-is-there-are"><a href="#减少使用-there-is-there-are" class="headerlink" title="减少使用 there is/there are"></a>减少使用 there is/there are</h4><p>以<strong>There is</strong> 或 <strong>There is</strong> 开头的句子将普通名词嫁接到普通动词上。这种乱点鸳鸯谱的方式会使读者感到厌烦。通过提供真实的主语和真实的动词来表达才是对读者的真爱。</p>
<p>在最佳情况下，您可以简单地删除“<strong>There is”</strong>或“<strong>There are”</strong> （以及句子后面的另一个单词或两个单词）。例如，考虑以下句子：</p>
<p>There is a variable called met_trick that stores the current accuracy.</p>
<p>删除 <strong>There is</strong> 用更好的主语替换通用主题。例如，以下任一句子比原始句子更清晰：</p>
<p>A variable named met_trick stores the current accuracy. </p>
<p>The met_trick variable stores the current accuracy.</p>
<h5 id="您有时可以通过将真实的主语和真实的动词从句子的末尾移到开头来修复-There-is或-There-are-句子。"><a href="#您有时可以通过将真实的主语和真实的动词从句子的末尾移到开头来修复-There-is或-There-are-句子。" class="headerlink" title="您有时可以通过将真实的主语和真实的动词从句子的末尾移到开头来修复 There is或 There are 句子。"></a>您有时可以通过将真实的主语和真实的动词从句子的末尾移到开头来修复 <strong>There is</strong>或 <strong>There are</strong> 句子。</h5><p>例如，请注意，<strong>You</strong> 的代词出现在以下句子的结尾：</p>
<p>There are two disturbing facts about Perl you should know.</p>
<p>用 You 替换 there is ：</p>
<p>You should know two disturbing facts about Perl.</p>
<p>在其他情况下，写作者以 <strong>There is</strong> 或 <strong>There are</strong> 开始句子，以避免创建真实的主语或动词的麻烦。如果不存在任何主题，请考虑创建一个。例如，以下 <strong>There is</strong> 句子不能识别接收实体：</p>
<p>There is no guarantee that the updates will be received in sequential order.</p>
<p>用有意义的主语（例如:<strong>client</strong>）代替“ There is”可以为读者带来更清晰的体验：</p>
<p>Clients might not receive the updates in sequential order.</p>
<p>练习</p>
<ol>
<li>There is a lot of overlap between X and Y.</li>
<li>There is no creator stack for the main thread.</li>
<li>There is a low-level, TensorFlow, Python interface to load a saved model.</li>
<li>There is a sharding function named distribute that assigns keys.</li>
</ol>
<p>可以改写为：</p>
<ol>
<li>X and Y overlap a lot.</li>
<li>The main thread does not provide a creator stack.</li>
<li>TensorFlow provides a low-level Python interface to load a saved model.</li>
<li>The distribute sharding function assigns keys.</li>
</ol>
<h4 id="最小化特定的形容词和副词（可选）"><a href="#最小化特定的形容词和副词（可选）" class="headerlink" title="最小化特定的形容词和副词（可选）"></a>最小化特定的形容词和副词（可选）</h4><p>形容词和副词在小说和诗歌中表现出色。由于形容词，普通的草能变成<strong>杂草</strong> <strong>prodigal</strong> 和<strong>葱绿</strong> <strong>verdant</strong>，而毫无生气的头发变换到的东西<strong>柔滑</strong> <strong>silky</strong> 和<strong>流动</strong> <strong>flowing</strong>。副词能让马跑地<strong>疯狂</strong> <strong>madly</strong>和<strong>自由</strong> <strong>freely</strong>，让狗叫得<strong>大声</strong> <strong>loudly</strong> 和<strong>凶猛</strong> <strong>ferociously</strong>。不幸的是，形容词和副词有时会加入很多噪音。那是因为形容词和副词的定义过于松散，对技术读者而言主观。更糟糕的是，形容词和副词会使技术文档听起来像营销材料一样危险。例如，请考虑以下技术文档中的内容：</p>
<p>Setting this flag makes the application run screamingly fast.</p>
<p>诚然，<strong>screamingly fast</strong> <strong>令人尖叫的速度</strong> 能引起了读者的注意，但不一定是一种很好的方式。向您的读者提供事实数据，而不是像市场营销人员讲话。将无定形副词和形容词重构为客观的数字信息。例如：</p>
<p>Setting this flag makes the application run 225-250% faster.</p>
<p>前面的更改是否会剥夺其某些魅力的句子？是的，有一点，但是修改后的句子获得了准确性和可信度。</p>
<h3 id="简短的句子"><a href="#简短的句子" class="headerlink" title="简短的句子"></a>简短的句子</h3><p>软件工程师通常愿意精简代码，主要出于以下原因：</p>
<ul>
<li>简短的代码更易于他人阅读。</li>
<li>简短的代码更易于维护。</li>
<li>多余的代码可能会引入潜在的故障。</li>
</ul>
<p>以上规则，同样适用于技术写作：</p>
<ul>
<li>简短的文档可读性更好。</li>
<li>简短的文档更易于维护。</li>
<li>多余的文档行会引入额外的问题。</li>
</ul>
<p>寻找最短的文档实现需要时间，但最终还是值得的。短句子比长句子更有效地进行交流，并且短句子通常比长句子更容易理解。</p>
<h4 id="一个句子只聚焦在一个想法"><a href="#一个句子只聚焦在一个想法" class="headerlink" title="一个句子只聚焦在一个想法"></a>一个句子只聚焦在一个想法</h4><p>将每句话聚焦在一个想法上思想或概念上。就像程序中的语句执行单个任务一样，句子也应该执行单个想法。例如，以下很长的句子包含多种想法：</p>
<p>The late 1950s was a key era for programming languages because IBM introduced FORTRAN in 1957 and John McCarthy introduced Lisp the following year, which gave programmers both an iterative way of solving problems and a recursive way.</p>
<p>1950年代后期是编程语言的关键时代，因为IBM于1957年推出了FORTRAN，而John McCarthy于次年推出了Lisp，这为程序员提供了解决问题的迭代方法和递归的方法。</p>
<p>将长句子分解为一连串的单意识句子会产生以下结果：</p>
<p>The late 1950s was a key era for programming languages. IBM introduced FORTRAN in 1957. John McCarthy invented Lisp the following year. Consequently, by the late 1950s, programmers could solve problems iteratively or recursively.</p>
<p>1950年代后期是编程语言的关键时代。IBM在1957年推出了FORTRAN。第二年，John McCarthy发明了Lisp。因此，到1950年代后期，程序员可以使用迭代或递归的方法来解决问题。</p>
<p>练习</p>
<p>将以下长句子转换为一系列短句子。不要修改太多；最后只剩下几句话而不是只有一句话。</p>
<p>In bash, use the if, then, and fi statements to implement a simple conditional branching block in which the if statement evaluates an expression, the then statement introduces a block of statements to run when the if an expression is true, and the fi statement marks the end of the conditional branching block.</p>
<p>可以改写成</p>
<p>In bash, use an if, then, and fi statement to implement a simple conditional branching block. The if statement evaluates an expression. The then statement introduces a block of statements to run when the if an expression is true. The fi statement marks the end of the conditional branching block.</p>
<h4 id="将长句子转换为列表"><a href="#将长句子转换为列表" class="headerlink" title="将长句子转换为列表"></a>将长句子转换为列表</h4><p>许多冗长的技术语句中，都有一个渴望摆脱困境的清单。例如，考虑以下句子：</p>
<p>To alter the usual flow of a loop, you may use either a <strong>break</strong> statement (which hops you out of the current loop) or a <strong>continue</strong> statement (which skips past the remainder of the current iteration of the current loop).</p>
<p>要更改循环的通常流程，可以使用<strong>break</strong>语句（使您跳出当前循环）或<strong>continue</strong>语句（跳过当前循环的当前迭代的其余部分）。</p>
<p>当您看到连词<strong>or</strong>长句子时，请考虑将该句子重构为项目符号列表。当您看到长句子中嵌入的项目或任务列表时，请考虑将该句子重构为项目符号或编号列表。例如，前面的示例包含连词<strong>或**</strong>or**，因此让我们将长句子转换为以下项目符号列表：</p>
<p>要更改循环的通常流程，请调用以下语句之一：</p>
<ul>
<li>break，使您跳出当前循环。</li>
<li>continue，跳过当前循环的当前迭代的其余部分。</li>
</ul>
<p>练习</p>
<p>将以下句子重构为更简短的内容。确保您的答案包含一个列表：</p>
<ol>
<li>To get started with the Frambus app, you must first find the app at a suitable store, pay for it using a valid credit or debit card, download it, configure it by assigning a value for the Foo variable in the /etc/Frambus file, and then run it by saying the magic word twice.</li>
<li>KornShell was invented by David Korn in 1983, then a computer scientist at Bell Labs, as a superset of features, enhancements, and improvements over the Bourne Shell (which it was backwards compatible with), which was invented by Stephen Bourne in 1977 who was also a computer scientist at Bell Labs.</li>
</ol>
<p>可以改写为</p>
<p>Take the following steps to get started with the Frambus app:</p>
<p>请按照以下步骤使用 Frambus 应用：</p>
<ol>
<li>Find the app at a suitable store.</li>
</ol>
<p>在应用商店搜索该应用。</p>
<ol>
<li>Pay for the app using a valid credit or debit card.</li>
</ol>
<p>使用有效的信用卡或借记卡购买该应用。</p>
<ol>
<li>Download the app.</li>
</ol>
<p>下载安装应用。</p>
<ol>
<li>Configure the app by assigning a value for the Foo variable in the /etc/Frambus file.</li>
</ol>
<p>在 /etc/Frambus 文件中，为 Foo 变量分配一个值来配置应用。</p>
<ol>
<li>Run the app by saying the magic word twice.</li>
</ol>
<p>The following two Bell Labs computer scientists invented popular shells:</p>
<ul>
<li>Stephen Bourne invented the Bourne Shell in 1977.</li>
<li>David Korn invented the KornShell in 1983.</li>
</ul>
<p>The KornShell’s features are a backwards-compatible superset of the Bourne Shell’s.</p>
<h4 id="消除或减少多余的单词"><a href="#消除或减少多余的单词" class="headerlink" title="消除或减少多余的单词"></a>消除或减少多余的单词</h4><p>许多句子都包含填充词，即文本的垃圾食品，它占用空间而不滋养读者。例如，看看是否可以在以下句子中找到不必要的单词：</p>
<p>An input value greater than 100 causes the triggering of logging.</p>
<p>替换<strong>causes the triggering of</strong> <strong>为</strong>动词 <strong>trigger</strong> 可以产生较短的句子：</p>
<p>An input value greater than 100 triggers logging.</p>
<p>通过练习，您会发现多余的单词，并享受删除他们的快乐。例如，考虑以下句子：</p>
<p>This design document provides a detailed description of Project Frambus.</p>
<p>句子 <strong>provides a detailed description of</strong> 可以缩减为动词 <strong>details</strong>，句子变为：</p>
<p>This design document details Project Frambus.</p>
<p>下表建议了一些常见的啰嗦的句子的替换：</p>
<table>
<thead>
<tr>
<th>啰嗦</th>
<th>简洁</th>
</tr>
</thead>
<tbody><tr>
<td>at this point in time</td>
<td>now</td>
</tr>
<tr>
<td>determine the location of</td>
<td>find</td>
</tr>
<tr>
<td>is able to</td>
<td>can</td>
</tr>
</tbody></table>
<h4 id="减少从句（可选）"><a href="#减少从句（可选）" class="headerlink" title="减少从句（可选）"></a>减少从句（可选）</h4><p>一个<strong>从句</strong>是一个句子中的独立逻辑片断，其中包含一个主语和动作。每个句子包含以下内容：</p>
<ul>
<li>一个主句</li>
<li>零个或多个从句</li>
</ul>
<p>从句在主从句中会修改了主要的意思。还会暗示着，从句比主句重要。例如，考虑以下句子：</p>
<p>Python是一种解释型编程语言，于1991年发明。</p>
<ul>
<li>主句：Python是一种解释型编程语言</li>
<li>从句：于1991年发明</li>
</ul>
<p>通常，您可以通过引入从句的词来识别它们。以下列表（绝不完整）显示了引入从句的常用词：</p>
<ul>
<li>which</li>
<li>that</li>
<li>because</li>
<li>whose</li>
<li>until</li>
<li>unless</li>
<li>since</li>
</ul>
<p>有些从句以逗号开头，有些则没有。例如，以下句子中突出显示的从属子句以单词“ <strong>因为**</strong>because”**开头，并且不包含逗号：</p>
<p>I prefer to code in C++ because I like strong data typing.</p>
<p>我更喜欢用C ++编写代码，因为我喜欢强大的数据类型。</p>
<p>编辑时，请仔细检查从属子句。记住one sentence = one idea 公式。句子中的从句是扩展单个概念还是将其分支成一个单独的概念？如果是后者，请考虑将有问题的从属子句分成单独的句子。</p>
<p>练习</p>
<p>判断哪些句子包含从句，这些从句应该被分支成独立的句子。(不要重写句子，只要找出需要重写的句子就可以了)</p>
<p>Python is an interpreted language, which means that the language can execute source code directly. </p>
<p>这个句子里的从句扩展了主句的意思，所以这个句子还可以。</p>
<p>Bash is a modern shell scripting language that takes many of its features from KornShell 88, which was developed at Bell Labs. </p>
<p>第一个从句扩展了主句的意思，而第二个从句则向另一个方向发展。把这个句子分成两部分。</p>
<p>Lisp is a programming language that relies on Polish prefix notation, which is one of the systems invented by the Polish logician Jan Łukasiewicz. </p>
<p>第一个从句扩展了主句的意思，而第二个从句则向另一个方向发展。把这个句子分成两部分。</p>
<p>I don’t want to say that Fortran is old, but only radiocarbon dating can determine its true age. </p>
<p>这个句子里的从句扩展了主句的意思，所以这个句子还可以。</p>
<h4 id="区分-that-和-which"><a href="#区分-that-和-which" class="headerlink" title="区分 that 和 which"></a>区分 that 和 which</h4><p><strong>that</strong> 和 <strong>which</strong> 都是用来引入了从句的。它们之间有什么区别？好吧，在某些国家，这两个词几乎可以互换。但是，不可避免的是，机智的美国读者会愤怒地宣布您再次混淆了这两个词。</p>
<p>在美国，使用 <strong>which</strong> 从句意味着从句是不必要的部分，而使用 <strong>that</strong> 则表明是一个重要的短语，句子不能没有。例如：</p>
<p>Python is an interpreted language, <strong>which</strong> means the processor runs the program directly.  </p>
<p>Python是一种解释性语言，这意味着处理器可以直接运行程序。</p>
<p>FORTRAN is perfect for mathematical calculations <strong>that</strong> don’t involve linear algebra. FORTRAN是完美的数学计算是不涉及线性代数。</p>
<p>这样的解释有用吗？可能不会。相反，请尝试以下操作：如果您大声朗读句子并听到从属子句之前的停顿，则使用<strong>which</strong>。如果你没有听到暂停，使用 <strong>that</strong>。返回并阅读两个例句。您听到第一句话中的停顿了吗？</p>
<p>在<strong>which</strong>前面放置逗号；在 <strong>that</strong> 之前不要使用逗号。</p>
<h3 id="列表和表格"><a href="#列表和表格" class="headerlink" title="列表和表格"></a>列表和表格</h3><p>读者通常喜欢列表，好的列表可以将混乱转变为有序。因此，在写作时，尽可能将散文转换为列表。</p>
<h4 id="选择正确的列表类型"><a href="#选择正确的列表类型" class="headerlink" title="选择正确的列表类型"></a>选择正确的列表类型</h4><p>以下列表在技术写作中占主导地位：</p>
<ul>
<li>无序列表 bullets lists</li>
<li>有序列表 numbered lists</li>
<li>嵌入式列表 embedded lists</li>
</ul>
<p>未排序的项目使用<strong>无序列表</strong>；排序的项目使用 <strong>有序列表</strong>。换一种说法：</p>
<ul>
<li>如果修改列表的顺序不会改变含义，则使用<strong>无序列表</strong>。</li>
<li>如果修改列表的顺序会改变含义，则使用<strong>有序列表</strong>。</li>
</ul>
<p>下面例子我们使用了<strong>无序列表</strong>，因为重新排列项目不会改变含义：</p>
<p>Bash提供以下字符串操作机制：</p>
<ul>
<li>子字符串会从字符串开头删除</li>
<li>将整个文件读入到一个字符串变量</li>
</ul>
<p>相比之下，下面例子使用有序列表，因为重新排列其项目会改变列表的含义：</p>
<p>请执行以下步骤来重新配置服务器：</p>
<ol>
<li>停止服务器。</li>
<li>编辑配置文件。</li>
<li>重新启动服务器。</li>
</ol>
<p><strong>嵌入式列表</strong>（有时称为 <strong>run-in</strong> 列表）包含在一个句子。例如，下面句子包含了四个项目的嵌入式列表。</p>
<p>llamacatcher API使调用者可以创建和查询美洲驼、分析羊驼、删除骆驼和跟踪单峰骆驼。</p>
<p>一般而言，嵌入式列表是展示信息较差的方法。尽量将<strong>嵌入式列表</strong>转换为无序列表或有序列表。</p>
<p>例如，上面的例子可以转化为无序列表：</p>
<p>llamacatcher API使调用者可以执行以下操作：</p>
<ul>
<li>创建和查询美洲驼。</li>
<li>分析羊驼。</li>
<li>删除骆驼。</li>
<li>跟踪单峰骆驼。</li>
</ul>
<p>将以下段落转换为列表形式：</p>
<p>今天，在工作中，我必须编写三个单元测试的代码，编写设计文档，并查看Janet的最新文档。下班后，我必须不用水洗车，然后不用毛巾擦干。</p>
<p>以下是列表的形式。</p>
<p>我今天工作必须执行以下操作：</p>
<ul>
<li>编码三个单元测试。</li>
<li>编写设计文档。</li>
<li>查看Janet的最新文档。</li>
</ul>
<p>下班后，我必须执行以下操作：</p>
<ol>
<li>不用水洗我的车。</li>
<li>不用毛巾擦干我的车。</li>
</ol>
<h4 id="保持清单项目平行"><a href="#保持清单项目平行" class="headerlink" title="保持清单项目平行"></a>保持清单项目平行</h4><p>如何区分好的列表和坏的列表？好的列表是平行的，坏的列表则相反。<strong>平行</strong>列表中的项目看起来属于一起。换句话说，平行列表中的所有项目都符合下面的参数：</p>
<ul>
<li>语法</li>
<li>逻辑类别</li>
<li>大小写</li>
<li>标点</li>
</ul>
<p>相反，<strong>非平行</strong>列表中的至少一项不符合上面参数。</p>
<p>例如，以下列表是平行的，因为所有项都是复数名词（语法），可食用（逻辑类别），小写（大小写），并且没有句点或逗号（标点符号）。</p>
<ul>
<li>carrots</li>
<li>potatoes</li>
<li>cabbages</li>
</ul>
<p>相比之下，以下列表在所有四个参数上都不是平行的：</p>
<ul>
<li>carrots</li>
<li>potatoes</li>
<li>The summer light obscures all memories of winter.</li>
</ul>
<p>以下列表是并行的，因为所有项目都是完整的句子，并带有完整的句子大写和标点符号：</p>
<ul>
<li>Carrots contain lots of Vitamin A. （胡萝卜含有大量的维生素A）</li>
<li>Potatoes taste delicious. （土豆味道鲜美）</li>
<li>Cabbages provide oodles of Vitamin K. (卷心菜提供大量的维生素K）</li>
</ul>
<p>列表中的第一项建立了读者的预期，后面项目反复强化这种预期。。</p>
<h4 id="列表项使用动词开头"><a href="#列表项使用动词开头" class="headerlink" title="列表项使用动词开头"></a>列表项使用动词开头</h4><p>推荐在有序列表中，项目使用动词开头，例如 <strong>打开**</strong>open** 或 <strong>启动</strong> <strong>start</strong>。下面是一些示例，请注意以下列表中所有的项目是如何以动词开头的：</p>
<ol>
<li>Download the Frambus app from Google Play or iTunes.</li>
</ol>
<p>下载 Frambus 应用（Google Play 或 iTunes）。</p>
<ol>
<li>Configure the Frambus app’s settings.</li>
</ol>
<p>配置 Frambus 应用的设置。</p>
<ol>
<li>Start the Frambus app.</li>
</ol>
<p>启动 Frambus 应用。</p>
<p>以下有序列表是不平行的，因为前两项以动词开头，而第三项则不是：</p>
<ol>
<li>Instantiate the Froobus class.</li>
</ol>
<p>实例化 Froobus 类。</p>
<ol>
<li>Invoke the Froobus.Salmonella() method.</li>
</ol>
<p>调用 Froobus.Salmonella() 方法。</p>
<ol>
<li>The process stalls.</li>
</ol>
<p>这个过程停滞不前。</p>
<h4 id="正确使用标点符号"><a href="#正确使用标点符号" class="headerlink" title="正确使用标点符号"></a>正确使用标点符号</h4><p>如果列表项是句子，请使用首字母大写并使用标点符号。否则，请勿使用句子大写和标点符号。例如，以下列表项是一个句子，因此使“ <strong>Most”</strong>中<strong>M</strong>大写， 并在句末加句号。</p>
<ul>
<li>Most carambolas have five ridges.</li>
</ul>
<p>但是，下面的列表项不是句子，所以使 <strong>the</strong> 中的 <strong>t</strong> 小写并不加标点。</p>
<ul>
<li>the color of lemons</li>
</ul>
<h4 id="创建有用的表格"><a href="#创建有用的表格" class="headerlink" title="创建有用的表格"></a>创建有用的表格</h4><p>分析型的头脑倾向于使用表格。如果一个页面上包含多个段落和一个表格，工程师往往将目光移向表格。</p>
<p>创建表格时，请遵循以下原则：</p>
<ul>
<li>用有意义的表头标记每列。不要让读者猜测每一列的内容。</li>
<li>避免在表格单元格中放入太多文本。如果一个表格单元格包含两个以上的句子，请问问自己该信息是否属于其他格式。</li>
<li>尽管不同的列可以保存不同类型的数据，但是要在各个列中尽可能的做到平行性。例如，特定表格列中的单元格不应是数字数据和著名的马戏团大象的混合。</li>
</ul>
<p><strong>注意：</strong>某些表格不能很好地呈现所有形式的信息。例如，在笔记本电脑上看起来不错的表格在手机上可能看起来很糟糕。</p>
<h4 id="介绍每个列表和表格"><a href="#介绍每个列表和表格" class="headerlink" title="介绍每个列表和表格"></a>介绍每个列表和表格</h4><p>我们建议在每个列表和表格前加上一句话，告诉读者该列表或表格代表什么。换句话说，给出列表或表格上下文：即使用冒号结束的介绍性句子。</p>
<p>尽管不是必需的，但我们建议将“ <strong>following</strong> ”一词放入介绍的句子中。参考如下例子：：</p>
<p>The following list identifies key performance parameters:</p>
<h5 id="以下列表确定了关键性能的参数"><a href="#以下列表确定了关键性能的参数" class="headerlink" title="以下列表确定了关键性能的参数:"></a>以下列表确定了关键性能的参数:</h5><p>Take the following steps to install the Frambus package:</p>
<h5 id="采取以下步骤安装-Frambus-软件包"><a href="#采取以下步骤安装-Frambus-软件包" class="headerlink" title="采取以下步骤安装 Frambus 软件包:"></a>采取以下步骤安装 Frambus 软件包:</h5><p>The following table summarizes our product’s features against our key competitors’ features:</p>
<p>下表总结了我们产品和主要竞争对手的特点：</p>
<p>练习</p>
<p>为下表写一个介绍性句子：</p>
<table>
<thead>
<tr>
<th>语言能力</th>
<th>发明者</th>
<th>推出年份</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td>Lisp</td>
<td>约翰·麦卡锡</td>
<td>1958年</td>
<td>递归</td>
</tr>
<tr>
<td>C++</td>
<td>比尼亚·斯特鲁斯特鲁普（Bjarne Stroustrup）</td>
<td>1979年</td>
<td>面向对象</td>
</tr>
<tr>
<td>Python</td>
<td>吉多·范·罗苏姆（Guido van Rossum）</td>
<td>1994年</td>
<td>简单</td>
</tr>
</tbody></table>
<p>The following table contains a few key facts about some popular programming languages:</p>
<p>下表展示了一些流行编程语言的关键信息：</p>
<p>The following table identifies the inventor, year of invention, and key feature of three popular programming languages: </p>
<p>下表列出了三种流行编程语言的发明者、发明年份和主要特征：</p>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>本节提供了一些构建内聚段落的指导原则。但是首先，先读一下下面的这段话：</p>
<p>写作的流程很简单：理清主题各部分之间的依赖关系，并以逻辑流的形式呈现这些部分，使读者能够理解您。</p>
<h4 id="写一个精彩的开头句"><a href="#写一个精彩的开头句" class="headerlink" title="写一个精彩的开头句"></a>写一个精彩的开头句</h4><p>开头句子是任何段落中最重要的句子。忙碌的读者只关注开头的句子，有时会跳过后面的句子。因此，将精力集中在开头句上。</p>
<p>好的开头句确立了段落的中心点。以下段落就是个好例子：</p>
<p>循环会多次运行同一代码块。例如，假设您编写了一段代码来检测输入行是否以句号结尾。要计算一百万条输入行，那请创建一个运行一百万次的循环。</p>
<p>前面的开头句将段落的主题确立为循环的简介。相比之下，以下开篇句子将读者引向错误的方向：</p>
<p>代码块是相同功能内的连续代码集。例如，假设您编写了一段代码来检测输入行是否以句点结尾。要评估一百万条输入行，请创建一个运行一百万次的循环。</p>
<p><strong>注意：</strong>有效的开头句可以采用多种形式。也就是说，并非所有出色的段落都以陈述主题的句子开头。例如，以反问开头的段落可以吸引读者。</p>
<h4 id="一个段落聚焦一个主题"><a href="#一个段落聚焦一个主题" class="headerlink" title="一个段落聚焦一个主题"></a>一个段落聚焦一个主题</h4><p>一个段落应代表一个独立的逻辑单元。将每个段落限制为当前主题。不要描述将来的话题会发生什么或过去的话题会发生什么。当我们要修改编辑时，一定要毫不犹豫地删除（或移至另一段）任何与当前主题无直接关联的句子。</p>
<p>下面例子中，假设开头句正确表达了段落的主题，你能找到其中不符合该主题的句子吗？</p>
<p>毕达哥拉斯定理指出，直角三角形的两条直角边的平方和等于斜边的平方。三角形的周长等于三个边的总和。您可以使用勾股定理来测量对角线距离。例如，如果您知道乒乓球桌的长度和宽度，则可以使用勾股定理确定对角线距离。要计算乒乓球桌的周长，请将长度和宽度相加，然后将其乘以2。</p>
<p>我们删去了第二和第五句话，得出了一个专门针对勾股定理的段落：</p>
<p>毕达哥拉斯定理指出，直角三角形的两条直角边的平方和等于斜边的平方。 三角形的周长等于三个边的总和。您可以使用勾股定理来测量对角线距离。例如，如果您知道乒乓球桌的长度和宽度，则可以使用勾股定理确定对角线距离。要计算乒乓球桌的周长，请将长度和宽度相加，然后将其乘以2。</p>
<h4 id="段落不要太长或太短"><a href="#段落不要太长或太短" class="headerlink" title="段落不要太长或太短"></a>段落不要太长或太短</h4><p>长段落在视觉上令人生畏。很长的段落构成了可怕的“文字墙”，读者会忽略。读者通常欢迎只有三到五个句子的段落，同时忽略超过七个句子的段落。修订时，请考虑将很长的段落分为两个单独的段落。</p>
<p>相反，段落也不要太短。如果您的文档包含大量的单句段落，则说明您语言组织不够。请设法将这些零散段落组合成连贯的段落，或者组合成列表形式。</p>
<h4 id="回答what，why-以及-how"><a href="#回答what，why-以及-how" class="headerlink" title="回答what，why 以及 how"></a>回答what，why 以及 how</h4><p>好的段落回答以下三个问题：</p>
<ol>
<li><strong>What -</strong> 告诉读者这是什么</li>
<li><strong>Why -</strong> 为什么让读者知道这一点很重要</li>
<li><strong>How -</strong> 读者应如何使用这些知识。或者，读者应该如何知道您的观点是正确的？</li>
</ol>
<p>下面例子就回答了 What，Why 以及 How：</p>
<p><strong>** 该 grap() 函数返回一个数据集的平均值和中位数之间的增量。**</strong> <strong>** 许多人毫不怀疑地相信，平均值之道总是真理。但是，平均值很容易受到几个非常大或非常小的数据点的影响。**</strong> <strong><strong>调用garp()可以帮助确定是否有几个非常大或非常小的数据点对均值的影响太大。相比较高的grap()值，较小的grap()值说明平均值更有意义。</strong></strong></p>
<h3 id="受众"><a href="#受众" class="headerlink" title="受众"></a>受众</h3><p>我们认为您应该喜欢数学。因此，本章节以一个公式开始：</p>
<p>好的文档 = 您的受众完成一项任务所需的知识和技能 - 您的受众当前的知识和技能</p>
<p>换句话说，请确保您的文档提供了受众所需的信息，而受众还没有这些信息。因此，本章节说明了如何执行以下操作：</p>
<ul>
<li>定义您的受众群体。</li>
<li>确定您的读者需要学习的内容。</li>
<li>提供合适您读者的文档。</li>
</ul>
<p>如以下视频所示，针对错误的受众可能会很混乱：<a href="https://youtu.be/eFtXIrmsMwI" target="_blank" rel="noopener">https://youtu.be/eFtXIrmsMwI</a></p>
<h4 id="定义您的受众"><a href="#定义您的受众" class="headerlink" title="定义您的受众"></a>定义您的受众</h4><p>认真的文档工作会花费了大量时间和精力来定义他们的受众。这些工作可能进行用户调查，用户体验研究，聚焦小组和文档测试。您可能没有那么多时间，所以本章节采用一种更简单的方法。</p>
<p>首先确定您的受众<strong>角色</strong>。示例角色包括：</p>
<ul>
<li>软件工程师</li>
<li>技术非工程师角色（例如技术项目经理）</li>
<li>科学家</li>
<li>科学领域的专业人员（例如医师）</li>
<li>工科本科生</li>
<li>工科研究生</li>
<li>非技术职位</li>
</ul>
<p>我们很高兴地认识到，许多非技术人员具有出色的技术和数学技能。但是，角色仍然是定义受众时必不可少的。具有相同角色的人通常对某些基本技能和知识有一定的共识。例如：</p>
<ul>
<li>大多数软件工程师都知道流行的排序算法，Big O 符号和至少一种编程语言。因此，您可以假定软件工程师了解O(n)的含义，但不能假定非技术角色也可以了解O(n)。</li>
<li>针对同一研究项目，医生的专业报告和普通受众的报纸文章应该看起来有很大的不同。</li>
<li>大学教授对研究生进行一种新型的机器学习方法的教学方法，会完全不同于对本科生的教学方法。</li>
</ul>
<p>如果处于同一角色的每个人都共享完全相同的知识，那么写作会容易得多。不幸的是，同一角色内的知识也会迅速产生分支。Amal是Python方面的专家，Sharon的专业知识是C++，Micah的专业知识是Java。Kara喜欢Linux，但是David只知道iOS。</p>
<p>角色本身不足以定义受众。也就是说，您还必须考虑受众对知识的接近程度。Project Frombus的软件工程师对相关的Project Dingus有所了解，但对无关的Carambola项目一无所知。普通的心脏病专家比普通的软件工程师对耳朵问题的了解要多，但比听觉专家要少得多。</p>
<p>时间也会造成差距。例如，几乎所有软件工程师都学过微积分。但是，大多数软件工程师在工作中并不使用微积分，因此他们对微积分的了解逐渐消失。相反，与同一项目的新工程师相比，经验丰富的工程师通常对当前项目的了解要多得多。</p>
<h5 id="样本受众分析"><a href="#样本受众分析" class="headerlink" title="样本受众分析"></a>样本受众分析</h5><p>以下是虚拟Zylmon项目的样本受众分析：</p>
<p>Zylmon项目的目标受众包括以下角色：</p>
<ul>
<li>软件工程师</li>
<li>技术产品经理</li>
</ul>
<p>目标受众在以下方面有相近的知识：</p>
<ul>
<li>我的目标受众已经知道Zyljeune API，它们与Zylmon API有点相似。</li>
<li>我的目标读者知道C ++，但通常没有在新的Winged Victory开发环境中构建C ++程序。</li>
<li>我的目标受众是大学里的线性代数，但团队的许多成员都需要复习矩阵乘法。</li>
</ul>
<h4 id="确定受众可以学到什么"><a href="#确定受众可以学到什么" class="headerlink" title="确定受众可以学到什么"></a>确定受众可以学到什么</h4><p>写下目标受众学习以实现目标所需的一切清单。在某些情况下，列表应包含目标受众需要执行的任务。例如：</p>
<p>阅读文档之后，受众将知道如何执行以下任务：</p>
<ul>
<li>使用Zylmon API按价格列出酒店。</li>
<li>使用Zylmon API可以按位置列出酒店。</li>
<li>使用Zylmon API通过用户评分列出酒店。</li>
</ul>
<p>请注意，您的受众有时必须按一定顺序完成任务。例如，您的受众可能需要在学习如何编写特定类型的程序之前，先学习如何在新的开发环境中构建和执行程序。</p>
<p>如果您正在编写设计规范，那么您的列表应该关注目标受众应该学习的信息，而不是精通特定任务：例如：</p>
<p>阅读设计规范后，受众将学到以下内容：</p>
<ul>
<li>Zylmon胜过Zyljeune的三个原因。</li>
<li>Zylmon花了5.25个工程年来开发的五个原因。</li>
</ul>
<h4 id="使文档适合受众"><a href="#使文档适合受众" class="headerlink" title="使文档适合受众"></a>使文档适合受众</h4><p>满足受众需求的写作需要无私的同理心。您必须创建满足受众好奇心而不是您自己的解释。为了使文档适合受众，您如何跳出自己的脚步？不幸的是，我们无法提供简单的答案。但是，我们可以提供一些要重点关注的参数。</p>
<h5 id="词汇和概念"><a href="#词汇和概念" class="headerlink" title="词汇和概念"></a>词汇和概念</h5><p>使您的词汇与受众匹配。请参阅<a href="https://docs.google.com/document/d/16aoMrMGHPIR1i_eUNRvksdDdwcDG6KiOJN6Vfh-n8-s/edit#heading=h.j6q144iyxgk4" target="_blank" rel="noopener">单词</a>以获取帮助。</p>
<p>注意亲近。您团队中的人员可能理解您团队的缩写，但是，其他团队中的人员是否也理解相同的缩写？随着目标受众的扩大，假设您必须进行更多说明。</p>
<p>同样，软件团队中经验丰富的人员可能了解团队项目的实施细节和数据结构，但几乎其他所有人（包括团队的新成员）都不了解。除非您是专门为团队中其他经验丰富的成员撰写的，否则通常您必须解释的内容超出了您的预期。</p>
<h5 id="知识的魔咒"><a href="#知识的魔咒" class="headerlink" title="知识的魔咒"></a>知识的魔咒</h5><p>专家经常遭受知识的魔咒，也就是说，他们对主题的专业理解破坏了对新手的解释。作为专家，很容易忘记新手不知道您已经知道的知识。新手可能不理解解释，而这些解释需要专家们不停地用和各种引用以及更深的知识来进行各种解释。</p>
<p>从新手的角度来看，知识的磨咒就好是由于模块尚未编译而导致的“找不到文件”链接器错误。</p>
<h5 id="简单的话"><a href="#简单的话" class="headerlink" title="简单的话"></a>简单的话</h5><p>英语已经成为全球技术交流的主要语言。但是，英语并不是大多数技术读者的母语。因此，更喜欢简单的单词而不是复杂的单词。避免使用奥术，过时或过于复杂的英语单词； <a href="https://www.google.com/search?q=sesquipedalian" target="_blank" rel="noopener">倍半数</a> 和稀有词会排斥大多数读者。</p>
<h5 id="文化中立和成语"><a href="#文化中立和成语" class="headerlink" title="文化中立和成语"></a>文化中立和成语</h5><p>使您的作品保持文化中立。不需要读者了解NASCAR，板球或相扑的复杂性，以了解某个软件的工作原理。例如，下面的句子（加上像苹果派一样的美国人的棒球比喻）可能会使某些巴黎读者感到困惑：</p>
<p>If Frambus 5.0 was a solid single, Frambus 6.0 is a stand-up double.</p>
<p><strong>习惯用语</strong>是短语，其整体含义不同于该短语中各个单词的字面含义。例如，以下短语是成语：</p>
<ul>
<li>a piece of cake</li>
<li>Bob’s your uncle</li>
</ul>
<p>蛋糕？鲍勃？大多数美国读者都认可第一个习惯用法。大多数英国读者都认可第二种成语。如果您是专门为英国观众写的书，那么 鲍勃的叔叔 就可以了。但是，如果您要为国际读者写作，那么用此任务替换该惯用法很容易。</p>
<p>习语在我们的演讲中根深蒂固，以至于习语的特殊非文字含义对我们来说是不可见的。也就是说，习语或成语是知识魔咒的另一种形式。</p>
<p>请注意，受众中的某些人使用翻译软件来阅读您的文档。比起简单朴素的英语，翻译软件往往在文化参考和习语方面很无力。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>你可以写句子。您可以编写段落。但是，您可以将所有这些段落组织到一个连贯的文档中吗？</p>
<h4 id="说明文件范围"><a href="#说明文件范围" class="headerlink" title="说明文件范围"></a>说明文件范围</h4><p>一个好的文档首先要定义其范围。例如：</p>
<p>本文档描述了Project Frambus的总体设计。</p>
<p>更好的文档还定义了未覆盖的范围，即目标读者可能希望文档涵盖但是文档并没有未涵盖主题。例如：</p>
<p>本文档未介绍相关技术Froobus项目的设计。</p>
<p>这些作用域和非作用域语句不仅使读者受益，而且使作者（您）受益。在编写时，如果文档的内容偏离范围声明，则必须重新调整文档的范围或修改范围声明。在查看初稿时，请删除（或分支到另一个文档）任何不利于满足范围说明的部分。</p>
<h4 id="陈述你的受众"><a href="#陈述你的受众" class="headerlink" title="陈述你的受众"></a>陈述你的受众</h4><p>好的文档明确指定了它的受众。例如：</p>
<p>我为支持Project Frambus的测试工程师编写了此文档。</p>
<p>除了受众的角色之外，良好的受众声明还可以指定任何必备的知识或经验。例如：</p>
<p>本文档假定您了解矩阵乘法以及如何冲泡一杯真正好的茶。</p>
<p>在某些情况下，受众声明还必须指定先决条件文件。例如：</p>
<p>在阅读本文档之前，您必须阅读“ Project Froobus：A New Hope”。</p>
<h4 id="预先建立关键观点"><a href="#预先建立关键观点" class="headerlink" title="预先建立关键观点"></a>预先建立关键观点</h4><p>工程师和科学家们很忙，他们不一定会阅读您全部76页的设计文档。想象一下，您的同龄人可能只会阅读第一页的第一段。在查看文档时，请确保文档的开头回答了读者的基本问题。</p>
<p>专业作家将大量精力放在第一页上，以增加读者进入第二页的几率。但是，任何长文档的第一页都是最难写的页面。因此，准备好多次修改页面。</p>
<p>始终为长的工程文档写一份总结性摘要（TL; DR）。尽管这个摘要必须非常简短，但是应该花很多时间来编写它。无聊或令人困惑的执行摘要是一个危险信号，会让你的读者直接你的文档丢到垃圾桶。</p>
<h4 id="为受众写作"><a href="#为受众写作" class="headerlink" title="为受众写作"></a>为受众写作</h4><p>本课程反复强调定义受众的重要性。在本节中，我们将重点放在受众定义上，以将其组织为文档。</p>
<h5 id="定义受众"><a href="#定义受众" class="headerlink" title="定义受众"></a>定义受众</h5><p>回答以下问题有助于您确定文档应包含的内容：</p>
<ul>
<li>谁是您的目标受众？</li>
<li>您的读者在阅读文档之前已经知道什么？</li>
<li>您的读者在阅读您的文档后应该知道或能够做什么？</li>
</ul>
<p>例如，假设您已经发明了一种新的排序算法。以下列表包含对以上问题的一些潜在答案：</p>
<ul>
<li><p>我的目标受众是组织中的所有软件工程师。</p>
</li>
<li><p>我的大多数目标受众在学校期间都学习了排序算法。但是，多年以来，大约有25％的目标受众尚未实现或评估排序算法。</p>
</li>
<li><p>阅读此文档后：</p>
</li>
<li><ol>
<li>读者知道该算法如何工作。</li>
<li>读者可以用所需的语言来实现算法。</li>
<li>读者知道在什么情况下该算法要优于流行的快速排序算法。</li>
<li>读者了解某些情况下的性能下降。</li>
</ol>
</li>
</ul>
<h5 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h5><p>定义受众之后，整理文档以提供读者在阅读文档后应该知道或能够做的事情。例如，文档的大纲可能如下所示：</p>
<ol>
<li><p>算法概述</p>
</li>
<li><ol>
<li>Big O 复杂度</li>
<li>用伪代码实现</li>
</ol>
</li>
<li><p>用C语言实现的示例</p>
</li>
<li><ol>
<li>使用其他语言实现的提示</li>
</ol>
</li>
<li><p>更深入的算法分析</p>
</li>
<li><ol>
<li>最佳数据集</li>
<li>边界案例问题</li>
</ol>
</li>
</ol>
<p>此外，使用受众群体定义可帮助您选择编写文档的正确方法。例如，目标受众研究了排序算法，但是大约四分之一的受众可能不记得不同算法的细节。因此，您的文档可能应该插入指向 quicksort 的现有教程的链接，而不是试图解释 quicksort。</p>
<h4 id="将主题分为几个部分"><a href="#将主题分为几个部分" class="headerlink" title="将主题分为几个部分"></a>将主题分为几个部分</h4><p>您将代码模块化为文件，类和方法。模块化代码更易于阅读，理解，维护和重用。使您的文档模块化可为您带来相同的好处。您可能对代码中的功能模块化有很强的直觉，但是如何将这些原理应用于您的写作中？</p>
<p>想象一下，您有一个空罐子，需要把一大堆岩石，粗砂砾和沙子打包。您将如何打包它们以确保可以将所有物料放入罐子中？当然，您需要先放置大石头，然后倒入砾石中，然后用沙子填充剩余的空气空间。如果尝试以相反的顺序执行此操作，则将失败。</p>
<p>读者的头很像一个空罐子，您的信息通常分为三种大小：岩石，砾石和沙子。断面是岩石。您需要用石头来构造读者的罐头内部的空间，以接受其余信息。</p>
<p>但是，您如何确定什么是大石头而不是砾石？一种策略是在短时间内（可能只有2到5分钟）记录自己谈论或随意写的话题。是的，这需要一定的纪律。以测试您会产生了什么内存。你做了以下的事了吗？</p>
<ul>
<li>用模糊不清的方式描述概念？</li>
<li>列出您的受众需要完成的步骤才能达到目标？</li>
<li>描述系统可以表达的属性的排列？</li>
</ul>
<p>您所指的未指定内容可能是构成主题的大型概念。如果您的演讲没有做到这一点，请返回并尝试这种结构。</p>
<h3 id="标点（可选）"><a href="#标点（可选）" class="headerlink" title="标点（可选）"></a>标点（可选）</h3><h4 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h4><p>编程语言强制执行有关标点的明确规则。相反，在英语中，有关逗号的规则有些模糊。作为指导，在读者自然会在句子中某处停顿的地方插入逗号。用音乐上来做类比，如果句号是整个音符的休止符，那么逗号可能是半音符或四分音符的休止符。换句话说，逗号的暂停要短于一段时间。例如，如果您大声阅读以下句子，则可能会在单词 <em>just</em> 之前短暂停留：</p>
<p>C behaves as a mid-level language, just a couple of steps up in abstraction from assembly language.</p>
<p>有些情况下需要逗号。例如，使用逗号分隔嵌入式列表中的项目，如下所示：</p>
<p>我们公司使用C++，Python，Java和JavaScript。</p>
<p>您可能想知道列表的最终逗号，该逗号插入在项目N-1和N之间。该逗号（称为<strong>串行逗号</strong>或<strong>牛津逗号）是</strong>有争议的。我们建议仅提供最后一个逗号，因为技术写作需要选择最不明确的解决方案。也就是说，我们实际上更喜欢通过将嵌入列表转换为项目符号列表来规避争议。</p>
<p>在表达条件的句子中，在条件和结果之间放置逗号。例如，以下两个句子在正确的位置提供逗号：</p>
<p>If the program runs slowly, try the –perf flag.</p>
<p>If the program runs slowly, then try the –perf flag.</p>
<p>您还可以在一对逗号之间进行快速定义或离题，如以下示例所示：</p>
<p>Python, an easy-to-use language, has gained significant momentum in recent years.</p>
<p>最后，避免使用逗号将两个独立的想法粘贴在一起。例如，以下句子中的逗号是被称为<strong>逗号拼接</strong>的标点重罪：</p>
<p>萨曼莎（Samantha）是一位出色的编码员，她编写了大量测试。</p>
<p>使用句号而不是逗号来分隔两个独立的思想。例如：</p>
<p>萨曼莎（Samantha）是一位出色的编码员。她写了大量的测试。</p>
<h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>一个时期将不同的思想分开；分号统一了高度相关的思想。例如，请注意以下句子中的分号如何结合了第一和第二个想法：</p>
<p>更新配置文件后，重新运行Frambus；更新现有源代码后，请勿重新运行Frambus。</p>
<p>分号之前和之后的思想必须全部是语法完整的句子。例如，以下分号是错误的，因为分号后面的段落不是完整的句子：</p>
<p>Rerun Frambus after updating your configuration file; not after updating existing source code.</p>
<p>在使用分号之前，请先问问自己，如果您将思想转到分号的相对两侧，该句子是否仍然有意义。例如，反转前面的示例仍会产生一个有效的句子：</p>
<p>Don’t rerun Frambus after updating existing source code; rerun Frambus after updating your configuration file.</p>
<p>您几乎应该始终使用逗号（而不是分号）来分隔嵌入列表中的项目。例如，以下分号的使用是不正确的：</p>
<p>Style guides are bigger than the moon; more essential than oxygen; and completely inscrutable.</p>
<p>许多句子在分号后立即放置过渡词或短语。在这种情况下，请在转换后放置逗号。请注意以下两个示例中过渡后的逗号：</p>
<p>Frambus provides no official open source package for string manipulation; however<strong>,</strong> subsets of string manipulation packages are available from other open source projects.</p>
<p>Even seemingly trivial code changes can cause bugs; therefore<strong>,</strong> write abundant unit tests.</p>
<h4 id="破折号"><a href="#破折号" class="headerlink" title="破折号"></a>破折号</h4><p>破折号是引人注目的标点符号，具有丰富的标点符号可能性。破折号比逗号表示更长的暂停（更大的中断）。如果逗号是四分音符休止符，则破折号是半音符休止符。例如：</p>
<p>C++ is a rich language—one requiring extensive experience to master.</p>
<p>编写者有时使用一对破折号来阻止题外话，如以下示例所示：</p>
<p><strong>Protocol Buffers</strong>—often nicknamed <strong>protobufs</strong>—encode structured data in an efficient yet extensible format.</p>
<p>我们可以在前面的示例中使用逗号而不是破折号吗？当然。为什么我们选择破折号而不是逗号？感觉。艺术。经验。请记住，英语的标点符号是糊状且具有延展性的。</p>
<h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>使用括号可以保留次要点和题外话。括号告诉读者，所附文字并不重要。</p>
<p>有关句号和括号的规则使许多写作者大跌眼镜。以下是标准：</p>
<ul>
<li>如果一对圆括号包含整个句子，则句号在右圆括号内。</li>
<li>如果一对括号使一个句子结尾但不包含整个句子，则句点就在右括号之外。</li>
</ul>
<p>例如：</p>
<p>(Incidentally, Protocol Buffers make great birthday gifts.)</p>
<p>Binary mode relies on the more compact native form (described later in this document).</p>
<h3 id="Markdown-（可选）"><a href="#Markdown-（可选）" class="headerlink" title="Markdown （可选）"></a>Markdown （可选）</h3><p><strong>Markdown</strong>是一种轻量级的标记语言，许多技术专业人员使用它来创建和编辑技术文档。使用Markdown，您可以在纯文本编辑器(如vi或Emacs)中编写文本，插入特殊字符来创建标题、加粗、项目符号等。例如，下面的示例显示了一个用Markdown格式化的简单技术文档</p>
<p>## bash and ksh</p>
<p><strong>bash</strong> closely resembles an older shell named <strong>ksh</strong>. The key</p>
<p><em>practical</em> difference between the two shells is as follows:</p>
<p>* More people know bash than ksh, so it is easier to get help for bash problems than ksh problems.</p>
<p>上述的文档会被渲染成如下的样子：</p>
<p><strong>bash and ksh</strong> <strong>bash</strong> closely resembles an older shell named <strong>ksh</strong>. The key <em>practical</em> difference between the two shells is as follows: More people know bash than ksh, so it is easier to get help for bash problems than ksh problems.</p>
<p>Markdown解析器将Markdown文件转换成HTML。然后，浏览器可以将生成的HTML显示给读者。我们建议您通过学习下面的教程来熟悉Markdown</p>
<ul>
<li><a href="https://www.markdowntutorial.com/" target="_blank" rel="noopener">www.markdowntutorial.com</a></li>
<li><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">Mastering Markdown</a></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>始终使用术语。</li>
<li>避免模棱两可的代词。</li>
<li>首选主动语态而不是被动语态。</li>
<li>选择强动词。</li>
<li>选择具体的动词而不是模糊的动词。</li>
<li>将每个句子聚焦在一个事上。</li>
<li>将一些长句子转换为列表。</li>
<li>消除不必要的单词。</li>
<li>如果次序重要，请使用编号列表；与次序无关，则使用项目符号列表。</li>
<li>保持列表项的平行属行。</li>
<li>用祈使性单词开始编号的列表项。</li>
<li>正确地介绍列表和表格。</li>
<li>创建漂亮的开头句，以建立本段落的中心思想。</li>
<li>将每个段落集中在一个主题上。</li>
<li>确定您的受众需要学习的内容和目标。</li>
<li>让文档贴近您的受众。</li>
<li>在文档开头处说明文档的主要观点。</li>
</ul>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="自我编辑"><a href="#自我编辑" class="headerlink" title="自我编辑"></a>自我编辑</h2><p>想象一下，您刚刚编写了文档的初稿。您如何做得更好？在大多数情况下，达到可最终发布的文档是一个反复迭代的过程。从零开始形成初稿通常是最困难的步骤。编写完初稿后，还要确保能留出大量时间来完善文档。</p>
<p>本章节中的编辑技巧可以帮助您将初稿转换为文档，从而更清晰地传达您的受众所需的信息。你可以使用其中的一个小或全部的技巧；但重要的是找到适合您的策略，然后将该策略作为写作日常的一部分。</p>
<p><strong>注意：</strong>本章节的技巧以技术写作一的基本写作和编辑技能为基础。本单元总结了该课程中有用的编辑技术。有关更详细的复习，请访问技术写作的第一部分 <a href="https://docs.google.com/document/d/16aoMrMGHPIR1i_eUNRvksdDdwcDG6KiOJN6Vfh-n8-s/edit#heading=h.zrd92of27j0" target="_blank" rel="noopener">自学单元</a>。</p>
<h3 id="采用样式指南"><a href="#采用样式指南" class="headerlink" title="采用样式指南"></a>采用样式指南</h3><p>公司，组织和大型开源项目经常采用已有的风格样式。<a href="https://developers.google.com/" target="_blank" rel="noopener">Google Developers</a>网站上的许多文档项目都遵循《 <a href="https://developers.google.com/style" target="_blank" rel="noopener">Google Developer文档样式指南》</a>。如果您以前从未使用过样式指南，那么乍一看，《 Google Developer文档样式指南》可能看起来有点吓人，它提供了有关语法，标点符号，格式设置和计算机接口文档等主题的详细指南。所以，您可能更喜欢从 《<a href="https://developers.google.com/style/highlights" target="_blank" rel="noopener">样式指南精要</a>》 开始。</p>
<p><strong>注意：</strong>对于较小的项目，例如团队文档或小型开源项目，《样式指南精要》已经够你用了。</p>
<p>精要内容中列出的一些准则在第一部分中有介绍。您应该可以回想起一些：</p>
<ul>
<li>使用<a href="https://developers.google.com/tech-writing/one/active-voice" target="_blank" rel="noopener">主动语态</a>来明确谁在执行操作。</li>
<li>将顺序步骤格式化为 <a href="https://developers.google.com/tech-writing/one/lists-and-tables" target="_blank" rel="noopener">编号列表</a>。</li>
<li>将其他列表格式化为项目符号列表。</li>
</ul>
<p>精要还介绍了许多其他技术，这些技术在编写技术文档时可能会有用，例如：</p>
<ul>
<li><a href="https://developers.google.com/style/person" target="_blank" rel="noopener">写第二人称</a>。将您的受众称为“您”而不是“我们”。</li>
<li><a href="https://developers.google.com/style/clause-order" target="_blank" rel="noopener">将条件子句放在指令之前</a>，而不是之后。</li>
<li>为与代码相关的文本格式设置<a href="https://developers.google.com/style/code-in-text" target="_blank" rel="noopener">代码字体</a>。</li>
</ul>
<h3 id="像受众一样思考"><a href="#像受众一样思考" class="headerlink" title="像受众一样思考"></a>像受众一样思考</h3><p>你的受众是谁？退后一步，尝试从他们的角度阅读草稿。确保文档的目的明确，并为读者可能不熟悉的任何术语或概念提供定义和解释。</p>
<p>给你的受众设置一个“人设”可能会对写作有所帮助。其中可以包含以下任何属性：</p>
<ul>
<li><p>角色，例如：系统工程师 或 <em>QA</em>测试人员。</p>
</li>
<li><p>最终目标，例如：还原数据库。</p>
</li>
<li><p>知识和经验的一组假设。例如，您可能假设您的“人设”是：</p>
</li>
<li><ul>
<li>熟悉Python。</li>
<li>运行Linux操作系统。</li>
<li>平时在命令行的环境工作。</li>
</ul>
</li>
</ul>
<p>然后，您可以模拟他们来阅读初稿。告诉受众您所做的任何假设可能特别有用。您还可以提供指向资源的链接，如果他们需要复习特定主题，他们可以在其中了解更多信息。</p>
<p>请注意，过分依赖角色（或两个角色）可能会导致文档过于狭窄而无法对大多数读者有用。</p>
<p>有关技术写作一的复习和更多信息，请参阅<a href="https://docs.google.com/document/d/16aoMrMGHPIR1i_eUNRvksdDdwcDG6KiOJN6Vfh-n8-s/edit#heading=h.lxllsbersc8a" target="_blank" rel="noopener">受众</a>自学单元。</p>
<h3 id="大声朗读"><a href="#大声朗读" class="headerlink" title="大声朗读"></a>大声朗读</h3><p>不同的上下文或写作风格可能会疏远、吸引甚至打扰你的受众。给定文档设定什么样的样式在一定程度上取决于受众。例如，旨在招募新志愿者的开放源项目贡献者指南可能采用更非正式和对话的风格，而商业企业应用程序的开发者指南则更可能采用更正式的风格。</p>
<p>要检查您的写作是否有对话性，请大声朗读。识别尴尬的措词，太长的句子或其他不自然的内容。另外，您也可以尝试请其他人为您朗读您的草稿。</p>
<p>有关调整写作风格以适合受众的更多信息，请参阅<a href="https://developers.google.com/style/tone" target="_blank" rel="noopener">样式和作者语气</a>。</p>
<h3 id="稍后再回来"><a href="#稍后再回来" class="headerlink" title="稍后再回来"></a>稍后再回来</h3><p>在您编写了第一稿（或第二稿或第三稿）之后，请将其放在一边。一小时（或两到三个）后再回来阅读，这样在阅读时会有新鲜感。于是，您几乎总是会注意到一些可以改进的地方。</p>
<h3 id="改变场景"><a href="#改变场景" class="headerlink" title="改变场景"></a>改变场景</h3><p>一些写作者喜欢打印他们的文档，并且手里拿着一支红色铅笔，查看纸质的文档副本。这种换一种场景来审阅自己的作品时，可以帮助您找到需要改进的地方。如果要使这个经典技巧更富现代感，你可将文稿复制到其他文档中并更改字体，大小和颜色。</p>
<h3 id="寻找同伴编辑"><a href="#寻找同伴编辑" class="headerlink" title="寻找同伴编辑"></a>寻找同伴编辑</h3><p>就像工程师需要同伴人审查他们的代码一样，写作者也需要其他编辑者来向他们提供有关文档的反馈。请他人来审阅您的文档，并给您具体的建设性意见。您的同伴编辑者不必是文档技术主题的主题专家，但他们确实需要熟悉您遵循的样式指南。</p>
<h2 id="组织大型文档"><a href="#组织大型文档" class="headerlink" title="组织大型文档"></a>组织大型文档</h2><p>您如何将大量信息归并到一整个文档或网站中？或者说，您如何将现有的混乱文档或网站重组为平易近人且有用的工具？以下策略可以帮助您：</p>
<ul>
<li>整理组织文档</li>
<li>添加导航</li>
<li>逐步展开信息</li>
</ul>
<h3 id="什么时候写大文档"><a href="#什么时候写大文档" class="headerlink" title="什么时候写大文档"></a>什么时候写大文档</h3><p>您可以将一组信息组织成较长的单一文档或一组较短的相关文档。一组较短的相互关联的文档通常以网站，Wiki或类似结构化格式发布。</p>
<p>有些读者比其他人来说更喜欢长文档。对此，对于这两类的读者，他们会有如下的搜索行为：</p>
<ul>
<li>Hong发现阅读长文件很困难并且迷失方向。他更喜欢使用站点搜索来找到问题的答案。</li>
<li>Rose更喜欢单一的长文档。她经常使用Web浏览器中的内置页面搜索功能在当前页面上找到有用的信息。</li>
</ul>
<p>那么，您应该将材料组织成一个文档还是网站中的一组文档？请考虑以下准则：</p>
<ul>
<li>当针对刚接触该主题的读者时，How-to操作指南，入门介绍性的概述和概念指南通常以较短的文档出现时，会更好地发挥作用。例如，对于您的主题完全陌生的读者可能很难记住很多新的术语，概念和事实。请记住，您的受众阅读您的文档的目的可能是想以最快的速度来全面地了解该主题。</li>
<li>深入的教程，最佳实践指南和命令行参考页可以以长文档的方式出现，尤其是针对那些已经对工具和主题有一定经验的读者。</li>
<li>出色的教程一般可以依靠叙述的方式来引导读者完成较长文档中的一系列相关任务。但是，即使是大型教程，很多时候分割成较小的部分会更好。</li>
<li>许多较长的文档并非连续阅读。例如，用户通常浏览参考页面以搜索某个命令的参数或标志的说明。</li>
</ul>
<p>本章节的其余部分介绍了可用于编写较长文档的技术，例如教程和一些概念性指南。</p>
<h3 id="整理文件"><a href="#整理文件" class="headerlink" title="整理文件"></a>整理文件</h3><p>本节提出了一些准备写长文档的技术，包括创建大纲和起草引言。在完成文档的初稿之后，可以根据您的概述和简介对其进行复审，以确保您没有错过任何本来打算涵盖的内容。</p>
<h4 id="文档大纲"><a href="#文档大纲" class="headerlink" title="文档大纲"></a>文档大纲</h4><p>从结构化的高层级的大纲开始，可以帮助您对相关的主题进行分组并确定哪里需要更多详细信息。大纲可帮助您在开始写作之前就先讨论主题。</p>
<p>您可能会发现将大纲视为文档的叙述很有用。这世上还没有一个编写大纲的标准方法，但是以下准则提供的实用技巧可能会对您有帮助：</p>
<ul>
<li><p>在要求读者执行任务之前，请向他们解释为什么要执行任务。例如，以下要点说明了本教程中有关审核和改善网页可访问性的部分大纲：</p>
</li>
<li><ul>
<li>介绍浏览器插件；说明我们将使用审计报告的结果来修复一些错误。</li>
<li>列出运行插件和审计网页可访问性的步骤。</li>
</ul>
</li>
<li><p>将大纲的每个步骤限制为，描述概念或完成特定任务。</p>
</li>
<li><p>结构化大纲，以便文档在与读者最相关的时候才引入相关的信息。例如，当您的读者刚开始使用基础知识时，他们可能不需要在文档的简介部分中了解（或想要了解）项目的历史。如果您觉得项目的历史记录很有用，请在文档末尾添加指向此类信息的链接。</p>
</li>
<li><p>在概念性信息和实际步骤之间交替的文档可能是一种特别吸引人的学习方式。考虑解释一个概念，然后说明读者如何将其应用于示例项目或自己的工作中。</p>
</li>
<li><p>如果您要与将要审阅和测试文档的贡献者团队合作，则提纲特别有用。在开始写文档之前，请与您的撰稿人分享您的大纲，看看他们是否有任何建议。</p>
</li>
</ul>
<h4 id="大纲练习"><a href="#大纲练习" class="headerlink" title="大纲练习"></a>大纲练习</h4><p>对于本练习，请查看并更新以下长篇教程简介的高层级大纲。您可以重新排列，添加和删除主题。</p>
<p>##项目的历史</p>
<p>描述该项目的发展历史。</p>
<p>##先决条件</p>
<p>列出读者在开始之前应熟悉的概念，以及任何软件或硬件要求。</p>
<p>##系统设计</p>
<p>描述系统如何工作。</p>
<p>##受众</p>
<p>描述本教程的目标对象。</p>
<p>##设置教程</p>
<p>解释如何配置环境以跟进本教程。</p>
<p>## 故障排除</p>
<p>说明在实践本教时如何诊断并解决在以下情况下可能发生的潜在问题。</p>
<p>##有用的术语</p>
<p>列出读者需要遵循的术语定义教程。</p>
<p>以下是一种可能的解决方案：</p>
<p>##观众</p>
<p>描述了本教程的目标读者。</p>
<p>##先决条件</p>
<p>列出了读者在开始之前应熟悉的概念以及</p>
<p>所有软件或硬件要求。</p>
<p>##设置本教程</p>
<p>介绍如何配置您的环境以遵循本教程。</p>
<p>##有用的术语</p>
<p>列出了读者阅读本</p>
<p>教程需要了解的术语定义。</p>
<h4 id="介绍文档"><a href="#介绍文档" class="headerlink" title="介绍文档"></a>介绍文档</h4><p>如果文档的读者找不到与该主题相关的内容，则他们基本上会忽略这个文档。要为您的用户设置基本规则，建议您提供一个包含以下信息的简介：</p>
<ul>
<li>文档涵盖的内容。</li>
<li>您希望读者具备哪些先验知识。</li>
<li>该文件未涵盖的内容。</li>
</ul>
<p>请记住，您想使文档易于维护，因此请勿尝试介绍中的所有内容。</p>
<p>下面的段落演示了前面列表中的思想，作为一个名为Froobus的假设文档发布平台的概述：</p>
<p>本文档说明了如何使用Froobus系统发布Markdown文件。</p>
<p>Froobus是一个运行在Linux服务器上的将Markdown文件转成HTML页面的发布系统。</p>
<p>本文档适用于熟悉Markdown语法。要了解语法，请参阅 Markdown 参考。您还需要了解在</p>
<p>Linux终端下的一些命令。</p>
<p>本文档不包含有关安装或配置Froobus发布系统的内容。有关Froobus的安装，请参阅使用入门手册。</p>
<p>完成初稿后，请对照概述中设置的期望检查整个文档。您的简介是否提供您所涵盖主题的准确概述？您可能会发现把这种审核认为是文档的质量保证（QA）是很有效的。</p>
<h4 id="介绍练习"><a href="#介绍练习" class="headerlink" title="介绍练习"></a>介绍练习</h4><p>对于本练习，请查看并修订以下介绍，以获取一种称为F@的假设编程语言的最佳实践指南。删除您认为与此无关的任何信息，并添加您认为丢失的任何信息。</p>
<p>本指南列出了使用F@编程语言的最佳实践。</p>
<p>F@是在2011年开发的一个开源社区项目。本指南提供了F@的代码风格指南。除了本指南中的最佳实践之外，确保您已安装并运行F@命令行Linter。该编程语言在健康行业中被广泛采用。</p>
<p>如果你有有关最佳做法列表的补充建议，请到F@的github上给我们开issue。</p>
<p>​    以下是一种可能的修改：</p>
<p>本指南列出了使用F@编程语言的最佳实践。</p>
<p>在阅读本指南之前，请先完成F@开发人员的入门教程。本指南提供了F@代码风格指南。除了</p>
<p>本指南中的最佳实践之外，确保您已安装并运行F@命令行Linter。</p>
<p>如果你有有关最佳做法列表的补充建议，请到F@的github上给我们开issue。</p>
<h3 id="添加导航"><a href="#添加导航" class="headerlink" title="添加导航"></a>添加导航</h3><p>为读者提供导航和路标，可确保他们能够找到所需的内容以及不需要的信息。</p>
<p>清晰的导航包括：</p>
<ul>
<li>简介和摘要部分</li>
<li>一个清晰有逻辑的主题</li>
<li>有助于用户理解主题的标题和副标题</li>
<li>介绍该工具的概述</li>
<li>目录菜单，向用户显示他们在文档中的位置</li>
<li>链接到相关资源或更深入的信息</li>
<li>链接到下一步学习</li>
</ul>
<p>以下各节中的技巧可以帮助您写出不错文档标题。</p>
<h4 id="首选基于任务的标题"><a href="#首选基于任务的标题" class="headerlink" title="首选基于任务的标题"></a>首选基于任务的标题</h4><p>选择描述您的读者正在从事的任务的标题。避免使用不熟悉的术语或工具的标题。例如，假设您正在写创建新网站的过程。要创建站点，读者必须初始化Froobus框架。要初始化Froobus框架，必须运行 carambola 命令行工具。乍一看，在说明中添加以下任一标题似乎合乎逻辑：</p>
<ul>
<li>运行carambola命令</li>
<li>初始化Froobus框架</li>
</ul>
<p>除非您的读者已经非常熟悉该主题的术语和概念，否则最好使用更熟悉的标题，例如“ 创建站点<em>”</em>。</p>
<h4 id="在每个标题下提供文字"><a href="#在每个标题下提供文字" class="headerlink" title="在每个标题下提供文字"></a>在每个标题下提供文字</h4><p>大多数读者至少喜欢在每个标题下进行简短介绍以提供一些背景信息。避免在第二级标题之后放置三级标题，如以下示例所示：</p>
<p>##创建网站</p>
<p>###运行carambola命令</p>
<p>在此示例中，简要介绍可以帮助读者确定方向：</p>
<p>##创建网站</p>
<p>要创建站点，请运行<code>carambola</code>命令行工具。该命令会显示一系列提示，以帮助您配置站点。</p>
<p>###运行carambola命令</p>
<h4 id="标题练习"><a href="#标题练习" class="headerlink" title="标题练习"></a>标题练习</h4><p>帮助读者浏览您的文档可帮助他们找到成功使用您的工具所需的信息。通常，清晰，井井有条的目录或大纲就像地图一样，可以帮助用户导航工具的功能。</p>
<p>对于本练习，请改进以下大纲。您可以重新排列，添加和删除主题，也可以创建辅助条目。</p>
<p>关于本教程</p>
<p>进阶主题</p>
<p>建立资产导航树</p>
<p>定义资源路径</p>
<p>定义和建设项目</p>
<p>启动开发环境</p>
<p>定义和建设资源</p>
<p>下一步是什么</p>
<p>定义图像资源</p>
<p>受众</p>
<p>参考</p>
<p>建立图像资源</p>
<p>定义图像项目</p>
<p>建立影像专案</p>
<p>设置教程</p>
<p>选择教程资产根</p>
<p>关于本指南</p>
<p>以下是一种可能的修改：</p>
<p>##关于本教程</p>
<p>###受众</p>
<p>###关于本指南</p>
<p>###高级主题</p>
<p>##设置本教程</p>
<p>###选择本教程根目录</p>
<p>###启动开发环境</p>
<p>###构建资产导航树</p>
<p>###定义资源路径</p>
<p>##定义和构建资源</p>
<p>###定义图像资源</p>
<p>###构建图像资源</p>
<p>##定义和构建项目</p>
<p>###定义图像项目</p>
<p>###构建图像项目</p>
<p>##定义和构建数据库</p>
<p>###定义数据库</p>
<p>###建立数据库</p>
<p>##推送，发布和查看数据库</p>
<p>###推送数据库</p>
<p>###发布数据库</p>
<p>###查看数据库</p>
<p>##配置“点数据”的显示规则</p>
<p>###定义，配置和构建矢量数据</p>
<p>##另请参阅</p>
<p>###示例数据文件</p>
<p>##下一步做什么</p>
<h3 id="循序递近"><a href="#循序递近" class="headerlink" title="循序递近"></a>循序递近</h3><p>对于许多乐于按自己的节奏阅读文档的读者而言，学习新的概念，想法和技术是一个有益的体验。但是，过快地面对太多新概念和说明可能会令人不知所措。读者很可能会接受较长的文档的形是，文档会逐步地在需要的时候层层递近。以下技术可以帮助您写出这样的层层递进的文档：</p>
<ul>
<li>尽可能地，在需要用到的地方引入新的术语和概念。</li>
<li>分解大块文字。为了避免在一个页面上出现多个较大的段落，请在适当的地方引入表格，图表，列表和标题。</li>
<li>分解大量步骤。如果您的复杂步骤列表特别长，请尝试将它们重新排列为较短的列表，以解释如何完成子任务。</li>
<li>从简单的示例和说明开始，然后逐步添加更多有趣和复杂的技术。例如，在创建表单的教程中，首先说明如何处理文本响应，然后介绍其他技术来处理多个选择，图像和其他响应类型。</li>
</ul>
<h2 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h2><p>还记得老师给您分配的阅读篇章吗？您翻阅了教科书的指定部分，非常希望…是的，图片！查看插图比阅读文本有趣得多。实际上，在阅读技术资料时，绝大多数成年人还是小孩，他们仍然渴望图片而不是文字。</p>
<p><img src="../images/jE6R_7ISrWtAcm5rnEX7JgrrX-YzwtIqsSWqcFRr9P6raZxlIdkYNlRDwKoU0-i-LIafqfR_Se1pq__H-81I3C4gEMNcOgNoZ1m6S9bGlhMEen2lhOMORpJUae2tdt8LaoXJgxfo-20200314140000135.jpeg" alt="三个孩子指着这些图片时读了一本书。"></p>
<p><strong>图**</strong>1.<strong>**良好的图片以文本无法不可比拟的方式吸引读者。</strong></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Nepalese_Children.JPG" target="_blank" rel="noopener">Nirmal Dulal [CC BY-SA 4.0（https://creativecommons.org/licenses/by-sa/4.0）]</a></p>
<p>根据<a href="https://www.sciencedirect.com/science/article/pii/S0747563212000921" target="_blank" rel="noopener">Sung和Mayer（2012）的研究</a>，提供任何图片（无论好坏）都会使读者更喜欢该文档。但是，只有教育性的 图片才能帮助读者学习。本章节提供了几种方法来帮助您创建真正胜过千言的图示。</p>
<h3 id="首先写标题"><a href="#首先写标题" class="headerlink" title="首先写标题"></a>首先写标题</h3><p>通常，在创建插图之前写标题会很有帮助。然后，创建最能说明标题的插图。此过程可帮助您检查插图是否符合目标。</p>
<p>好的标题具有以下特征：</p>
<ul>
<li>他们很<strong>简短</strong>。通常，标题只是几个单词。</li>
<li>他们解释了<strong>要点</strong>。查看此图形后，读者应该记住什么？</li>
<li>他们<strong>聚焦</strong>读者的注意力。当照片或图表包含很多细节时，聚焦尤其重要。</li>
</ul>
<p>示例：</p>
<p>目标受众：CS本科生参加“数据结构入门”课程。</p>
<p>考虑以下三个图形，每个图形使用相同的标题。</p>
<p><img src="../images/n2VrvJB3FR75g6ZAy8tYZQLwRdU4IXSo5kVAiYEupjAz3750NR8Fpgk9s6aKGB2bmiS2mls4mRQIYsf-B51dO3dfuM1RANyADpjALmHeH94GC0lh-XzDjmXrTbsrPqfyWEl1h76J-20200314135944582.png" alt="img"></p>
<p><strong>标题**</strong>A<strong>**。单向链表包含内容和指向下一个节点的指针。</strong></p>
<p><img src="../images/D6dcerQce7rgaGRG_YafpEK8gH1CAWTiY91CunUMVHiB_D3YWT4cHM7QqQD-Oi0XKTEbmVYW3AtavR_jh6bgUqTe_08phRnvnR2Zy_dxTEj-vmbjKeC-WxEhvGWIztIrx-6-tFd_-20200314140016480.png" alt="用三个箭头连接的四个盒子"></p>
<p><strong>标题**</strong>B<strong>**。单向链表包含内容和指向下一个节点的指针。</strong></p>
<p><img src="../images/O8QRqho8LjEXTIF5hbiK31kBDFwQpeTMvyAwFcVxUoRrVjY3n6KQl4wNY25H6As1M9YvuaP0_jGHlD1Z8ELWIDGRTw1ZtJ03_bYuad-yRyPq5ifK91kCjP_AXqPyLox9zj1tD3xi-20200314140024181.png" alt="img"></p>
<p><strong>标题**</strong>C<strong>**。单向链表包含内容和指向下一个节点的指针。</strong></p>
<p>前三个图中的哪一个最能说明其标题？</p>
<ul>
<li>图A很糟糕。链条很漂亮，但是没有信息。链还错误地暗示了一个单链表同时指向向后和向前。</li>
<li>图B是可以的。这个插图帮助学生认识到第一项指向第二项，第二项指向第三项，以此类推。但是，虽然标题同时引用了<strong><em>内容</em></strong>和<strong><em>指针</em></strong>，但是插图显示的是指针，而不是内容。</li>
<li>图C是最好的、最有启发意义的选择。插图清楚地描述了每个节点的内容部分和指针部分。</li>
</ul>
<h3 id="限制单个图片中的信息量"><a href="#限制单个图片中的信息量" class="headerlink" title="限制单个图片中的信息量"></a>限制单个图片中的信息量</h3><p>很少的智力工作可以像学习一幅精美的画作一样有收获，它逐渐揭示了洞察力和意义。人们为在世界艺术博物馆中做到这一点付出了很多钱。</p>
<p><img src="../images/yaRvvgA5PXE6Ew63bb-wgKN2_65DgQL-scySq9rdBLEa8489yPhaY6hagxfP6VnIanEEX-1zSkwZhO3hq82t7qeZPHJAK43TmCqoSCBHVAqoNpg1i-qhKQRLzMDFnBJyrjv-MBNw-20200314140036522.jpeg" alt="Pere Tanguy的画像，作者Vincent van Gogh-罗丹博物馆，公共领域，https：//commons.wikimedia.org/w/index.php？curid = 119599"></p>
<p><strong>图**</strong>2.<strong>**您会很高兴研究梵高的这幅画。</strong></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Van_Gogh_-_Portrait_of_Pere_Tanguy_1887-8.JPG" target="_blank" rel="noopener">Pere Tanguy的画像，文森特·梵高-罗丹博物馆[公共领域]</a></p>
<p>相比之下，如下所示的高度复杂的技术插图往往会阻止大多数读者：</p>
<p><img src="../images/48v7yt9pVjD6rlZzFOjMML79V7Bx5xLvZG94Q35d375Nyp_Gjc4nVUWxnmITLDPpKM5cmrpN1_Tj-ui6Gl7E8BMZt3Ei-At6VRjl3P9OYDAkuzySTagGqNcXuPNrMAlsayQCFmMQ-20200314140049461.png" alt="img"></p>
<p><strong>图**</strong>3.<strong>**复杂的框图使读者不知所措。</strong></p>
<p>就像您避免过长的句子一样，也要努力避免视觉冲击。根据以往经验，不要在一个图表中放置超过一个段落的信息。（另一种经验法则是避免插图需要五个以上的无序列表来解释。）我听到您说：“但是，现实生活中的技术系统可能比图3所示的系统复杂得多。” 您是对的，但是您可能不会觉得要在单个段落中解释这个复杂的系统。</p>
<p>将视觉混乱变成连贯且有用的东西的诀窍是将复杂的系统组织成子系统，如下图所示：</p>
<p><img src="../images/Yeyo20lvR4xle9wsHUuSRWJR_Xdh3Ig_bWvBkvFub6-2jHAs-Jg9e6CNQIf73mIVNHB8GQBP7s_t1JyB8D1qJOjq1NqjgGucfukUGfuR6tGmNq-0B80Gtm9iqpAs1dXCofsUDZo9-20200314140059131.png" alt="img"></p>
<p><strong>图**</strong>4.<strong>**分为三个子系统的复杂系统。</strong></p>
<p>显示“大图”之后，分别提供每个子系统的图示。</p>
<p><img src="../images/zeC0klriuJFNa_-cSgpsD8qZuYDOIBjT7SCwd3AZdhsyPoCJFdHLT7MeWr3k1rfRieIrTr_2JaVkmOz3eJdgI0vo6gpO-D9AHliITi8L8L0CQ91sBM8M3UnntuONbPxaIlwkklPp-20200314140107828.png" alt="img"></p>
<p><strong>图**</strong>5.<strong>**复杂系统的一个子系统的扩展细节。</strong></p>
<p>另外，可以从简单的“大图片”开始，然后在每个后续插图中逐步扩展细节。</p>
<h3 id="吸引读者的注意力"><a href="#吸引读者的注意力" class="headerlink" title="吸引读者的注意力"></a>吸引读者的注意力</h3><p>面对如下复杂的屏幕截图时，读者难以确定相关内容：</p>
<p><img src="../images/HajIj_VeHCkeZ97hmSxff8WcRnTFKXax3YkBFCMsZXrztnv3rjoXkS-a8BIynrjnEgsDBSMSdsa996evyJdAY7kLlMcDP9nlDpewVcXgE5dRPiwey2ZR-xmsMeCIjS86AOPnWhV8-20200314140117466.png" alt="三个块，每个块都有一个简单的标签"></p>
<p><strong>图**</strong>6.<strong>**读者不知道该关注什么。</strong></p>
<p>添加视觉提示，例如下图中的红色椭圆，可以帮助读者专注于屏幕截图的相关部分：</p>
<p><img src="../images/175ofZpKAWCFWKeFBTzgETTftuYjG8lIjLa0JG60njiuDciLbZFyzX7peMb_sWG-hqk1rA8NJN7jh6mwhU0w7gdqGP7g0M3DhH4PSkYMFIhhZ6rfd0RaFYVnHWni15-cC_PTxMnv-20200314140124914.png" alt="相同的屏幕截图，但其中一个菜单项用红色圈出"></p>
<p><strong>图**</strong>7.<strong>**读者会关注于破坏图案的形状。</strong></p>
<p><strong>标注</strong>提供了另一种吸引读者注意力的方法。对于图片和艺术线条，标注可以帮助我们的眼睛找到合适的落地位置。图片中的标注通常比图片的段落说明更好，因为标注将读者的注意力集中在图片的最重要的地方。然后，在您的解释中，您可以直接关注图表的相关部分，而不必花费时间描述您所讨论的图像的哪个部分。</p>
<p>在示例图像中，标注和箭头快速将读者引导至目标。</p>
<p><img src="../images/283dqnnnKtWlKVb68D3je8av_MxYUVZY1BDTTRXrrSU4gKoWUPAfoyGcx_BButTMCUu_CTSnuTzF1XFil_oi5zLzvTeK-D_WpLY8GgLB9neNR3xgUvr_yTRr3twRp5Q78SnN4LCK-20200314140141013.png" alt="img"></p>
<p><strong>图**</strong>8.<strong>**标注引导读者的视线。</strong></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Phobos_colour_2008.jpg" target="_blank" rel="noopener">NASA / JPL-Caltech /亚利桑那大学[公共领域]</a></p>
<h3 id="插图重构"><a href="#插图重构" class="headerlink" title="插图重构"></a>插图重构</h3><p>与写作一样，插图的初稿也不够好。修改插图以澄清内容。修改时，请问自己以下问题：</p>
<ul>
<li>如何简化图示？</li>
<li>我应该将此插图分为两个或更多个简单的插图吗？</li>
<li>插图中的文字是否易于阅读？文字与背景是否有足够的对比？</li>
<li>什么是重点？</li>
</ul>
<p>例如，考虑<a href="https://wikipedia.org/wiki/Tube_map#History" target="_blank" rel="noopener">伦敦地铁地图</a>的 <a href="https://wikipedia.org/wiki/Tube_map#History" target="_blank" rel="noopener">演变</a>。在1931年之前，绘制了地铁地图，并按比例绘制了地上道路和像轨道一样弯曲的地铁线。</p>
<p><img src="../images/euP3eyeWX-VG131ipdWv9a77kx4mqw5L_1KCDpmHY20evqxkr1ZT1jWbeA-gThj5Ojvh3E3QDW2tR7t7RtR7jM-VCtSDoYSOyYeTJrRQOm_O5SxOEFu8a9tzBmyN-7einM3mEZd_-20200314140152285.jpeg" alt="1908年伦敦地铁的复杂地图，包括地上道路"></p>
<p><strong>图**</strong>9. 1908<strong>**年的按地面街道绘制的伦敦地铁地图</strong></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Tube_map_1908.jpg" target="_blank" rel="noopener">[公共区域]</a></p>
<p>1931年，哈里·贝克（Harry Beck）革新了一种新型的公共交通地图，通过取消地上标记和比例尺来简化旧地图。相反，他的设计专注于使用地图的人们真正关心的是：从A站到B站。即使1931年的地图取得了成功，但贝克仍然多年对地图进行反复的简化和并使用清晰易读。现在考虑一下<a href="https://www.google.com/search?tbm=isch&q=london+tube+map" target="_blank" rel="noopener">现代的地铁图</a>，尽管出现了新的线路和车站，但它们仍然与贝克的设计保持接近。</p>
<img src="../images/5jC-OPwHxr6Mj-fuKPtgUX0XfCoVMUlmjm7siCMKz6AXsXDLP_QjJtDPunYBXKPpP3-zmhjyTXxJ9HPTN8ApVgomXgg4kkKLx2shmxKnSLRr443FHY9grmrM-_8Lrk6J0htz9Ovn-20200314140207008.png" alt="img" style="zoom:200%;" />

<p>考虑以下原始插图：</p>
<p><img src="../images/xnR8SI5KCSPzQ6Dg0m5UTwHS_V5Vm5dAXjTV_--_8pokF63WyiUM-8ZXVnL3uuiDEZqfZpMK1hh15EvW5gxgo5w8vf3fv6cucArmYHaauvhEQx7pW4D7iU_Yx3AXO93IrsD9Wuru-20200314140221061.png" alt="img"></p>
<p><strong>图**</strong>10.<strong>**复杂图。</strong></p>
<p>上图的内容应该是：</p>
<p>对于递归函数，在return语句中调用函数本身，直到获得基本解为止。</p>
<p>考虑这个图表的复杂性是以什么方式隐藏了要点？您将如何解决这些问题？</p>
<p>该图中可能存在的一些问题包括：</p>
<ul>
<li><strong>问题</strong>：鲜艳的色彩使读者的注意力从图片的其他部分移开。<br> <strong>解决方案</strong>：仔细选择颜色，以免它们压倒图片。</li>
<li><strong>问题</strong>：图片的色彩对比度不足。这使得某些视力较弱或某些类型的色盲的人无法访问该图。<br> <strong>解决方案</strong>：消除不必要的颜色使用，并确保颜色 <a href="https://material.io/design/color/text-legibility.html#legibility-standards" target="_blank" rel="noopener">符合标准的颜色对比建议</a>。</li>
<li><strong>问题</strong>：当前箭头指向两个方向，这使得该图的流程变得不清楚。<br> <strong>解决方案</strong>：将箭头分为两部分，其中一组说明调用功能，另一组说明从功能返回。</li>
</ul>
<p>当然，图中还有其他未在这里指出的问题。</p>
<p>这是一个改进的图示：</p>
<p><img src="../images/8bngRBIGBzJEejHZ_ekuvFCKyTEG0rfQx7ZLF21yPSKzzCiB3KxmnUh5xocI00rR5zfU1AxBQfk8wLu1RNTulzbJ8w7kVlQCcyN5snEHZlvHY3sT9u1PEkldFGK2j-3yj3WKS8fs-20200314140231439.png" alt="img"></p>
<p><strong>图**</strong>11.<strong>**上图的简化版本。</strong></p>
<p>您在改进的插图中看到哪些缺陷？</p>
<p>这是两个仍然存在的缺陷：</p>
<ul>
<li>该图仍然太复杂。要解释此插图，需要的不仅仅是段落。考虑删除多余的信息或添加说明标签如何简化解释。</li>
<li>当函数之间相互调用或返回数据时，分开显示箭头有助于显示，但返回箭头可能会受益于告诉读者返回值是什么的标签。</li>
</ul>
<h3 id="插图工具"><a href="#插图工具" class="headerlink" title="插图工具"></a>插图工具</h3><p>有许多工具可用于创建图表。这里推荐三个免费的作图工具：</p>
<ul>
<li><a href="https://drawings.google.com/" target="_blank" rel="noopener">Google Drawings</a></li>
<li>Draw.<a href="https://draw.io/" target="_blank" rel="noopener">IO</a></li>
<li>LucidChart</li>
</ul>
<p>从这些工具导出图表供文档使用时，通常最好将文件导出为SVG或<a href="https://wikipedia.org/wiki/Scalable_Vector_Graphics" target="_blank" rel="noopener">可缩放矢量图形</a>。可伸缩矢量图形可以轻松地根据空间限制来缩放图表，因此无论大小如何，您最终都可以得到高质量的图像。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>好的示例代码通常是最好的文档。即使您的段落和列表像水一样清澈，程序员仍然更喜欢好的示例代码。毕竟，文本是与代码不同的语言，并且它是读者最终关心的代码。尝试用文本描述代码就像尝试用英语解释一首意大利诗。</p>
<p>好的样本是<strong>正确</strong>，<strong>简洁的</strong>代码，您的读者可以 <strong>快速理解它们，</strong>并以<strong>最小的副作用轻松地重用它们</strong>。</p>
<h3 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h3><p>示例代码应满足以下条件：</p>
<ul>
<li>构建没有错误。</li>
<li>执行它要执行的任务。</li>
<li>尽可能是可以上生产的代码。例如，该代码不应包含任何安全漏洞。</li>
<li>遵循特定于语言的约定。</li>
</ul>
<p>示例代码是直接影响用户编写代码的方式。因此，示例代码应示例最佳的编码方法。如果编码的方法不止一种，请以您的团队认为最好的方式对其进行编码。如果您的团队尚未考虑每种方法的利弊，请花一些时间去对比一下各种方式的好坏和优缺。</p>
<p>始终测试您的示例代码。随着时间的流逝，系统会发生变化，示例代码可能会出错。与其他任何代码一样，测试并维护您的示例代码。</p>
<p>许多团队将其单元测试用作示例程序，这有时是个坏主意。因为，单元测试的主要目标是测试，而示例程序的唯一目的是教育。</p>
<p>一个<strong>程序**</strong>片断**是示例程序的一个碎片，可能只有一行或几行长。这种程序片段繁多的文档通常会随着时间的推移而降级，因为团队倾向于不像完整的示例程序那样严格地测试程序片段。</p>
<h3 id="运行示例代码"><a href="#运行示例代码" class="headerlink" title="运行示例代码"></a>运行示例代码</h3><p>好的文档说明了如何运行示例代码。例如，在运行示例之前，您的文档可能需要告知用户执行以下活动：</p>
<ul>
<li>安装某个库。</li>
<li>配置某些环境变量的值。</li>
<li>配置集成开发环境（IDE）。</li>
</ul>
<p>用户并不总是正确执行上述活动。在某些情况下，用户喜欢直接在文档中运行或（使用）示例代码。（如：“单击此处运行此代码。”）</p>
<p>编写者应考虑描述示例代码的预期输出或结果，尤其是对于难以运行的示例代码。</p>
<h3 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h3><p>示例代码应该简短，仅包括基本组件。当C语言新手想学习如何调用该malloc函数时，请给该程序员一个简短的代码片段，而不是整个Linux源代码树。不相关的代码可能会使您的受众分散注意力并使他们困惑。也就是说，切勿使用错误的做法来缩短代码；总是喜欢正确而不是简洁。</p>
<h3 id="易理解"><a href="#易理解" class="headerlink" title="易理解"></a>易理解</h3><p>请遵循以下建议来创建清晰的示例代码：</p>
<ul>
<li>选择自描述性的类，方法和变量名。</li>
<li>避免读者难以理解的编程技巧。</li>
<li>避免深层嵌套的代码。</li>
<li>可选：使用粗体或彩色字体将读者的注意力吸引到示例代码的特定部分。但是，明智地使用突出显示——太多的突出显示意味着读者不会特别关注任何内容。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下哪个示例示例程序中的代码行会更有帮助？假设目标受众由go.soAPI的新软件工程师组成。</p>
<ol>
<li>MyLevel = go.so.Level(5, 28, 48)</li>
<li>MyLevel = go.so.Level(rank=5, 28, 48)</li>
<li>MyLevel = go.so.Level(rank=5, dimension=28, opacity=48)</li>
</ol>
<p>答案<strong>3</strong>是这里的最佳选择。尽管试图使示例代码尽可能短，但省略参数名称会使新手学习起来更加困难。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>遵循以下示例代码注释的建议：</p>
<ul>
<li>保持简短，但易懂清楚始终高于简洁。</li>
<li>避免编写明显 代码的注释，但也要记住，对您（专家）而言显而易见的东西可能对新手而言并不明显。</li>
<li>将您的评论精力集中在任何非直觉的代码上。</li>
<li>当你的读者非常有技术有经验，不解释 什么<em>what</em> <em>——</em>代码是什么，解释为什么 <em>why ——</em>代码为什么这么干。</li>
</ul>
<p>您应该将代码的描述放在代码注释中还是在示例代码之外的文本（段落或列表）中？请注意，复制并粘贴代码的读者不仅会拷走代码，还会拷走其中的注释。因此，将代码的说明放入代码注释中以便一同复制粘贴。相比之下，当您必须解释冗长或难以解释的概念时，通常应将注释文本放在示例程序之前。</p>
<p><strong>注意：</strong>如果必须牺牲能上生产环境质量的代码，以便使代码更短且更易于理解，请在注释中解释您的决定。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>您在以下代码片段的注释中看到什么问题？假设代码针对的是不熟悉brAPI但对流的概念有一定经验的程序员：</p>
<p>/ *从文本文件创建路径为 /tmp/myfile 的流 */</p>
<p>mystream = br.openstream(pathname=“/tmp/myfile” ，mode= “z” )</p>
<p>注释包含以下缺陷：</p>
<ul>
<li>该注释只是说明了代码中相当明显的部分。</li>
<li>该代码段未解释的不直觉的部分。即，mode参数是什么，z 值是什么意思？</li>
</ul>
<h3 id="可重用"><a href="#可重用" class="headerlink" title="可重用"></a>可重用</h3><p>为了使读者轻松地重用示例代码，请提供以下内容：</p>
<ul>
<li>运行示例代码所需的所有信息，包括所有依赖关系和设置。</li>
<li>可以以有用的方式扩展或自定义的代码。</li>
</ul>
<p>拥有简洁明了且易于理解的示例代码是一个很好的开始。但是，如果毁了读者的应用程序，他们将不会高兴。因此，在编写示例代码时，请考虑由于将代码集成到另一个程序中而引起的任何潜在副作用。没有人想要不安全或效率很低的代码。</p>
<h3 id="正反示例"><a href="#正反示例" class="headerlink" title="正反示例"></a>正反示例</h3><p>除了告诉读者 要做什么，有时还要明智的向读者展示了什么不该做。例如，许多编程语言都允许程序员在等号的两侧放置空格。现在，假设您正在使用某种语言（例如bash）编写教程，该语言不允许在等号的两边使用空格。在这种情况下，同时展示好例子和反例子将使读者受益。例如：</p>
<p>正确的示例</p>
<p>＃有效的字符串分配。</p>
<p>s=“The Rain in Maine.”</p>
<p>错误的示例</p>
<p>＃由于在字符串的两边都有空格，因此字符串分配无效</p>
<p>＃等于符号。</p>
<p>s = “The Rain in Maine.”</p>
<h3 id="并列示列"><a href="#并列示列" class="headerlink" title="并列示列"></a>并列示列</h3><p>一个好的示例代码集展示了<strong>一系列**</strong>的<strong><strong>复杂</strong></strong>度**。</p>
<p>完全不了解某种技术的读者通常渴望获得一些简单的示例来上手。示例代码集中的第一个也是最基本的示例通常称为 <a href="https://wikipedia.org/wiki/" target="_blank" rel="noopener"Hello,_World!"_program">Hello World程序</a>。掌握了基础知识之后，工程师们需要更复杂的程序。一组好的示例代码提供了一系列简单，适当和复杂的示例程序。</p>
<p>以下哪一项是一组好的函数示例，以向新手介绍编程函数概念的教程？</p>
<ol>
<li><p>以下是一组函数：</p>
</li>
<li><ol>
<li>一个不带参数且不返回任何东西的函数。</li>
<li>一个带有一个参数但不返回任何东西的函数。</li>
<li>一个具有一个参数并返回一个值的函数。</li>
<li>具有三个参数并返回一个值的函数。</li>
</ol>
</li>
<li><p>以下是一组函数：</p>
</li>
<li><ol>
<li>具有三个参数并返回一个值的函数。</li>
</ol>
</li>
<li><p>以下是一组函数：</p>
</li>
<li><ol>
<li>一个具有一个参数并返回一个值的函数。</li>
<li>具有三个参数并返回一个值的函数。</li>
</ol>
</li>
</ol>
<p>最好的答案是<strong>1</strong>。提供涵盖一系列复杂性的样本通常是最明智的选择，尤其是对于新来者。抵制诱惑，匆匆走向非常复杂的示例程序，绕过新人渴望的初级和中级示例程序。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>技术写作两个涵盖了以下技术写作中级课程：</p>
<ul>
<li>采用统一的样式。</li>
<li>换位思考。</li>
<li>大声朗读文档（对自己）。</li>
<li>编写初稿后，离开一会儿再回来查看文档。</li>
<li>寻找一个好的同伴编辑。</li>
<li>文档大纲。或是先写下类别，这后再组织起来。</li>
<li>介绍文档的范围和所有先决条件。</li>
<li>首选基于任务的标题。</li>
<li>循序渐进地写作（在某些情况下）。</li>
<li>在创建插图之前，请考虑写标题。</li>
<li>将信息量限制在一个图示中。</li>
<li>通过标注来集中读者的注意力。</li>
<li>创建简单易懂的示例代码。</li>
<li>保持代码注释简短，但更推崇清楚而不是简洁。</li>
<li>避免编写显而易见 的代码注释。</li>
<li>将您的注释集中在任何非直觉的代码上。</li>
<li>不仅提供示例，还提供反例。</li>
<li>提供一系列复杂度的代码示例。</li>
<li>有连续修订记录的版本管理。</li>
<li>为不同类别的用户提供不同的文档类型。</li>
<li>与读者已经熟悉的东西进行比较和对比。</li>
<li>在教程中，通过示例来增强概念。</li>
<li>在教程中，指出危险之处。</li>
</ul>
<h1 id="技术写作资源"><a href="#技术写作资源" class="headerlink" title="技术写作资源"></a>技术写作资源</h1><p>这里总结了其他技术写作资源。</p>
<h2 id="编辑风格指南"><a href="#编辑风格指南" class="headerlink" title="编辑风格指南"></a>编辑风格指南</h2><p>一个<strong>编辑风格指南</strong>规定了编辑团队的指导方针。例如，您的组织应采用以下哪个规则作为标题？</p>
<ul>
<li>标题用 sentence case（仅将每个标题的首字母大写）</li>
<li>标题用 title case （将每个标题中的单词首字母大写）</li>
</ul>
<img src="../images/oRi1oFcErhRddvpYrB-UMIJxoa1RaPboq8KmdxiPUa3ud5b0z_WFgtHFx320fqQe5eHcoKpY0Aj94DV9Qw3xZjFbwvJwdZXzrTeD2UpJpGP1occ81ITmXfURNp6-bX_xPMVwzd_h-20200314140248427.png" alt="img" style="zoom:200%;" />
 （译者注：左边中是Title Case，右边是 Sentence case）

<p>不要浪费时间和精力争论这类问题。而是要求您的组织采用统一的编辑风格指南。一个<strong>编辑风格指南</strong>提供了写作的一种约定。是 Sentence case 还是Title case 并不重要。整个团队采用统一的编辑风格指南才很重要。</p>
<p>嗯，但是要用哪个编辑风格指南呢？您可能已经熟悉通用的编辑样式指南（例如《<a href="https://www.chicagomanualofstyle.org/home.html" target="_blank" rel="noopener">芝加哥样式手册》</a>或《 [牛津大学样式指南》](<a href="https://www.ox.ac.uk/sites/files/oxford/media_wysiwyg/University" target="_blank" rel="noopener">https://www.ox.ac.uk/sites/files/oxford/media_wysiwyg/University</a> of Oxford Style Guide.pdf)）。但是，您的工程团队应使用专门从事技术写作的编辑风格指南。所以，我们建议选择以下选项之一：</p>
<ul>
<li>在<a href="https://developers.google.com/style" target="_blank" rel="noopener">谷歌的开发者文档风格指南</a>规定了谷歌有关的项目，任何人书写的开发者文档的编辑准则。</li>
<li>《<a href="https://docs.microsoft.com/en-us/style-guide/welcome/" target="_blank" rel="noopener">Microsoft写作风格指南》</a>为编写技术文档的任何人提供了指南。</li>
</ul>
<p>不要编写自己的编辑风格指南。创建和维护编辑风格指南需要大量资源，并且会引起巨大冲突。就是说，有团队创造了新术语，而现有的编辑风格指南中没有出现。发生这种情况时，组织可以执行以下任一操作：</p>
<ul>
<li>要求编辑风格指南的维护者添加新术语。</li>
<li>创建并维护您自己的<strong>用法指南</strong>或<strong>样式表</strong>，以将团队的专业词汇的拼写和单词用法编入规章。</li>
</ul>
<h2 id="开源文档的机会"><a href="#开源文档的机会" class="headerlink" title="开源文档的机会"></a>开源文档的机会</h2><p>Google的<a href="https://developers.google.com/season-of-docs/" target="_blank" rel="noopener">“Season of Docs”</a> 计划旨在促进开源项目与技术作家之间的协作。对于从事开源项目的人们来说，这是一个提高他们的技术写作技能的好机会。</p>
<p>文档季节每年运行一次。要随时了解2020年计划，您可以加入邮件列表或Slack工作区，如有关<a href="https://developers.google.com/season-of-docs/docs/discussion" target="_blank" rel="noopener">讨论频道</a>的页面中所述。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/13/SQL_Joins/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/13/SQL_Joins/" class="post-title-link" itemprop="url">SQL_Joins</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-13 13:47:38 / Modified: 14:54:33" itemprop="dateCreated datePublished" datetime="2020-03-13T13:47:38-04:00">2020-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="../images/INNER_JOIN.png" alt="Visual_SQL_Joins/INNER_JOIN.png"></p>
<h2 id="Inner-Join"><a href="#Inner-Join" class="headerlink" title="Inner Join"></a>Inner Join</h2><p> This query will return all of the records in the left table (table A) that have a matching record in the right table (table B). This Join is written as follows:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; </span><br><span class="line"><span class="keyword">FROM</span> Table_A A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Table_B B</span><br><span class="line"><span class="keyword">ON</span> A.Key = B.Key</span><br></pre></td></tr></table></figure>

<h2 id="Left-Join"><a href="#Left-Join" class="headerlink" title="Left Join"></a>Left Join</h2><p>This query will return all of the records in the left table (table A) regardless if any of those records have a match in the right table (table B). It will also return any matching records from the right table. This Join is written as follows:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span> Table_A A</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Table_B B</span><br><span class="line"><span class="keyword">ON</span> A.Key = B.Key</span><br></pre></td></tr></table></figure>

<h2 id="Right-Join"><a href="#Right-Join" class="headerlink" title="Right Join"></a>Right Join</h2><p>This query will return all of the records in the right table (table B) regardless if any of those records have a match in the left table (table A). It will also return any matching records from the left table. This Join is written as follows:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span> Table_A A</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> Table_B B</span><br><span class="line"><span class="keyword">ON</span> A.Key = B.Key</span><br></pre></td></tr></table></figure>

<h2 id="Outer-Join"><a href="#Outer-Join" class="headerlink" title="Outer Join"></a>Outer Join</h2><p>This Join can also be referred to as a <code>FULL OUTER JOIN</code> or a <code>FULL JOIN</code>. This query will return all of the records from both tables, joining records from the left table (table A) that match records from the right table (table B). This Join is written as follows:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span> Table_A A</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Table_B B</span><br><span class="line"><span class="keyword">ON</span> A.Key = B.Key</span><br></pre></td></tr></table></figure>

<h2 id="Left-Join-Excluding-Inner-Join"><a href="#Left-Join-Excluding-Inner-Join" class="headerlink" title="Left Join Excluding Inner Join"></a>Left Join Excluding Inner Join</h2><p>This query will return all of the records in the left table (table A) that do not match any records in the right table (table B). This Join is written as follows:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt; </span><br><span class="line"><span class="keyword">FROM</span> Table_A A</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Table_B B</span><br><span class="line"><span class="keyword">ON</span> A.Key = B.Key</span><br><span class="line"><span class="keyword">WHERE</span> B.Key <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h2 id="Right-Join-Excluding-Inner-Join"><a href="#Right-Join-Excluding-Inner-Join" class="headerlink" title="Right Join Excluding Inner Join"></a>Right Join Excluding Inner Join</h2><p>This query will return all of the records in the right table (table B) that do not match any records in the left table (table A). This Join is written as follows:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span> Table_A A</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> Table_B B</span><br><span class="line"><span class="keyword">ON</span> A.Key = B.Key</span><br><span class="line"><span class="keyword">WHERE</span> A.Key <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h2 id="Outer-Join-Excluding-Inner-Join"><a href="#Outer-Join-Excluding-Inner-Join" class="headerlink" title="Outer Join Excluding Inner Join"></a>Outer Join Excluding Inner Join</h2><p>This query will return all of the records in the left table (table A) and all of the records in the right table (table B) that do not match. This Join is written as follows:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span> Table_A A</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Table_B B</span><br><span class="line"><span class="keyword">ON</span> A.Key = B.Key</span><br><span class="line"><span class="keyword">WHERE</span> A.Key <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">OR</span> B.Key <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/12/ICC%E6%98%AF%E5%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/ICC%E6%98%AF%E5%95%A5/" class="post-title-link" itemprop="url">ICC是啥</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-12 19:45:23 / Modified: 21:32:42" itemprop="dateCreated datePublished" datetime="2020-03-12T19:45:23-04:00">2020-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、背景知识："><a href="#一、背景知识：" class="headerlink" title="一、背景知识："></a>一、背景知识：</h1><h2 id="1-ICC是做什么的，为什么会有ICC"><a href="#1-ICC是做什么的，为什么会有ICC" class="headerlink" title="1. ICC是做什么的，为什么会有ICC"></a>1. ICC是做什么的，为什么会有ICC</h2><p>ICC这个称号我还是在这里看到的，一般他们只是自称consultant company。ICC的主营业务是向客户租赁合格的软件开发人才，按小时收取费用。当一家企业需要一个新的系统或者更新，增强自己的老系统时，传统的方法是寻找一家软件开发的企业，将系统的需求转包过去，然后坐等系统建成就好了。但是这样的方式对于企业来说成本高，效率低，而且经常由于无法快速沟通导致系统不合用，维护修改更需要依靠别人，一旦开发商不再支持，系统便会停止维护直到死掉。为了避免这样的现象，一些企业开始自行组建软件的开发维护队伍。由于软件开发的突发性劳动密集，前后期需要的专业人员则很少的这种特性，临时性的项目使得公司不愿意大量雇佣长期员工。此时，大量的临时性软件开发职位便产生了。而由于计算机行业的枯燥性，造成了美国本土计算机人才的缺乏，从而产生大量临时性工作缺口，ICC也就应运而生了。ICC通过合法手段从印度购入大量廉价人才，然后转包给这些需要临时性雇员的公司，从中赚取利润。大公司因此规避了人员雇用方面的法律责任，一纸合同完全把对应外来务工人员的各种法律活动屏蔽在项目外，使得项目小组可以高效开发系统，快速搭建平台，然后留下一两个高手维护，剩下的全部打回，成本低，效率高，客户很满意。ICC获得的大公司合同，价格是按<br>照美国专业人员的标准制定，然后使用的确实价格低廉的印度员工，利润丰厚，ICC很满意。那些印度员工从每月300美元的生活中解放出来，每月可以拿到4K以上，并且熬两年也许还可以获得更高的职位，获取绿卡什么的，员工也很满意。要说不满意的，只有这个版上的大量牛人们，可是算起来他们的能量又太少了，这样一个局内人大家都满意，少数局外人不满意的东西想要废除掉，恐怕不是那么容易吧。ICC的主要客户是那些大型的公司，你能听说过的企业，除了那些零售商，几乎都会使用ICC的服务。ICC崛起了，而以前曾经红火一时的系统集成商则没落了，现在在美国几乎已经销声匿迹，根源就是这种软件开发项目的自主化趋势造成的。要说冤，那些集成企业才是冤呢。</p>
<h2 id="2-ICC的常用概念和名词解释"><a href="#2-ICC的常用概念和名词解释" class="headerlink" title="2.  ICC的常用概念和名词解释"></a>2.  ICC的常用概念和名词解释</h2><ul>
<li><p>ICC = 就是那个Consultant Company</p>
</li>
<li><p>Vendor = 中间商，一般是大型猎头公司或者大型ICC公司，比较有名的包括CGI, Keane, TekSystem等等，他们又比较广阔的人脉，客户资源丰富</p>
</li>
<li><p>Client = 客户，就是最终要做项目的公司，一般都是大型的企业，制造业，银行，证券，港口，咨询甚至有些政府部门。几乎听说过名字的公司都在这个行列。</p>
</li>
<li><p>project = 项目，所有的周期都是围绕项目产生的，项目的周期也就是合同的周期</p>
</li>
<li><p>consultant = 就是服务提供者，被压迫，被剥削，没有自由身份，拼命干活还满脸笑容的那个家伙</p>
</li>
</ul>
<p>下面是各种consultant的类型</p>
<ul>
<li>BA = Business Analysist 商务分析，就是能够听懂客户要求，并且转化成数学或计算机模型的人物，价格昂贵，其实就是个翻译</li>
<li>PM = Project Manager 项目经理，包工头</li>
<li>TL = Team Leader 工头</li>
<li>SA = System Artichure 作系统分析和设计的，师傅</li>
<li>Sr. Developer/Engineer/Programmer = 熟工</li>
<li>Developer/Engineer/Programmer = 民工</li>
</ul>
<h2 id="3-ICC的工作流程是怎样的"><a href="#3-ICC的工作流程是怎样的" class="headerlink" title="3. ICC的工作流程是怎样的"></a>3. ICC的工作流程是怎样的</h2><ul>
<li><p>雇用过程Hiring.   包括招聘，面试，办身份，培训等几个步骤，这个流程是ICC公司内部进行的，不算等身份办妥的时间，一般需要持续2-6个月，如果需要等身份，可能需要的时间更长。</p>
</li>
<li><p>销售过程Marketing. 包括Vendor phone interview，Client phone interview，On site interview等等步骤，价格也是这个时候谈定的，一般要持续1个月左右的时间</p>
</li>
<li><p>服务过程Contract.   这个过程是在client那里完成的，就是实实在在的给client干活，一般情况下这个过程的长度就是合同期限的长度，有些会续约，一般以6个月为一个单位，也见过能长达2年的。</p>
</li>
</ul>
<p>Hiring和Marketing的过程中，consultant是没有工资拿的，一般还会要求支付2000美元左右的deposit，作为办身份的押金，这笔押金一般会在第一个项目的第一个月完成后，因此进入consultant的开始一段时间是相当郁闷的，一般人都会陷入经济危机中，manage好你的存款这个时候非常重要，有些ICC这个阶段提供住房和伙食的补贴，以及报销一些必要的交通开支等等，这就算是很好的待遇了，有些则什么都没有。</p>
<p>Contract过程就比较愉快了，一旦签了contract，consultant就开始有工资了，但是ICC也会停止提供各种补贴，不过有钱总比什么都没有好。</p>
<p>每次contract完成之后就又会进入下一轮的marketing之中，循环开始。</p>
<h2 id="4-ICC的价格和工资标准"><a href="#4-ICC的价格和工资标准" class="headerlink" title="4. ICC的价格和工资标准"></a>4. ICC的价格和工资标准</h2><p>ICC一般是按照小时支付工资的，但是和你签订的合同一定是按照年薪的，否则会导致无法办理身份，一般ICC会在你做决定之前跟你讲清楚你的工资是什么时候开始支付，按照什么标准支付。有些会给你一个很低的死工资大概1月3K左右，刚刚够H1的底线，而且还是一样找到项目才开始发，这种合同一般是签给直接从印度或中国召来的人的。身在美国的consultant一般不会接受这种合同，因此谈一个比率(rate)就是比较重要的了，50%-80%都是常见的比率范围，对于新入行，需要办身份的consultant来说60%是一个可以接受的比率。</p>
<ul>
<li>Consultant的常见收费（wage）水平如下，单位 $/小时<ul>
<li>BA ：100 - 180</li>
<li>PM : 80 - 160</li>
<li>TL : 70 - 120</li>
<li>SA : 60 - 120</li>
<li>Sr.: 60 - 120</li>
<li>Developer… : 30 - 80</li>
</ul>
</li>
</ul>
<p>这里的价格仅供参考，使我经常见到的东海岸纽约/华盛顿地区的价格，高级人才的价格一般会集中在下限附近，Developer级别则情况都比较平均，大部分中国人可以找到50以上的职位。30的下限往往针对没有任何经验，只经过简单培训的的外行价格。</p>
<p>年收入的估算方法 Total = wage * rate * 8 * 30 * 10 - 10K 例如：你约定的比率为60%，找到的Client给你的价格为60块每小时，那么你的平均年收入大约相当于60 * 0.6 * 8 * 30 * 10 - 10k = 76,400$</p>
<p>*10代表每年一般会有2个月左右的时间是无工资的。</p>
<p>-10K是因为大部分的ICC不提供各种benefite，需要自己支付许多东西大约一年 10K</p>
<p>大型的ICC我接触的少，据说待遇反而苛刻，小型的ICC完全没有信誉可言，比较危险，合同比较宽松，中型的相比来说更适合在北美的中国人考虑。</p>
<h1 id="二、ICC找工作攻略"><a href="#二、ICC找工作攻略" class="headerlink" title="二、ICC找工作攻略"></a>二、ICC找工作攻略</h1><p>了解了ICC的由来，性质，价值和工资体系后，就可以开始制定自己的目标和战术了</p>
<h2 id="1-基本条件："><a href="#1-基本条件：" class="headerlink" title="1.基本条件："></a>1.基本条件：</h2><ol>
<li>你实在找不到工作，甚至可能导致身份失效，如果有任何permanent, fulltime 的机会，无论那个机会工资多低，老板多mean，package多小，一定比ICC好，所以ICC一定只是你最后不得已的选择。</li>
<li>你确实不想回国，或者实在无法在国内找到好机会。</li>
<li>你是学工科的或者理科的，或者至少有这些方面的背景。</li>
<li>你有2000$左右的现金，和足够半年左右的生活费用的存款，或者你做好了打黑工刷盘子的准备。</li>
<li>你有一定的英文交流能力，至少打电话要能听懂，能表达</li>
<li>你心理健康，身体健康，胸怀宽容，气度恢宏，不会因为老板mean，同事坏，违法违规，说话不算等等等等负面事件导致身心俱疲，心力憔悴，甚至自我毁灭或者毁灭他人等等不良后果。</li>
<li>你的伴侣具有同样的上述优点，至少在你的帮助下具有以上优点。</li>
<li>你愿意relocate到附近的大城市，特别是纽约/华盛顿/三番之类的地方。</li>
<li>你确定自己能够handle多线程操作，同时找正常的工作和找ICC两不耽误 </li>
<li>请再次确认你已经没有别的路可走了。</li>
</ol>
<h2 id="2-基本策略："><a href="#2-基本策略：" class="headerlink" title="2.基本策略："></a>2.基本策略：</h2><p>ICC能帮我办身份，我就是花钱买身份的，其它都是末节，自古华山一条路，用2000$+6-10个月时间换一个permanent的职位和合法的美国工作签证是值得的。守住这条心里底线，对于你遇到各种负面事件的心理平衡或许会有帮助。ICC只是个起步，未来才是我们憧憬的。</p>
<h2 id="3-步骤："><a href="#3-步骤：" class="headerlink" title="3.步骤："></a>3.步骤：</h2><ol>
<li>给自己起个名字，英文的，有没有姓没关系，最好不是你常用的那个，重新起一个，专门用来找工作。</li>
<li>注册一个email地址，gmail或者yahoo都可以，专门用来保存找工作的事情。</li>
<li>有可能的话重新注册一个cell phone，保证不会影响到你正常的找工作流程。如果觉得贵，这也不是必需的，但是你要能分辨不同的公司来电话的特点。</li>
</ol>
<p>以上3个步骤主要是为了不打扰你正常的找工作的进度，有些公司喜欢在网上乱搜，发现不匹配的简历从而确定是否造假，如果你确定无妨，直接用自己的名字也可以。我没改名字，我的同事有改了的，自己考虑清楚就好。</p>
<h2 id="4-选定发展方向"><a href="#4-选定发展方向" class="headerlink" title="4. 选定发展方向"></a>4. 选定发展方向</h2><p>一般consultant有6个方向，我由于国内有经验，所以略过这一步</p>
<ol>
<li>c/c++方向，机会少，难度大，工资一般，除非你确实非常熟悉这个领域，不推荐。</li>
<li>asp/.net方向，机会适中，难度适中，可 以考认证提升含金量，前景广阔，工资高</li>
<li>VB方向，包括office vb 和标准vb，机会少，难度小，可以考认证，未来发展不是很理想，工资低</li>
<li>Java方向，包括pure java和J2EE，机会多，难度高，可以考认证，前景广阔，但涵盖范围广，要求知识点非常多，驳杂难精，工资高</li>
<li>Oracle数据库方向，机会适中，难度适中，前景广阔，工作轻闲，可以考认证，工资中，新入行的建议考虑。</li>
<li>PM/BA/SA方向，能选这个方向的人已经用不着看我的帖子了。如果你是计算机行业的，可以根据喜好选择，否则，请慎重考虑这一步，如果你不能确定，建议你咨询自己计算机专业的朋友，因为这很可能是你未来10年的工作领域，慎重。</li>
</ol>
<h2 id="5-写简历"><a href="#5-写简历" class="headerlink" title="5. 写简历"></a>5. 写简历</h2><p>  准备两份简历，一份用来找你理想的正常的工作，另一份找ICC。正常简历不多说了，有无数人都有了经验谈。这里说说ICC简历，和你普通用来找工作的简历不同，这份简历里应该事无巨细一一罗列，如果你选择Java方向，请确定Java出现了5次以上。你用过的所有软件，名称，版本号，你知道的每一种技术，你做过的<br>项目里面用过的每一种算法，甚至你听说过的技术，不用着急学这些技术，进入ICC后，你有时间去学习。这个简历说白了是用来被人家搜索的，确保任何相关行业的ICC都可以搜索到你的简历。这个简历可以吹牛，但是不必造假，他的唯一用处就是获得ICC来的电话，把你曾经做过的intern, co-op, ta, ra甚至社会实践，帮boss修自行车,volunteer 打义工都可以算成你的工作经验，如果实在没有经验也没关系，那就实话实说，我是好孩子，学过许多许多技术，弄一个大列表就好了。记住你的简历里一定要清晰你的方向，不是所有的ICC都找所有方向的人，大部分的ICC没有那么多培训资源，所以确定好你的方向对于双向选择会很有力，有了方向，你的技术关键字最好优先选择该方向的，不熟悉的话，可以咨询专业朋友。不怕长，4-5页也没关系。 准备4个版本，word, pdf, txt, html确定都看起来不错。</p>
<h2 id="6-更新简历"><a href="#6-更新简历" class="headerlink" title="6. 更新简历"></a>6. 更新简历</h2><p>常用网站：Dice, CareerBuilder, Monster，特别是dice几乎是专业consultant公司聚集地，在网上填写简历，确定打开了让employer浏览的选项，每3天一定要注意刷新自己的简历，确保他总在搜索结果的前面。</p>
<h2 id="7-主动投递"><a href="#7-主动投递" class="headerlink" title="7. 主动投递"></a>7. 主动投递</h2><p>在上述网站建立好简历后，就可以开始主动投递过程了，输入你确定的方向关键字，asp就输入asp .net，java就输入java，搜索，你会得到一个大列表。这个结果里面鱼龙混杂，大部分都是鱼，就是ICC发布的虚假工作信息，少数是龙，需要你认真对待。</p>
<p>识别鱼龙信息</p>
<ol>
<li>发现our direct client…，consultant，consulting字样的帖子，一定来自于ICC，而且这样的帖子内容全是假的，唯一有用的就是可以建立一个沟通你与consultant company的渠道。</li>
<li>如果发现一份来自于你没听说过的公司的招聘信息，点进去后发现里面介绍的requirement异乎寻常的详细，甚至连各种技术细节都明码标价，这信息一定是假的</li>
<li>点击公司名称，发现这家公司在最近3天内发布了10条以上不同工作岗位的招聘信息，不用我说了吧，肯定是假的</li>
<li>大公司的招聘信息一般是真实的，但是不是所有的大公司都会相应你的application的，比如IBM，工作机会看起来爆多，实际上HR看都不看，几乎所有的职位都是通过internal reference过去的或者co-op/intern职位转正的，外部信息完全无效。这是MM在IBM的manager说的，相对可靠。</li>
<li>大公司，听说过的公司的只要看到合适的职位一定要仔细对待，这些就是水池不多的龙了。</li>
<li>记住真实信息只占不到10%的比例，如果你觉得有一半是真实的，多半你已经受骗了。你已经区分出了虚假信息和真实信息，真实消息认真对待，网上不是没有真的东西的，我在amazon的面试机会就是从dice上找到的，对于鱼，用垃圾简历快速申请，对于龙仔细填写cover letter发送自己精心专门修改的简历，对于不鱼不龙无法确定的东西，使用正常简历，利用快速申请完成。如此下来，每天3小时左右，就可以处理所有的网上信息了。如果你还要找你自己行业的工作，继续，恕我无法帮忙了。</li>
</ol>
<h2 id="8-准备计算机知识"><a href="#8-准备计算机知识" class="headerlink" title="8. 准备计算机知识"></a>8. 准备计算机知识</h2><p>发简历的同时，你要开始准备计算机知识了，毕竟ICC也是要面试的，不过相对简单和低要求罢了。按照你确定的方向，学习编程，多动手，多试验，上网找相关面试问题，备好答案，不用怕现在开始已经晚了，刚开始找工作，phone interview要过的关口多了，紧张关，语言关，口音关，然后才轮到技术关，一般半个月时间差不多够你熟悉基本的软件开发过程了，也能简单书写一些程序了，这时多参加phone interview，慢慢也就找到感觉了，什么问题问得多，哪里技术要点多，多余专业朋友交谈，听人家说能长不少见识，一个技术词汇，听说过就比两眼一抹黑强得多。如果有时间而且有能力，考个专业认证是个非常不错的选择，多看看书，多做做实验，以中国人的智商，考认证不在话下。有了认证对很多公司都是非常有吸引力的。而且面试问题也多出自考试要点。</p>
<h2 id="9-Phone-interview"><a href="#9-Phone-interview" class="headerlink" title="9. Phone interview"></a>9. Phone interview</h2><p>大约在你把简历post上几天以后，就会开始有各种ICC联系你，名字千奇百怪，口音百怪千奇，99%是印度人，80%是印度女人，它一般会说一大串我是什么什么公司，我有一个什么什么职位match你的background什么的，然后就是你是否感兴趣，然后就是让你介绍一下你的各种status，如果发现你需要H1B，他会特别高兴得告诉你，我们可以办啊。没听清楚不要紧，不用怕rude，直接问，还听不明白可以让他拼给你，或者让他给你写信，Are you a consultant company? where is your location? can you giveme a email for your detail information? Do you have benefit package? Do youhave training plan for new consultant? how many consultants are there inyour company? how many sales are there in your company?…反正就当多练练电话口语好了，很多印度人口音很重，还能帮你提高下听力水平。什么都不要答应，就是不停的接，要联系信息，什么事情都是interested但是需要consider就行了。回过头上网查一下这个公司的情况，看看网页，一般很简单的网站，把他们的联系方法留下来，发份简历过去，一般不多久后就会要求你进行technical interview，这样的公司很多，NY/NJ地区就有1700多家，永远不会有过了这村没这店的情况，放心大胆的实验。大部分ICC只有10个左右的consultant，有的只有几个，如果是local的，可以要求去看看你们公司什么的。差不多过个半个月1个月的，你就能够差不多摸清附近的consultant company的底子了。</p>
<h2 id="10-Technical-Interview-By-ICC"><a href="#10-Technical-Interview-By-ICC" class="headerlink" title="10.Technical Interview By ICC"></a>10.Technical Interview By ICC</h2><p>  ICC的Technical Interview大部分是由普通consultant完成的，因此技术也不会多么出众，但是会就是会，不会就是不会，他们没有经历过HR培训，因此不懂得如何判断背后的事情，少量高级的ICC会聘请专业的人士进行面试，但那样的公司却不见得好。我曾经帮着ICC面试过无数人，这种面试最重要的是看你是不是能听懂题目，知道往什么方向想就行了，专业技能很多ICC是允许进来后再培训的。很多完全没有专业背景，一听就知道简历作假的人也给了offer，这种offer不值钱，因此发起来也轻松得很。不用着急和ICC签约，一般他们会给你一个时限，如果你觉得时间还充裕，大可以扔到一边继续找工作，以后再吃回头草也很容易，一个电话打回去，再要你的可能性也很大，因此千万别被人忽悠了，好像这个offer就是天下少有人间第一的东西，不今天拿下你就丢了个大金砖。</p>
<h1 id="三、了解ICC"><a href="#三、了解ICC" class="headerlink" title="三、了解ICC"></a>三、了解ICC</h1><h2 id="11-确定ICC的工作地点和工作范围，"><a href="#11-确定ICC的工作地点和工作范围，" class="headerlink" title="11. 确定ICC的工作地点和工作范围，"></a>11. 确定ICC的工作地点和工作范围，</h2><p>ICC Onsite interview</p>
<p>很多ICC要求上门的Onsite interview，记住如果是那种直接发给你email的on site intervew邀请，让你几点几点到什么地方去面试的公司，而你甚至从来没听说他，也没有过phone interview的过程，千万不要信，这种公司会一次性发出几千份这样的邀请，貌似传销在中国的做法，去了就要求签约，危险性极大，听朋友们说过这样的东西，也接到过这样的信，但我反正是没敢招惹这样的公司。正常的ICC赚的是把你出租给大公司后的利润，而不是办身份的那点deposit，而那种直接发offer的公司就不好说了。如果你经过正常的交往，预约，phone intervew or phone screen，你感觉确实和他的recruiter有了联系的公司，向你发出on site的邀请，如果是本地的，你就可以去了，远程的一定要打听清楚位置，是否报销路费什么的，传说中有负责付费的公司，但是我没见过，大部分的人都是自己掏腰包去面试的。所以你一定要确定那个位置是你可以接受的范围。要知道，大部分的ICC只局限于公司地点附近的范围寻找client，这也是为什么NJ那么多ICC的缘故，他们吃的就是华尔街。如果有家公司告诉你他们可以负责帮你寻找全美国的机会，他们的client遍及全美，却让你跑到2000mile以外去面试还不负责你的travel plan，那么直接忽略掉就好了。骗子没商量。ICC不可能那么干的，正经公司则一定会直接给你买好机票和酒店的服务，让你自己先买然后报销的都需要掂量一下，何况什么都不管的。一般情况下，如果你想在NY工作，NJ的ICC就是可以考虑的，如果你想在DC工作，那么Virginia的就没问题，ICC最多可以跨2个州的距离服务，很少有ICC会服务超过这个范围。有不少ICC会负责你去client那里on-site intervew的路费，所以太远了，她受不了。</p>
<h2 id="12-Negotiate"><a href="#12-Negotiate" class="headerlink" title="12. Negotiate"></a>12. Negotiate</h2><p>如果有了ICC对你有兴趣，你也确定了这家ICC值得考虑，那么就可以开始谈判了，一般的ICC都会有一些标准程序，大部分的consultant都是这样的，但决不意味着这样的合同就不能修改，条件都是可以谈的。注意谈的几点内容。</p>
<ol>
<li>deposite，一般要求2000，有些甚至要求3000，但是这个数字是可以谈的，注意几点，押多少，什么时候归还，用什么方式归还（因为可能涉及Tax），我最终只押了500，我有个同事1分没押，还有个同事押了3000，这个数字非常重要，关系到你如果没有开始contract就跳槽的话你的损失会有多大。一般的ICC这个押金确实会归还，只不过会拖几个月，确定你给公司拿回利润了才还给你，还是打在工资里，让你白交好多税。如果押的少，一切没关系，压得多，这个返还就很重要了。一般你的技术越好，手里offer越多，就越好谈，我有个同事手里攥了10多份ICC的Offer，然后谈成了不要押金。如果要求以归还押金方式返还的话，很多ICC是不愿意的，因为这样会留下他们向员<br>工收取押金的证据，这是不合法的，所以尽量要求少交押金是王道。</li>
<li>工资的支付方式，一般的ICC会合你签一份阴阳合同，就是给移民局看得一份，自己明白的一份。这样的东西做不得准，其实全靠信誉。如果你发现公司工作场所还比较大，有3个以上的专职sales，2上以上的专职recruiter，经理，财务，秘书配备齐全，那么一般就可以信，如果只是小猫三两只，办公室狭小，人人都是全能选手的，小心<br>，小心，自己考虑，我被骗过。刚刚看到回复中有人讨论是否周末发薪水的问题，我只能说我曾经在的是发的，听说也有不发的，前面的公式只供参考，不要较真，真正混到ICC去干了，已经是有钱就谢天谢地了。真正在你拿到client的Job offer后，你还会被要求和公司另外签一份合同，那里面是按照年薪方式确定你的薪水的，这个薪水就是你能拿多少了，但是这个数字和你最开始与公司谈的条件息息相关，比率如何，月pay还是周pay，有些甚至签订了自第一个project后，按月连续pay的，不过很少见就是了，周末，假期怎么算也都要在最开始谈妥，有些甚至承诺vacation的，所以谈判至关重要。最惨的往往是直接从印度拉来得那些，什么都没得谈，咱们还是有的谈的。</li>
<li>工作地点，你可以限定自己的工作地点，比如你只希望在NY地区寻找机会，这样可以省得你不停的搬家，对于有家室的朋友尤其重要。</li>
<li>假期，和休假方式，这个东西很麻烦，说实话，我没看见过有人休假，也没看见过有中国人真的在ICC常待，所以，旁枝末节的东西不要也罢。</li>
</ol>
<p>反正和ICC谈就一条，钱，自己损失多少，能拿多少，计算清楚就好，不超过自己的底线就万事OK。</p>
<h1 id="四、拿ICC-Offer"><a href="#四、拿ICC-Offer" class="headerlink" title="四、拿ICC Offer"></a>四、拿ICC Offer</h1><h2 id="13-Take-the-offer"><a href="#13-Take-the-offer" class="headerlink" title="13. Take the offer"></a>13. Take the offer</h2><p>如果你到了3月上旬，中旬，甚至3月下旬还没有搞定一家普通的工作，甚至连机会都看不到，如果再不File你的H1B申请就可能丢失身份，打道回府的话。抓紧最后的时间联系曾经对你感兴趣的ICC，最好是你已经做过一番考察的那些，确定它们的工作地点和工作范围。3月份也是ICC签约的高峰期，很多人抱有相同的想法，因此这个时候有些ICC的工作效率会下降，所以自己把握好时间，否则一旦耽误了file申请那就不划算了。申请材料要早早备好，各种需要的公正也要备齐，复印件就好，原件保留好，以后transfer或者重新申请都有用。做好一切物理上的，生理上的和心理上的准备后，签约从了吧。奴隶生涯从此开始，历史的车轮再也没你什么事了。</p>
<h2 id="14-分水岭"><a href="#14-分水岭" class="headerlink" title="14.分水岭"></a>14.分水岭</h2><p>到了这里就是一个分水岭了，整理一下目前的状态，首先，你已经屈尊从了一个奴隶贩子。第二，你已经开始办理合法的手续。第三，你还憧憬着一些未来。根据不同人的不同情况，在你take了offer以后，你在ICC的经历会呈现多极化发展，如果你是一个拥有美国学位的master或者ph.D，别奇怪，我在consultant公司还见过卖身的CS专业phD呢，个人选择的路不同而已，有些人喜欢这样的生活方式，有些人遇到了特别的困难，有些人只是运气不好，做人要宽容。言归正传，你是Master或以上学位，你可以在毕业后使用Opt开始工作，这种情况，你的毕业日期就是你开始工作的时间，不过不见得是开始拿钱的时间。这是你的选择有两条，</p>
<ol>
<li>继续找正常工作，如果找到，让他file另一份h1b申请，这是合理而且合法的，前提是H1B名额没有用完，而且你能找到正经的职位。时间紧，任务重，要知道这两年H1B Advanced的名额也越来越早用光了，以现在的情况来看，明年advanced h1b名额不排除开始就用完的可能，所以很可能明年的这一条选项已经作废了。所以安排好你自己<br>的schedule，抓紧在4月份之前搞定工作是正途。对了，顺便说一句，如果你打算申请明年的H1B，那么，现在开始都已经有点晚了，找工作脱个几个月挺正常的，确实有人1周搞定的，但大部分人没那么好运气。所以，抓紧吧。</li>
<li>认命了，在consultant公司老实呆着，接受培训，自己努力学习CS知识，争取在2个月内搞定所选方向上的各种知识点，3个月后上班，1个project之后被留在那个大公司成为华尔街一员。那么这个时候就是你开始学习的时候了，你的简历上标注的那些你没掌握的古怪名词，抓紧时间看吧。多混混技术版面，各种tutorial一定要熟练掌握，<br>自己编两个项目做做看，没有实际经验就找有经验的人打听打听，反正拿出你们当年考G,T的本事，2个月在拼出一个什么认证也不是不可能的。Oracle DBA认证2个月拿下的人好像不少，所以，努力吧。<br>  如果你是一个F2，H4，或者CPT使用过渡的F1，首先，让我们祝福一下这些人。如果你为了爱情放弃自己的事业，成熟的人脉，多年的经验飘洋过海来到异国他乡只为与爱人团聚，这叫浪漫，如果你同时还办了张F2/H4的签证，那就叫WS，变成了羡慕美国过来吃白食，抢资源的WSN/V。这种奇怪的MITBBS理论让我彻底远离这个是非之地。很多时候这里只有一种声音，并不代表世界上只有一种声音。别说什么怎么不回去，首先这要问F1而不是F2，另外回去了的不会出现在这里。牢骚发完，言归正传，由于没有Opt，你只能等待H1B批准，10月1号生效之日后才能开始工作，有些ICC从此就不理你了，直到有了什么新的信息出现。h1b file, h1b recieve, h1b approve, h1b active等等，而你只能在家里等着。有些ICC比较nice，你可以要求在这漫长的6个月里参加培训，打打零工什么的。由于时间充裕，所以你可以仔细研究技术，面试技巧，多上网看看，同样也因为时间充裕，所以你可能会懈怠，会彷徨，会苦恼什么的，希望你有一个关心<br>你体贴你的另一半，要知道，在ICC的经历很难用愉快来形容，而一般情况下你对世界看法往往是来自于你对周围20米环境的看法，所以，这段时间你会觉得世界灰暗，天空污染严重什么的，如果你还偏巧和另一半在冷战/热战/无间战什么的，那么，希望你有一个坚强的内心。</li>
</ol>
<h1 id="五、ICC-培训"><a href="#五、ICC-培训" class="headerlink" title="五、ICC 培训"></a>五、ICC 培训</h1><h2 id="15-Training"><a href="#15-Training" class="headerlink" title="15.Training"></a>15.Training</h2><p>等待是痛苦的，等待H1B抽签结果，审批结果，生效日期更是痛苦的，而与此同时，偏偏你又必须经理人生中最灰暗的几个月，没有工资，一切都靠积蓄维持，可能你还不得不去租NJ很贵很贵的房子，你又要开始重新学习一种新的技术，貌似你以前的努力，奋斗全都变成废纸一张，手里拿着自己熟悉领域的master/phd却要学习民工才干的垃圾计算机技术。内心是痛苦的，工作却是繁忙的，民工的技术也是技术，不那么好学，东西多，时间短，还需要理解然后还需要练习，操作，欲仙欲死是对这段时间比较好地描述。</p>
<p>有不少ICC公司有培训，包括技术培训，职业培训，interview培训，简历培训，行业培训什么的。ICC的目的是把一个Fresh的人包装成experienced的人来卖，造假也是需要技术含量的，培训就成了唯一的方法。培训的东西都很皮毛，但是很应景，一般技术培训还好，其他方面就是完全针对Interview会怎么问来弄得了。东西很实在，短短两个月时间需要把你训练成，人家突然发问，你上一个项目在哪里？你都能顺口背出地址门牌的那种。不过因为大部分培训都是由consultant客串的，因此课程没有那么专业，也没有那么有条理，时间上更是往往安排在休息时间。再加上大量印度人的奇怪口音，恩，这个课程实在有些…不过好歹这也是培训，多少能学点东西不是。</p>
<p>Training的过程无聊的，掌握的知识也是有限的，如何用有限的知识去套取无限的机会就看你的本事了。作为行内人士，自己的道路一定要确定好，换来换去是最大的忌讳。搞Java您就一头扎下去，搞c你也别觉得java机会多就匆忙换lane，要知道各种技能都有各种技能的优势，你可以理解为游戏中的技能树，最怕的就是哪样都没多少级，树倒是挺大。放低身段，摆正心态，你现在就是个民工，学的是手艺，比瓦工唯一好一点的就是不用晒太阳。所以不要看不起谁，三人行必有我师，我更觉得每个人都有优点，虽然你不见得一定去学习，适合他的优点不见得就适合你，但是认识别人的优点其实要比认识别人的缺点对你自身的帮助更大。</p>
<p>我们的口号是学习，练习，实习。学计算机都知道，看半天书，比不上写一段程序，找你的朋友帮忙给你个实际project要求来练习，要比你死背半天书有用的多，不过花的时间也会长的多。如果你确定自身只是短暂的计算机生涯，那么，死背书也是可以的，整理大量的相关方向的面试题目，背下来，混过关的也有的是呢。我这里有Java方向的一些题目，如果有人需要的话，我可以贴上来，那是我在ICC作Trainer时整理的，成功帮助4个Fresh的Bachelor拿到职位。其他方向的题目就只能靠自己组织了，不难，四处google就是了，关键是要给出自己的答案，对不对关系不大，但是一定要自信。</p>
<h1 id="六、身份"><a href="#六、身份" class="headerlink" title="六、身份"></a>六、身份</h1><h2 id="16-H1B"><a href="#16-H1B" class="headerlink" title="16.H1B"></a>16.H1B</h2><p>这是律师给我的H1B application的材料清单</p>
<ul>
<li><p>Job description letter 公司提供，一般你看不到</p>
</li>
<li><p>Completed information sheet 公司提供，一般你看不到，但是公司会让你添一张他们自己格式的表格。</p>
</li>
<li><p>Current resume 你提供，真实，可靠，经得起追查的简历，可以与你找工作给公司的简历不同，一般公司都会理解。</p>
</li>
<li><p>Signed I-129 一般公司会给你办</p>
</li>
<li><p>Typed sheet with 会要求你填表</p>
</li>
<li><p>Daytime phone number</p>
</li>
<li><p>Evening phone</p>
</li>
<li><p>Permanent address</p>
</li>
<li><p>Foreign address</p>
</li>
<li><p>A copy of your social security card (if applicable) 你提供，可以没有<br>School transcripts 成绩单的复印件，如果没有美国的，要提供国内的，F2们要注意，中文的就可以，最好有英文译本。</p>
</li>
<li><p>School degrees 学位证明，同样，没有美国的，要提供国内的</p>
</li>
<li><p>OPT card (applicable if you are a student graduating from US) F1们需要提供</p>
</li>
<li><p>All I-20 (applicable if you are a student graduating from US) 你提供，所有的I20，不管过没过期，一起复印打包给他，他会挑</p>
</li>
<li><p>All passport pages – even the blank ones 你提供，所有页啊</p>
</li>
<li><p>I-94 – front and back (And please specify the dates of entries and departures from / to US) (If applicable to you) 也是所有的I-94，包括更新过的。</p>
</li>
<li><p>Experience letter from previous employer </p>
</li>
<li><p>Awards and recommendations </p>
<p>H1B抽签有两种结果，抽中或者没中，H1B申请也有两种结果，批准的和没批准的，运气坏的时候什么事情都可能发生，踩个香蕉皮就挂掉的人也不是没有，因此一颗红心两手准备是必需的，为H1B的申请结果作备份更是必要的。如果你像我一样是F2，那么一切就简单了，只要你的另一半还保持着身份，你应该还有机会换回来，手续我不是很清楚，但是确实是这样。如果你是独立的F1又没有另一半，或者你的另一半身分依靠你，那么你就需要寻找一些备份了。常用的方法是找个社区大学注册成part time学生，然后需要的时候转为full time的f1。这个方法需要你花一些钱，而且转成F1会要求你花更多的钱，我所认识的大部分印度人都是这样的。方法二就需要很早以前作打算，其实大部分美国高学历留学生可能都能符合加拿大，澳大利亚之类移民，我不熟悉过程，不过打听下还是有方法，不贵，实惠，比其他备份好得多，但是缺点是必须早下手。  H1B批准了以后，基本就可以放心了，老老实实的任命学习工作就是了，这个时候的世界依然灰暗，但是前景已经可以预期，所以曙光就在前头，胜利再向你招手。</p>
</li>
</ul>
<h2 id="17-Marketing"><a href="#17-Marketing" class="headerlink" title="17.Marketing"></a>17.Marketing</h2><p>  一切准备就绪以后，就要开始Marketing了，如果是F1你现在应该已经在公司里熬过了2个月左右，如果是F2你可能已经熬过了4个月甚至更多。Marketing的第一步就是修改简历。公司会要求你修改你的简历，造假成为多年工作经验的简历，编造隶属于某大公司假的项目，然后针对这些假的经历准备问题，答案，反复练习。这一步也是版上被诟病最多的部分，所谓ICC违规，一般其实也就是这里，前面的程序可都是合法的，除了完全让你抓不到证据的deposit，但是这一部分却是两家公司打交道的事情，弄到天上也就是个民事案件，最坏结果也就是辞退。这也是为什么很难清理这种违规，我在国内经验丰富，真实，一样比不过假简历，这是现实，就像强奸，你不能反抗，你就享受吧。不过是否更改简历一般还是看你个人意愿的。你自我愿意保持纯洁，拒绝造假也是可以的。不过那样公司就会把你按照Fresh的方法来销售了，价格很低，30块一小时，你觉得可以也没问题。我见过这样的consultant。如果你像我一样有国内经验，也可以保持纯洁不造假，虽然机会会少一些，但是依然能够通过你的能力被客户认可，准确地说，用人单位搜索的时候靠简历，雇用的时候还是看你面试的能力的。听说过因为简历造假被打回的案例，但是细一打听，这个也就是个理由，真正的原因还是因为技术差，无法干活。而且那个印度哥们没多久又被另一家大公司contract过去了，没见影响他的什么前程。很多ICC里面工作的中国人consultant从来不到这里来也是因为自己觉得自己用了假简历没面子又会被骂，中国人在consultant里面可能连10%都不到，影响大局的绝对不是那几个中国人。</p>
<p>这一部分见仁见智，自己斟酌，造假我也不能担保就没事，不造假的我也不能担保就高尚，自己斟酌吧，已经ICC了还装什么大尾巴狼。</p>
<h1 id="七、面试"><a href="#七、面试" class="headerlink" title="七、面试"></a>七、面试</h1><h2 id="18-Interview"><a href="#18-Interview" class="headerlink" title="18.Interview"></a>18.Interview</h2><p>公司把你Marketing后，你就必须面临高密度的Interview考验了，一般情况下interview分为6种</p>
<ol>
<li>simulation interview 模拟面试，一般是由已经工作了的consultant来做的，主要是让你熟悉你的专业领域各种问题，避免紧张和听不清楚题目的问题。然后公司会要求你当众作presentation，介绍你的项目（关于你的简历），你的背景，你的特长什么的，如果你的公司没有这样的安排，建议你也找朋友帮你做做这样的训练，对于面对<br>interview的各种技巧掌握很有帮助。由熟悉的人或者朋友的朋友什么的来面试你，考考你，这种是最简单的，但有时候又是最难得，在朋友面前开不了口，认不了真的人比比皆是，一说就是you know，总觉得你是朋友肯定知道我说什么，朋友一细问就勾肩搭背胡言乱语试图避让。这些其实都是心理上的问题，有些人确实在熟人面前反而不知道该怎么回答正式的问题，但大部分人，如果不能在熟人面前侃侃而谈，那么面对陌生人也不会有什么好的状态。因此，如果你又面对熟人不知道怎么答问题的情况，反而建议你多练习几遍，因为这样的训练其实可能对你未来的工作道路非常有好处。</li>
<li>Technical interview by Vendor 中间商的技术面试，一般的ICC都是通过Vender来进行销售的，大量的资源掌握在Vender手里，大公司们通 过Vender发布信息，ICC通过Vender获得资源，所以Vender的认可，是你能够获得更多资源的关口。Vender的Interview可能是最难过的interview.很多Vender会找专业的HR公司来进行这样的操作，HR公司有专门进行各种专业能力Interview的人才，感觉很奇怪，似乎这个行当也被印度人垄断了，大量印度口音。问题非常详细，程序细节部分非常多，很少有算法之类的，那些是phd干的，民工只需要懂写程序就好了。准备的时候需要非常仔细，很多技术细节的内容可能写程序一辈子都遇不到但他会问。举个Java问题例子，primitive类型中，哪些不是thread safe的，什么时候会出现这样的问题，为什么。答案是long和double类型，因为Java是以32 bit为字长的，而<br>long和double是64位的，可能出现前一个thread在读取第二个字节，而下一个thread却修改了第一个字节。所以不安全。这是个印度人告诉我的，说实在的，就算你真得有10年8年Java经验，也不见得用得着这个东西。要知道，谁会在项目中不使用对象而使用单独的long来操作的，不要说thread safe，基本的封装都没有满足，这也太不安全了吧。说的可能太专业了，但是我只能说做这种interview真的很变态。但也没法子，接受吧。他们会在interview之后填写一张表格，表示你的水平如何，如果你的ICC sales和Vender比较熟，可以拿到这个结果，然后就需要你根据你薄弱的部分进行提高了。这种面试的技巧是一定要不停的说，一个问题，拼命答，如果你会，就把相关的问<br>题也都说上，随便延伸，只要相关还有道理就说，可以把interviewer的思路引导你熟悉的领域。如果你不会，就需要寻找hint，一般他会给你一些，如果还不会，可以直接问他答案，事实上，作为人都有一种指点别人的欲望，比如我在这里拼命码字，所谓人之初好为人师嘛。给interviewer一个机会指点你并不会怎么影响你的成绩，当然如果你一直需要指点那基本上就fail定了。这种Interview往往比较专业，所以不那么容易糊弄，但不是所有的Vender都会这么要求，因此蒙混过关的也不少。有些Vender还会要求你进行一些测试考试，一般在网上进行，专门的网站，Vender花钱或者ICC花钱，如果不会，擅用Google对你会很有帮助。很多时候直接google问题加答案选项，出现匹配数最多的那个往往就是正确答案 （比如四千万个match的答案一定比两千万个match的答案更正确）。不管你选哪个CS方向，Hashtable和Design pattern是两个必问的问题，无论是ICC还是普通公司的interview，一定要详细准备。</li>
<li>HR interview by Vendor 中间商的HR面试，这个面试相对简单，只有少数的Vender关心你的behavior什么的，面试更像是走过场，不过依然建议你细心准备，这种面试题目有时候很古怪，考验你的全方位的思考能力，比如让你推销一份报纸你该怎说，你喜不喜欢锻炼，为什么什么的。这种面试往往在找普通工作时经常遇到，因此，认真准备不吃亏的。准备这样的interview要注意一点，一定要保持你的性格特点，这点很重要，观察自己，寻找一个性格特点，比如你是一个非常细心的人，非常有活力的人，非常友善的人，然后根据你的性格特点设计你的答案。比如你是一个细心的人，你在卖报纸的时候就会准备非常详尽的资料，丰富的数据来打动对方什么的。同时你在体育<br>运动方面可能就会比较偏向于技巧性，就算非要跑步都喜欢去Gym里算卡路里。这样的面试没有所谓的正确答案，别人的答案也不见得适合你，精心准备，精心设计，发自本心最好。比如你一生中最大的成就是什么，很多人喜欢说虽然我已经取得了很多的成就，但是我最大的成就还没有到来或者我会努力争取更大的成就，这似乎是个通用答案，但不见得就比回答我找了个很漂亮的老婆更impressive。一般情况下中间商关心你的实际技能是否与简历相符，你的心理是否成熟，是否有过合作的经历等等，因此你的答案最好也能够包含这方面的信息，顺便聊聊自己过去成功的经验什么的是个不错的选择。<br>比如，“我曾经遇到过类似的情景”，“我的经验告诉我”，甚至和interviewer开两句玩笑都可以提高你的印象分。在这个面试中introduce yourself是标准第一个问题，一定要熟练准备。</li>
<li>Technical interview by Client 客户的技术面试，相比Vender的interview，多数时候client的interview更简单，但是更与项目相关，大部分的client不使用专业hr公司进行面试，而是从已经建立的组里抽个人面试。这样的面试随机性就很大了，也就是说看你的人品了，可能很简单，也可能遇上个刁难的，甚至有刁难半天，最后简单<br>通过的，反正什么样的鸟都有。准备时注意项目相关，仔细阅读人家的需要，然后发掘自身中相关的部分，准备相关的技术问题，最好能把技术问题和自己的经验相关起来回答，比如说起对方的项目，使用什么什么架构，然后告诉他，我以前用过这种架构，有什么优点，可能遇到什么问题，如果能这样，几乎肯定能过。对于新入行的人来说，这一关就比较难过了，因为太多东西真的是经验相关，所以只能说good luck了。不过多听多看，总是有好处的，找找朋友让他们给你介绍介绍项目里面的东西，可能也会比较有帮助。Introduce your last project是最常问的技术问题，一定要对你简历上所有内容做<br>到了如指掌，无论真假都要信手拈来才行。</li>
<li>HR interview by Client 一般的Client不太关心这方面的问题，谁见过找民工还要挑帅的的？所以也很少有这种interview，但我这里还是列了出来，因为普通工作中常见，ICC毕竟不是我们一辈子的归宿不是。这种Interview关注的是一个人的行为习惯，个性，潜力等等，所有的问题没有标准答案，问题类似于上面的，可以一起准备。了解自己，尤其是了解自己的长处，别觉得可笑，很少有人知道自己优点是什么，觉得自己一无是处的多，觉得自己天下第一的也不少，但是能准确认识自身优势的人少而又少，因此，这里面的门道可能是最大的，兄弟我功力不够，就不多说了。</li>
<li>On site interview by Client 再一次提醒你，记住你是民工，虽然你可能比有些人挣得多，但你就是民工。衣着不用太讲究，普通的formal就可以了，不用在这方面花太多精力，领带不是必需的，花色也没什么关系，女孩子穿靴子还是穿凉鞋都是最后码砖头的，人家关心的不是这些，关心的就是你的能力，技术能力，交往能力，沟通能力，合作能力，尽量在这四方面做准备，问题的范围基本上是technical interview和HR interview的综合，答案着重于突出自己的四种能力特别是技术能力和合作能力。作项目必须的，要想打动对方，这两点强调在强调。</li>
</ol>
<h1 id="八、离开"><a href="#八、离开" class="headerlink" title="八、离开"></a>八、离开</h1><h2 id="19-离开ICC"><a href="#19-离开ICC" class="headerlink" title="19. 离开ICC"></a>19. 离开ICC</h2><p>很少见到中国人以ICC为职业，美国人倒是不少，那些人喜欢一年只上半年班，剩下的日子去旅游的生活态度。中国人一般折腾不起，ICC的目的是为转换身份，保持身份，或者挣两个小钱什么的，因此几乎是从进门开始，我们就打了离开的谱，ICC的老板也明白这个事情，这也是为什么他们要收押金，有些还拖着不还的道理，三个字，见多了。可是具体怎么离开呢，一般的方法有三种：</p>
<ol>
<li>打时间差，在被发配到client那里之前找到正经的工作，这个方法其实比较难，主要是看运气，可能开始点背，进了ICC，后来翻运大杀四方也说不定，优点是省时间，可以直接进入正式企业，缺点是由于你没有从ICC那里拿过工资，所以H1 Transfer的手续不齐全，押金肯定就别指望要回来了。律师说这样的情况严格从法律上来讲已经处<br>于out of status了，所以需要重新递交申请才能拥有新的H1B，六年内重新提交H1B申请不占新名额。只要你的公司愿意要你，这些都不是问题，180天内out of status对将来没什么影响。最坏的结果好像是需要出国激活，与OPT和H1间的gap处理起来一样。</li>
<li>老老实实给ICC打工，指望Client看上你，留下你，说起来好想挺悬，可是最终我发现好象这样的成功概率最高，中国人大部分勤劳肯干，吃苦耐劳，而且也足够聪明，见过不少这样的成功案例，前面看到有人鄙视华尔街的程序员，感觉太不厚道，卖盗版的都算作IT的凭什么做软件的就不能算华尔街的了。因为很多consultant程序员原来的是什么学经济的，学数学的，学机械的，留下的职位也千奇百怪，反正不都是程序了。主要是因为进入公司内部，认识了新人，有了自己的network，然后就可以找到内部的人reference，好多公司都是门槛高，进去就是那么回事。牛人就那么几个，剩下的都是混日子的，能让真正缺人的manager看到你的简历，其实已经成功了一半了。在职场外面的学生们总是担心这个担心那个，找工作四处乱发，但是一旦你进入职场，所有的都靠人际关系了，对了这东西在美国叫network。这种方式的好处是需要努力+运气，还有良好的沟通交往能力，如果你是万金油类型的人物，那就没问题了。缺点是从法律<br>上来说公司不能直接留下contractor，会被告，不过如公司真正想要你，也会通过各种手段迂回，比如你进入的是另外的部门之类的，反正作假不是只有ICC会的，彼此都知道对方是什么东西，因此也相安无事。</li>
<li>慢慢找工作，就是普通的跳槽，这样的是满多的，人不可能一辈子点背，总有时来运转的时候，找到工作跳槽，天经地义，谁也不能说什么。手续也就是标准的跳槽，比较容易，由于你已经给ICC工作过了，所以基本上也不会有人阻拦，缺点是时间太长。也不排除跳到其他ICC的，只是为了争取自己的最大利益罢了。谁也别说谁什么，就<br>是老百姓过日子罢了。</li>
</ol>
<h2 id="20-终"><a href="#20-终" class="headerlink" title="20.终"></a>20.终</h2><p>写了这么多，快两万字了，谢谢那些看到这里的人（如果还有的话）。写了3天，终于把这些心得体会完成了，感谢大家阅读和回复，希望大家不要找MM的麻烦，人家的ID还是挺好的，不打算废掉。这里顺便回答一些同学的问题。对于各种意见，我一开头就说了，这是一段很阴暗的介绍。没什么可自豪的，也没什么可丢人的，在ICC的人只不过和许多端盘子，教中文，送外卖的人一样，为养活自己而努力着罢了。我说过很多遍，ICC是找不到工作的人的最后一个选择，所以那些有工作的人谴责ICC的人，只不过是“何不食肉糜”新版。还有些人觉得只要自己守规矩，其他人也守规矩，这个世界一定更美好。看我这篇文字会破坏这些人对这个世界的美好感觉，你可以看看格林童话迪斯尼故事，在那里好人永远胜利坏人永远被惩罚公主和王子从此幸福的生活在一起。</p>
<p>ICC不是一家公司，而是全美数千家公司的总称，美国的一切都是无罪推定的（来美签证除外），法院没说他们违法，我也没那个资格。现在，我已经离开ICC，这也是为什么我跑来这里发疯，在ICC有多少人有心情跑来长篇大论我不知<br>道，反正当时我没心情。现在的我，依然还是程序员，工作不好也不坏，在湾区，勉强能过吃光花光身体健康的生活。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/11/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E5%88%B7%E9%A2%98%E7%9A%84%E8%BE%9B%E8%8B%A6%E5%BE%97%E5%88%B0%E5%BA%94%E6%9C%89%E7%9A%84%E5%9B%9E%E6%8A%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/11/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E5%88%B7%E9%A2%98%E7%9A%84%E8%BE%9B%E8%8B%A6%E5%BE%97%E5%88%B0%E5%BA%94%E6%9C%89%E7%9A%84%E5%9B%9E%E6%8A%A5/" class="post-title-link" itemprop="url">如何让你刷题的辛苦得到应有的回报</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-11 09:00:45 / Modified: 10:03:32" itemprop="dateCreated datePublished" datetime="2020-03-11T09:00:45-04:00">2020-03-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>开场：不卑不亢。你就假装其实你已经有了另一个FLAGUAP的Offer了，就不会太患得患失的，你的气场会感染面试官的。见过太小心的面试者，第一印象不好。</p>
</li>
<li><p>其他大厂也许不一样，但是狗家技术面寒暄之类的都是过场，所以你的回答别太长了，因为你占用的是自己一会儿解题的时间。但也别就两句话，自己把握吧。亚麻有LP内容，还是需要认真答的，但是面试官应该给你留够时间解题。 </p>
</li>
<li><p><strong>一定要重复题目，确认要求</strong>，甚至确认sample input/output。然后问一些edge cases，这样一来表明你的确有考虑这些问题（面试官在等你说呢），二来也是给你自己时间想题目了。 </p>
</li>
<li><p>思考过程千万不要沉默，也不能完全的自言自语（因为他需要听你的思考过程）。如果你会紧张，把面试官想像成你的teammate或者一起做题的小伙伴（就是那种你熟悉的，给你信心的场景），你们一起来解这道题，你给他讲解你的想法。 </p>
</li>
<li><p>先在白板上把你的数据结构和算法解释了，给出space and time complexity（别等人问）。 不要马上写code。 如果你秒杀暴力算法，就直接接着优化吧. 有的题目很明显是要优化的，但是你还是可以很快的提一下暴力解法。Of course you are not looking for this brute force implementation. OK, this can be optimized by …. <strong>展示一个有层次的分析问题的过程，远远好于上来就提出最优解</strong>。多说话才能展示你对不同数据结构和算法的掌握啊。Communication在打分里是和data structure，algorithm并列的一项，你说有多重要。 </p>
</li>
<li><p>开始写code之前问一下：should I start implement it in code, or you want me to conitnue to optimize it? 这样你也大概知道你的位置和面试官的期待在哪里。 </p>
</li>
<li><p><strong>写完code一定要跑test cases</strong>，不是盯着你的code自己看，要说出来。你刚开始问的那些edge cases就是一个提醒。 - 字迹不要太潦草。你不赶时间，除非你思如泉涌怕自己忘了。一些null checking的无聊但是必须的语句，在征得面试官同意的情况可以只写一个comment： // check null etc… (May I skip these checks to save time?). 但是这个comment一定要写，否则面试官可能写报告的时候会忘记。 </p>
</li>
<li><p>class和变量名不要那么长，给自己找麻烦，但是需要解释一句，免得面试官对你的coding style有疑问（sorry I will keep the variable names short just for convenience. In real code I will sure use more descriptive names).  另外， </p>
</li>
<li><p>提前买个小白板练习，因为用Dry eraser写code和用笔写感觉不太一样，尤其是留白的掌握上 </p>
</li>
<li><p>对自己口语没有太大信心的，找个题，边写边讲，用手机录一下自己听听。国人有时候讲英文会吞字节，不太清楚，但是自己不知道，所以要自查一下。  </p>
</li>
</ul>
<p>还有一个问题是<strong>如果题目已经见过了怎么办，要不要如实相告</strong>？说实话我不推荐。那个好人卡没有太大分量，最后你还得解题才能证明自己。如果面试官没有备份的问题（有的比较懒），他说你就解一下呗。万一你的code有错呢？万一你的解法其实不是他想要的最优呢？backfired on you. 你就当从来没有听说过，上面几个过程一个不要少，时间允许的话甚至可以装一装深度思考。:-) 这个时候你展示思路的发展就尤其重要，一下子跳到最优解，面试官心里会觉猜你做过题。如果其他几轮你表现不好，就更坐实了这种猜测。  </p>
<p>还有小伙伴担心没有解出follow up。其实除非特别简单的题，new grad的话有个working code（在加上以上强调的沟通），应该至少有一个weak hire了，最差也是border line，但是L4/L5就很悬。</p>
<p>以前狗家5轮都是coding或者<a href="http://https//www.educative.io/courses/grokking-the-system-design-interview?affiliate_id=5749180081373184/" target="_blank" rel="noopener">system design</a>（除非你面的是manager）。大约半年前加了一个behavioral and leaderhsip round，所以如果你是L3，你会有4轮coding和一个BQ。但是HR好像没有给很多hint怎么准备。题目无非就是你讲故事，或者问你这个情况你会怎么做。大家不要误会那个leadership是要怎么管理别人。老美的leadership含义很广，对L3/4/5来说，leadership其实是怎么管理自己-自己的项目，进度，成长，沟通等等。Behavioral那都是common sense了，team work什么的。</p>
<p>亚麻的那个军规16条很好，可以做基础。狗家自己特别的是：<br>- 你得能管理自己的项目和进度，能够prioritize自己的项目。根据什么标准prioritize？你自己的喜好吗？亚麻军规里其实有，我不敢说的太明了。其实都是common sense<br>- 需求不明确怎么办？你会自己想办法吗？还是依赖别人？Project的需求总在变，你会撂摊子不干了，或者抱怨连天吗？<br>- 亚麻里有个having backbone，那是指manager。如果你的同事做了不好的事或者决定呢？你会视而不见或者和稀泥吗？想想狗家“不做恶”的信条，想想你怎么融入啊？</p>
<p>需要准备至少3-4个故事，比如怎么处理和team里的人的conflict，项目要miss deadline了怎么办的等等。实在没有？那也要编啊。一定要有细节，因为面试官会问得很细。还有一句“废话”，要显示出你对产品的热情，对自己职业的热情，而不是就安于一个“码农”，说说你怎么提高自己的，online course? open source project？</p>
<p>说实话我不觉得这种对非manager的BQ面试有什么用，只能过滤一下无脑的愣头青吧。但是你只要知道面试官想听的keyword，还是比涮题简单的吧。</p>
<p>另外，我们写面试报告的时候，不能用he or she，就是不想透露任何在HC环节能引起歧视的信息，包括年龄，种族等等。狗家在这点上真是很nice和认真的。所以大家回答问题的时候，可千万别一不小心说漏了嘴。那很可能是一票否决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/10/%E6%80%8E%E4%B9%88%E7%9C%8B%E7%BE%8E%E8%82%A1%E6%9C%9F%E8%B4%A7%E7%86%94%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/10/%E6%80%8E%E4%B9%88%E7%9C%8B%E7%BE%8E%E8%82%A1%E6%9C%9F%E8%B4%A7%E7%86%94%E6%96%AD/" class="post-title-link" itemprop="url">怎么看美股期货熔断</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-10 20:35:18 / Modified: 21:38:12" itemprop="dateCreated datePublished" datetime="2020-03-10T20:35:18-04:00">2020-03-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>隐隐约约有种“整个欧洲的灯火正在熄灭”之感…</p>
<p>金融类分析很多大佬都说过了，作为混实业圈的，我当下最纯粹的愿望，就是希望：国家要顶住。</p>
<p>这个顶住不是指我们的经济下行。虽然这两年数据都挺难看，加上疫情一来，经济下行早已是板上钉钉。但这个我们顶得住，林毅夫的判断没过时，三四百个城镇的现代化还是足够维持二十年的增长。</p>
<p>要顶住的，是美帝的压力。</p>
<p>因为现在不是修昔底德陷阱了，现在是400毫米等降水线南移。</p>
<p>这是个比烂的时代，其中一个比烂特点就是：我们从来没有去真正解决08金融危机，取而代之是债权币权的双手扩张，用大水漫灌的手段去缓解。</p>
<p>就像很多经济学老实人说的：大家都在吃药。</p>
<p>这个药吃下来，金融国吃出了产业空心化，制造国吃出了产能过剩，资源国吃出了高通胀与高失业。哥仨摆一块，一整个2933大危机的前夜。</p>
<p>所以有一段时间，国际关系学者都在讲“尸体论”：各大力量高强度对峙，但并不真想直接对线，而是期望有对手先扛不住倒下，成为过冬的储备粮。</p>
<p>所以尽管互相放狠话展现肌肉，也努力收小弟划分势力范围，但毕竟是“耗”，是斗而不破。</p>
<p>前提是美帝不爆金融危机。</p>
<p>因为体制与禀赋的不同，我朝到今天已经是个制造大国。制造的收益虽然比不上金融和资源，但是制造的收益有其稳定性。</p>
<p>毕竟人活着就得吃喝拉撒，除非人口凭空蒸发掉，否则再难工厂也得开工、餐馆也得营业。</p>
<p>制造国的最大弱点是产能过剩。</p>
<p>但是我朝体制在此，能进行高强度的产能调配。虽然代价也很沉重，但至少能大大延缓产能过剩的爆炸性后果；</p>
<p>另一次要弱点是市场不足导致的工业衰退。</p>
<p>我们近几年一直饱受市场空间萎缩的折磨，但毕竟人口基数在这，有个庞大的内需市场作为托底。所以即使外部空间被锁喉，内部还能保持工业循环。</p>
<p>制造为本、庞大的内需市场、稳定的体制，三者结合，保证了我朝经济的基本稳定收益。</p>
<p>这时，美帝的金融突然有点要崩的样子。</p>
<p>资本无国界，哪里收益高就去哪里。所以必定有相当规模的美帝资本会加大力度流入我朝，但这又会进一步刺激美帝的产业空心化。</p>
<p>要注意，美帝作为政府，境外的私人资本收益是分不到多少的，有太多律师和会计会帮助大资本对抗美帝政府的税收。</p>
<p>国内资本跑到海外赚的钱，美帝分不到。而国内的就业、社会福利和吓死人的军费开支都要靠那点美债来支撑。</p>
<p>而10年期美债收益率已经跌到0.5%左右了，历史新低，他娘的2933大危机时也没这么低。国债当年要是这个德性，罗斯福新政怕是无米之炊。</p>
<p>单凭这一点，美帝就必然会上手段来阻止资金外流。制造业回流可以是说说官话，钱必须回流。</p>
<p>往大了说。</p>
<p>资本的重要载体，货币，必须具有一定稳定性。尤其是给其他货币定价的货币，美元。</p>
<p>美元必须和现有的实体资源保持某种程度的价值稳定联系，做不到，那就无法为全球资源做有效定价，那就会导致美元全球货币这一身份的崩溃。</p>
<p>原油已经跌到30美元一桶了，沙特在这个基础上还想增产。据说货币一般是要随着产能的扩张而膨胀的，想知道美元能不能跟着通胀一下？</p>
<p>没法胀，10年期国债0.5%的收益率你胀毛。一边告诉我钱不值钱（收益率新低），一边告诉我钱值钱（标价实体资源新低），你错乱了？</p>
<p>没错乱。这就是一边债权币权两手扩张，大水漫灌；一边利用全球货币美元和全球力量美军稳定定价权，强买强卖。</p>
<p>这就是个巨大的套利模型，不过代价被转移了，转移到金融国产业空心化的工人失业、制造国生产过剩的高度内卷、资源国被剥夺定价权和工业的高通胀和高失业。</p>
<p>因为定价权的稳定，超发货币得以不反应到cpi上，并不对普通人美国人生活造成巨大冲击。但是货币就是资本的一种，它必然追求收益率。</p>
<p>实体领域已经无法提供能满足该类资本的收益，它们就扎堆进了虚拟领域，追求空气币球鞋赌石一样的收益。</p>
<p>虚拟领域的高收益一旦脱离实体的支持，就会不可持续，最终要向实体收益水平进行回归。</p>
<p>一回归，就炸了。</p>
<p>虽然是大水漫灌超发的钱，但钱毕竟是钱。只有确定钱能回来，政府才会愿意把钱放出去。钱出去了不回来，没有政府会开闸。</p>
<p>但是美帝是金融帝国主义，他不能关闸。</p>
<p>他就只能换个角度，保证钱回来，甚至保证钱都不愿意出去。</p>
<p>比好太难太慢，那就比烂，让你的收益率比我烂。</p>
<p>那就不是“耗”了。</p>
<p>所以，要顶住。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=432430716&auto=1&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
