<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%A7%E8%83%BD%E8%BF%87%E5%89%A9%E4%B8%80%E7%9B%B4%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%87%BA%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%A7%E8%83%BD%E8%BF%87%E5%89%A9%E4%B8%80%E7%9B%B4%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%87%BA%E7%8E%B0/" class="post-title-link" itemprop="url">为什么产能过剩一直在中国出现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-24 23:35:59 / Modified: 23:36:38" itemprop="dateCreated datePublished" datetime="2020-04-24T23:35:59-04:00">2020-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工业就是过剩，过剩就是工业，过剩，是真理。</p>
<p>之所以出现在中国，是因为你有工业了。</p>
<p>思考这个问题前，先换一个角度：</p>
<p>把国籍给忘咯。</p>
<p>然后想，例如，这地球上的服装产能过剩吗？不用找资料你都能反应过来，肯定过剩；</p>
<p>那手机产能呢？不好意思也过剩了，17年就转入存量市场了。现在的产能，全球每人每两年换一部绝对没问题；</p>
<p>那建筑产能呢？全球每人至少一辈子一套房？哎，也过剩了。建筑产能自中国起来后，全球就算过剩了，稀缺的从来都是土地。</p>
<p>切换一下角度你会发现：这个地球上，有大量工业门类的产能早已处于严重过剩状态。没有进入过剩的，都是受其他资源禀赋的限制：例如地球上有多少矿、有多少能源、有怎样的技术。</p>
<p>归根结底，就是技术限制而已。</p>
<p>为什么过剩？因为工业的核心就是过剩。</p>
<p>工业的核心是什么？生产。现行的主流生产形态是什么？规模化流水线，俗称量产。</p>
<p>为什么选择量产？因为只有这种标准化大批量的生产模式，才能摊平每件产品的成本，把人员、装备、土地、水电等庞大的前置费用摊下去，摊出一个大众普遍能接受的产品定价。</p>
<p>而这种规模化流失线必然导致过剩。</p>
<p>为了通过更低的定价获得更大的市场份额，参与者都会在自己能承受的范围内进行量产优化竞争。</p>
<p>没有太强制的资源约束，整体市场呈现纯粹竞争状态，这种是最容易过剩的，例如服装。</p>
<p>垄断性竞争与寡头竞争也一样。日化用品是个典型的垄断性竞争环境，品牌及定价分层非常清晰；手机是典型的寡头竞争环境，所有参与者在定价上要谨慎思考对手的反应。</p>
<p>这俩行业为什么也过剩？因为在格局相对稳定的环境下，参与者都会设计汰旧机制，用技术和广告来刺激消费迭代，增加相同份额下的市场收益。</p>
<p>男生比较熟悉的有“科技以换壳为本”和“挤牙膏”，女生比较熟悉的有“化妆品的区别是广告和代言人”。</p>
<p>狠一点，直接缩短产品生命周期，例如灯泡。再狠一点的，库存一把火烧了，人为制造稀缺。</p>
<p>这些行为都极大地加深了产能过剩。民用电子工业之花手机过剩了，民用机械工业之花汽车也过剩了。统统过剩，听着离共产主义都不远啦。</p>
<p>说到共产主义，很多人想：娘的，计划经济总不过剩吧？完全垄断，还能过剩？</p>
<p>抱歉，还是过剩，而且往往是低水平过剩。</p>
<p>怎么个低水平法呢？就是这类产品市场需求已经在衰退，但是国有资本在官僚体制的影响下，依然盲目扩张产能。</p>
<p>实际上，你去翻翻我们和苏联的资料，你会发现我们不是没有轻工业制成品，只是我们有的，很多不是老百姓想消费的。</p>
<p>苏联人真不缺洗衣机，但那玩意长得像垃圾桶一样，真的很难看出是洗衣机。</p>
<p>社会主义国家当年的普遍匮乏，实际是国家将有限资源投入到了军重工业领域。民用工业的产能不足，背后其实是军重工业产能的严重过剩。</p>
<p>其实还是过剩。</p>
<p>讲到这里就能看出来，工业的过剩趋势是必然的。解决过剩的终极手段，只有信息穿透。</p>
<p>但这个穿透太难做到了。</p>
<p>你不仅要穿透你的消费者，你还要穿透你的竞争对手。哪怕你的员工人均尤里，所有人在他们面前都是透明的，你还要穿透这个世界。</p>
<p>因为你要预判各种波动，地震海啸疫病新技术爆发，这些都会干扰需求。可能吗？不可能。</p>
<p>只要信息迷雾存在，产能就一定过剩。就像只要A.T.field存在，人的感情一定过剩一样。</p>
<p>为什么不管姓资姓社，都关注社会化大生产与私有制之间的矛盾？因为必然导致产能过剩。</p>
<p>工业就这鸟样。</p>
<p>讲到这里，再回顾一下我们的过剩。</p>
<p>一直有学者强调我们的两种过剩：制度性过剩与结构性过剩。</p>
<p>前者主要指政府干预下的产能管理混乱，例如盲目扩张、强行保留、指标干涉等；</p>
<p>后者主要指各种我们不要的低端产业，例如服装、玩具、钢铁等等。</p>
<p>前者的过剩我认为是应当解决的：继续推行双轨制，战略产业和战略红线由国家兜底，例如芯片国家砸大钱、粮食化工等原材料国企保证基础供应。剩下的产能交由市场来决定，该关关。</p>
<p>但是有一票反复强调结构性过剩的，觉得中国以后就不要生产玩具衣服，也不要做眼镜水杯。这些东西污染大、利润薄、技术含量低，做来干嘛？</p>
<p>况且现在已经过剩了，转出去吧。</p>
<p>我对此强烈反对。所有国家，无外乎三个重心：资源、金融、制造。</p>
<p>资源要不要？废话都想要，可是要得到吗？问地壳运动和大西洋暖流去要啊？</p>
<p>金融要不要？要，我们也已经是全球金融资本体量第一了。但是能不能只要金融？不行。</p>
<p>美帝重点全转至金融，不到五十年已经问题多多。以我们的体量，重心金融，矛盾爆发不过十年。</p>
<p>那剩下的还有什么？只有制造了。</p>
<p>这也是为什么我们有全球最全的工业门类。谁特么想做流水线工人？还不是因为我们地大物不博，钞票外人又不认，想维持生活只能打工这样子。</p>
<p>既然我们注定是长期是以制造国为第一身份，也已经拥有了全球最全的工业门类和最大的工业产能，那这些门类的产能过剩必然在我们这爆发。</p>
<p>结构性过剩不是一个问题，因为这个结构长期存在。真正要解决的不是这个结构，而是过剩。</p>
<p>不大改结构，解决过剩的思路就俩，对外搞点势力范围，圈下来的地方输出你的产能；对内规划有效投资，把过剩产能投入到你的资产增值里。</p>
<p>前者是大英帝国，后者是罗斯福新政。</p>
<p>说实话这二者都无所谓，因为维系产能是关键。打通任督二脉固然好，不行的话，吸星大法也行。</p>
<p>但当下的问题，是几乎所有人讨论到中国的产能过剩，第一反应都是去产能。仿佛把低端工厂关了，工人就会找到更优厚的岗位，释放的资金就会去做产业升级，积累的技术就会自动互联网化了。</p>
<p>这脑回路不知道是怎么连起来的。</p>
<p>现实是：</p>
<p>相当多的产线工人无处可去，最后只能国家吸纳。国家要么是设立冗余岗位，要么是强行扩张国企产能来吸收，最后都是国家财政负担。</p>
<p>很多劳动力是进不了基建项目的。像纺织工业有大量女工，而且年龄颇大，怎么安置？包装、家具的大龄男工也多，怎么上工地？</p>
<p>不要说什么回老家种地，说这话的家里肯定没人种地。小农状态下种地收益太低，失业工人多数也没资本去买地，不如直接报贫困户。</p>
<p>释放的资金也没去做产业升级。资金背后是人，人看不懂这个行业他敢投吗？他长期做实体的信任那些金融机构吗？掉头还是去房地产。</p>
<p>房地产都是安分的，狠一点的直接搞地下钱庄，给还在做实业的同行放贷。无他，这业务他熟啊。</p>
<p>积累的技术和产线经验则是直接消失。工业知识是严重偏工程类的，需要海量实践为基础才有改进。航空发动机的参数大学课本都会写，造出来的工艺工序没个五十年你摸索不出来。</p>
<p>这还不是最致命的。最致命的，是大量已经成型的产业集群在加速消解。</p>
<p>中国的产线工人工资早就高于东南亚了，为什么这么多年转过去的还就是一些纺织厂和玩具组装线？因为你有产业集群在维护收益。</p>
<p>孟加拉的纺织厂坏一台设备，要从山东找技工来修；缺一种面辅料，要从广州中大进口；培训一道新工序，要从浙江请老师傅来教。</p>
<p>12年前我在尼日利亚，一个印度人开的锅厂，一个冲压机对一片钢板砸一下就完工的那种，印度人要年薪30万请个茂名的中专生在那待着。</p>
<p>而这一切，在国内任何一个纺织园区，都是一个电话一天解决的事。湖州织里生产了全球四分之一的童装，师傅、技工、面辅料，基本都在厂子的五公里范围内能找到。</p>
<p>这种高效灵活的产业集群，保证了在中国用工成本不断上涨的同时，还能以东南亚相近价格更高质量的优势来竞争。</p>
<p>而且，这种产业集群正是工业升级的坚实基础。</p>
<p>我们的工业软件很垃圾，和我们的产能相比简直是耻辱。以前国家为主动，中科院工信部做了一些努力，但效果一般；互联网一票人进来做点概念，效果更一般。</p>
<p>真正出成果出好苗子的，全是这些低端产能里的龙头企业自我逼迫升级，咬牙慢慢摸索出来的，简直和好莱坞早期一堆烂片堆一部经典一样。</p>
<p>如今一看是低端，又产能过剩，大手一挥，指望他们自己关停并转。</p>
<p>当年的关停并转也没啥好效果啊。</p>
<p>现在应对产能过剩的方法，好比做盆栽，拿着剪刀这里咔嚓一下那里划一刀，姿势好看账目数据漂亮，就算去产能成功。</p>
<p>这样的花花草草摆在风雨里，一天就得萎了。</p>
<p>要么你圈下一块市场，水肥管够，你们去长，谁长成参天大树谁牛逼；要么你没水没肥但地管够，你们也去长，土壤贫瘠一点，但长得壮也是本事。</p>
<p>现在是治一木之才者治一林。</p>
<p>减肥可以靠节食，但总归是要靠运动、睡眠和合理饮食。手术不改善根本体质，而且有危险，特别是当主刀医生连肥肉肌肉和内脏都分不清的时候。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/JS%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/JS%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">JS总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-24 09:32:51 / Modified: 13:48:25" itemprop="dateCreated datePublished" datetime="2020-04-24T09:32:51-04:00">2020-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>一、 变量类型</p>
<p>二、 深拷贝与浅拷贝</p>
<p>三、 原型与原型链</p>
<p>四、 继承与实现</p>
<p>五、 实现class与extends</p>
<p>六、 作用域、执行上下文与闭包</p>
<p>七、 this</p>
<p>八、 apply、call、bind实现</p>
<p>九、 同步与异步</p>
<p>十、 AMD、CMD、CommonJS与ES6模块化</p>
<p>十一、 script标签之async与defer</p>
<p>十二、 改变数组本身的api</p>
<p>十三、 window之location、navigator</p>
<p>十四、 ajax与fetch</p>
<p>十五、 WebSocket</p>
<p>十六、 短轮询、长轮询与WebSocket</p>
<p>十七、 长连接与短连接</p>
<p>十八、 存储</p>
<p>十九、 跨域</p>
<p>二十、 setTimeout与setInterval</p>
<p>二十一、 requestAnimationFrame</p>
<p>二十二、 事件</p>
<h2 id="一、变量类型"><a href="#一、变量类型" class="headerlink" title="一、变量类型"></a>一、变量类型</h2><h3 id="与"><a href="#与" class="headerlink" title="==与==="></a>==与===</h3><h4 id="对于-的判断"><a href="#对于-的判断" class="headerlink" title="对于==的判断"></a>对于==的判断</h4><ul>
<li>并不是那么严谨的判断左右两端是否相等</li>
<li>它会优先对比数据的类型是否一致</li>
<li>不一致则<strong>进行隐式转换</strong>，一致则判断值的大小，得出结果</li>
<li>继续判断两个类型是否为null与undefined，如果是则返回true</li>
<li>接着判断是否为string与number，如果是把string转换为number再对比大小</li>
<li>判断其中一方是否为boolean，如果是就转为number再进一步判断</li>
<li>判断一方是否为object，另一方为string、number、symbol，如果是则把object转为原始类型再判断</li>
</ul>
<h5 id="比较情况"><a href="#比较情况" class="headerlink" title="比较情况"></a>比较情况</h5><ol>
<li>数组 == 值，(值类型指的是原始类型)会先转成数值再比较，与字符串比较会先转成字符串再比较</li>
<li>引用 == 值，会把引用类型转成原始类型再比较</li>
<li>值 == 值，直接比较类型再比较值的大小</li>
<li>字符串 == 数字，则把字符串转为数值再比较</li>
<li>其他类型 == boolean，则把boolean转成数值再进一步比较</li>
<li>undefined == null，也会发生隐式转换，且2者可以相互转换，即2者相等，与自身也相等</li>
<li>对象 == 非对象，如果非对象为string或number，则返回ToPrimitive(对象) == 非对象，的结果；ToPrimitive方法的参数如果是原始类型则直接返回；如果是对象，则调用valueOf方法，如果是原始值再进行原始类型转换和大小对比；如果不是原始值则调用toString，且结果为原始值则进行原始类型比较，如果不是原始值则抛出错误</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下结果都为true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">5</span>]==<span class="number">5</span>,[<span class="string">'5'</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">name</span>:<span class="string">'5'</span>&#125;==<span class="string">'[object Object]'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>==<span class="number">5</span>,<span class="literal">true</span>==<span class="number">1</span>,<span class="literal">false</span>==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>==<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">5</span>,<span class="number">6</span>]==<span class="string">'5,6'</span>,[<span class="string">'5'</span>,<span class="string">'6'</span>]==<span class="string">'5,6'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大白话：优先比较类型，同类型，比大小，非原始，调ToPrimitive，为对象调valueOf，还非原始调toString，最后还非原始则报错，如果为原始则进行类型对比，如果不同类型再转换，之后对比大小。</p>
</blockquote>
<p>所谓==比较就是要转换成同类型比较，如果无法转成同类型就报错</p>
<blockquote>
<p>优先比类型，再比null与undefined，再比string和number，再比boolean与any，再比object与string、number、symbol；以上如果转为原始类型比较，则进行类型转换，直到类型相同再比较值的大小。这就是==的隐式转换对比，比较绕，给个图就清晰了！</p>
</blockquote>
<p>如下为判断步骤</p>
<img src="../images/1719d4f703af20a1.png" alt="img" style="zoom:200%;" />

<p>思考？如何判断此表达式（注意==!与!==） <strong>[]==![]</strong></p>
<ul>
<li>基于运算符的优先级此式会先运算![]的结果</li>
<li>!优先于==，且[]为真值(转成boolean，结果为true的就为真值，包括{}；转成false的就为假值)，![]结果为false，所以当前表达式转化为 []==false</li>
<li>通过之前总结的转换关系，任何类型与boolean类型比较，所以[]==false 转化为 []==0 比较</li>
<li>此时变为object与0比较，调用object的转换成原始类型的方法valueOf其结果还是valueOf</li>
<li>再调用toString结果为’’，再进行string转成number，则[]转成数字类型0</li>
<li>表达式进一步转换成0==0，结果为true。</li>
</ul>
<p>虽然过程复杂，记住判断的思路即可，非对象之间，先类型转换再比大小，对象比较则调用获取原始值方法再进一步比较。</p>
<p>如下为toString与valueOf转换</p>
<p><img src="../images/1719d4e8d3757d58.png" alt="img"></p>
<h4 id="对于-的判断-1"><a href="#对于-的判断-1" class="headerlink" title="对于===的判断"></a>对于===的判断</h4><ul>
<li>===属于<strong>严格判断</strong>，直接判断两者类型是否相同，不同则返回false</li>
<li>如果相同再比较大小，<strong>不会进行任何隐式转换</strong></li>
<li>对于引用类型来说，比较的都是引用内存地址，所以===这种方式的比较，除非两者存储的内存地址相同才相等，反之false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a=[]</span><br><span class="line"><span class="keyword">const</span> b=a</span><br><span class="line">a===b <span class="comment">//true</span></span><br><span class="line">---------------</span><br><span class="line"><span class="keyword">const</span> a=[]</span><br><span class="line"><span class="keyword">const</span> b=[]</span><br><span class="line">a===b <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="7大原始类型与Object类型"><a href="#7大原始类型与Object类型" class="headerlink" title="7大原始类型与Object类型"></a>7大原始类型与Object类型</h4><ol>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>BigInt</li>
<li>String</li>
<li>Symbol</li>
<li><strong>Object</strong></li>
</ol>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><h5 id="原始类型判断"><a href="#原始类型判断" class="headerlink" title="原始类型判断"></a>原始类型判断</h5><ul>
<li><strong>原始类型</strong>string、number、undefined、boolean、symbol、bigint都能<strong>通过typeof</strong>(返回字符串形式)直接判断类型，还有对象类型function也可判断</li>
<li><strong>除了null</strong>无法通过typeof(为object)直接判断类型(历史遗留)，包括对象类型，typeof把null当作对象类型处理，所以typeof无法判断对象类型，<strong>typeof也能判断function</strong></li>
</ul>
<h5 id="非原始类型判断-以及null"><a href="#非原始类型判断-以及null" class="headerlink" title="非原始类型判断(以及null)"></a>非原始类型判断(以及null)</h5><p>判断数组</p>
<ul>
<li>使用<code>Array.isArray()</code>判断数组</li>
<li>使用<code>[] instanceof Array</code>判断是否在Array的原型链上，即可判断是否为数组</li>
<li><code>[].constructor === Array</code>通过其构造函数判断是否为数组</li>
<li>也可使用<code>Object.prototype.toString.call([])</code>判断值是否为’[object Array]’来判断数组</li>
</ul>
<p>判断对象</p>
<ul>
<li><code>Object.prototype.toString.call({})</code>结果为’[object Object]’则为对象</li>
<li><code>{} instanceof Object</code>判断是否在Object的原型链上，即可判断是否为对象</li>
<li><code>{}.constructor === Object</code>通过其构造函数判断是否为对象</li>
</ul>
<p>判断函数</p>
<ul>
<li>使用<code>func typeof function</code>判断func是否为函数</li>
<li>使用<code>func instanceof Function</code>判断func是否为函数</li>
<li>通过<code>func.constructor === Function</code>判断是否为函数</li>
<li>也可使用<code>Object.prototype.toString.call(func)</code>判断值是否为’[object Function]’来判断func</li>
</ul>
<p>判断null</p>
<ul>
<li>最简单的是通过<code>null===null</code>来判断是否为null</li>
<li><code>(!a &amp;&amp; typeof (a) != &#39;undefined&#39; &amp;&amp; a != 0)</code>判断a是否为null</li>
<li><code>Object.prototype.__proto__===a</code>判断a是否为原始对象原型的原型即null</li>
</ul>
<p>判断是否为NaN</p>
<ul>
<li><code>isNaN(any)</code>直接调用此方法判断是否为非数值</li>
</ul>
<p>一些其他判断</p>
<ul>
<li><code>Object.is(a,b)</code>判断a与b是否完全相等，与===基本相同，不同点在于Object.is判断<code>+0不等于-0</code>，<code>NaN等于自身</code></li>
<li>一些其他对象类型可以基于原型链判断和构造函数判断</li>
<li><code>prototypeObj.isPrototypeOf(object)</code>判断object的原型是否为prototypeObj，不同于instanceof，此方法直接判断原型，而非instanceof 判断的是右边的原型链</li>
</ul>
<p>一个简单的类型验证函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWho</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// null</span></span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">'null'</span></span><br><span class="line">  <span class="keyword">const</span> primitive = [<span class="string">'number'</span>, <span class="string">'string'</span>, <span class="string">'undefined'</span>,</span><br><span class="line">    <span class="string">'symbol'</span>, <span class="string">'bigint'</span>, <span class="string">'boolean'</span>, <span class="string">'function'</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> x</span><br><span class="line">  <span class="comment">//原始类型以及函数</span></span><br><span class="line">  <span class="keyword">if</span> (primitive.includes(type)) <span class="keyword">return</span> type</span><br><span class="line">  <span class="comment">//对象类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(x)) <span class="keyword">return</span> <span class="string">'array'</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Object]'</span>) <span class="keyword">return</span> <span class="string">'object'</span></span><br><span class="line">  <span class="keyword">if</span> (x.hasOwnProperty(<span class="string">'constructor'</span>)) <span class="keyword">return</span> x.constructor.name</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(x)</span><br><span class="line">  <span class="keyword">if</span> (proto) <span class="keyword">return</span> proto.constructor.name</span><br><span class="line">  <span class="comment">// 无法判断</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"can't get this type"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、深拷贝与浅拷贝"><a href="#二、深拷贝与浅拷贝" class="headerlink" title="二、深拷贝与浅拷贝"></a>二、深拷贝与浅拷贝</h2><p>在项目中有许多地方需要数据克隆，特别是引用类型对象，我们无法使用普通的赋值方式克隆，虽然我们一般使用第三方库如lodash来实现深拷贝，但是我们也需要知道一些其中的原理</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ul>
<li><code>Object.assign({},obj)</code>浅拷贝object</li>
<li><code>obj1={...obj2}</code>通过spread展开运算符浅拷贝obj2</li>
<li><code>Object.fromEntries(Object.entries(obj))</code>通过生成迭代器再通过迭代器生成对象</li>
<li><code>Object.create({},Object.getOwnPropertyDescriptors(obj))</code>浅拷贝obj</li>
<li><code>Object.defineProperties({},Object.getOwnPropertyDescriptors(obj))</code>浅拷贝obj</li>
</ul>
<p>简单实现浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a原拷贝对象，b新对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  b[key] = a[key]</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(a)) &#123;</span><br><span class="line">  b[key] = a[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝</strong>只拷贝一层属性对于<strong>引用类型无法拷贝</strong></p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>通过<strong>JSON的2次转换</strong>深拷贝obj，不过无法拷贝<strong>undefined</strong>与<strong>symbol</strong>属性，无法拷贝<strong>循环引用</strong>对象</li>
<li>自己实现深拷贝</li>
</ul>
<p>简单深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单版深拷贝，只能拷贝基本原始类型和普通对象与数组，无法拷贝循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleDeepClone</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> b=<span class="built_in">Array</span>.isArray(a) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(a)) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> a[key]</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">'object'</span> || a[key] === <span class="literal">null</span>) &#123;</span><br><span class="line">      b[key] = a[key]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      b[key] = simpleDeepClone(a[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//精简版深拷贝只能拷贝基本原始类型和普通对象与数组，可以拷贝循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">a, weakMap = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">'object'</span> || a === <span class="literal">null</span>) <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">if</span> (s = weakMap.get(a)) <span class="keyword">return</span> s</span><br><span class="line">  <span class="keyword">const</span> b = <span class="built_in">Array</span>.isArray(a) ? [] : &#123;&#125;</span><br><span class="line">  weakMap.set(a, b)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(a)) b[key] = clone(a[key], weakMap)</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//js原生深拷贝，无法拷贝Symbol、null、循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSdeepClone</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!data || !(data <span class="keyword">instanceof</span> <span class="built_in">Object</span>) || (<span class="keyword">typeof</span> data == <span class="string">"function"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> data || <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">constructor</span> = data.<span class="keyword">constructor</span>;</span><br><span class="line">  const result = new <span class="keyword">constructor</span>();</span><br><span class="line">  for (const key in data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.hasOwnProperty(key)) &#123;</span><br><span class="line">      result[key] = deepClone(data[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较完善的深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝具体版，非完全，但大部分都可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClonePlus</span>(<span class="params">a, weakMap = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> a</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">null</span> || type !== <span class="string">'object'</span>) <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">if</span> (s = weakMap.get(a)) <span class="keyword">return</span> s</span><br><span class="line">  <span class="keyword">const</span> allKeys = <span class="built_in">Reflect</span>.ownKeys(a)</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Array</span>.isArray(a) ? [] : &#123;&#125;</span><br><span class="line">  weakMap.set(a, newObj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> allKeys) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = a[key]</span><br><span class="line">    <span class="keyword">const</span> T = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span> || T !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      newObj[key] = value</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> objT = <span class="built_in">Object</span>.prototype.toString.call(value)</span><br><span class="line">    <span class="keyword">if</span> (objT === <span class="string">'[object Object]'</span> || objT === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">      newObj[key] = deepClonePlus(value, weakMap)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (objT === <span class="string">'[object Set]'</span> || objT === <span class="string">'[object Map]'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (objT === <span class="string">'[object Set]'</span>) &#123;</span><br><span class="line">        newObj[key] = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        value.forEach(<span class="function"><span class="params">v</span> =&gt;</span> newObj[key].add(deepClonePlus(v, weakMap)))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newObj[key] = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        value.forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> newObj[key].set(i, deepClonePlus(v, weakMap)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (objT === <span class="string">'[object Symbol]'</span>) &#123;</span><br><span class="line">      newObj[key] = <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(value))</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    newObj[key] = <span class="keyword">new</span> a[key].constructor(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刨析深拷贝(个人思路)</p>
<ul>
<li>本人使用递归算法来实习深拷贝，由于使用递归，会让代码看起来更加易懂，在不触及调用栈溢出的情况下，推荐使用递归</li>
<li>深拷贝，其实考验的就是如何把引用类型给拷贝过来，还有Symbol类型比较特殊，如何实现一个比较完整的深拷贝就要涉及<strong>不同类型</strong>的拷贝方式</li>
</ul>
<ol>
<li>首先考虑简单的<strong>原始类型</strong>，由于原始类型在内存中保存的是值可以直接通过值的赋值操作，先判断传入参数是否为原始类型，包括null这里归为原始类型来判断，没必要进入对象环节，函数直接赋值不影响使用</li>
<li>经过原始类型的筛选，剩下<strong>对象类型</strong>，取出所有对象的键，通过<code>Reflect.OwnKeys(obj)</code>取出对象自身所有的键，包括Symbol的键也能取出</li>
<li>由于对象有2种体现形式，<strong>数组</strong>和<strong>普通对象</strong>，对于这2者要单独判断，先生成一个拷贝容器即newObj</li>
<li>接下来就可以开始遍历 步骤2 中获取到对象所有的键(仅自身包含的键),通过for..of 遍历，取出当前要拷贝的对象a，对应于当前遍历键的值，即a[key]</li>
<li>对a[key]值的类型进行判断，此值类型的可能性包括所有的类型，所以又回到步骤1中先判断原始类型数据；如果是原始类型可以直接赋值跳过这一轮，进行下一轮遍历</li>
<li>经过上一步的筛选，此时剩下的只是对象类型,由于对象类型无法通过typeof直接区分，所以可以借用原始对象原型方法 <code>Object.prototype.toString.call(obj)</code> 来进行<strong>对象具体类型</strong>的判断</li>
<li>toString判断的结果会以’[object xxx]’，xxx为对应对象类型形式体现，基于这种转换可以清晰判断对象的具体类型，之后再对各种类型进行相应的深拷贝即可</li>
<li>以上并未使用递归，由于上述的拷贝，还未涉及多层次的嵌套关系并不需要使用递归</li>
<li>接下来将要判断<strong>嵌套类型</strong>数据，(此顺序可变，不过出现频率高的尽量放在前头)首先判断普通对象和数组，如果是，则直接扔给递归处理，由于处理数组和普通对象的逻辑已经在这之前处理好了，现在只需重复上面的步骤，所以直接<strong>递归调用</strong>就好，递归到最后一层，应该是原始类型的数据，不会进入无限调用</li>
<li>接下来是判断2种<strong>特殊类型</strong>Set和Map，由于这2种类型的拷贝方式不同，进一步通过if分支对其判断，遍历里边所存放的值，Set使用add方法向新的拷贝容器添加与拷贝对象相同的值，此处值的拷贝也应该使用深拷贝，即直接把值丢给递归函数，它就会返回一个拷贝好的值。Map类似，调用set方法设置键和值，不过正好Map的键可以存放各种类型</li>
<li>到了拷贝Symbol环节，这个类型相对特殊一点，Symbol的值是唯一的，所以要获取原Symbol所对应的Symbol值，则必须通过借用Symbol的原型方法来指明要获取Symbol所对应Symbol的原始值，基于原始值创建一个包装器对象，则这个对象的值与原来相同</li>
<li>筛选到这里，剩余的对象，基本上就是一些内置对象或者是不需要递归遍历属性的对象，那么就可以基于这些对象<strong>原型的构造函数</strong>来实例化相应的对象</li>
<li>最后遍历完所有的属性就可以返回这个拷贝后的新容器对象，作为拷贝对象的替代</li>
<li>基于循环引用对象的解析，由于循环引用对象会造成循环递归导致调用栈溢出，所以要考虑到一个对象不能被多次拷贝。基于这个条件可以使用Map对象来保存一个拷贝对应的表，因为Map的键的特殊效果可以保存对象，因此正好适用于对拷贝对象的记录，且值则是对应的新拷贝容器，当下次递归进来的时候先在拷贝表里查询这个键是否存在，如果存在说明已经拷贝过，则直接返回之前拷贝的结果，反之继续</li>
<li>由于Map存放的键属于<strong>强引用类型</strong>，且深拷贝的数据量也不小，如果这些拷贝后的拷贝表不及时释放可能会造成垃圾堆积影响性能，因此需要使用到<strong>weakMap方法代替Map</strong>，weakMap存放的键为<strong>弱引用类型</strong>，且<strong>键必须为对象类型</strong>，正好之前的newObj就是对象类型可以存放，使用弱引用的好处，可以优化垃圾回收，weakMap存放的是拷贝表，此拷贝表在拷贝完成之后就没有作用了，之前存放的拷贝对象，经过深拷贝给新拷贝容器，则这些旧对象在销毁之后，对应于拷贝表里的对象也应该随之清除，不应该还保留，这就是使用弱引用来保存表的原因。</li>
</ol>
<p>以上就是本人在实现过程中的思路，可能讲的比较啰嗦，但是我还是希望使用通俗的话让各位明白，表达能力有限，望谅解。</p>
<p>接下来让我们看看WeakMap的好处</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    age: [&#123;</span><br><span class="line">      who: <span class="string">'me'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">deepClonePlus(obj, wm)</span><br><span class="line">obj=<span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.dir(wm) <span class="comment">// No properties 即为空</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出如果原拷贝对象被清空那么WeakMap保存的拷贝表也将被清空，总的来说方便一点，总比麻烦一点好</p>
<p>看看这种情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    age: [&#123;</span><br><span class="line">      who: <span class="string">'me'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'start'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  deepClonePlus(obj, wm) <span class="comment">// wm为手动传入的weakmap</span></span><br><span class="line">  <span class="comment">// 此处为了与下面对比，这里故意重置weakmap存储的拷贝值</span></span><br><span class="line">  wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'start'</span>) <span class="comment">// 耗时2645ms</span></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">let</span> m</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'start'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  deepClonePlus(obj, wm)</span><br><span class="line">  <span class="comment">// 此次为对照组，也执行创建WeakMap但是不重置之前拷贝的wm</span></span><br><span class="line">  m = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'start'</span>) <span class="comment">// 耗时73ms</span></span><br></pre></td></tr></table></figure>

<p>从以上对比可以看出如果是多次拷贝同一对象，最好使用WeakMap来存储拷贝表，那么之后的每次拷贝只需从拷贝表中取出值即可，由于是浅拷贝所以时间较短(<strong>注意：不过这种直接从WeakMap中取出的值属于浅拷贝，使用同一个wm对象拷贝出来的都是浅拷贝，如果每个都需要深拷贝那么只能每次重新创建WeakMap</strong>)</p>
<h2 id="三、原型与原型链"><a href="#三、原型与原型链" class="headerlink" title="三、原型与原型链"></a>三、原型与原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>只有对象类型才有原型概念</li>
<li>普通对象(即使用对象字面量或者Object构造器创建的对象)的原型为<code>__proto__</code>属性，此属性其实是个访问器属性，并不是真实存在的属性，或者可以使用es6的<code>Reflect.getPrototypeOf(obj)</code>和<code>Object.getPrototypeOf(obj)</code>方法获取对象的原型，其关系<code>Reflect.getPrototypeOf({}) === Object.getPrototypeOf({}) === {}.__proto__</code></li>
<li>普通函数有2个属性，一个是是<code>__proto__</code>(与普通对象类似)，还有一个是函数专有的<code>prototype</code>属性，因为函数有双重身份，即可以是实例也可以是构造器，所以关系比较特殊</li>
<li>不是所有的对象都会有原型，比如对象原型<code>Object.prototype</code>的原型<code>Object.prototype.__proto__</code>就指向null，字典对象的原型也为null(把对象的<code>__proto__</code>设置为null，或者使用<code>Object.create(null)</code>创建一个没有原型的字典对象，但是这个对象还是属于对象类型)，所以原始对象原型(Object.prototype)就是最原始的原型，其他对象类型都要继承自它。</li>
<li>箭头函数虽然属于函数，由Function产生，但是没有prototype属性没有构造器特性，所以也就没有所谓的constructor，就不能作为构造器使用</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>这里会详细介绍原型、原型链、实例、构造器的关系 先看最原始的关系</p>
<p><img src="../images/1719d5011fdf60d7.png" alt="img"></p>
<p>由如上关系可以验证<code>console.log(Function.prototype.__proto__.constructor.__proto__.constructor === Function) //true</code></p>
<ul>
<li>所有函数都是由Function函数构造器实例化而来</li>
<li>所有实例的原型都指向构造它的构造器的prototype</li>
<li>每个构造器自身特有的方法就是<strong>静态方法</strong>，原型上的方法可供所有继承它或间接继承它的实例使用</li>
<li>构造器也是函数，也是被Function实例化出来的，所以构造器的<code>__proto__</code>就是Function，但是构造器的prototype属性指向的原型，是此构造器实例化出来的实例所指向的原型；简单说构造器的prototype就是作为它的实例的原型</li>
</ul>
<p>看看函数的原型链</p>
<img src="../images/1719d5061a3d5f66.png" alt="img" style="zoom:200%;" />

<ul>
<li>在js中函数有多重身份，函数可以作为类就是构造器使用，定义静态方法，作为普通函数调用，</li>
<li>只有由原始函数构造器(Function)实例化的函数才拥有直接使用函数原型(Function.prototype)上面的内置方法，创建函数只能通过原始函数构造器生成，</li>
<li>普通函数作为构造器使用(new)时相当于类(class)使用，类的prototype就是实例的原型，我们可以给原型添加属性，给类添加属性时就相当于给构造器添加静态属性</li>
<li>普通函数在创建实例的时候，会生成一个实例的原型，此原型指向Object.prototype即原始对象原型，也就是继承对象原型，这么一来实例也继承了对象的原型，则实例也属于对象类型</li>
</ul>
<h2 id="四、继承与实现"><a href="#四、继承与实现" class="headerlink" title="四、继承与实现"></a>四、继承与实现</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>所谓继承一般说的是原型继承，一个原型上面定义的方法一般都是基于其实例的用途来定义的，也就是说，原型的方法应该是实例经常用到的通用方法，而构造器方法一般是特定情况下可能会用到的方法，可按需调用，原型方法只能供其实例来使用</li>
<li>继承可以让原型链丰富，根据需求定制不同的原型链，不会存在内存浪费的情况，原型只会保留一份，用到的时候调用就行，还能节省空间</li>
</ul>
<img src="../images/1719d50d1a53785a.png" alt="img" style="zoom:200%;" />

<ul>
<li>可以看出原型一般是一些共有的特性，实例是特有的特性，继承的越多越具体，原型链的最顶端是最抽象的，越底端越具体，这样一来我们可以根据需求在恰当位置继承来实现个性化的定制属性，统一而又有多样化</li>
</ul>
<h3 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h3><ul>
<li>通过es6的extends关键字来继承原型</li>
<li>手动实现原型继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//貌似这个方法就能实现原型继承，不过由于使用__proto__访问器是不推荐的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.v = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vv = v</span><br><span class="line">&#125;</span><br><span class="line">boo.prototype.__proto__ = foo.prototype</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> boo(<span class="number">3</span>)</span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="comment">//采用这种方式可以实现原型的继承，也是直接修改原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.v = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vv = v</span><br><span class="line">&#125;</span><br><span class="line">boo.prototype = <span class="built_in">Object</span>.create(foo.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: boo,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> boo(<span class="number">3</span>)</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment">//借助一个空构造器来实现原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.v = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vv = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">o.prototype = foo.prototype</span><br><span class="line">boo.prototype = <span class="keyword">new</span> o()</span><br><span class="line">boo.prototype.constructor = boo</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> boo(<span class="number">3</span>)</span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="comment">//class的extends会将子类的__proto__设置为父类</span></span><br><span class="line">如果实现类似extends的继承还需加上</span><br><span class="line">boo.__proto__ = foo</span><br></pre></td></tr></table></figure>

<p>实现构造器原型的继承，无非就是父构造器原型赋值给子构造器原型的原型，还有需要保证子构造器原型不能含有父构造器的属性</p>
<h2 id="五、实现class与extends"><a href="#五、实现class与extends" class="headerlink" title="五、实现class与extends"></a>五、实现class与extends</h2><h3 id="实现class"><a href="#实现class" class="headerlink" title="实现class"></a>实现class</h3><ul>
<li>es6加入的class其实是为了开发者方便创建类，与其他语言在写法上尽量一致，但是js原生并没有类这个东西，为了实现类的效果，可以通过js的构造器来实现，class使用new关键字生成实例，构造器也是通过new来实例化，那么可以推断class本质也是个构造器</li>
<li>手动实现class</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Class = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加原型方法</span></span><br><span class="line">  Constructor.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'原型方法getName:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加原型属性</span></span><br><span class="line">  Constructor.prototype.age = <span class="string">'原型属性age'</span></span><br><span class="line">  <span class="comment">//添加静态方法</span></span><br><span class="line">  Constructor.log = <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是构造器的静态方法log'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加静态属性</span></span><br><span class="line">  Constructor.isWho = <span class="string">'构造器静态属性isWho'</span></span><br><span class="line">  <span class="keyword">return</span> Constructor</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> i = <span class="keyword">new</span> Class(<span class="string">'我是实例'</span>)</span><br></pre></td></tr></table></figure>

<p>实现class语法糖，只需封装一层函数。</p>
<ul>
<li>返回的Constructor就是实例的构造器，其prototype是个空白的对象这是由于Function造成的</li>
<li>new后面调用的函数必须是一个构造器函数，用于构造实例，此构造器的this指向实例</li>
<li>构造器内部需要实现依照传入的参数设置实例的属性</li>
<li>定义Class时需要实现原型属性和静态属性的挂载</li>
</ul>
<p>以上只实现class的定义，接下来要实现能够兼容继承的写法</p>
<h3 id="实现extends"><a href="#实现extends" class="headerlink" title="实现extends"></a>实现extends</h3><ul>
<li>继承需要满足原型的继承</li>
<li>还需要满足可调用父类构造器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">const</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  Constructor.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Constructor</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">const</span> Class = (<span class="function"><span class="keyword">function</span> (<span class="params">_Parent = null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_Parent) &#123;</span><br><span class="line">    Constructor.prototype = <span class="built_in">Object</span>.create(_Parent.prototype, &#123;</span><br><span class="line">      <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Constructor,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    Constructor.__proto__ = _Parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    _Parent ? _Parent.call(<span class="keyword">this</span>, age) : <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  Constructor.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Constructor</span><br><span class="line">&#125;)(Parent)</span><br></pre></td></tr></table></figure>

<ul>
<li>实现原型继承，可以使用之前的继承写法，注意class形式的继承，会把父类设为子类的<code>__proto__</code></li>
<li>在构造函数内判断是否有父类，如果有就要调用父类的构造函数，把当前的this传入，这样才能生成父类构造器中定义的属性，这才算是真正的继承。继承不单继承原型还能实现继承父类构造器中定义的属性</li>
<li>对于原型方法和静态方法也是类似定义，注意定义的方法如果用到this需要使用function关键字定义函数，不可使用匿名函数，否则this无法指向调用对象本身</li>
</ul>
<h2 id="六、作用域、执行上下文与闭包"><a href="#六、作用域、执行上下文与闭包" class="headerlink" title="六、作用域、执行上下文与闭包"></a>六、作用域、执行上下文与闭包</h2><h3 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>所有未定义的变量直接赋值会自动声明为全局作用域的变量(隐式全局变量可以用delete删除，var定义的则不行)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span> <span class="comment">// 隐式全局变量 严格模式报错</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="number">2</span> <span class="comment">// 显式全局变量</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b) <span class="comment">//1 2</span></span><br><span class="line"><span class="keyword">delete</span> a  <span class="comment">// 严格模式报错</span></span><br><span class="line"><span class="keyword">delete</span> b  <span class="comment">// 严格模式报错</span></span><br><span class="line"><span class="built_in">console</span>.log(b,a) <span class="comment">// 2   a is not defined</span></span><br></pre></td></tr></table></figure>

<p>window对象的所有属性拥有全局作用域</p>
<p>内层作用域可以访问外层作用域，反之不行</p>
<p>var声明的变量，在除了函数作用域之外，在其他块语句中不会创建独立作用域</p>
<p>let和const声明的变量存在块语句作用域，且不会变量提升</p>
<p>同作用域下不能重复使用let、const声明同名变量，var可以，后者覆盖前者</p>
<p>for循环的条件语句的作用域与其循环体的作用域不同，条件语句块属于循环体的父级作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下语句使用let声明不报错，说明为不同作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment">// 此语句报错，说明循环体为条件语句块的子作用域</span></span><br><span class="line"><span class="comment">// for循环执行顺序为：条件语句块1-&gt;条件语句块2-&gt;循环体-&gt;条件语句块3-&gt;条件语句块2 依次类推</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i=x) &#123; <span class="comment">// x is not defined</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ul>
<li>作用域链也就是所谓的变量查找的范围</li>
<li>在当前作用域引用变量时，如果没有此变量，则会一路往父级作用域查找此变量，直到全局作用域，如果都没有，在非严格情况下会自动声明，所以是undefined，在严格条件下则会报错</li>
<li>变量的查找路径依据的是在创建这个作用域的地方向上查找，并非是在执行时的作用域，如下 b变量的值为2。可以看出当执行到需要b变量时，当前作用域下并没有b，所以要到定义这个b变量的静态作用域中寻找，即创建时候的作用域链上查找b的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义b，找到</span></span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用到b，当前作用域并没有，向上找</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = a()</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">s() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>作用域在脚本解析阶段就已经规定好了，所以与执行阶段无关，且无法改变</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul>
<li>执行上下文在运行时确定，随时可能改变</li>
<li>调用栈中存放多个执行上下文，按照后进先出的规则进行创建和销毁，最底部的执行上下文，也就是栈低的执行上下文为全局上下文，最早被压入栈中，其上下文中的this指向window，严格模式下为undefined</li>
<li>创建执行上下文时，会绑定当前this，确定词法环境，存储当前环境下函数声明内容，变量let与const绑定但未关联任何值，确认变量环境时，绑定var的初始值为undefined</li>
<li>在var声明之前，调用var声明的变量时值为undefined，因为创建了执行上下文，var声明的变量已经绑定初始undefined，而在let和const声明之前调用其声明的变量时，由于只绑定在了执行上下文中，但并未初始任何值，所以在声明之前调用则会抛出引用错误(即TDZ暂时性死区)，这也就是函数声明与var声明在执行上下文中的提升</li>
</ul>
<p>这里了解一下函数、变量提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(foo) <span class="comment">// foo()&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">5</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console.dir(foo) // undefined</span></span><br><span class="line"><span class="comment">var foo = 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">------------------------------</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.dir(foo) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>从以上代码结果可以得出结论：</p>
<ul>
<li>上面代码块能够体现，在解析阶段会将函数与变量提升，且函数的优先级比var声明的变量高，因为打印的是函数声明，如果var声明的优先级高，那么应该是undefined</li>
<li>从下面的代码块中可以看出foo在代码执行的时候被赋值为5，而函数声明在解析阶段已经结束，在执行阶段没有效果</li>
<li>还有一点 个人认为在解析阶段，函数声明与变量声明提升之后在代码块中的位置顺序没什么关系</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>所谓闭包就是函数与其词法环境(创建当前作用时的任何局部变量)的引用。闭包可以使内部函数访问到外部函数的作用域，当函数被创建时即生成闭包</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'hi'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line">fn1()() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>当你从函数内部返回一个内部函数时，返回的函数将会保留当前闭包，即当前词法环境</p>
<p>闭包只会保留环境中任何变量的最后一个值，这是因为闭包所保存的是整个变量的对象</p>
<p>闭包的作用域链包含着它自己的作用域，以及包含它父级函数的作用域和全局作用域</p>
<p>当返回一个闭包时，保留此闭包下的所有被外部引用的对象</p>
<p>闭包之间是独立的，在闭包环境下可以创建多个不同的闭包环境暴露给外部，从而实现不同的效果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>暴露闭包的方式不止返回内部函数一种，还可以使用回调函数产生闭包环境，或者把内部函数赋值给其他外部对象使用</li>
<li>闭包在没有被外部使用的情况下，随执行结束销毁，如何产生闭包并且保留闭包环境的关键就在于不让其环境被垃圾回收系统自动清除，那么就要使内部环境中的引用被外部保留，这样才能保留闭包</li>
<li>闭包虽然方便我们操作和保留内部环境，但是闭包在处理速度和内存消耗方面对脚本性能具有负面影响，除非在特定的情况下使用</li>
</ul>
<p>这里看个有趣的东西</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a=&#123;<span class="attr">name</span>:<span class="string">'me'</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> b=&#123;<span class="attr">who</span>:<span class="string">'isMe'</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> wm=<span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)  <span class="comment">// a被闭包保留</span></span><br><span class="line">    wm.set(b,<span class="number">1</span>) <span class="comment">// 弱引用b对象</span></span><br><span class="line">    <span class="keyword">return</span> wm <span class="comment">//wm被闭包保留</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wm=foo()()</span><br><span class="line"><span class="built_in">console</span>.dir(wm) <span class="comment">// No properties 即为空</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a=&#123;<span class="attr">name</span>:<span class="string">'me'</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> wm=<span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    wm.set(a,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> wm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wm=foo()()</span><br><span class="line"><span class="built_in">console</span>.dir(wm) <span class="comment">// 保存了对象a与其值1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从上块代码中可以看出，bar被return到外部环境，所以其内部形成闭包，bar中使用到的变量(a,wm)都会被保留下来，但是最后打印wm的时候为空？这是因为外部并没有引用到b对象，只是通过wm弱引用保存b的值，从wm为空可以看出，闭包内部的b被清除，所以wm也自动清除b的弱引用，可以论证之前所说，闭包只保留外部用到的变量</li>
<li>从下块代码能直接看出a就是闭包中的a，bar在外部执行时需要用到a与wm所以保留了下来</li>
<li>有人可能会不解，为什么上块代码中的b也被wm.set(b,1)引用，但是最终就没有呢，那是因为WeakMap中保留的是b的弱引用，可以理解为，wm中的b是依赖原函数中的b而存在，当wm被return时，闭包中的b，没有被任何外部所依赖，而是别人依赖它。可以这么理解 b牵着别人走，因为b没有被外面人牵着走，所以b这个链子就被断开，也影响到b牵的人一块丢了</li>
</ul>
<h2 id="七、this"><a href="#七、this" class="headerlink" title="七、this"></a>七、this</h2><p>先看一张图</p>
<img src="../images/1719d51548402b0f.png" alt="img" style="zoom:200%;" />

<p>this的绑定在创建执行上下文时确定</p>
<p>大多数情况函数调用的方式决定this的值，this在执行时无法赋值</p>
<p>this的值为当前执行的环境对象，非严格下总是指向一个对象，严格下可以是任意值</p>
<p>全局环境下this始终指向window，严格模式下函数的调用没有明确调用对象的情况下，函数内部this指向undefined，非严格下指向window</p>
<p>箭头函数的this永远指向创建当前词法环境时的this</p>
<p>作为构造函数时，函数中的this指向实例对象</p>
<p>this的绑定只受最靠近调用它的成员的引用</p>
<p>执行上下文在被执行的时候才会创建，创建执行上下文时才会绑定this，所以this的指向永远是在执行时确定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下undefined</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//非严格Number对象，严格模式 5</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>严格与非严格模式下的this指向是不同的，非严格总是指向一个对象，严格模式可以为任意值</p>
<img src="../images/1719d51c276f0ae3.png" alt="img" style="zoom:200%;" />

<p>执行后</p>
<img src="../images/1719d51da155695f.png" alt="img" style="zoom:200%;" />

<p>以上2图可以使用chrome开发工具来进行查看程序执行时的相关数据，可以看到严格模式下简单调用的函数内部的this指向undefined</p>
<h3 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h3><h4 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h4><p>在没有明确调用者情况下函数内部this指向window，严格模式下都为undefined，除非绑定函数的this指向，才会改变this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  boo()</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 取出对象中的函数，再进行调用</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = obj.foo</span><br><span class="line">foo()()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 直接通过对象调用函数，再调用返回的函数，可以看出this的指向随调用对象改变</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//obj,严格下 obj</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = obj.foo()</span><br><span class="line">foo()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 基于回调函数也是如此</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="基于调用者以及不同调用方式"><a href="#基于调用者以及不同调用方式" class="headerlink" title="基于调用者以及不同调用方式"></a>基于调用者以及不同调用方式</h4><p>函数调用也就是在函数名后面加个()，表示调用，如果函数名前没有加任何东西，那么默认为<strong>简单调用</strong>，在严格与非严格环境下，简单调用的函数内部this指向undefined与window，但是全局环境下的this永远为window</p>
<p>基于对象</p>
<p>当函数作为<strong>对象的方法</strong>调用时，不受函数定义方式或者位置影响</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数this指向调用者对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// obj1,严格下 obj1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window,严格下 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    boo()</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">obj1.boo = obj.foo</span><br><span class="line">obj1.boo()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 不同调用对象时，this指向调用者</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// obj,严格下 obj</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    boo() <span class="comment">// window,严格下 undefined</span></span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">obj1.boo = obj.foo()</span><br><span class="line">obj1.boo() <span class="comment">// obj1,严格下 obj1</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// this指向最近的调用者</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  obj1: &#123;</span><br><span class="line">    name: <span class="string">'obj1'</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>.name) <span class="comment">// obj1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.obj1.foo()</span><br></pre></td></tr></table></figure>

<p>基于new关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于new关键字调用的函数内部this指向实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// foo实例</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> foo) <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo.prototype.isPrototypeOf(<span class="keyword">this</span>)) <span class="comment">//true</span></span><br><span class="line">  that = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> that</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> foo()</span><br><span class="line"><span class="built_in">console</span>.log(that === f) <span class="comment">// true</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 嵌套函数内部this与调用函数所在环境的this无关</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// foo实例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  boo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> foo()</span><br></pre></td></tr></table></figure>

<p>基于定时器与微任务</p>
<p>微任务中的简单调用的函数this指向window严格下指向undefined，而<strong>定时器中的回调函数不管在严格还是非严格环境下this永远指向window</strong>，说明一点，调用window对象的方法时this指向window也就是全局对象，换句话说，简单调用的函数如果属于window本身自带的方法那么这个方法的this指向window</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步任务中简单调用的函数都是进入队列，最后由全局环境调用</span></span><br><span class="line"><span class="keyword">const</span> id = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 window</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 window</span></span><br><span class="line">    clearInterval(id)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">&#125;);</span><br><span class="line">----------------------------------------------</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> boo()</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">&#125;)()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 定时器的回调最终都会被作为简单函数被执行，定时器属于window对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//window ,严格下window</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">foo.call(<span class="number">5</span>)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 函数内部的this就是指向调用者，并且可以看出简单调用的回调函数中的this也指向window</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo(callback) &#123;</span><br><span class="line">    callback()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo === obj.foo) <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj) <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//window ,严格下undefined</span></span><br><span class="line">&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 通过arguments调用的回调函数中的this指向调用者，注意严格与非严格下的arguments对象有所不同</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo(callback) &#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo === obj.foo) <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj) <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//arguments对象 ，严格下 arguments对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>es6引入的箭头函数，是不具有this绑定，不过在其函数体中可以使用this，而这个this指向的是箭头函数当前所处的词法环境中的this对象，可以理解为，this在箭头函数中是透明的，箭头函数包不住this，所以函数内部与外部的this为同一值</p>
<ul>
<li>判断箭头函数的this指向，我们可以把箭头函数看成透明，其上下文中的this就是它的this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看出箭头函数中的this就是其所在环境的this，箭头函数无法固定this，由其环境决定</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window ,严格下还是window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 可见对象中的this指向window，箭头函数中的this指向对象中的this。由于只有创建执行上下文才会绑定this指向，而除了全局上下文，只有函数作用域才会创建上下文环境从而绑定this，创建对象不会绑定this，所以还是全局this</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  <span class="keyword">this</span>:<span class="keyword">this</span>,</span><br><span class="line">  foo:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window ，严格下 window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.dir(obj.this) <span class="comment">//window ，严格下 window</span></span><br><span class="line">obj.foo()</span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="comment">// 对象方法内部嵌套箭头函数，则此箭头函数的this属于外部非箭头函数this。当调用obj.foo时foo函数创建的执行上下文中的this绑定对象obj，而箭头函数并不会绑定this，所以其this属于foo下的this，即对象obj</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//obj ，严格下 obj</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()()</span><br></pre></td></tr></table></figure>

<h3 id="如何改变函数的this指向"><a href="#如何改变函数的this指向" class="headerlink" title="如何改变函数的this指向"></a>如何改变函数的this指向</h3><p>最简单的方法通过apply、call、bind来给函数绑定this</p>
<ul>
<li>apply方法中第一个参数为被调用的函数中的this指向，传入你想要绑定的this值即可，第二个参数为被调用函数的参数集合，通常是个数组</li>
<li>call与apply方法基本一致，区别在于传入参数形式不同，call传入的参数为可变参数列表，参数按逐个传入</li>
<li>bind方法与以上不同的是不会直接调用函数，只是先绑定函数的this，到要使用的时候调用即可，此方法返回一个绑定this与参数之后的新函数，其传入参数形式同call</li>
<li>通过变量保留指定this来达到固定this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过变量保留父级this，进行对_this变量修改也就达到修改原this的效果</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      _this.name = <span class="string">'OBJ'</span></span><br><span class="line">      <span class="built_in">console</span>.dir(obj.name) <span class="comment">// OBJ</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()()</span><br></pre></td></tr></table></figure>

<h2 id="八、apply、call、bind实现"><a href="#八、apply、call、bind实现" class="headerlink" title="八、apply、call、bind实现"></a>八、apply、call、bind实现</h2><p>这3者的实现其实差不多，bind实现可能会有点不一样，都要实现this的改变</p>
<h3 id="手动实现apply"><a href="#手动实现apply" class="headerlink" title="手动实现apply"></a>手动实现apply</h3><ul>
<li>思路就是想办法使函数被传入的thisArg调用，那么函数的this就指向调用者</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.Apply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, args = Symbol.for(<span class="string">'args'</span></span>)) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>)            <span class="comment">//this为这个方法的调用者=&gt;foo函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>)      <span class="comment">//生成一个不重复的键</span></span><br><span class="line">  thisArg[fn] = <span class="keyword">this</span> || <span class="built_in">window</span> <span class="comment">//把foo函数作为传入this的一个方法</span></span><br><span class="line">  args === <span class="built_in">Symbol</span>.for(<span class="string">'args'</span>) </span><br><span class="line">  ? thisArg[fn]()</span><br><span class="line">  : thisArg[fn](...args)       <span class="comment">//调用这方法，传参</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]           <span class="comment">//使用完删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">age,height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) <span class="comment">// obj</span></span><br><span class="line">  <span class="built_in">console</span>.log(age)       <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(height)    <span class="comment">// null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  age: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo.Apply(obj,[obj.age,<span class="literal">null</span>])</span><br></pre></td></tr></table></figure>

<h3 id="手动实现call"><a href="#手动实现call" class="headerlink" title="手动实现call"></a>手动实现call</h3><p>基本思路同apply，就是传参形式改变一下,这里通过arguments获取参数列表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.Call = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>)            <span class="comment">//this为这个方法的调用者=&gt;foo函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>)      <span class="comment">//生成一个不重复的键</span></span><br><span class="line">  thisArg[fn] = <span class="keyword">this</span> || <span class="built_in">window</span> <span class="comment">//把foo函数作为传入this的一个方法</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">  args.length ? thisArg[fn](...args) : thisArg[fn]()  <span class="comment">//调用这方法，传参</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]           <span class="comment">//使用完删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动实现bind"><a href="#手动实现bind" class="headerlink" title="手动实现bind"></a>手动实现bind</h3><p>bind函数要能够返回严格绑定this与参数后的函数，调用这个返回的函数时有可能还会传入参数，那么需要拼接参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.Bind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>)       <span class="comment">//生成一个不重复的键</span></span><br><span class="line">  thisArg[fn] = <span class="keyword">this</span> || <span class="built_in">window</span>  <span class="comment">//把foo函数作为传入this的一个方法</span></span><br><span class="line">  <span class="keyword">const</span> f = thisArg[fn]         <span class="comment">// 负责一份函数</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]            <span class="comment">//删除原来对象上的函数，但是保留了this指向</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arg = args.concat(...arguments)</span><br><span class="line">    f(...arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">age, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)       <span class="comment">// obj</span></span><br><span class="line">  <span class="built_in">console</span>.log(age)             <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(height)          <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  age: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo.Bind(obj, obj.age)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="九、同步与异步"><a href="#九、同步与异步" class="headerlink" title="九、同步与异步"></a>九、同步与异步</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul>
<li>基于js的单线程同时只能处理一件事情，而同步即是在主线程上排队执行的任务，只有当前任务执行完成，才会进入下一个任务。同步执行的函数会在预期得到结果，也就是可以清楚什么时候能得到返回值</li>
<li>所有同步代码只会进入调用栈，同步代码会阻塞主线程的执行，而且会优先与其他非同步代码执行</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul>
<li>异步是指当前执行的代码会进入异步线程处理之后才会再由主线程处理回调</li>
<li>异步的结果不是马上能够得到，而是会在将来的某个时间点获取到</li>
<li>通常异步代码所要经过的步骤比同步代码多，由于异步代码不是直接放在调用栈中执行，而是要派发(可能不需要)给其他线程处理，等处理完成后的回调放在某个地方存储(比如任务队列)，等到同步队列执行完成之后才会取回异步回调代码进行执行</li>
</ul>
<h4 id="异步、单线程与EventLoop"><a href="#异步、单线程与EventLoop" class="headerlink" title="异步、单线程与EventLoop"></a>异步、单线程与EventLoop</h4><p>先看一张图，有个大体架构</p>
<img src="../images/1719d5330a5a1b7f.png" alt="img" style="zoom:200%;" />

<ul>
<li>js主线程处理当前正在执行的代码，它会执行当前调用栈栈顶的执行上下文，从堆空间(一般是存储对象)和栈空间(一般存储非对象值以及对象引用)取数据，进而处理当前调用栈所用到的数据</li>
<li>所有的同步代码会按照代码顺序压入调用栈中等待主线程执行，如果代码中遇到了异步代码，则会根据异步类型抛给异步线程执行</li>
<li>异步类型，主要分为微任务与宏任务</li>
<li>任务队列其实本质就是一块内存空间，里面的任务是依据FIFO先进先出的规则来执行，所有异步代码执行完毕的回调都是加入到异步任务队列中等待主线程的调用</li>
<li>异步可以提高cpu的利用率</li>
</ul>
<h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><ul>
<li>微任务队列与宏任务队列的区别就在于，主线程对于其中的任务调度的区别，主进程会优先执行微任务队列中的全部任务，当微任务中的全部任务执行完毕才会进而转到宏任务执行</li>
<li>微任务可以由这些方法关键字调用产生Promise、async、await、MutaionObserver、process.nextTick(Node.js环境）</li>
<li>如果调用微任务方法时，方法内部包含其他线程干预处理时，会抛给指定线程执行，而主线程继续执行下面的代码，等到其他线程处理完成之后，如果有回调函数则会把回调加入到指定异步类型(这里为微任务队列)的队列中排队等待主线程执行</li>
<li>微任务与宏任务的主要区别在于，主线程优先执行全部微任务，待执行完成之后才会挨个执行宏任务</li>
</ul>
<h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><ul>
<li>一般的宏任务队列存放的是WebApis的回调，WebApis中包含许多线程，GUI渲染线程(与js主线程互斥不能同时执行)、事件触发线程、定时器线程、异步网络请求线程</li>
<li>宏任务存放由异步WebApis产生的回调函数，但优先级低于微任务</li>
</ul>
<h5 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h5><ul>
<li>js单线程设计之初就是为了简化代码，解决DOM冲突，如果js为多线程语言，那么有可能产生多个线程同时操作DOM的情况，那么将会导致js操作同个DOM引起冲突，介于多线程的锁机制来解决冲突，但又使得js的代码复杂度提高</li>
<li>基于js单线程的设计，进而引出异步执行的方式，使得js具有类似多线程程的效果，但不管异步还是同步，js永远都只有一个线程在执行</li>
</ul>
<h5 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h5><ul>
<li>事件循环机制是针对于主线程的调度方式</li>
<li>可以理解为主线程在寻找任务执行的过程就是事件循环，其寻找方式就是调用机制</li>
<li>先了解一下浏览器是如何执行js代码的<ul>
<li>通常浏览器在最开始运行js代码的入口就是html中的script标签所涵盖的代码</li>
<li>当GUI渲染线程解析到script标签，则会把标签所涵盖的js代码加入到宏任务队列中</li>
<li>首先js引擎(如V8引擎)先取第一个宏任务，即script的代码块，然后主线程在调用栈中解析js代码</li>
<li>等所有代码解析完成之后开始运行js代码</li>
<li>如果遇到同步代码直接执行</li>
<li>遇到异步代码，如果是宏任务类型即异步WebApis处理的异步代码，那么将会通知WebApis在对应的线程中处理异步任务，此时js主线程继续执行下面的代码，在其他线程处理完毕之后如果有回调函数，则异步线程会将回调函数加入到宏任务队列尾部，</li>
<li>如果是微任务类型的异步代码，也同宏任务处理，只不过是把回调函数加入到微任务队列中，其执行的优先级高于宏任务队列</li>
<li>当同步代码全部执行完成，主线程将会一直检测任务队列，如果有异步微任务则执行完全部的微任务</li>
<li>进一步执行浏览器渲染进程绘制页面，之后就是开始下一轮的事件循环，就又回到取宏任务执行</li>
<li>这里注意，所有的微任务都是由宏任务中执行的代码产生，一开始只有宏任务队列有任务</li>
</ul>
</li>
</ul>
<p>以下展示的是事件循环大致流程</p>
<p><img src="../images/1719d53968ef6d36.png" alt="img"></p>
<p>以下为主线程判断逻辑</p>
<img src="../images/image-20200424115518421.png" alt="image-20200424115518421" style="zoom:50%;" />

<h3 id="前端异步的场景"><a href="#前端异步的场景" class="headerlink" title="前端异步的场景"></a>前端异步的场景</h3><ul>
<li>前端异步主要用于代码可能会发生等待，而且等待过程不能阻塞主线程运行的情况</li>
<li>通常WebApis接口都是异步调用的，由于需要其他线程的处理，就需要等待其返回结果，那么js主线程就没必要一直等待，这样就需要使用异步来进行处理</li>
<li>比如定时器任务setTimeout、setInterval、ajax请求、图片动态加载、DOM事件触发这些都属于浏览器执行的异步任务；如js中的Promise、async、await属于js语言自身的异步操作这些都可以实现异步</li>
<li>当需要动态加载图片的时候就需要用到异步；当需要执行的js的同步代码需要长时间占用的主线程时可以使用异步方式拆分为多个步骤执行，这样可以避免浏览器页面长时间无响应或者卡顿</li>
<li>当需要执行很长一段时间才能得到结果的代码时也可以使用html5中的Web worker在浏览器渲染进程下新开一个线程用来专门执行此代码，通过postMessage来返回运行结果这样也不会占用js主线程，但是这个线程无法操作DOM和BOM</li>
</ul>
<h3 id="WebWorker多线程"><a href="#WebWorker多线程" class="headerlink" title="WebWorker多线程"></a>WebWorker多线程</h3><ul>
<li>基于js单线程的局限性，如果执行一个很耗时间的函数，那么主线程将会被长时间占用，因此导致事件循环暂停，使得浏览器无法及时渲染和响应，那么将会造成页面崩溃，用户体验下降，所以html5支持了webworker</li>
<li>webwork简单理解就是可以让特定的js代码在其他线程中执行，等执行结束后返回结果给主线程接收即可</li>
<li>比如在js中需要实现一个识别图片的算法，而且此算法需要很长的计算时间，如果让js主线程来执行将会导致上述发生的事情，那么正好可以使用webwork技术来实现。</li>
<li>创建一个webworker文件，其中写入算法代码，在最后调用postMessage(result)方法返回结果给主线程，js主代码中通过w=new Worker(文件路径)来创建一个渲染进程的webworker子线程实例，通过w.onmessage=function(e){console.log(e.data)}给其添加一个事件监听器，当webworker中传递消息给js主线程时会在此回调函数中执行，通过调用w.terminate()终止webworker线程</li>
<li>webworker线程与js主线程最大的区别就在于webworker线程无法操作window与document对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.html(主线程)</span></span><br><span class="line"><span class="keyword">const</span> w= <span class="keyword">new</span> Worker(<span class="string">'postMessage.js'</span>)</span><br><span class="line">w.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;</span><br><span class="line">w.postMessage(<span class="string">'b'</span>) <span class="comment">// b is cat</span></span><br><span class="line">w.terminate() <span class="comment">// 手动关闭子线程</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// postMessage.js(worker线程)</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">this</span>.postMessage(e.data+<span class="string">' is tom'</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>: <span class="keyword">this</span>.postMessage(e.data + <span class="string">' is cat'</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:  <span class="keyword">this</span>.postMessage(e.data + <span class="string">" i don't know"</span>)</span><br><span class="line">    <span class="keyword">this</span>.close() <span class="comment">// 自身关闭</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="十、AMD、CMD、CommonJS与ES6模块化"><a href="#十、AMD、CMD、CommonJS与ES6模块化" class="headerlink" title="十、AMD、CMD、CommonJS与ES6模块化"></a>十、AMD、CMD、CommonJS与ES6模块化</h2><p>模块化的引入主要是用于解决命名冲突、代码复用、代码可读性、依赖管理等</p>
<h3 id="AMD异步模块定义"><a href="#AMD异步模块定义" class="headerlink" title="AMD异步模块定义"></a>AMD异步模块定义</h3><ul>
<li>AMD全称Asynchronous Module Definition异步模块定义</li>
<li>AMD并非原生js支持，是RequireJS模块化开发当中推广的产物，AMD依赖于RequireJS函数库，打包生成对应效果的js代码</li>
<li>RequireJS主要用于解决多个js文件之间的依赖关系、浏览器加载大量js代码导致无响应、异步加载模块</li>
<li>RequireJS通过<code>define(id?,dependencies?,factory)</code>定义模块，id可选，为定义模块的标识，默认为模块文件名不包括后缀，dependencies可选，是当前模块依赖的模块路径数组，factory为工厂方法，初始化模块的函数或者对象，如果为函数将会只执行一次，如果是对象将作为模块的输出</li>
<li>通过<code>require(dependencies,factory)</code>导入模块，其中dependencies为需要导入的模块路径数组，factory为当模块导入之后的回调函数，此函数的参数列表为对应导入的模块</li>
<li>通过require.config(配置对象)配置各模块路径和引用名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="CMD通用模块定义"><a href="#CMD通用模块定义" class="headerlink" title="CMD通用模块定义"></a>CMD通用模块定义</h3><ul>
<li>CMD全称Common Module Definition通用模块定义</li>
<li>同AMD，CMD也有一个函数库SeaJS与RequireJS类似的功能</li>
<li>CMD推崇一个文件一个模块，推崇依赖就近，定义模块<code>define(id?,deps?,factory)</code>，id同AMD，deps一般不在其中写依赖，而是在factory中在需要使用的时候引入模块，factory函数接收3各参数，参数一require方法，用来内部引入模块的时候调用，参数二exports是一个对象，用来向外部提供模块接口，参数三module也是一个对象上面存储了与当前模块相关联的一些属性和方法</li>
<li>通过<code>seajs.use(deps,func)</code>加载模块，deps为引入到模块路径数组，func为加载完成后的回调函数</li>
</ul>
<p>AMD、CMD的主要区别在于</p>
<p>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><ul>
<li>CommonJS模块规范，通常用于Nodejs中的模块化</li>
<li>拥有4个环境变量modul、exports、require、global</li>
<li>通过<code>module.exports</code>(不推荐exports)导出模块对象，通过require(模块路径)加载模块</li>
<li>当一个模块同时存在exports和module.exports时后者覆盖前者</li>
<li>规范中<code>__dirname</code>代表当前模块文件所在的文件夹路径，<code>__filename</code>代表当前模块文件夹路径+文件名</li>
<li>CommonJS通过同步的方式加载模块，其输出的模块是一个拷贝对象，所以修改原的模块不会对被引入的模块内部产生影响，且模块在代码运行的时候加载</li>
</ul>
<h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><ul>
<li>es6引入的export与import用于解决js自身不具备模块功能的缺陷</li>
<li>通过export或者export default导出模块接口，通过import xxx from ‘路径’，导入模块</li>
<li>对于export导出的接口可以使用import {接口} from ‘路径’，通过解构的方式按需导入</li>
<li>对于export default默认导出的，可以使用import xxx from ‘路径’，来导入默认导出的接口，xxx可以是自定义名称，且一个模块只能有一个默认导出，可以有多个export</li>
<li>还可以通过别名的方式设置导出和导入的接口名，如export {a as foo}，把foo作为a的别名导出，import foo as b from 路径，把b当作foo的别名导入</li>
<li>es6模块是在代码编译时输出接口即编译时加载，es6是通过命令来指定导出和加载，且导出的是模块中的只读引用，如果原始模块中的值被改变了，那么加载的值也会随之改变，所以是动态引用</li>
</ul>
<h2 id="十一、script标签之async与defer"><a href="#十一、script标签之async与defer" class="headerlink" title="十一、script标签之async与defer"></a>十一、script标签之async与defer</h2><h3 id="使用async属性"><a href="#使用async属性" class="headerlink" title="使用async属性"></a>使用async属性</h3><ul>
<li>如果script标签设置了这个值，则说明引入的js需要异步加载和执行，注意此属性只适用于外部引入的js</li>
<li>在有async的情况下脚本异步加载和执行，并且不会阻塞页面加载，但是也并不会保证其加载的顺序，如果多个async优先执行，则先加载好的js文件，所以使用此方式加载的js文件最好不要包含其他依赖</li>
</ul>
<h3 id="使用defer属性"><a href="#使用defer属性" class="headerlink" title="使用defer属性"></a>使用defer属性</h3><ul>
<li>如果使用此属性，也将会使js异步加载执行，且会在文档被解析完成后执行，这样就不会阻塞页面加载，但是它将会按照原来的执行顺序执行，对于有依赖关系的也可使用</li>
<li>html4.0中定义了defer，html5.0中定义了async</li>
</ul>
<h3 id="不同情况"><a href="#不同情况" class="headerlink" title="不同情况"></a>不同情况</h3><ul>
<li>如果只有async，那么脚本在下载完成后异步执行。</li>
<li>如果只有defer，那么脚本会在页面解析完毕之后执行。</li>
<li>如果都没有，那么脚本会在页面中马上解执行，停止文档解析阻塞页面加载</li>
<li>如果都有那么同async，当然此情况一般用于html的版本兼容下，如果没有async则defer生效</li>
<li>不过还是推荐直接把script标签放在body底部</li>
</ul>
<h2 id="十二、改变数组本身的api"><a href="#十二、改变数组本身的api" class="headerlink" title="十二、改变数组本身的api"></a>十二、改变数组本身的api</h2><ol>
<li><code>pop()</code>  尾部弹出一个元素</li>
<li><code>push()</code> 尾部插入一个元素</li>
<li><code>shift()</code>  头部弹出一个元素</li>
<li><code>unshift()</code>  头部插入一个元素</li>
<li><code>sort([func])</code> 对数组进行排序,func有2各参数，其返回值小于0，那么参数1被排列到参数2之前，反之参数2排在参数1之前</li>
<li>reverse() 原位反转数组中的元素</li>
<li><code>splice(pos,deleteCount,...item)</code>  返回修改后的数组，从pos开始删除deleteCount个元素，并在当前位置插入items</li>
<li><code>copyWithin(pos[, start[, end]])</code> 复制从start到end(不包括end)的元素，到pos开始的索引，返回改变后的数组，浅拷贝</li>
<li><code>arr.fill(value[, start[, end]])</code> 从start到end默认到数组最后一个位置，不包括end，填充val，返回填充后的数组</li>
</ol>
<p>其他数组api不改变原数组</p>
<h2 id="十三、window之location、navigator"><a href="#十三、window之location、navigator" class="headerlink" title="十三、window之location、navigator"></a>十三、window之location、navigator</h2><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><ul>
<li>location为全局对象window的一个属性，且<code>window.location===document.location</code>，其中的属性都是可读写的，但是只有修改<strong>href</strong>和<strong>hash</strong>才有意义，href会重新定位到一个URL，hash会跳到当前页面中的anchor名字的标记(如果有)，而且页面不会被重新加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这行代码将会使当前页面重定向到http://www.baidu.com</span></span><br><span class="line"><span class="built_in">window</span>.location.href = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 如果使用hash并且配合input输入框，那么当页面刷新之后，鼠标将会自动聚焦到对应id的input输入框，</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"target"</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">window</span>.location.hash = <span class="string">'#target'</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>先看下其拥有的属性</p>
<img src="https://user-gold-cdn.xitu.io/2020/4/21/1719d5465e6deae5?imageslim" alt="img" style="zoom:200%;" />

<p>这里补充一个<strong>origin</strong>属性，<code>返回URL协议+服务器名称+端口号 (location.origin == location.protocol + &#39;//&#39; + location.host)</code></p>
<ul>
<li>可以通过上述属性来获取URL中的指定部分，或者修改href于hash达到重新定位与跳转</li>
<li>添加hash改变监听器，来控制hash改变时执行的代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>, funcRef);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = funcRef;</span><br></pre></td></tr></table></figure>

<p>location方法</p>
<p><img src="../images/1719d54a9be043de.png" alt="img"></p>
<ul>
<li><code>assign(url)</code>,通过调用<code>window.location.assign</code>方法来打开指定url的新页面<code>window.location.assign(&#39;http://www.baidu.com&#39;)</code>在当前页面打开百度，可回退</li>
<li><code>replace(url)</code>,在当前页面打开指定url，不可回退</li>
<li><code>reload([Boolean])</code>,调用此方法将会重新加载当前页面，如果参数为false或者不填，则会以最优的方式重新加载页面，可能从缓存中取资源，如果参数为true则会从服务器重新请求加载资源</li>
</ul>
<h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><ul>
<li><code>window.navigator</code>对象包含<strong>有关浏览器的信息</strong>，可以用它来查询一些关于运行当前脚本的应用程序的相关信息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器的代码名:"</span> + navigator.appCodeName + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器的名称:"</span> + navigator.appName + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"当前浏览器的语言:"</span> + navigator.browserLanguage + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器的平台和版本信息:"</span> + navigator.appVersion + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器中是否启用 cookie :"</span> + navigator.cookieEnabled + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"运行浏览器的操作系统平台 :"</span> + navigator.platform + <span class="string">"&lt;br&gt;"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>navigator.appCodeName</code> 只读,任何浏览器中，总是返回 ‘Gecko’。该属性仅仅是为了保持兼容性。</li>
<li><code>navigator.appName</code> 只读,返回浏览器的官方名称。不要指望该属性返回正确的值。</li>
<li><code>navigator.appVersion</code> 只读,返回一个字符串，表示浏览器的版本。不要指望该属性返回正确的值。</li>
<li><code>navigator.platform</code> 只读,返回一个字符串，表示浏览器的所在系统平台。</li>
<li><code>navigator.product</code> 只读,返回当前浏览器的产品名称（如，”Gecko”）。</li>
<li><code>navigator.userAgent</code> 只读,返回当前浏览器的用户代理字符串（user agent string）</li>
</ul>
<p>如下在不同浏览器打印的信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">chrome:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Macintosh; Intel Mac OS X 10_12_6)</span></span><br><span class="line"><span class="comment">    AppleWebKit/537.36 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Chrome/61.0.3163.91 Safari/537.36</span></span><br><span class="line"><span class="comment">safari:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Macintosh; Intel Mac OS X 10_12_6)</span></span><br><span class="line"><span class="comment">    AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0</span></span><br><span class="line"><span class="comment">    Safari/604.1.38</span></span><br><span class="line"><span class="comment">ios11刘海X:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (iPhone; CPU iPhone OS 11_0 like Mac OS X)</span></span><br><span class="line"><span class="comment">    AppleWebKit/604.1.38 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Version/11.0 Mobile/15A372 Safari/604.1</span></span><br><span class="line"><span class="comment">ipad：</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (iPad; CPU OS 9_1 like Mac OS X)</span></span><br><span class="line"><span class="comment">    AppleWebKit/601.1.46 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Version/9.0 Mobile/13B143 Safari/601.1</span></span><br><span class="line"><span class="comment">galxy sansum:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Linux; Android 5.0; SM-G900P Build/LRX21T)</span></span><br><span class="line"><span class="comment">    AppleWebKit/537.36 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Chrome/61.0.3163.91 Mobile Safari/537.36</span></span><br><span class="line"><span class="comment">安装uc浏览器：</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Linux; U; Android 6.0.1; zh-CN; Mi Note 2 Build/MXB48T)</span></span><br><span class="line"><span class="comment">    AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0</span></span><br><span class="line"><span class="comment">    Chrome/40.0.2214.89 UCBrowser/11.4.9.941 Mobile Safari/537.36</span></span><br><span class="line"><span class="comment">winphone:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Linux; Android 5.1.1; Nexus 6 Build/LYZ28E)</span></span><br><span class="line"><span class="comment">    AppleWebKit/537.36 (KHTML, like Gecko) </span></span><br><span class="line"><span class="comment">    Chrome/61.0.3163.91 Mobile Safari/537.36</span></span><br><span class="line"><span class="comment">hybrid方法的可能：</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (iPhone; CPU iPhone OS 11_0 like Mac OS X)</span></span><br><span class="line"><span class="comment">    AppleWebKit/604.1.38 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Mobile/15A372 weibo/80011134</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="十四、ajax与fetch"><a href="#十四、ajax与fetch" class="headerlink" title="十四、ajax与fetch"></a>十四、ajax与fetch</h2><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><ul>
<li>ajax全称Asynchronous JavaScript And XML也就是异步js与xml，它可以让页面在不刷新的情况下发起请求获取数据</li>
<li>使用<code>window.XMLHttpRequest</code>构造器实例化一个网络请求对象<code>const XHR = new XMLHttpRequest()</code></li>
<li><code>XHR.open(method, url, [ async, [ user, [ password]]])</code>此方法用来发送一个请求，method为请求方法，url为请求地址，async为boolean值默认为true即使用异步请求，user和password在请求需要用户和密码的时候使用</li>
<li><code>XHR.send(body)</code>参数为发生请求主体内容，其格式可以为FormData、ArrayBuffer、Document、序列化字符串，在收到响应后，响应的数据会自动填充XHR对象的属性</li>
<li>当需要设置请求头时可以调用<code>XHR.setRequestHeader(header,value)</code>设置请求头的类型与值，当以post方式发起请求就用设置<code>XHR.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)</code>此请求头，值可更改</li>
<li>通过监听实例的onreadystatechange属性方法，当readyState的值改变的时候会触发onreadystatechange对应的回调函数<code>XHR.onreadystatechange = function () { }</code></li>
<li>请求状态readyState有5个值，对应5个请求状态，只读<ul>
<li>0 表示 请求还未初始化，尚未调用 open() 方法。</li>
<li>1 表示 已建立服务器链接，open() 方法已经被调用。</li>
<li>2 表示 请求已接受，send() 方法已经被调用，并且头部和状态已经可获得。</li>
<li>3 表示 正在处理请求，下载中； responseText 属性已经包含部分数据。</li>
<li>4 表示 完成，下载操作已完成。</li>
</ul>
</li>
<li>还有status属性，它是这次请求中的响应数字状态码，即为我们平时看到的1xx、2xx、3xx、4xx、5xx表示此次请求的状态结果，在还未发起请求和出错时都为0，只读</li>
<li><code>XHR.responseText</code>属性为此次响应的数据，为字符串，可能是JSON格式需要JSON.parse解析</li>
<li><code>XHR.responseXML</code>属性为xml形式的数据，可以通过<code>XHR.responseType = &#39;document&#39;</code>和<code>XHR.overrideMimeType(&#39;text/xml&#39;)</code>来解析为XML</li>
<li><code>XHR.withCredentials</code>属性设置为boolean值，通过此属性来设置是否使用cookies、authorization等凭证字段</li>
<li><code>XHR.timeout</code>通过此属性来设置请求超时时间</li>
<li><code>XHR.ontimeout</code>通过此属性来设置请求超时的回调函数,函数的参数为事件对象</li>
<li><code>XHR.abort()</code>此方法用来终止网络请求</li>
<li><code>XHR.getAllResponseHeaders()</code>此方法用来获取所有的响应头</li>
<li><code>XHR.getResponseHeader(name)</code>此方法用来获取指定的响应头</li>
<li>还有6个关于进度的事件<ul>
<li>loadstart 在收到响应的第一个字节触发</li>
<li>progress 在接收期间不断触发</li>
<li>error 发生错误</li>
<li>abort 调用abort方法而终止</li>
<li>load 接收到完整数据，可代替readystatechange与readyState判断</li>
<li>loadend 在通信完成或abort error load事件后触发</li>
</ul>
</li>
<li>通过<code>XHR.addEventListener(eventname,callback)</code>方法添加对应的事件监听，其回调函数接收一个事件对象参数</li>
<li>progress事件对象有3个属性用于查看当前进度相关信息，lengthComputable为boolean值，表示进度是否可用，position表示已经接收的字节数，totalSize表示总需要传输的内容长度即Content-Length字节数，通常在分片传输内容的时候用到</li>
</ul>
<p>简单的发起一次请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的发起一个请求</span></span><br><span class="line"><span class="keyword">const</span> XHR = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">XHR.open(<span class="string">'get'</span>,<span class="string">'http://127.0.0.1:3000/test?key=value'</span>)</span><br><span class="line">XHR.send()</span><br><span class="line">XHR.addEventListener(<span class="string">'load'</span>,(e)=&gt;&#123;</span><br><span class="line">  <span class="comment">// 服务端返回的是查询参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(XHR.response) <span class="comment">// &#123;"key":"value"&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于XMLHttpRequest封装一个请求方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送的数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  type: <span class="string">"post"</span>,</span><br><span class="line">  url: <span class="string">"http://127.0.0.1:3000/test"</span>,</span><br><span class="line">  data: data,</span><br><span class="line">  dataType: <span class="string">'application/json'</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求构造器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params">conf</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = conf.type || <span class="string">'get'</span></span><br><span class="line">  <span class="keyword">this</span>.url = conf.url || <span class="string">''</span></span><br><span class="line">  <span class="keyword">this</span>.data = conf.data || &#123;&#125;</span><br><span class="line">  <span class="keyword">this</span>.dataType = conf.dataType || <span class="string">''</span></span><br><span class="line">  <span class="keyword">this</span>.success = conf.success || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.error = conf.error || <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// send方法</span></span><br><span class="line">Ajax.prototype.send = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.url === <span class="string">''</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> XHR = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  XHR.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (XHR.status &gt;= <span class="number">200</span> &amp;&amp; XHR.status &lt; <span class="number">300</span> || XHR.status == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="keyword">this</span>.success === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.success(XHR.response)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  XHR.addEventListener(<span class="string">'error'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="keyword">this</span>.error === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.error(e)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.type.toLowerCase() === <span class="string">'get'</span>) &#123;</span><br><span class="line">    XHR.open(<span class="string">'get'</span>, <span class="keyword">this</span>.url)</span><br><span class="line">    XHR.send(<span class="literal">null</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    XHR.open(<span class="keyword">this</span>.type, <span class="keyword">this</span>.url)</span><br><span class="line">    XHR.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="keyword">this</span>.dataType || <span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">this</span>.data</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataType === <span class="string">'application/json'</span>) &#123;</span><br><span class="line">      data = <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">    XHR.send(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line"><span class="keyword">const</span> ajax = <span class="keyword">new</span> Ajax(config).send()</span><br></pre></td></tr></table></figure>

<p>由于网络请求模块封装较繁琐，这里就简单封装了一下，仅供参考（。＾▽＾）</p>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><ul>
<li>fetch API提供了js接口，用于替代XMLHttpRequest方式的网络请求，fetch()全局方法使用起来比XHR更加方便</li>
<li>fetch方法接受2个参数，参数1为请求url或 Request 对象，参数2为可选配置对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch方法返回一个Promise对象，可用then方法接收结果，用catch方法捕获异常，同Promise使用</span></span><br><span class="line"><span class="comment">// 配置对象具体配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  method: <span class="string">'GET'</span>,      <span class="comment">// 请求方法</span></span><br><span class="line">  headers: &#123;          <span class="comment">// 头信息</span></span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">'Mozilla/4.0 MDN Example'</span>,</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;  <span class="comment">// 请求的 body 信息，Blob, FormData 等</span></span><br><span class="line">    data: <span class="number">1</span></span><br><span class="line">  &#125;),</span><br><span class="line">  mode: <span class="string">'cors'</span>,             <span class="comment">// 请求的模式，cors、 no-cors 或 same-origin</span></span><br><span class="line">  credentials: <span class="string">'include'</span>,   <span class="comment">// omit、same-origin 或 include。为了在当前域名内自动发送 cookie, 必须提供这个选项</span></span><br><span class="line">  cache: <span class="string">'no-cache'</span>,        <span class="comment">// default 、 no-store 、 reload 、 no-cache 、 force-cache 或者 only-if-cached</span></span><br><span class="line">  redirect: <span class="string">'follow'</span>,       <span class="comment">// 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误), 或者 manual (手动处理重定向).</span></span><br><span class="line">  referrer: <span class="string">'no-referrer'</span>,  <span class="comment">// no-referrer、client或一个 URL。默认是 client。</span></span><br><span class="line">  referrerPolicy: <span class="string">'no-referrer'</span>, <span class="comment">// 指定 referer HTTP头</span></span><br><span class="line">  integrity: <span class="string">'sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE='</span>, <span class="comment">// 包括请求的  subresource integrity 值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发起请求</span></span><br><span class="line">fetch(<span class="string">'http://biadu.com'</span> [, config])</span><br></pre></td></tr></table></figure>

<ul>
<li>hen的回调函数接受一个Response对象参数，其对象拥有9个属性，8个方法</li>
<li>9个属性<ul>
<li>type 只读 包含Response的类型 (例如, basic, cors)</li>
<li>url 只读 包含Response的URL</li>
<li>useFinalURL 包含了一个布尔值来标示这是否是该Response的最终URL</li>
<li>status 只读 包含Response的状态码</li>
<li>ok 只读 包含了一个布尔值来标示该Response成功(状态码200-299)</li>
<li>redirected 只读 表示该Response是否来自一个重定向，如果是的话，它的URL列表将会有多个</li>
<li>statusText 只读 包含了与该Response状态码一致的状态信息</li>
<li>headers 只读 包含此Response所关联的Headers 对象</li>
<li>bodyUsed Body 只读 包含了一个布尔值来标示该Response是否读取过Body</li>
</ul>
</li>
<li>8个方法<ul>
<li>clone 创建一个Response对象的克隆</li>
<li>error 返回一个绑定了网络错误的新的Response对象</li>
<li>redirect(url, status) 用另一个URL创建一个新的 response</li>
<li>arrayBuffer 接受一个 Response 流, 并等待其读取完成. 并 resolve 一个 ArrayBuffer 对象</li>
<li>blob  blob()方法使用一个 Response 流，并将其读取完成</li>
<li>formData 将 Response 对象中的所承载的数据流读取并封装成为一个对象</li>
<li>json 使用一个 Response 流，并将其读取完成。解析结果是将文本体解析为 JSON</li>
<li>text 提供了一个可供读取的”返回流”, 它返回一个包含USVString对象，编码为UTF-8</li>
</ul>
</li>
</ul>
<h2 id="十五、WebSocket"><a href="#十五、WebSocket" class="headerlink" title="十五、WebSocket"></a>十五、WebSocket</h2><ul>
<li>WebSocket是一种在单个TCP连接上进行全双工通信的协议，即连接双方可以同时实时收发数据，它可以在用户的浏览器和服务器之间打开双工、双向通讯会话。</li>
<li>WebSocket API提供全局方法<code>WebSocket(url[, protocols])</code>创建实例,参数1 对方绝对url其url以<code>ws://</code>或者<code>wss://(加密)</code>开头，参数2 protocols是单协议或者包含协议的字符串数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须传入绝对URL，可以是任何网站</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.baidu.com'</span>) </span><br><span class="line">s.readyState    <span class="comment">// 0 建立连接 1 已经建立 2 正在关闭 3 连接已关闭或者没有链接成功</span></span><br><span class="line">s.send(<span class="string">'hello'</span>) <span class="comment">// 发送的数据必须是纯文本</span></span><br><span class="line">s.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">s.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">s.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当接收到消息时</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.data) <span class="comment">// 数据是纯字符</span></span><br><span class="line">&#125;</span><br><span class="line">s.close()   <span class="comment">// 关闭连接</span></span><br><span class="line">s.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * event.wasClean 是否明确的关闭 </span></span><br><span class="line"><span class="comment">    * event.code 服务器返回的数值状态码</span></span><br><span class="line"><span class="comment">    * event.reason 字符串，服务器返回的消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>10个属性<ul>
<li>binaryType 返回websocket连接所传输二进制数据的类型（blob, arraybuffer）</li>
<li>bufferedAmount 只读 返回已经被send()方法放入队列中但还没有被发送到网络中的数据的字节数。一旦队列中的所有数据被发送至网络，则该属性值将被重置为0。但是，若在发送过程中连接被关闭，则属性值不会重置为0。</li>
<li>extensions 只读 返回服务器选择的扩展名。这当前只是空字符串或连接协商的扩展列表</li>
<li>onclose 用于指定连接失败后的回调函数</li>
<li>onmessage 用于指定当从服务器接受到信息时的回调函数</li>
<li>onopen 用于指定连接成功后的回调函数</li>
<li>protocol 只读 服务器选择的下属协议</li>
<li>readyState 只读 当前的链接状态，共4个<ul>
<li>0 建立连接</li>
<li>1 已经连接</li>
<li>2 正在关闭</li>
<li>3 连接已经关闭或者没有连接成功</li>
</ul>
</li>
<li>url 只读 WebSocket 的绝对路径</li>
</ul>
</li>
<li>2个方法<ul>
<li>close(code, reason) 数字状态码 可选 默认 1005和一个可选的类可读的字符串，它解释了连接关闭的原因。</li>
<li>send(data) 向服务器发送数据（ArrayBuffer，Blob等）</li>
</ul>
</li>
</ul>
<h2 id="十六、短轮询、长轮询与WebSocket"><a href="#十六、短轮询、长轮询与WebSocket" class="headerlink" title="十六、短轮询、长轮询与WebSocket"></a>十六、短轮询、长轮询与WebSocket</h2><h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><ul>
<li>http 短轮询是server收到请求不管是否有数据到达都直接响应http请求，服务端响应完成，就会关闭这个TCP连接；如果浏览器收到的数据为空，则隔一段时间，浏览器又会发送相同的http请求到server以获取数据响应</li>
<li>缺点：消息交互的实时性较低（server端到浏览器端的数据反馈效率低）</li>
</ul>
<p>简单演示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 每秒发送一次短轮询</span></span><br><span class="line"><span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>, <span class="string">'http://127.0.0.1:3000/test?key=value'</span>)</span><br><span class="line">  xhr.addEventListener(<span class="string">'load'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="comment">// 如果不需要可以关闭</span></span><br><span class="line">      clearInterval(id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  xhr.send()</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><ul>
<li>http 长轮询是server收到请求后如果有数据，立刻响应请求；如果没有数据就会停留一段时间，这段时间内，如果server请求的数据到达（如查询数据库或数据的逻辑处理完成），就会立刻响应；如果这段时间过后，还没有数据到达，则以空数据的形式响应http请求；若浏览器收到的数据为空，会再次发送同样的http请求到server</li>
<li>缺点：server 没有数据到达时，http连接会停留一段时间，这会造成服务器资源浪费</li>
</ul>
<p>简单演示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>, <span class="string">'http://127.0.0.1:3000/test?key=value'</span>);</span><br><span class="line">  xhr.addEventListener(<span class="string">'load'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="comment">// 如果不需要可以关闭</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.response != <span class="string">''</span>) <span class="keyword">return</span></span><br><span class="line">      ajax()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>当server的数据不可达时，基于http长轮询和短轮询的http请求，都会停留一段时间</li>
<li>都是用于实时从服务器获取数据更新</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>http长轮询是在服务器端的停留，而http短轮询是在浏览器端的停留</li>
<li>短轮询隔一段时间向服务器发起请求，不管服务器数据有没有变化都直接返回结果，长轮询则在服务器数据有发生变化的时候才返回结果，如果在一定时间没有变化那么将会超时自动关闭连接</li>
</ul>
<p><img src="../images/1719d557898dae06.png" alt="img"></p>
<h3 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h3><ul>
<li>为了解决http无状态，被动性，以及轮询问题，html5新推出了websocket协议，浏览器和服务器只需完成一次握手，两者即可建立持久性连接，并进行双向通信</li>
<li>基于http进行握手，发生加密数据，保持连接不断开</li>
<li>优点：<ul>
<li>较少的控制开销，在进行客户端与服务器的数据交换时，用于协议控制的数据包头较小</li>
<li>更强的实时性，全双工通信，不必局限于一方发起的请求，服务器与客户端可以随时发送数据，延迟更少</li>
<li>有状态的连接，websocket在通信之前需要双方建立连接，才能进行通信，而http协议在每次请求都要携带状态信息</li>
<li>基于二进制数据传输，websocket定义了二进制帧，可以处理二进制内容，相比于文本传输，提高了效率</li>
<li>支持自定义子协议，可以自行扩展协议，如部分浏览器支持压缩等</li>
<li>更好的压缩效果，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>
</ul>
</li>
</ul>
<h2 id="十七、长连接与短连接"><a href="#十七、长连接与短连接" class="headerlink" title="十七、长连接与短连接"></a>十七、长连接与短连接</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><ul>
<li>HTTP/1.0中默认使用短连接，也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接</li>
<li>当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话</li>
<li>短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</li>
<li>像WEB网站的http服务一般都用短连接，并发量大，但每个用户无需频繁操作情况下需用短连接</li>
</ul>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><ul>
<li>从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码<code>Connection:keep-alive</code></li>
<li>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接</li>
<li>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接</li>
<li>长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接</li>
<li>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况</li>
</ul>
<h3 id="长短轮询和长短连接区别"><a href="#长短轮询和长短连接区别" class="headerlink" title="长短轮询和长短连接区别"></a>长短轮询和长短连接区别</h3><ul>
<li>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接</li>
<li>长短连接通过双方请求响应头是否设置<code>Connection:keep-alive</code>来决定使用，而是否轮询，是根据服务端的处理方式来决定的，与客户端没有关系</li>
<li>实现方式不同，长短连接通过协议来实现，而长短轮询通过服务器编程手动实现</li>
</ul>
<h2 id="十八、存储"><a href="#十八、存储" class="headerlink" title="十八、存储"></a>十八、存储</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul>
<li>cookie是由服务器发送给客户端用于存储少量信息，以键值对形式存储{key：value}</li>
</ul>
<p><img src="../images/1719d55c683250a9.png" alt="img"></p>
<ul>
<li>客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态</li>
<li>cookie是不可跨域，但是只在域名不同的情况下不支持跨域，忽略协议与端口，<code>https://localhost:80/</code>和<code>http://localhost:8080/</code>的Cookie是共享的，可以通过domain设置域，path设置域下的共享路径</li>
<li>cookie属性<ul>
<li>name 表示设置的cookie名也就是key，不能重复，不可更改</li>
<li>value 表示设置cookie的值</li>
<li>domain 表示cookie绑定的域名，默认绑定当前域，多级域名不可交换cookie，如果设置以点开头的域名，则所有子域名可以访问，如设置<code>.baidu.com</code>，则<code>a.baidu.com</code>可访问其上级域名的cookie</li>
<li>path 表示cookie所能使用的路径，默认’/‘路径，只要满足当前匹配路径以及子路径都可以共享cookie</li>
<li>maxAge 表示cookie失效时间，单位秒，正数为失效时间，负数表示当前cookie在浏览器关闭时失效，0表示删除cookie</li>
<li>secure 表示cookie是否使用安全协议传输如HTTPS、SSL，默认不使用，只在HTTPS等安全协议下有效，这个属性并不能对客户端的cookie进行加密，不能保证绝对的安全性</li>
<li>version 当前cookie使用的版本号，0 表示遵循Netscape的Cookie规范(多数)，1表示遵循W3C的RFC2109规范(较严格)，默认为0</li>
<li>same-site 规定浏览器不能在跨域请求中携带 Cookie，减少CSRF攻击</li>
<li>HttpOnly 如果这个属性设置为true，就不能通过js脚本来获取cookie的值，用来限制非HTTP协议程序接口对客户端Cookie进行访问，可以有效防止XSS攻击(跨站脚本攻击，代码注入攻击)</li>
</ul>
</li>
<li>前端通过document.cookie对cookie进行读写操作</li>
<li>创建cookie就是后端的事情了</li>
</ul>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul>
<li>session 表示服务器与客户端的一次会话过程，session对象存储特定用户的属性及配置信息</li>
<li>当用户在应用程序的 Web 页之间跳转时，存储在session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 session 超时失效时会话结束</li>
</ul>
<p><img src="../images/1719d5619add7922.png" alt="img"></p>
<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 session ，请求返回时将此 session 的唯一标识信息 sessionID 返回给浏览器，浏览器接收到服务器返回的 sessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 sessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 sessionID，再根据 sessionID 查找对应的 session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 session 证明用户已经登录可执行后面操作</li>
<li>session 的运行依赖 session id，而 session id 是存在 Cookie中的</li>
</ul>
<h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><ul>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。用户验证这种场合一般会用 session</li>
<li>session保存在服务器，客户端不知道其中的信息；反之，cookie保存在客户端，服务器能够知道其中的信息</li>
<li>session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</li>
<li>session中保存的是对象，cookie中保存的是字符串</li>
<li>session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的</li>
<li>session: 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</li>
<li>cookie: 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现session的一种方式</li>
</ul>
<h3 id="本地存储localStorage与sessionStorage"><a href="#本地存储localStorage与sessionStorage" class="headerlink" title="本地存储localStorage与sessionStorage"></a>本地存储localStorage与sessionStorage</h3><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><ul>
<li>localStorage浏览器api，用于存储本地数据，可持久化，永不过期，除非主动删除</li>
</ul>
<p>基本使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">"b"</span>, <span class="string">"isaac"</span>);  <span class="comment">//设置b为"isaac"</span></span><br><span class="line">localStorage.getItem(<span class="string">"b"</span>);           <span class="comment">//获取b的值,为"isaac"</span></span><br><span class="line">localStorage.key(<span class="number">0</span>);                 <span class="comment">//获取第0个数据项的键名，此处即为“b”</span></span><br><span class="line">localStorage.removeItem(<span class="string">"b"</span>);        <span class="comment">//清除c的值</span></span><br><span class="line">localStorage.clear();                <span class="comment">//清除当前域名下的所有localStorage数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据，一般用于跨页面共享数据</li>
<li>可通过<code>window.addEventListener(&quot;storage&quot;, function(e){}</code>设置localStorage事件监听，当存储区域的内容发生改变时，将会调用回调</li>
</ul>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><ul>
<li>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(name, num);    <span class="comment">//存储数据</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'value2'</span>, <span class="number">119</span>);</span><br><span class="line">sessionStorage.valueOf();             <span class="comment">//获取全部数据</span></span><br><span class="line">sessionStorage.getItem(name);         <span class="comment">//获取指定键名数据</span></span><br><span class="line">sessionStorage.sessionData;           <span class="comment">//sessionStorage是js对象，也可以使用key的方式来获取值</span></span><br><span class="line">sessionStorage.removeItem(name);      <span class="comment">//删除指定键名数据</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用方式与localStorage类似</li>
<li>仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</li>
<li>主要用于存储当前页面独有的数据，不与浏览器其他页面共享</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>数据存储方面<ul>
<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</li>
<li>sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。</li>
</ul>
</li>
<li>存储数据大小<ul>
<li>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。</li>
<li>sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
</ul>
</li>
<li>数据存储有效期<ul>
<li>sessionStorage：仅在当前浏览器窗口关闭之前有效； localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；</li>
<li>cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</li>
</ul>
</li>
<li>作用域不同<ul>
<li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li>
<li>localStorage在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</li>
<li>cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在</li>
</ul>
</li>
</ul>
<p><img src="../images/1719d566c4dee532.png" alt="img"></p>
<h2 id="十九、跨域"><a href="#十九、跨域" class="headerlink" title="十九、跨域"></a>十九、跨域</h2><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><ul>
<li>jsonp是一种跨域通信手段，通过script标签的src属性实现跨域，由于浏览器同源策略，并不会截断script的跨域响应</li>
<li>通过将前端方法名作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信</li>
<li>由于使用script标签的src属性，因此只支持get方法</li>
</ul>
<p>来实现一下吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端准备</span></span><br><span class="line"><span class="comment">// 定义回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// arg为服务端传来的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`客户端获取的数据：<span class="subst">$&#123;arg&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建script标签</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"><span class="comment">// 给script标签的src属性赋值，值为请求url，查询参数callback，需与后端对应</span></span><br><span class="line"><span class="comment">// fn为前端回调函数名</span></span><br><span class="line">s.src = <span class="string">`http://127.0.0.1:3000/test?callback=fn`</span></span><br><span class="line"><span class="comment">// 向html添加此标签，添加完成之后浏览器自动请求script的src对应的网址</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(s);</span><br><span class="line"><span class="comment">// 等待浏览器收到响应之后，将会自动执行响应内容的代码</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 后端准备</span></span><br><span class="line"><span class="comment">// nestjs(ts)处理</span></span><br><span class="line">@Controller(<span class="string">'test'</span>) <span class="comment">//api</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">  @Get() <span class="comment">//get方式请求</span></span><br><span class="line">  <span class="comment">//取url中的查询参数，即?之后的键值对，键与值对应query对象参数的键与值</span></span><br><span class="line">  callback(@Query() query) &#123;  </span><br><span class="line">    <span class="comment">// 返回的数据</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="string">'我是服务端返回的数据'</span>;</span><br><span class="line">    <span class="comment">// 取查询参数，这里的callback要与前端?之后的键名一致，fn即fn函数名</span></span><br><span class="line">    <span class="keyword">const</span> fn = query.callback;</span><br><span class="line">    <span class="comment">// 返回结果，格式：函数名(服务器的数据)，注意这里需要序列化成字符串，如果参数本身是字符串那么要加引号，前端并不知道data是字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;fn&#125;</span>('<span class="subst">$&#123;data&#125;</span>')`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// express(js)处理，同上</span></span><br><span class="line">router.get(<span class="string">'/test'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="string">'我是服务器返回的数据'</span></span><br><span class="line">  <span class="comment">// req.query为查询参数列表</span></span><br><span class="line">  <span class="keyword">const</span> fn = req.query.callback</span><br><span class="line">  <span class="comment">// 返回数据</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;fn&#125;</span>('<span class="subst">$&#123;data&#125;</span>')`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>响应内容</p>
<p><img src="../images/1719d571d31cb770.png" alt="img"></p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ul>
<li>跨域资源共享cors，它使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源</li>
<li>需要服务端与客户端同时支持cors跨域方式才能进行跨域请求，服务端通过设置<code>Access-Control-Allow-Origin:*</code>即可开启cors允许跨域请求，使用通配符*表示允许所有不同域的源访问资源，也可单独设置指定允许的源域名</li>
<li>使用cors跨域时，将会在发起请求时出现2种情况：</li>
<li>简单请求，需满足以下条件<ul>
<li>使用get、head、post方式发起的请求</li>
<li>Content-Type 的值仅限于下列三者之一：<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
</li>
<li>不满足这些条件即为预检请求</li>
</ul>
</li>
<li>预检请求<ul>
<li>需预检的请求要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求</li>
<li>预检请求的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响</li>
<li>当满足以下条件之一，将会发送预检请求<ul>
<li>使用了下面任一 HTTP 方法：</li>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ul>
</li>
<li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type (需要注意额外的限制)</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li>Content-Type 的值不属于下列之一:<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
<li>满足以上条件之一将会发起预检请求，总共会发起2次请求，第一次为OPTIONS方式的请求，用来确定服务器是否支持跨域，如果支持，再发起第二次实际请求，否则不发送第二次请求</li>
</ul>
</li>
</ul>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><ul>
<li>postMessage可用于不同页面之间的跨域传递数据</li>
<li><code>postMessage(data,origin[, source])</code>data为发送的数据只能发送字符串信息，origin发送目标源，指定哪些窗口能接收到消息事件，如果origin设置为*则表示无限制，source为发送消息窗口的window对象引用.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.html --&gt;</span><br><span class="line">&lt;iframe src=<span class="string">"http://127.0.0.1:5501/postMessage.html"</span></span><br><span class="line">name=<span class="string">"postIframe"</span> onload=<span class="string">"messageLoad()"</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 定义加载之后执行的函数，给postMessage.html发送数据</span></span><br><span class="line"><span class="regexp">function messageLoad() &#123;</span></span><br><span class="line"><span class="regexp">  const url = 'http:/</span><span class="regexp">/127.0.0.1:5501/</span>postMessage.html<span class="string">'</span></span><br><span class="line"><span class="string">  window.postIframe.postMessage('</span>给postMessage的数据<span class="string">', url)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 用于监听postMessage.html的回馈，执行回调</span></span><br><span class="line"><span class="string">window.addEventListener('</span>message<span class="string">', (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">  console.log(event.data);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">----------------------------------------------</span></span><br><span class="line"><span class="string">&lt;!-- postMessage.html --&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  // 监听test.html发来的数据，延迟1秒返回数据</span></span><br><span class="line"><span class="string">  window.addEventListener('</span>message<span class="string">', (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="string">      event.source.postMessage('</span>给test的数据<span class="string">', event.origin)</span></span><br><span class="line"><span class="string">    &#125;,1000)</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>event对象的几个重要属性<ul>
<li>data 指的是从其他窗口发送过来的消息对象</li>
<li>type 指的是发送消息的类型</li>
<li>source 指的是发送消息的窗口对象</li>
<li>origin 指的是发送消息的窗口的源</li>
</ul>
</li>
</ul>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><ul>
<li>由于<code>window.name</code>属于全局属性，在html中的iframe加载新页面(可以是跨域)，通过iframe设置的src指向的源中更改name的值，同时主页面中的name也随之更改，但是需要给iframe中的window设置为<code>about:blank</code>或者同源页面即可</li>
<li>iframe使用之后应该删除，name的值只能为string类型，且数据量最大支持2MB</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.html --&gt;</span><br><span class="line"><span class="comment">// 封装应该用于获取数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">url, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isFirst = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">  loadFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">      <span class="comment">// 设置为同源</span></span><br><span class="line">      ifr.contentWindow.location = <span class="string">'about:blank'</span></span><br><span class="line">      isFirst = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      func(ifr.contentWindow.name)</span><br><span class="line">      ifr.contentWindow.close()</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(ifr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ifr.src = url</span><br><span class="line">  ifr.style.display = <span class="string">'none'</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(ifr)</span><br><span class="line">  <span class="comment">// 加载之后的回调</span></span><br><span class="line">  ifr.onload = loadFunc</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">`http://127.0.0.1:5501/name.html`</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">//</span></span><br><span class="line">&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line">&lt;!-- name.html --&gt;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">"iframe"</span> &#125;</span><br><span class="line"><span class="comment">// 修改name的值，必须为string类型</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="built_in">JSON</span>.stringify(obj);</span><br></pre></td></tr></table></figure>

<h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><ul>
<li><code>document.domain</code>的值对应当前页面的域名</li>
<li>通过对domain设置当前域名来实现跨域，不过仅限于域名不同，但是又要属于同一个基础域名下，如<code>http://a.baidu.com</code>与<code>http://b.baidu.com</code>这2个子域名之间才能使用domain跨域，一般用于子域名之间的跨域访问</li>
<li>domain只能赋值为当前域名或者其基础域名，即上级域名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.html --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'baidu.com'</span>;</span><br><span class="line"><span class="keyword">const</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">ifr.src = <span class="string">'a.baidu.com/test.html'</span>;</span><br><span class="line">ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line">ifr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> doc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">  <span class="comment">// 此处即可操作domain.html的document</span></span><br><span class="line">  ifr.onload = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">----------------------------------------------</span></span><br><span class="line"><span class="regexp">&lt;!-- domain.html --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ domain.html下设置为与test.html中的domain一致</span></span><br><span class="line"><span class="regexp">  document.domain = 'baidu.com';</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要就是通过设置为同源域名(只能为其基础域名)，通过iframe操作另一个页面的内容</li>
</ul>
<h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><ul>
<li>nginx反向代理，代理从客户端来的请求，转发到其代理源</li>
<li>通过配置nginx的配置文件实现代理到不同源</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// nginx.conf配置</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  listen 80;  // 监听端口</span><br><span class="line">  server_name  www.baidu.com; // 匹配来源</span><br><span class="line">  location / &#123;  //匹配路径</span><br><span class="line">    // 反向代理到http://127.0.0.1:3000</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class="line">    // 默认入口文件</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm index.jsp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>nginx反向代理还能实现负载均衡</li>
</ul>
<h2 id="二十、setTimeout与setInterval"><a href="#二十、setTimeout与setInterval" class="headerlink" title="二十、setTimeout与setInterval"></a>二十、setTimeout与setInterval</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><ul>
<li>setTimeout属于webApi的一部分，可以实现延时调用，属于异步宏任务，一次性使用</li>
<li><code>setTimeout(func|code, [delay], [arg1], [arg2], ...)</code> 参数1为想要执行的函数或代码字符串，参数2为延迟执行时间，单位毫秒默认0，参数3及之后的参数为参数1为函数时传入的参数，调用之后会返回一个定时器id</li>
<li>此方法只执行一次，可以使用<code>clearTimeout(id)</code>清除定时器来取消回调</li>
<li>看一下setTimeout的延迟执行机制</li>
</ul>
<p><img src="../images/1719d57a515531c0.png" alt="img"></p>
<ul>
<li>以上使用嵌套setTimeout来实现循环调用，可以从中看出setTimeout计时是从上一个setTimeout回调执行之后开始的，看看代码效果</li>
</ul>
<p><img src="../images/1719d57d50d46306.png" alt="img"></p>
<ul>
<li>上图计算的是2次调用回调之间的间隔，不包括回调执行时间，可以看出在开启定时器之后到执行回调的时间确实是参数2所设置的值，延迟时间与回调函数执行时间无关；</li>
<li>简单来讲setTimeout的延迟时间不包括自身回调所占用的时间</li>
</ul>
<p>也就是说setTimeout是在上一次回调执行之后才开启的定时</p>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><ul>
<li>setInterval同样也是webApi的一部分，主要用来定时循环执行代码</li>
<li>不同于setTimeout，此定时器的延迟执行机制有所不同</li>
<li><code>setInterval(func|code, [delay], [arg1], [arg2], ...)</code>，参数列表同setTimeout，参数2为每次循环时间</li>
</ul>
<p><img src="../images/1719d5823cbd8652.png" alt="img"></p>
<p>从上图可以先得出结论，setInterval的延迟执行时间包含自身回调执行所占用的时间，看看代码效果</p>
<p><img src="../images/1719d586296026d8.png" alt="img"></p>
<ul>
<li>上图计算的是2次调用回调之间的间隔，不包括回调执行时间，可以看出setInterval在2次执行之间的延迟受到了回调的影响，再验证一下</li>
</ul>
<p><img src="../images/1719d58a248e5cd3.png" alt="img"></p>
<ul>
<li>此次我把回调执行时间也算在计时之内，现在看来setInterval的定时时间确实包含了自身回调所占用的时间</li>
</ul>
<p>由于这2个api都属于异步宏任务，在执行的时候都会进入任务队列，如果队列前的任务执行时间较长，那么也会影响到定时器的执行时机</p>
<p>在浏览器中alert、confirm、prompt都会阻塞js主线程执行，直到弹窗消失，但是定时器还会继续执行；定时器并不能达到0延迟，最小延迟限制在4ms</p>
<h2 id="二十一、requestAnimationFrame"><a href="#二十一、requestAnimationFrame" class="headerlink" title="二十一、requestAnimationFrame"></a>二十一、requestAnimationFrame</h2><ul>
<li>在requestAnimationFrame还未出来之前，大多数使用定时器完成js动画，但是由于定时器不准确，而且每次更新动画的时候不能保证与浏览器渲染同步，这样将会导致画面的不流畅</li>
<li>由于目前主流屏幕的固定刷新频率一般为60HZ即一秒60帧，每次刷新间隔为1000/60ms，为了使浏览器得到最好的渲染效果，浏览器每次渲染应该与屏幕刷新率保持一致，那么对于js动画而言，最好的更新时机应该与浏览器尽量保持一致</li>
<li>当每次浏览器将要重绘之前，把要执行更新的动画更新完成，那么当浏览器渲染的时候将会保持最新的动画，这就是requestAnimationFrame所做的事情</li>
<li><code>requestAnimationFrame(callback)</code> 的参数就是每次渲染前需要执行的动画更新函数，当浏览器将要重绘画面时就会执行这个回调函数，这个回调函数接受一个参数，即从当前页面加载之后到现在所经过的毫秒数</li>
<li>此api将会与浏览器渲染同步，即浏览器渲染几次这个api将会执行几次，那么就达到了不掉帧的效果，画面效果就更加流程</li>
<li>requestAnimationFrame执行时机在事件循环机制中处于微任务队列之后，浏览器渲染之前，浏览器渲染之后就会进入下一次的事件循环(宏任务开始，浏览器渲染结束)</li>
<li>如果使用定时器进行js动画操作，那么首先将会导致动画更新与浏览器每次重绘时机不匹配，造成卡顿，其次过于频繁的更新动画还会导致不必要的性能开销，且并非能够达到更好的效果</li>
<li>简单说使用requestAnimationFrame更新的动画与浏览器保持同步，不会掉帧，除非浏览器掉帧或者，js主线程阻塞导致浏览器无法正常渲染，使用定时器更新动画，如果频率高了会影响性能，且达不到更好的效果，如果频率低了将会有不连贯的感觉</li>
</ul>
<p><img src="../images/1719d58f7ddf9656.png" alt="img"></p>
<ul>
<li>从上图可以看出确实是每帧执行一次，不过要注意，调用一次requestAnimationFrame只会执行一次，如果需要持续执行需要在回调函数内继续调用</li>
</ul>
<h2 id="二十二、事件"><a href="#二十二、事件" class="headerlink" title="二十二、事件"></a>二十二、事件</h2><h3 id="DOM0事件"><a href="#DOM0事件" class="headerlink" title="DOM0事件"></a>DOM0事件</h3><ul>
<li>DOM0事件并非w3c标准，在DOM标准形成之前的事件模型就是我们所说的0级DOM</li>
<li>添加DOM0事件，都是把一个函数赋值给文档元素，在事件监听函数被调用时，将会做为产生事件的元素方法调用，所以this指向目标元素，简单说就是直接把回调函数作为文档元素的一个方法调用</li>
<li>删除DOM0事件只需把事件赋值为null即可</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line">&lt;input type=<span class="string">"button"</span> onclick=<span class="string">"alert('hi!');"</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果回调方法返回一个false则会阻止浏览器事件的默认行为</li>
<li>DOM0事件在事件捕获阶段，无法接收事件，即没无法触发事件捕获，但是能够正常触发冒泡</li>
<li>由于DOM0事件的回调属于文档元素的方法，导致无法添加多个同名事件，不过看来兼容性最好</li>
</ul>
<h3 id="DOM2事件"><a href="#DOM2事件" class="headerlink" title="DOM2事件"></a>DOM2事件</h3><ul>
<li>由于w3c推出的1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型</li>
<li>在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型</li>
<li>2级DOM定义了事件传播，在事件传播过程中将会经历3个阶段：<ol>
<li>capturing阶段，即事件捕获阶段，在某个DOM上触发事件时，事件会先从Document对象 沿着dom数向下传递直到触发节点，此过程就是事件捕获阶段，在此过程中可以捕获传播的事件</li>
<li>目标元素的事件处理阶段，此阶段事件到达触发目标，调用回调处理事件</li>
<li>bubbling阶段，即事件冒泡阶段，在目标元素处理完成之后，此事件还会向上冒泡，回传到Document，此阶段与捕获阶段相反</li>
</ol>
</li>
<li>以上就是事件在触发之后的传播过程，可以配合下图理解</li>
</ul>
<p><img src="../images/1719d595e0ad539a.png" alt="img"></p>
<ul>
<li>DOM2 注册事件，可以通过<code>addEventListener(eventName,callback,isCapturing)</code>方法为元素设置事件监听器，参数1为注册事件名不带on开头的string类型，参数2为触发事件的回调函数，接受一个事件对象参数，参数3为是否在捕获阶段触发，默认为false</li>
<li>通过<code>removeEventListener(eventName,callback,isCapturing)</code>方法移除指定事件名、回调、是否捕获的事件，匿名回调无法删除</li>
<li>可给一个元素添加多个相同的事件，通过不同的回调实现不同效果</li>
<li>DOM2中的回调函数中的this指向，由浏览器决定，w3c标准中并未规定其指向，一般情况this指向window</li>
<li>回调函数event对象参数</li>
<li>属性<ul>
<li>type 发生事件的类型</li>
<li>target 发生事件的阶段，为触发事件的对象，可以与currentTarget不同</li>
<li>currentTarget 正在处理事件的节点，即注册此回调函数的元素</li>
<li>clientX，clientY鼠标相对浏览器的x坐标与y坐标</li>
<li>screenX，screenY鼠标相对于显示器左上角x，y坐标</li>
</ul>
</li>
<li>方法<ul>
<li>stopPropagation() 阻止当前事件的进一步传播</li>
<li>preventDefault() 阻止浏览器执行与世界相关的默认动作，与DOM0返回false相同</li>
</ul>
</li>
<li>触发时机<ul>
<li>document 往 target节点传播，捕获前进，遇到注册的捕获事件立即触发执行</li>
<li>到达target节点，触发事件（对于target节点上，是先捕获还是先冒泡则捕获事件和冒泡事件的注册顺序，先注册先执行）</li>
<li>target节点 往 document 方向传播，冒泡前进，遇到注册的冒泡事件立即触发</li>
</ul>
</li>
</ul>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><ul>
<li>事件代理又或是事件委托，通过事件冒泡机制，使用单一父节点来操作多个子节点的响应，简单讲就是把所有子节点的事件去除，只给父节点注册事件，那么就可以通过事件冒泡机制来处理子节点的响应</li>
<li>基于事件委托可以减少事件注册，节省内存，简化dom节点于事件的更新</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"f"</span>&gt;</span><br><span class="line">  &lt;li&gt;a&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;b&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;c&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#f'</span>)</span><br><span class="line">  <span class="comment">// 点击li时触发事件委托</span></span><br><span class="line">  ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 处理元素为父元素</span></span><br><span class="line">    <span class="built_in">console</span>.dir(event.currentTarget)  <span class="comment">// ul#f</span></span><br><span class="line">    <span class="comment">// 触发元素为子元素，event.target为具体触发对象</span></span><br><span class="line">    <span class="built_in">console</span>.dir(event.target)         <span class="comment">// li</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line">  <span class="comment">// 通过点击添加子元素</span></span><br><span class="line">  ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> child = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">    child.innerText = <span class="string">'我是新增的子元素'</span></span><br><span class="line">    event.currentTarget.appendChild(child)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line">  <span class="comment">// 通过点击删除子元素</span></span><br><span class="line">  ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.currentTarget.removeChild(event.target)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">----------------------------------------------</span></span><br><span class="line"><span class="regexp">&lt;!-- 如果点击span 想知道是哪个li下面的元素 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul id="f"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;a&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;b&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;c&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  const ul = document.querySelector('#f')</span></span><br><span class="line"><span class="regexp">  ul.addEventListener('click', function foo(event) &#123;</span></span><br><span class="line"><span class="regexp">    let target = event.target</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 一级级向上寻找直到找到满足条件的元素</span></span><br><span class="line"><span class="regexp">    while (target.nodeName.toLowerCase() !== 'li') &#123;</span></span><br><span class="line"><span class="regexp">      target.target.parentNode</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    console.dir(target) /</span><span class="regexp">/ li</span></span><br><span class="line"><span class="regexp">    console.dir(target.parentNode === event.currentTarget) /</span><span class="regexp">/true</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>以上就是几个简单的事件代理的例子，事件代理能够在我们平时开发中减少很多不必要的代码，优化事件系统，但是在使用的过程也要注意相应的问题</p>
<p>事件代理基于冒泡机制，如果代理层级过多，且在冒泡阶段如果被某层阻止冒泡那么父级将不会收到事件</p>
<p>理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理，所以建议就近委托</p>
<p>如果事件代理了许多情况那么要做好完善逻辑分析，避免一些误判的情况</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AF%AF%E5%8C%BA%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AF%AF%E5%8C%BA%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">英语学习的正确方法与误区分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-24 01:52:48 / Modified: 01:53:06" itemprop="dateCreated datePublished" datetime="2020-04-24T01:52:48-04:00">2020-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>著名语言学家Greg Thomson说的：“外语学习的原理是如此之复杂，以至于没有人能说清楚；但掌握语言的过程又是如此之简单，以至于不需要说清楚。”讨论语言学习的原 理，是件非常复杂的事，在下当然也没把握能描述得很清楚。而且因为外语学习就连学术界都存在很多尖锐的争论，本人也不敢说自己有把握能把争论化解。但还是 决定先从简单入手，做些抛砖引玉的工作吧，探讨一下外语学习的真谛，特别是对大家在外语学习上普遍存在的误解进行分析和澄清，希望能对外语学习者有所帮 助，对外语教学工作着有所启发，就知足了。<br>　　<br>　　 本人多年来一直在给各高校，企业和其他英语学习者做英语学习方法讲座。讲时从不煽情，从不靠表演噱头，也不搞励志，每次必将严肃的科学依据送给大家。近五 年来听众过万，还比较受欢迎，其中有相当部分的人能够非常理解和赞同并提出了很多尖锐问题和改进意见，在此表示深深感谢。曾有很多人奉劝在下以此演讲能 力，把风格改为煽情鼓动式，定能红遍全国和累积财富。本人对名无兴趣，否则早就这么做了。也不愿胡说八道而误人子弟。至于财富吗，不是不喜欢，而是已经有 够多的了。所以本人很幸运，现在可以摆脱金钱的烦恼，静下心来读书和思考了。现在把以前演讲的部分内容整理一下发在这里，希望和大家探讨。
　　</p>
<p>　　告诉你外语学习的真实方法及误区分析(精编版)<br>　对外语学习的主要误区<br>　　<br>　　我们普遍对学外语学习方法的认识是：<br>　　<br>　　1．要有语言环境, 多跟外国人交流，最好是能出国，不久自然就能会说了。<br>　　2．学习外语要多记多背，也就是说是用记忆学语言。<br>　　3．想纠正发音，一定要专听和模仿纯正的发音，比如BBC或VOA那种。<br>　　4．要学习外语语法，如果语法熟练，说句子就正确了。<br>　　5．要有词一定词汇量，要大量背单词。但背英语单词很难。<br>　　6．以前学的是书面语或过时的英语，和现在口语是不一样的，所以我口语不好。<br>　　7．学外语必须非常刻苦，长时间反复练习。<br>　　<br>　　“全错！而且不但错，事实正好相反！”<br>　　<br>　 　 您没看错，我说的正是：“以上这些结论不但是错误的，而且基本上与事实是正好相反的。” 大家对外语学习的误解之深，范围之广，达到了另人惊叹的程度。尽管科技发展到了今天，人们对语言获得过程的误解仍相当普遍，尤其是咱们中国人。中国人对语 言学习的误解深来源于中国有着深厚的文化传统以及单一民族和单一语言。我帮大家逐一进行分析和提供分析依据，大家可以自己得出正确结论。<br>“怎么会错呢？难道学外语不是在语言环境下最好吗？难道想纠正口音不是要听标准的发音吗？这不是理所当然的事吗？”<br>　　<br>　　 咳，天下有多少事都是看似理所当然，而事实正好相反呢。我们先找一个最简单的分析。就先说第3条，“纠正发音”吧。<br>　　<br>　 　 大家一定都认为，要想学好发音，或纠正自己不标准的发音，当然要去听纯正的，标准的发音啦，最好是地道的英国音或美国音了，这还能错？不幸的是，刚好错 了，而且正好相反。语音专家发现，成年人要想纠正自己的发音，不能只听标准发音，而是要听大量的 “非标准发音”，也就是说，带口音的发音。比如德国口音的英语，法国口音，意大利口音，印度口音，中国口音等，而且种类越多越好。这是怎么回事？这个结论 的来源，要从当年哈佛大学的语音专家们，在做口音研究时，用日本人做试验讲起。<br>各位知道为什么做语音实验会用日本人吗？大家普遍会答是因为日本人 发音说英语很难听。接着问，那为什么日本人发音难听？每次问到这里，听众中总有些笑声，很多人答曰日本人舌头硬。其实日本人跟大家一样，舌头并不特殊，发 音不准的原因是因为他们的日语造成的。大家都知道英语有大约44个发音（元音加辅音），而日语只有大约30个。不是听说日语有50音图吗？很遗憾，日语的 五十音图很多是重复的。比如第一行元音：“啊依呜唉喔”，确实是不同，但第二行“喀七库开阔”（近似的汉语表示啊，大家别太较真），却是只多了一个辅音 K，其他是借第一行元音拼出来的（Ka, Ki, Ku, Kai, Ko），所以并没有50个音。于是日本人在说英文时，很多音是发不出来的。比如“日 r”的音，日语中不存在（没有ra,yi ru,rai ro），所以不会说。很常用的read and write，日本人只能说成 lead and light，用“l”代替“r”，是个很典型的例子。于是当时哈佛大学就找了在美国的成年后才到美的日本人做实验。首先问这些被实验者，read 和lead两个音，大家听得明白吗？大家一致答听的出区别。再问那为什么会说错，这些日本人有的说“我们的口腔结构不同。”有的说“我们发音部位很你们不 同，我们的靠前，你们靠后。”也有人说“我们舌头硬，老美舌头软。”接下做了实验，让这些日本人听许多“r”或“l”打头的词（不给看拼写），二选一的答 案，做完了测试，发现大家的正确率是50%。各位已经发现问题了，二选一能答对一半，实际就是根本不会，纯粹瞎懵，命中率当然是一半。当看到这一结果时， 测者和被测者全傻了。因为要是全对了，那分析和调整一下舌头位置或口型就可以解决；如果全错也不要紧，掉个个儿就成了。但对一半就美救了。大家想，根本听 不出两个音的差别，怎么可能区分清楚发音和正确发音。但结论已经出来了：发音不准的主要原因不是嘴的问题，而是耳朵的问题。<br>其实发音不准主要是因 为耳朵听不准这件事，大家是有实际观察经验的。比如有人唱歌走调，是什么原因呀？是不是嗓子不好？不是，主要是耳朵听不准，所以唱歌走调的人唱完了觉得自 己唱得挺对的，你们怎么都说我走调呢？原因是他们的耳朵听不准音，自己听不出走调了。（如果您唱歌不走调，自己堵上耳朵唱一个试试，别人保证说您走调 了）。那么这些被做实验的日本人都在美国生活了一段了，天天听标准音，为什么改不了口音？原因是：成年人的耳朵听音不准，分辨能力低，听不准一个不在自己 母语语音范围内的新标准发音，也听不出自己和标准音的区别（可能自己觉得有些区别，但具体也说不明白），以为自己已经发到标准了，其实还有差距。日本人母 语缺音太多，所以最吃亏。（大家在网上可以找到日本人用来测试“r- l”分辨率还剩多少的测试网站，大家可以试试，很好玩儿。中国北方大部分地区的同学或普通话标准的同学会得分很高的）。<br>　　<br>　　 科学实验告诉我们，只有小孩子的耳朵对各种语言有高分辨率，才可以听准任何语言的发音而模仿到位，成年人不行了。具体说，大多数人到十二岁以上就不行了， 这个能力失去了。这就导致了成年人为了纠正外语发音时或提高发音准确度，单纯听和模仿标准外语发音不行，因为做不到，所以如何纠正成年人的发音的最重要环 节就是提高成年人的听音准确度。而实践经验证明，多听各种非标准音，有助于成年人提高听力敏感度和分辨力，从而达到定准和自然纠正自己发音的效果。（什么 是各种非标准音？比如英文 “very interesting”, 法国口音是 “vehi intehisting”，日本口音是 “veli indelisding”，中国口音是“外瑞-因踹斯停”）。当经过一段时间仔细听和分辨各种口音的适应训练后（当然不是仅听非标准音，要和该句的标准音 以及自己的模仿发音进行对同时比训练），听者的听音敏感度提高了，甚至能准确分辨带口音的人来自哪个国家，发音就自然进步了。这是成年人纠正发音的科学方 法，跟大家想当然的结论正好相反。<br>　讲到这里，大家不应该会此结论还存有疑问吧？其实中国同学最容易理解这个结论。因为中国话的口音变化很大，比 英语明显，英国音与美国音之间的区别，还赶不上普通话与天津话的区别（离北京才120公里）。所以中国同学对口音比较敏感。有意思的是，中国有个标准音叫 做“普通话”，而英语国家没有。在美国并不以任何城市的口音做标准，英国也如此，伦敦话并非标准，而且其他英国人有时觉得很怪。（大家知道伦敦人常省略 “h” 和“t”音吗？比如 “head” 被说成 “ed”， “better”说成“be-r”）所以在这些英语国家，并没有严格的绝对标准。而中国人都应该说准普通话。但同样道理，如果小时候（十二岁以前）没有说 准，成年后就会有口音，尤其南方同学最吃亏，因为缺音。那应该如何纠正发音呢？如果按理所当然的推论，大家天天听标准音就行，那大家天天看新闻联播和听广 播就能纠正发音吗？结果不行。到北京住几年口音就改好了吗？结果还不行（还是小孩子行。）那找个说标准普通话的人一起生活还帮助纠正行吗？大家就笑了。很 多人帮父母纠正了多少年的口音了，也没见有效呀。那怎么办？原理是一样的：多听各地人的口音，并进行比对训练，耳朵敏感度越来越高，口音就越来越小。这是 成年人科学的纠正发音的方法。（在有些电影学院在纠正成年外地演员时会采用类似方法。）跟大家当初想的正好相反吧，但现在大家都明白了。遗憾的是，很多英 语老师也不明白这一点，所以总建议大家听一个标准音或追一个某国人交流。现在这一误区应该纠正了。</p>
<p>造成“哑巴英语”的最主要原因<br>　　<br>　 　 什么叫做“哑巴英语”？零英语基础的人不叫哑巴英语。哑巴英语是特指学习了几年以上的英语，有一定的阅读能力，但听说能力很差或根本不会的情况。特别是已 经过了的同学。大家已经学英语十年以上，每周6小时左右，总共达3000小时的英语学习，还是不会起码的交流。（不过应该声明：其实“一定的阅读能力”也 并不高。比如随便拿起一本英文小说，大家会发现不靠其他工具连一页都看不下去。）<br>　　 那“哑巴英语”是如何造成的呢？大家想当然的答案是五花八门的。比如一般都会说是“应试教育”造成的。我会考试，所以听不懂，不会说。这显然没抓对因果关 系。有人就会说了：是单词量小或单词不会应用，所以要多背单词；还有语法不好，组织句子不熟练，而且CHINGLISH就是语法问题嘛。所以要多研究学习 英文语法知识；当然最主要罪魁还是没机会用英文交流，如果有英文环境和交流机会就好了，于是努力寻找，很多人在大街上拦住外国人聊天。这些基本都是对学外 语的误解。什么道理？<br>　　我们先来做个实验。我说一句外语大家仔细听。准备好了呵：“SIX FIVE SENVEN THREE SIX EIGHT NINE FOUR”。大家听到了什么？<br>　　答：六个数字，可能是个电话号。<br>　　是几啊？<br>　　“六五七。。。什么什么四。”这是一般同学的答案。<br>　　为什么没听懂？是单词量的问题？不是。是语法问题？不是。是发音问题？不是。那是什么？<br>　　有同学答：您说得太快了。<br>　　可我用的是正常速度呀？外国人不就这速度告诉别人电话号码吗？哪用一个一个慢慢蹦呀？正常速度为什么你听不懂？<br>　　有人答：是不熟练。<br>　　十年前就会了，还说不熟。再说就算你非说不熟，那到底是哪个字听不明白呀？<br>　　答：都好象明白，可怎么感觉反应不过来呢？老师我反应慢。<br>　　快别这么说，你是个正常人，反应挺正常的。不过我倒要问了：你在那里反应什么呢？<br>　　这时总算有人醒悟：我刚才在那里反应中文呢。我刚听英文时，坐在那里在脑子里把它们飞快地转换成中文，才转一半您就说完了。<br>　　原因找到了。大家原来都在那里默默地翻译呢。可在座的没一个翻过来的，是何故？</p>
<p>正 常说话速度是每分钟120到180个字左右，英文中文差不多，一般一句话两秒种就结束了，说话是一句连着一句的。两秒长的一句话，就算所有单词都会，发音 语法都没问题，但需要把所有英文字都翻译成中文才明白（还别提分析语法），那需要多长时间？至少四、五秒。这时大家第二句话没听见，第三句都到一半了。听 不到，谈何听得懂？障碍已经产生了。短句子（四个单词以下）还好凑合，比如HOW ARE YOU？WHERE ARE YOU FROM？什么的，再快也没问题。一超过四个单词就跟不上了。科学家做过实验：如果听到外语需要必须在大脑中翻译的话，正常速度的语言一般人只能翻译到第 三个字就跟不上了，个别人能翻出四个，几乎没有人能超过四个。可大量的句子都是超过四个单词的呀。所以我们很多同学总在那里重复简单英语而提不高。那我练 得特熟，翻得特快，行吗？答案是：永远也不行。<br>　　可大家为什么非在脑子里翻译不可呢？因为大家听到英文时实际上脑子里空空没概念，但都学过每个 英文字的中文解释，想一下中文解释就明白了。所以都在那里努力“转换”而做不到。那能不能不想中文，听到英文直接就理解？这是一种什么状态？答案很简单： 要能用英文思维就行，说白了就是会用英文想事儿了。这个概念十年前还新鲜，现在知道的人越来越多：“会用任何语言流利交流的前提是必须能用这种语言思考， 做不到的就永远不能正常交流。”这是结论，没有英文思维，永远也听不懂正常速度的英文，永远也听不了长句子。关于英语思维是英语正常交流的前提这一结论因 为已经比较清楚和为人们接受，证据也比较多，所以不用在此辩论。但为什么我们学了十几年的英语都没有英语思维呢？大家看，如果学每个单词时都是通过背它的 中文解释学会，就有问题了吧。另外还有个原因：大家可能都曾试图说几句英语。我们想一下说英文的过程是怎样的？大家都是在说之前先想一句中文：我要说这一 句了。（停！大家说中文都不可以这样做。我们在说中文时，一句话都说一半了，脑子里都不能预先清楚知道后半句的所有字，继续说才知道。所以到这儿已经不对 了。）然后把这一句的所有英文单词找到对应的英文。现在能说了吗？照说还不行，还得组织一下句子，想一下语法吧！用什么时态？过去时？完成时？现在时？进 行时？将来时？单数复数？要加S吗？男他女她？等想完这些，20秒已过，对方早走了。于是我们发现，甚至外语学院毕业的同学，在说外语时都采用同一战术： “不想语法了。好不容易找到几个单词，赶紧往外蹦。”于是出来就是中式英语。难道是他们不熟悉语法知识吗？非也。因为根本来不急。大量的实验告诉我们，语 法知识的多少和交流的流利程度甚至正确度是没有丝毫关系的。语法书倒背如，还是不能交流，还是出语法错。原因很简单，从说话的思维机制上讲，人在说话时， 大脑是禁止思考语法规则的。一旦想规则，人就不能说话了。想一下我们中文都说得这么流利，能去想语法规则吗？主语用这个，谓语用那个，状语放在这里。。。 根本不可以！那英语也一样嘛。所以语法知识不但不帮助形成英语思维，反而在捣乱。<br>所以大家已经发现，“翻译”和“语法”不但不帮助提高交流能力， 反而阻碍英文思维。但大家看到翻译、语法几个字非常熟悉，原因是我们这么多年，就是这么学英语的。大家十几年来，不管是上课还是自学，用的方法叫做“语法 -翻译法”，英文叫TRANSLATION-GRAMMAR METHOD 。这种方法是英国人几百年前用来学习希腊语和拉丁语时建立的系统的外语学习方法，通过研究目标语言的语法结构，和单词在自己语言中的翻译去学习这种语言。 比如大家当时学这句时：<br>　　THIS IS A CAT。<br>　　这 是 一（只） 猫。<br>　　主语 谓语 数量 宾语<br>　　代词 系动词 不定冠词 名词<br>　　这句话是一般现在时<br>　　陈述句<br>　　第三人称单数<br>　　系表结构<br>　　。。。。语态<br>　　（我已晕菜。小时候想我妈可不是这样教我说中文的呀，外国孩子真可怜。后来才发现外国孩子说英文也不这样学，是中国孩子学英文才这样，是我们可怜。）<br>　　 后来知道，全世界都曾普遍使用这种方法学外语，结果都类似：可掌握一定外语知识，都不会交流，时间一久大家就把以前学得知识都仍了。知道其他国家的阶级兄弟也身受其害，感觉好了点。<br>　　 所以“语法-翻译法”是明显很有问题的，很多国家早已放弃。但还有一些国家，主要是中国和英国，仍存在一些“语法-翻译法”的捍卫者。本人在以后的章节会根据其他科学依据分析它深层问题，现在就要拍板儿砖的先请。<br>　　 至于有人认为是因为自己学的英语过时了这种观点，不用辩论了。课本上的英文没过时，而且无论哪国语，几十年的变化都至于影响到听不懂的地步，个别词而已。<br>　　<br>　　英语环境的问题<br>　　<br>　　 那有外语环境不就好了吗？比如出国。答案：非常错误。这一条是中国同学误解最深，吃亏最大的一条。<br>现 在出国的留学生和移民很多。大家在出国前，英语大多不好，可都这么想：到了国外英语环境自然就会了，天天听，而且被迫说英语，有几个月就流利了。当然，听 说有人也不行，那他们一定是因为老在中国人圈子里。大家都说在唐人街上的华侨一辈子都可能不会英语，我可不在唐人街住，到时候找外国房东家住，有机会跟他 多练习。可到了国外后，发现大家真还都不在唐人街住，因为那里讲广东话，更不懂，在唐人街上跟中国人也是讲英文的。尽管人家一般先用广东话跟你打招呼，发 现没反应后双方就开始各操费力的英文开始交流，好在到那里去的唯一目的是买菜，对付的了，不过感觉很滑稽，大家明明都是华人，还非得讲洋话。在国外一段时 间，居然很多人把广东话学会了，包括我在内。（不过大家不要误会了，国人在广东话环境能很快学会粤语，这可和学英语的原理截然不同，实际不是在学外语。近 似度太高，而且大家的语言思维是一样的，几个月就够。会西班牙语的人学意大利语就很快，也因为太接近。不用学，这两国人也能各操自己语言彼此交流。马克思 用三个月学会的那个外语和这个情况类似。）<br>　　 平时是在英语环境的，是在外国人家住的，也大工，也上补习班，也看英文电视和报纸。可过了几个月，甚至一两年过去了，发现怎么自己的英语还是这么差呀，听 不懂，说不好，只会一些日常生活很简单的用语，还讲得好难听。当然，到了国外，从张不开嘴到敢于开口，这一关还是过了。到国外两星期都敢说了，因为被逼 的。一旦敢说了，也就不再有心理障碍了。但说了两年了，怎么翻来覆去还是只会那几句？英语环境出什么问题了？<br>　　 大家如果现在上网，在搜索器中打“出国才知道的十大秘密”这几个字，就会看到，第一条就是“发现了并不是在英语环境中就能自然学会英语。”<br>　　我帮大家分析一下，很容易懂。比如有同学住到了外国房东家，满心欢喜认为可以通过交流学英语了。早上起来和房东问好：<br>　　老中：Hi, good morning! （练这句话有用吗？早会了，也不用到外国练呀！）<br>　　老外：Morning! Nice weather ah? Any plan for the weekend? （嘿，全听懂了，真是太棒了。）<br>　　老中：Stay in home. （想说点啥，一时没想起，这句接得还周正。或许有点毛病？反正人家听懂了直点头，也没提出异议。）<br>　 　老外：OK. Did you know last night there was a racoon got trapped in the dumpster? I heard the noise and called the cops, then they came and called the vets. A vet shot a tranquilizer dart from the tree at the its butt, ah bang, bulls-eye! Hell of a shot. Still, took them another hour to rescue tha’ poor bastard…<br>　　 这回傻眼了。在老中听来，是这样的 ..last night …tra…dumpter? Heard noice ….shut ….lazer, 还有。。。什么“不在”啊不可能，老外一定不会中文，可能是个和中文“不在”同音的字吧。接下来是an hour ….pour…butter? 不懂，于是尴尬地说了声see you later. 回屋了。设想一下，如果多听几遍是否就能懂？就算多听几遍，把一些连接处听懂了，there was, heard the noise, called.. took…..仍有很多难点，比如racoon, trapped, dumpster, vets, tranquilizer, bulls-eye, 所以还是不明白。那在多听呀，比如重复一百遍tranquilizer, tranquilizer, trann-qui-li-zerr!能懂吗？大家知道一定不行。所以并不是多听就多懂。<br>　　给大家举个极端的就例子明白了。你不是想要外语环境 吗？很好，我给你找一个。我找几个阿拉伯人在一间办公室交流，你每天都来，一天8小时听他们交流。过了三个月后我来看你，问你阿拉伯语听懂几句了？很多人 这时候很明白：“一句都不懂。”因为你听到的那些外国声音，都被语言学家称为“无效的输入”，或本人管它们叫“无效的声音”，因为不懂，跟听到的噪音没太 大区别。所以并不是多听就懂，听懂是有严格的条件的。后面我们重点讲需要什么严格条件，大家先不忙。<br>　　 回过头来再看刚才那位老中。如果那房东老外很有耐心，给咱解释一下总行吧。好，那咱看他应试图如何解释vets和tranquilizer这两个概念。别 忘了他只能讲英文，当然他在发现你有困难理解时，会试图从难到易变换解释方法。预备，开始： “Vet, vet, a veterinarian, you know, a doctor who practices veterinary medicine, ehh, an animal doctor!” 听的人更晕，怎么什么什么医生？还像动物？他很凶吗。接下来更莫名其妙了：”Tranquilizer, ehh, a drug that can knock an animal over. You know, you put this drug in a cartridge inside a dart, then you fire it from a gun and knock the target over, ehh, to pass out. Dart, a dart, small arrow….Oh for gods sake, forget it. You take care of yourself, buddy.”<br>　　 交流结束。先不管交流是否愉快，大家再仔细分析，从刚才的对话对提高英文能力什么帮助吗？可以说几乎是零。无非是与“真人”交流了，说了几个以前早就会的 简单问候语，听懂了几个单词但不知人家到底在讲啥，而且没有任何单词或其他东西是从以前的“不懂”到听过以后变得至少大概“懂”了吧。刚才我们论述过，不 懂的是“无效的声音”，纯粹白听，和听阿拉伯语广播一样，永远也不可能懂。这时这位同胞大哥又明白了一件事：原来用英文解释英文是不现实的。其实大家早就 明白这个道理却非要到国外去证实。大家都查过英-英字典或双解吧？早就听人说英文解释英文更准确，而且连查带学多好呀！碰到一个单词去查英-英字典，结果 发现解释里还有几个不认识的。再查解释的解释，一会儿就乱套了。很多读者都有英-英字典吧？我敢向大家保证，查过两次之后就放书架上再也不会去碰他了。大 家先别忙笑，分析一下为什么。<br>　　 这位新来的大陆同胞后来如何？先不说这位房东从此失去的与你交流的兴趣，而且你每月也不需要再和他交流，只要按时把支票放他信箱里就好。很快最短租期一 到，这老哥就搬走了。不是不好意思见房东，而是老外的房租比华人的贵（华人比较不注重装修，并且常不开发票收现金，所以给你优惠）。既然练不了英文，还不 走？还曾出过一个头疼的事：刚住下时订了份英文报纸，第一份还没看完半版，一个星期的都堆起来了，赶快退订。<br>这时，有以上同样经历的出国的朋友们 得出了这样一个结论：国外的真实语言环境太难了，我不适应，所以难学。咋办？去加拿大的同学们真走运。政府给所有新移民准备了英语培训班ESL Course。“小班纯外教。”原来在国内认为是很贵但是是最理想的学习条件，在加拿大居然是免费的。一个Native speaker老师带着几个学生用英语每天在一起交流。在这里不但免费，还发午餐。管饭！不但管饭，还发每天上课来回的车费。不但发车费，有的偏远省份还 发钱。只要一个月全勤，可以去政府领几百加币（几千人民币呢）。有如此的国家和政府，真幸福。再说不管饭也要去呀，英文要紧。于是大家踊跃报名。每天高高 兴兴来教室和老师同学交流英文。<br>　　 可是接着发生了这样的事：两星期后，许多中国同学就开始不来了。中国同学多半很聪明，很快就观察出问题来的。刚来上课时非常兴奋，老师自我介绍: “Hi! How are you? My name is …, I am from Canada. Nice seeing you all.”;同学互相认识，开始交流。但很快同学们发现，两个星期过了，并没有学会几个以前不会的“新东西”。还是只能听懂那些简单的日常用语。有一天中 午吃饭老师说是 “spaghetti”，这词记住了，是“通心粉”。但两星期才这几个词，太慢了，两年也不行啊？还不如我自己回家背单词呢。我当时听到这情况时还劝他 们：那也别走啊。至少你们可以跟老师说英语呀！回家找谁去呀？总不能老在街上跟人聊吧。这些同学不以为然：多说英语更有问题。因为我们发现，说来说去，都 是在说那些以前就会说的那些话。不会说的话，我们都在那里瞎说，这样越说越差。很多同学以前认为有机会多说就越说越好，但现在又明白了，原来不会说的话， 是不会在外语环境中自动变会的。比如有个同学想说她把全家福照片做了塑封带来。塑封不会说，怎么都不行。有人提出了：说个简单形式的总可以吧？她说 “I put plastics on my picture.” 老外能懂吗，当然能。于是英语交流实现了，人家继续跟你聊：Oh, what’s the picture about? 简单英语也可以交流啊， 甚至可以应付生活中的大部分琐事。但您说英文的能力提高了吗？零效果!所以不是“随意多说”就好。说是输出过程，脑子里还没有的拿什么输出啊？于是退课 了。（可怜的加拿大老师们还不断打电话求中国学生们回去。倒不是喜欢他们，而是上课学生少会被政府裁员的。）<br>　　 这时大家又得出了一个结论：噢，原来到了国外和老外瞎交流没效果，说的都是会的，听的都是能懂。不懂的很难懂，不会说还是不会说。我们现在明白了，原来到了国外，英文还要靠自己系统学。（那篇出国十大秘密的文章得出类似观察结果）。自己如何系统学呢？<br>这 时小班外教课不要了，大家组织了一个大班，请个老师来教外语。对这个老师的要求是：必须会讲中文。当然我是会讲中文的，于是被请去当老师了。我曾在加拿大 纯英文环境下教过英文，原因是我会中文。听起来很滑稽。我曾在周末到教堂去给中国同学上课。他们一般都是在教堂聚会后，（很多人不很信教，到那里是为了聚 会）用那里的教室上课，教室免费。我一给他们上课，他们觉得学习才“有效”，因为再复杂的英文，用中文解释一定明白。我会用英文上课，但大家才不听呢，我 又不象ESL那样管饭。一用中文，大家就高兴了。有一次一个学生问了我一句英文（记不得是哪句了），问我啥意思。我问他哪里听到的，他说在ESL课上。那 老外老说这句话，他听了两个星期了，都会背了，但就不知啥意思(无效)。我问他为什么不问老师，他说问过，但老师是老外，用英文给他解释了一遍，但那解释 他听不懂。（这又回到的用英文解释英文的问题。很多同学认为这是对的，比如用英-英字典。当然是对的，但经验告诉我们在英文基础比较低时不太现实,因为对 他们来说,英文解释很难懂。水平很高的同学才能用。所以国外的英文环境对原来英文水平很高的同学是很有效的。）接着我用中文给他解释了一遍，他回答说: “咳，是这意思啊！”以前两个星期都不明白的问题（无效声音），只用了两秒中就明白了。因为知道意思了就有效了。于是大家纷纷提问，把平时听到的不明白的 词和句子问我。再复杂的句子，只要用中文解释，一定懂。但读者又发现问题了：这不是还在用翻译法吗？没错，这样做的后果是很难形成英文思维，回到自然环境 中，又反应不过来了。<br>　　于是成年人在国外就掉在这个怪圈里了。再往四周一看，大部分的中国同学在国外的几年里，英文都是非常差的。除非原来英文水平很高的人，在国外进步很快。但这样的中国同学太少了。<br>关 于成年人在国外外语学得很慢这个事实，一般的老百姓也有普遍的认识。不光是中国人，比如在国外有很多其他国家的移民，在美国加拿大居住了很久，英语仍然很 差，大家都习以为常了。现在这些人也来中国出差或工作，我想大家见得也开始多了。美国政府对此也很了解，希望解决这一问题。大家知道，一般拿到绿卡的人5 年才能申请转美国公民。美国政府发现大部分移民5年以上英文还很差，于是试图通过修改移民政策鼓励学英文。政府提出：如果拿到绿卡后，4年就可以把英文说 流利，通过考试，第4年就给公民权。但美国的语言专家们纷纷起来反对，骂政府愚蠢。大部分人明明5年都学不会，奖励其中英语好的也不能让其他人学会呀？他 们说：好比大家都是饥民，你应该想办法给大家吃饱，而不是奖励其中最胖的人呀？这一职责登在了2005年《今日美国》上，后来这一政策没有实行。<br>　 　 那成年人在国外一般到底需要多长时间才能把外语说得比较流利呢？国外的语言专家有很深入的研究，他们发现，前提是如果能维持外语环境（不能每天缩在本族人 中），那么达到流利程度的时间需要年龄除以6。也就是说，如果三十岁到国外，需要5年才会比较流利。所以很多出国读研究生和工作5年以上的中国同学，英语 可能是非常流利的。但我们发现，由于开始时基础差，很难维持外语环境，所以很多移民留学生在国外5年以上外语仍很差。<br>　　<br>　　特殊群体<br>　　<br>　 　 我们一直在讲成年人在国外学习外语慢，那么小孩子不同吗？非常不同，他们是特殊群体。如果是小孩子（严格讲是12岁以下）到了国外环境，就算以前是零基 础，只需要大约一年的时间，每天几小时，外语就讲得非常流利了，和当地人几乎一样好，而且一点口音都没有。其实我们学会自己的母语也只用了这么长的时间。 大家总认为我们学母语时用了很长时间天天在语言环境中泡着，其实不然。我们两三岁母语就说得比较流利了，每天并不用很久。语言学家发现，婴儿是从六个月大 时开始注意语言符号的，之前并不知道语言和其他声音的区别。六个月大的婴儿，每天一共24小时，他先睡掉了十几个，剩下八小时左右，醒了就哭要吃，然后换 尿布，洗澡等等，然后自己玩儿，并不是随时注意听大人的语言。统计发现婴儿注意语言的时间每天一两个小时而已。但两年就会了。大家不要认为小孩子语言水平 低，他们是知识能力低，语言是很流利的。所以儿童是掌握语言最快的，比成人快5到10倍。这种差异是如何产生的？有没有办法让成年人也用学母语的速度学习 外语？这些问题正是国外语言专家研究的重点。尤其在近几年，已经有相当多的研究成果，下面就为大家介绍。<br>语言关键期之争<br>　　<br>　　 一直以来，人们的普遍观察和实验认为小孩学语言的能力远超过成年人。比如成年人和小孩一起到国外，尽管这些成年人以前有过多年外语学习基础，但到了新语言 环境还是很吃力，口音也改不掉。但是家里的小孩子很快（一年）就流利掌握了新语言，并且口音纯正，甚至成为了家长们出门的翻译。父母如果会讲多种语言，家 里的小孩子往往几岁之内几个语言都能流利交流。难怪我们敬爱的俞敏洪老师到了国外曾无限慨叹，自己学和教了几十年英文，单词量十几万，比一般老外多了好几 倍，但讲起英语来还不如自己在加拿大生的四岁的女儿流利。关于小孩子为什么能如此迅速掌握外语，国外多年来有大量的研究，代表人物是于1967年提出“关 键期假设”的Lenneberg博士。在此之后关于是否存在语言关键期的争论不断，反对方也通过大量实验和观察，甚至得出成年人在学习外语能力上还超过儿 童的结论。<br>　　<br>　　 由于实验前提，实验条件，流程设计，实验对象的局限性很强，课题研究的侧重点不同，得出的结论往往不能全面说明问题，所以大家各持己见，很难说服对方。但 笔者发现，反对方的实验，主要集中在学习者在类似学校的限定的“学习”环境中。而系统地学习外语，成年人理所当然占优势。其实这与成年人的“学习、理解力 和记忆力”比儿童占优势的特点相符，实验结果当然大部分认为没有关键期。而普遍对“关键期存在”观察往往是在自然的语言环境中，发现儿童有明显优势。另 外，不管是正方还是反方，对成年人几乎无法使口音纯正这一事实都是认同的。关于口音的问题，正方也往往试图在脑神经或听力器官方面寻找原因，一时还难找到 过硬的证据。而反方多试图在口腔肌肉控制能力上找证据。争论一直延续到了1997年，正方意外地突然得到了来自脑神经学实验证据的支持。<br>　　<br>　 　 1997年，英国《自然》杂志和美国《纽约时报》同时刊登了一篇名为“当成年人增加一个语言时，同一个大脑但两个系统”的文章。文中报道了美国SKM癌症 研究中心的功能核磁共振实验室对英语和其他各国语（有中文）的双语人士进行大脑扫描。在对从在小时后就学会了外语还是从成人后开始学习外语对他们大脑的不 同影响的实验中发现，发现在小时后就学会双语的人，两个语种语言区在大脑中是位于同一个区域，几乎重叠的；而在成年（十一二岁）以后才学会外语的人，两个 语言区在大脑中是分开的，可明显分辨两个不同的语言区，而在使用其中一个语言时，该种语种语言区是活跃的，而另一个语种语言区是关闭的，反之亦然。这一报 道在语言研究领域产生了不小的轰动。这一发现对语言学习的意义是什么呢？笔者总结为以下几点：<br>　　<br>　　1．一直以来，人们对不同年龄掌握语言作用在生理上的区别一直有怀疑和争论，而今通过“fMRI功能核磁共振”这一新技术，证实了以往对“不同年龄段语言形成机制不同”这一猜测的真实性，也就是确实存在生理上的关键期。<br>　　2．为外语思维的存在提供了证据。形不成这个新的“外语语言区”就无法用外语思维，只能在自己的记忆中“调取”外语知识，（成年人哑巴英语的本质）。关于这一点，下面会做更深入的分析。<br>　　3．不同国家的语言，形成的机理和在大脑中存在的位置是一样的。（注：后来科学家确实又发现了，中文语言区符合上述实验结论，但汉字在大脑中存储的位置确实特殊，以后我们再讨论这一发现对中国同学学外语的帮助）<br>　　4．尽管存在关键期，但语言能力实现的最终结果，成年人跟儿童应该是近似的，但实现过程应该就是遭成效率差别的主要原因。分析和改进实现过程，也就是语言区形成的过程，定能提高实现效率，而缩短形成时间。<br>　儿童获得语言的过程跟成人学习语言的不同：<br>　　<br>　　 这一课题学术界争论不休。因为没法敲开人脑来观察，大多只能使用间接证据，所以各派谁也不承认别人的实验的权威性。就不再拿科学资料烦大家了，先简单分析一下儿童获得语言和成人学习语言的过程到底有什么本质区别，成人应该如何象儿童学习“获得语言”的技巧吧。<br>　　<br>　 　 大家都知道我们的大脑有左右两个脑半球，每个脑半球负责不同的功能。绝大部分的人，左脑负责的是：数字，逻辑，计算，推理还有语言。右脑负责的是：图像， 色彩，音调，旋律还有浪漫。有人简单总结为左脑是逻辑脑或理性脑，右脑是图像脑或感性脑。（美国科学家曾进行过人群左右脑功能位置统计的比对，发现右手优 势的人，95%是这一顺序，5%是左右颠倒的。而左手优势的人，即我们说的左撇子，居然也是大部分人符合这一规律，达75%）。婴儿大脑所具有的神经元突 触数量大约是成人的两倍，负责左右脑的联系的神经也比成人丰富，所以小孩子在获得语言时，左右脑一起紧密配合使用。而到了大约六岁时，有人研究说如果这些 神经元突触还不使用就开始消退，有人研究说左右脑的神经链没有开始使用就开始萎缩（还有说断裂的），到了十二岁，这些神经元突触啊链啊就只有小时候的一半 了。所以成人以后，左右脑分工开始变的重要，但学语言的优势反而失去了，因为成年人开始只主要应用左脑来“学习”语言了。尽管目前科学证据还不够丰富，但 这一分析还是合理的。于是成年人和儿童对语言的掌握出现的本质区别。<br>　　<br>　　 先看成年人如何学习语言，这个大家比较熟悉。大家听说过很多学习方法，看过很多教材，见过一些成人学习外语的成功案例，但大多都是在用同一类方法在学习外 语，即用“记忆”的方法。大家看到这里觉得奇怪：没错啊？学外语不就是靠记忆吗？背单词，背句子，背文章。谁记忆力好或刻苦记忆谁就最厉害。我就是记忆不 好。但记忆有错吗？我们往下看错在哪里了。记忆完了存放到了大脑负责记忆的区域，形成的是对这种外语的知识的记忆。记忆过程符合记忆规律，大家最熟悉的是 德国心理学家艾宾浩斯Ebbinghaus 的记忆曲线，即记忆-遗忘-再记忆。有人说要忘掉七遍才能不忘，这里不再对记忆规律多讨论，总之很辛苦。语言的变化是非常复杂的，不能说只有两万句英语， 应该说有无数种组合，专家分析有几百万种常用组合，当然包括了一般人使用的近两万个单词和上万个词组。（英文单词一般是一词一意，个别的是两意。但词组一 般都是多意的，比如take off， 要按意义数分，词组可要比单词量还大了。）所以要有相当大量的知识才能准备应付这么多的变化。要达到相当的知识量，一般需要至少9000小时的记忆时间。 对大多数时间紧张或稍缺毅力的同学来讲，实在是太难了。9000小时意味这什么？一天一小时需要近30年，一天3小时要近10年。当然有些人确实是用这种 方法学会外语的，但真太不容易了，后面我们会做些案例分析。但先在这里对那些靠刻苦努力成功的同学表示十分的敬佩！<br>　　<br>　　 总之，成人学习语言的过程是：记忆——记忆区——知识。<br>　　<br>　 　 那儿童是如何掌握语言的？刚才说了，他们在掌握语言时，是左右脑紧密配合的，更准确说，是用右脑帮助左脑实现建立语言区。大家还记得右脑是图像脑吧。儿童 在最初听到任何语言的时候，一上来肯定是不懂的。但因为他们没有语言，再给他们解释也是无用的。那怎么办？没人着急，人家自己有办法。他们通过在出现这些 词句（一般先是简单词汇，更严格说是只这些词汇的语音）时的场景图像的观察（当然还包括触觉，嗅觉等其他辅助的感官刺激，盲童甚至仅靠这些辅助感官刺 激），而猜测这些词句大概代表的含义，并与图像进行“联系”。经过几次的重复刺激后，形成了对这一语音符号的“条件反射”，在大脑语言区的位置形成了脑神 经的一个网络结构逐渐构造该语言的语言区，最终实现了用这种语言的语音符号思维的能力。这个过程实现起来，既轻松，又快捷，成年人望尘莫及，而总是感到惊 叹。<br>　　<br>　　 总之，儿童的语言获取过程是：猜测——形成条件反射——建立语言区——实现语言思维。<br>语言条件反射<br>　　<br>　 　 说起语言是一种“条件反射”Conditional reflex，还真没太多人反对。大家在中学就学过，语言现象是“第二条件反射”，所以语言本身也叫做“第二信号系统”，使用工具和语言条件反射是人类特 有的能力。动物只有“第一条件反射。”忘记这一点的同学高考考政治时一定是靠突击背出来着，考完就仍了，完全违背了党和人民让你们学政治课的用意。不过应 该有相当多的同学记得。当然，后来科学家发现通过语言条件反射的训练，黑猩猩能够听懂相当数量的单词（目前最多几百到一千个词，还都是英文），只是不会 说，因为没有人类这么复杂的发音系统，但可以用手语回答。还发现黑猩猩会制作和使用简单工具。这一下，人类特有的东西越来越少。等哪天黑猩猩学会了生火取 暖，这事儿就真有点那个难说了。可大家到了学外语时，往往忽略了语言是条件反射这一事实。通过调查发现，大家最后对什么是条件反射，还都说不太清了，还总 是和记忆混淆。我们先复习一下：<br>　　<br>　　 诺贝尔奖金获得者、俄国生理学家巴甫洛夫（Ivan Pavlov）早在上世纪初就奠定的经典条件反射的基础。他的实验方法是，把食物显示给狗，测量到狗会大量分泌唾液。这叫非条件反射，不需要条件。但如果 随同食物反复给一个并不自动引起唾液分泌的中性信号刺激，如铃声，经过一段时间重复刺激后，狗会逐渐在只有铃声而没有食物的情况下就分泌唾液。一个原是中 性的刺激与一个原来就能引起某种反应的刺激相结合，而使狗学会对那个中性刺激做出反应，这就是经典性条件反射的基本内容，称为第一信号系统。另一类是抽象 信号，即语言、文字称为第二信号系统。第一信号系统就是对第一信号发生反应的大脑皮层机能系统，将直接刺激转为机体各种活动的信号。第二信号系统是对第二 信号（语言、文字）发生反应的大脑皮层机能系统，它是将第一信号系统的单纯刺激转变为具有抽象意义的词语的信号。第二信号系统是在第一信号系统的基础上建 立起来的，反过来又影响和支配了第一信号系统。<br>　　<br>　　 看着有点儿晕。中国人一千多年前做的实验既简单，又科学，大家记得“望梅止渴”的成语吧？话说有一年夏天，曹操率领部队去讨伐张绣，天气热得出奇。。。 咳，不讲那故事了，大家都熟悉。早该把诺贝尔奖发给曹操。分析一下这用真人做的条件反射实验是什么原理：一般人以前有过吃过酸梅的经历，酸梅可是好酸呐， 吃时定流很多口水，所以在见到酸梅就会流口水，这是第一条件反射。当把“酸梅”这两个字与酸梅实物建立了联系后，抽象的“酸梅”的声音或文字，就引起了对 酸梅图像的自然联想，同时引起了口水反应。（不好意思害也你流了回口水）。<br>　　<br>　　 看到后来有学者认为把语言全归结于“条件反射”太片面，把“条件反射”的拥护者归到了“行为学家”类。其实语言和思维确实复杂到用继续用条件反射研究已经不够了，但“口水”都流了，承认它是条件反射，并不妨碍做其他研究吗。<br>　　看到格雷厄姆的追随者“把语言思维转换成图象思维”一贴，觉得这个话题有意思，到这儿插个空讨论一下。<br>　　<br>　 　 其实语维本身是个很复杂的问题，但并不是单纯图象思维，主要还是以语言为主体，更准确说是语言的“声音”为主体。比如大家想：“外面在下雨。”实际上是这 些声音在脑子里打转，并非全是图象。当然这些声音思考的能力在当初建立时，是靠很清晰甚至多次类似图象帮助实现的。到了后来，抽象的东西和概念性的东西越 来越多，那是在这些形象词的基础上更进了一步，又不是简单用图象就能解释清楚了。但有意思的是，思维尽管是语言做载体，思维和语言交流时，图象确实在参 与，只是不象大家想的那么清晰。这些图象被称为“MIF” （mental images flash），中文没见过翻译，先叫它“思维闪像”或还是简称“MIF”吧。“MIF”是什么？还是用“外面在下雨。”这句，当你听到这句话时，脑子里迅 速闪过一个下雨的图象，图象停留时间短到你还没看清那是大雨还是小雨的程度。如果你从没见过下雨的情景（甚至电视上），那你脑子里一定不会出现这个 “MIF”。比如我说：“外面在下啊啊呢。”你没见过“啊啊”什么样，所以脑子里的图象刚到“外面”就停住了，所以没图象了。我们每天的思维，行为大多被 这些声音和与之相联系的图象所带领甚至控制，他们的速度太快了，有时快到我们几乎意识不到他们的存在。在说一句话前，我们是以一个“MIF”启动这句话 的，没有这些“MIF”，我们都不知如何起头说话。当你听到一句话，它又激活了你脑中的一个“MIF”，没这个“MIF”，你就根本听不懂。而这个 “MIF”正是你的生活经历带给你的。而这些“MIF”与其相关声音的连接正是语言形成的关键点，跟我们刚讲的条件反射刚好搭上线。<br>　　关于儿童语言获得和成年人学习语言的过程对比，有必要再加以说明。这是两个完全不同的路线，正是造成语言学习能力差异的主要原因。<br>　　<br>　 　 我们先看儿童的语言获取过程：猜测——形成条件反射——建立语言区——实现语言思维。我们倒着往回看：语言是思维，大家已经同意。学术界有三种说法，一是 语言决定论，认为语言决定思维；二是思维决定论，认为思维带动语言；三是认为两者互相依托。其实三者不必争，都认为语言和思维紧密结合。那大脑的语言区 呢？这一问题上上世纪就解决了。1861年，法国医生保罗.布洛卡（Paul Broca），准确地找到了语言区的位置，于是该语言区被命名为布洛卡区。十几年后，德国医生魏尼克（Wernicke）又发现了大脑中另一个负责语言的 区域，后也被以发现者名字命名。大脑中的语言区最主要的是这两个，他们都不是负责记忆的。婴儿刚出生，大脑象白纸一样，随着开始接受“色、声、香、味、 触”等刺激，脑神经开始忙起来。这些神经主要集中在大脑皮层（cerebral cortex）即灰质部分中，而灰质下面的白质，则是这些脑神经的长纤维。这些纤维由绝缘材料包着，分别向各处传送电脉冲。语言区的形成是通过这些神经纤 维按一定规律铺垫而成。具体形成的脑神经机理目前还不十分清楚，我们只能从外界现象和脑受损伤的症状观察，这里不再细说。从外界看，是条件反射形成的。<br>　　<br>　 　 那成人学习语言的过程：学习——记忆——记忆区——知识这一途径呢？我们已经知道语言不是知识（有某些知识的成分，但那不是语言能力的本质），那语言是否 在记忆区？学医学和心理学的同学比较清楚不是。就算我们没专业知识，但有这样的观察：有的人记忆受损，什么都记不得，但说话没问题。他怎么没吧语言忘了 呢？原来语言本不是记忆。大家记得成龙演的“我是谁？”或Matt Damon演的“伯恩的身份”吧？两人都是连自己名字都不记得了，但说话甚至多种外语都会说。既然本不是记忆，就谈不上真正意义的“会忘记”，当然也就知 道语言不应该是靠记忆或“背诵”得来的了。而记忆的方式正是成年人学习的主要手段，有人抱怨忘了也就不奇怪了。<br>　　<br>　　关于记忆力<br>　　<br>　 　 这里顺便来讨论一下记忆力和年龄的关系。大家知不知道人的一生多大岁数时记忆力是最好的？10岁？18岁？越小越好？错！是30岁左右。一般实验显示是 25到30岁，有些单纯真对女性的实验甚至发现是35岁40岁。年纪大，记忆力是非常好的，认为不好纯属为懒得记自己找借口，而自我暗示的结果还真让你记 不住。其实如果正常使用大脑，到70多才开始记忆损失明显。而年纪越小记忆力越差，3岁时实际上长期记忆力几乎是零。所以大家3岁以下的事一般都记不得， 有几件事记得就了不得了。怎么老有人说小孩子记忆力好呢？三岁小孩给他换个妈他过几天就不记得了，还说好呢。所以我们发现很多家长让小孩子背东西，古诗啊 什么的，正是违背了儿童的思维特点而强迫他们使用最不擅长和现在最不用的东西，而放弃和压制了他们应该开发的那些智力。每次想到这里总来气，大人学习受点 苦也罢，小孩子受了罪还受害。真是害人不浅呀！大家也许听说过国外上小学上课尽是玩儿，很早就放学了，回了家哪有什么作业呀？还是玩儿。有作业也都是些小 游戏，小实验项目等。到了中学还这样，天天关心课外活动能力和交际能力，13岁没找对象老师还找去谈话问是否和异性相处有问题。（很多中国移民小孩被老师 找，回来一问是这事儿，家长当时都吓坏了。）然后也没有什么高考，过SAT就成。SAT上那数学题让咱初中小孩做，全满分，这些小老外那叫觉得难。你说他 们不怕耽误下一代？不怕，人家明白着呢。<br>　　 看咱中国同学，恨不得幼儿园时就急着学小学课程，小学生可怜啊，早起天还没亮，下学作业写到天黑，周末还有课外学习。中学生更可怜啊，为了考上大学了，那 苦就不说了。高考，真烤啊。“啊，我中了！”考上大学了，这回可放鸭子了。敞开玩儿吧。再看外国同学们，上了大学了，功课突然紧了，每天学习跟打仗式的， 比中国一般大学学生的学习强度高几倍。一门高数课我们要学半年，国外恨不得几星期就学完还考试。能行吗？当然行。因为人到了这个年龄，记忆力，理解力都开 始快到高峰，一个月学习的收获比中学小学一年都多。（其实中国大学生也能作到，只是大多一学期都在玩儿，到最后两周一突击，好几门都过，因为能力一样嘛。 只是在国外上大学，每星期都是中国那最后两星期）。结果本科时，人家把以前中学小学被咱拉下的早都补上了，到研究生阶段一下就把咱盖过去了。到这阶段，要 做研究项目，需要创造力了。结果外国同学小时候开发的智力全用上了，中国同学到此时才思枯竭，小组项目中只有给人家找资料的份，人家还经常不爱带你玩 儿。（很久以前考出去的中国留学生中有很多到了国外还是比较优秀的，但那多是人精，不能拿我们的人精跟一般外国人比。大家同级别比一下）。不说这事了。改 变教育体制是要靠大家努力的。<br>　　<br>　　 我们还是说说这和学语言有什么关系？明明是成人记忆力好，学习能力强，3岁小孩没什么记忆力，理解力跟成年人更不能比，可成年人学语言困难，3岁小孩最容 易。其他原因不谈，单从记忆上看，刚好是因为成年人记忆力好而且用记忆去学语言，所以困难；小孩记忆力差，而刚好不用记忆力学语言，所以容易。刚好又证明 语言获得不是靠记忆！<br>　　感谢大家的和理解。前两天脑子真不行，今天看一心禅兄的文章，受启发忽然想到一个比较恰当的比喻：比如大家问：“应该如 何学佛啊？”答案一定不是一句话，也不是可以立即能给答案的。如果谁能说：告诉你吧，学佛就是念阿弥陀佛。或说：就是烧香拜佛；或说：就是吃斋；或说：就 是念经；或说：就是打坐，或说就是以上的全部等等，那一定不可信。必须通过严肃认真，从各方面分析，阐述，比喻，引导，最后使读者自己得到了系统的理解， 才是正路。<br>　　 国外关于外语学习的理论体系很成成功的就好几个，各有优点，但都是厉经推敲和拥有丰富的理论和实验基础，绝不是某个人排脑门子想出来的XX学习法。在下会努力向大家把精华简单介绍出来，大家看看就明白，不过写起来会麻烦点，大家要有耐心。<br>　 　 如果我又能去发明了什么漏屋法，那还能斜呼成啥样儿啊？因为仔细一看，从“十倍速法，百倍速法，雷电风暴法，风驰电掣法，正向逆向法，到疯狂法，变态法， 如醉如痴法，走火入魔法，最后再来一个千万别学法，没给我留地儿，除非叫“乾坤终极毁灭法”（怀疑没准儿也早有人叫了）。哈哈！<br>　　<br>　　祝大家周末愉快！<br>　　　中国“英”雄<br>　　<br>　 　 正如许多同学说过的，的确有人就是用刻苦记忆的方式学好英文的。这当然是事实，大家可以举出的例子也很多。而且这些通过自己努力记忆的艰苦“学习”方式而 获得成功的同学和前辈，是值得大家十分的钦佩的。外语学习的成功，不但给他们本人带来了新的能力，更强的自信，一个成功的经历，而且往往带给他们更强的人 生动力和意想不到的人生命运转机，甚至有人从社会最底层一夜成为全国老幼皆知的人物。这也是中国特有的现象。但我们在对他们敬佩的同时，无一例外地发现， 他们的成功是大多数人很难做到，因为那需要超人的毅力和极其刻苦的训练。正如钟道隆老师所说的那样，象“逆水行舟那样难，所以叫逆向”。钟老师自己就听坏 了17个收录机和数个收音机。三年中听写英语每天写满20页稿纸，有的阶段学英语时间达每天十几个小时以上。大年三十大家看电视吃年饭到半夜两点，钟老师 听写英语到了两点。其他”英”雄的故事都很类似。（在下这“”是打在“英”字上，意思指“英语”很厉害，不是“英雄”反话的意思。）<br>　　 我很欣赏新东方一位DW老师的讲话，他这样对同学们说：“其实我自己的方法也不错，但我之所以没叫DW法，因为我背单词，背句子，背课文，听广播，看电 影，唱英文歌都用过，不能说我具体怎么学会的，所以不能管这叫DW学习法。但我是在英语四级之后，又学了6000小时。”他也是英雄之一，但在下认为这话 说得令人尊敬。（英语四级需要3000小时左右才能实现，加上6000小时，共9000个小时，在下也同意他对刻苦学习所需时间的这一总结）。正因为如此 难，他们才确实是英雄，不过广大同学们怎么办？这样的艰难的学习经历如何有推广的可能？而已经成功的这些为数不多的人们，如果你们中又有人开始在教别人学 外语，问一句，当看到那些满脸期望看着你们的同学时，你们中是否有人心里会闪过这一念头：“老子当年都是这么刻苦学的，你们现在还差得远呢！”在一味“励 志劝学”中，是否有自我找感觉的成分？<br>　　<br>　　 就这一现象，我们应做如下思考：为什么国外没有类似对外语学习成功个人的追捧？没有某某外语学习法？为什么那里外语学习研究已有数百年的历史，目前研究水 平已尖端到脑神经学的层面，而且国际知名的专家很多，但却常说“对很多实现的具体实现过程尚不清楚”？每个成功的语言学实验成果公布时，总是详尽地公布本 实验的条件和前提而不泛泛下结论性论断？大家如果真能冷静观察，“稍微”了解一下国外近些有关语言学研究的“科普级解释”的报道，以中国同学的这种敏锐的 思维，定会得出比任何其他民族都更清醒而深刻的结论。<br>二律背反？<br>　　<br>　　 回到成年人学习语言和儿童获得语言的对比上，听起来好象给绕住了: 先说了因为关键期的存在，儿童和成人在大脑生理结构上的客观区别使儿童成为了掌握语言的天才而成年人是弱者；但后来又说是儿童获得语言的过程和方式与成年 人不同，才是造成他们掌握语言效率和时间的差异的主要原因，所以才检讨了半天成年人的方法多么多么费力和存在误区。那到底是先天后天谁决定的呀？还是谁决 定了谁呀？解决方案到底是什么？<br>　　<br>　　（有人精神了，啊，要进入正题了。不过先解了上面这个悖论套儿再说。是要进入实质问题了，不过一会儿还是要先痛说革命家史。嘻！长征可以跳过，最少也得从八年抗战讲起吧，不能直接就讲解放战争呀。所以大家还要继续有耐心。）<br>　　<br>　 　 首先说，确实关键期的生理结构特点使得儿童在自然语言环境下掌握语言的方式是最自然，最轻松，最快速而且效果最好的。所以要获得一门或几门语言，最理想的 是在关键期前或一般说12岁以前。成年人习惯于“学习”外语，而且是记忆式和翻译式的，所以效率低，时间长，效果差。但从理论上说，如果有办法使成年人按 获得母语的过程去掌握外语，就算有一定生理差异，应该也是很有效的呀？因为成年人条件反射能力又未失去，大脑中空地方有得是，理解力还比儿童强，生活经 验、知识、甚至记忆都可以帮助加速外语的掌握，再加上个科学的语音训练法，应该不会差太多了吧？这一假设是成立的，所以关键难点就在于成人不会自动用当年 的母语实现过程去掌握外语，往往没有某些“必要条件和手段”让他们用自然法掌握语言，或有了条件而“控制不住”地还在使用习惯了的“学习”手段和陷入各种 误区。所以解决方法就是要从提供“必要条件和手段”以及“强迫”他们回避各种误区的干扰（无论有无自然外语环境的地方）。这一点，正是近几十年来国外的语 言学专家和语言教育学家们一直在努力的方向。无数优秀的专家学者为此奋斗了毕生经历，而许多国家，特别是美国，英国，加拿大，为语言研究投入了亿万的资 金。近些年光美国就达每年上百亿美圆，还不要去估算他们对脑神经学方面研究的投入。人类对语言学的科学研究进行的如此不懈奋斗，如果我们不了解甚至不愿了 解，实在说不过去，同时也就无法让我们每个学习者作到对语言有起码的正确认识。<br>　　<br>　　 在这里要插一句关于在没有自然外语环境下的关键期以下的儿童掌握外语的问题。比如中国的儿童。家长们，你们可千万别觉得你们一直以来让自己的小孩从小开始 学习外语，还送他们去补习外语是英明之举，其实中间的很多东西又都搞反了。因为如果是“学习”外语的话，那成年人的学习记忆和理解能力远远超过儿童，还不 如等长大以后再学。而且儿童“学习”外语也是很难建立外语思维的。小朋友的问题在后面我们会找篇幅专门讨论，我们先集中解决成人的问题。<br>　　世纪之战<br>　　<br>　 　 能用一种语言流利交流的前提是用会这种语言思维这一概念，在国外老百姓长期以来是普遍接受的，没有什么争论。但应该如何实现它，这个在专业领域中的各学派 一直是斗得很厉害。随着科学技术的不断发展，孰优孰劣逐渐也就越来越明显，到了上个世纪末的最后几年，局势才比较明朗化。为大家介绍一下，看人类对大家最 关心的问题是怎样进行研究的。另外“外语”和“第二语言” 严格从学术上来说是有区别的。但在这里咱们不区那么细了，都叫外语甚至语言好了。笔者分析国外关于语言学习的研究，是由几个主要领域从上至下形成了一个完 整的“生物链”。我们从最上层看起。<br>　　<br>　　1． 神经语言学Neurolinguistics<br>　　研究者主要是以人类语言能力 和现象的脑神经原理为研究重点的一些医学专家和心理学家。他们的研究核心不是如何学外语，而是对人类大脑如何接收、存储、加工和提取言语信息的具体实现机 制和对脑神经结构的影响做研究。（这方面的研究和论著浩如烟海，中国近几年引进了一些资料，仅“Brain and Language”一个原文期刊，北图就放了整两排的大书架。另外最近有人把“成功学”范畴的“N.P.L”：Neuro-Linguistic Programming 翻译为神经语言学，很让人看着糊涂。有人为了区别，说你们搞语言的就改翻译成叫“语言神经学”吧，“神经语言”掉个位置变成“语言神经”，别影响我们销售 NPL课程，现在正火呢。唉，斯文扫地。）<br>　　<br>　　2． 语言学<br>　　主要对语言本身的分析和研究。语言获得、语言掌握、言语生 成、言语理解和语言教学的理论体系。他们依靠和参考神经语言学的研究成果，分析这些成果对语言现象在实践层面的意义，在语言使用的范畴做科学实验，为近一 步的语言教学提供理论依据。（大家所关心的“学习方法”的理论层面，和这一个领域中最多。）<br>　　<br>　　3． 语言教育学<br>　　主要根据以上两个领域的研究成果和教学者自身的教学经验和对语言学的理解，研究在语言教学中的实际应用，提出具体的教学方法和学习方法，分析对比教学效果，制定最佳语言教学的方案，教学模式等。（大家关心的“学习方法”的实践层面在这里有。）<br>　　<br>　　4． 语言产品设计者<br>　　主要根据以上三个层面的研究成果，结合客户需求和商业化模式，设计，制造和推广出供学习者使用的各种产品。（这里面鱼龙混杂，硝烟滚滚。但无论本人观点和喜好是什么，决定在此不对任何商家和产品做评论。我把判断工具交给大家后，大家自己就会看明白了。）<br>　　<br>　 　 以上四个领域的依存关系非常清楚，但相互之间的界限有时会模糊。有的专家甚至跨越多个领域。整个链条系统非常庞大，几个领域之间常常出现断层，而且经常头 上产生的变化传到尾巴上时，很多事都已事过境迁了。但无论如何，头上发生的风吹草动，往往会给各个领域带来震荡。比如最近英国的神经语言学家通过实验发 现，会用两种语言的人（指有双语思维能力的人），他们的大脑聪明程度相对单一语言的人高，而且正是外语思维能力大幅度迅速地提高了他们的聪明度。2005 年，BBC发布了Bilingual Boosts Brain Power的报道，在语言学，教育学界同时掀起外语研究旋风。关于这一层的其他故事，我们以后在找机会详谈，先进入第二层和第三层，否则真有同学跟我急 了。<br>　　　语言学和语言教育紧密相连，各种方法论多出此门。在外语学习上，一个“语法-翻译法”Grammar-Translation，统治了 世界数百年。一直到上世纪中叶，也是随着自然科学的发展，语言学上开始不可避免地出现了“百家争鸣”的繁荣景象。如著名的前面提到过的Lenneberg 博士，也是在这一时期提出的关键期理论的。很多著名的学习体系开始形成和推广，有的一直在今天看来还有很多合理和可用的因素。比较著名的学习方法非常简单 地介绍如下：<br>　　<br>　　Audio-Lingualism<br>　　先听录音，学生模仿和记忆，再逐渐单个句进行重复和替换，变换训练。（典型的有了广播和录音机的直接产物。）<br>　　<br>　　Cognitive-Code<br>　　还是很象语法-翻译法但已经开始进行听、说、读、写四个方面的联系，交流能力受到重视，但还是较偏重于学习甚至是语法学习。<br>　　<br>　　The Direct Method<br>　　几个分支方法都在这一名下。老师通过使用外语例句来展示和讨论新语法内容，学生从实例中猜测和讨论新出现的语法现象，并试图使用新学的结构实践外语会话。老师回答问题并指出和纠正学生的语法错误。还比较偏重语法教学。<br>　　<br>　　The Natural Approach<br>　　教师用目标语言（即外语）授课，学生到可以用母语或外语提问。学生的错误不再被指出和纠正，课堂更着重使用外语，但作业中语法练习仍很多。<br>　　<br>　　Total Physical Response (T.P.R)<br>　 　这是大家常听到的著名的“完全肢体反应法”，简称T.P.R。通过学生对外语指令的听和猜，做出相映的身体反应。比如听到“Sit Down!”时要真的坐下。逐渐难度开始增加，而且学生开始试着给出指令。母语翻译过程完全避免了，并且大家是在观察和身体力行进行动作模仿地建立条件反 射。从直觉上我们就发现了这种方法对建立外语思维一定是非常奏效。的确如此！所以该方法至今仍在世界各地采用。但该法的局限性比较大，对教师的要求也高， 因为很多指令做不好动作就难以领悟。而且实现思维的词汇量有限（抽象的东西没办法做动作），一般500到800个左右，最多1000个。但已经是非常了不 起了。后面我会再找机会详细讨论一下这一方法并给大家这几百个典型TPR词汇，到时大家回去就可以开始自己或和朋友玩儿了。<br>　　<br>　　Suggestopedia<br>　 　这种形式是在一个融洽而轻松的气氛下，几乎只使用外语的课堂。老师的任务是创造一个这样的环境，把复杂的外语对话“表演出来”让大家理解。对老师的要求 相当高，但建立外语思维的效果相当明显。（如果你有一个外国朋友能天天这样和你交流，那我一定不说跟老外交流效果差。泰国有所很知名的学校就一直在这样教 语言，两个老师在课堂上表演，学生看着，都学得很快。哪天我一定得去学上一段）。<br>　　<br>　　 大家已经看出来了，这几种方法除头两个外，越来越远离“语法-翻译”的传统，从“学习记忆”向“交流应用”，逐渐向建立语言思维的方向发展。而在语言学研 究上，也同时逐渐形成了一个重要的外语语言学流派，它就叫做S.L.A.（Second Language Acquisition）。它的革命胜地是在美国。一场反映新兴活跃学术思潮和保守的老牌英国的“语法-翻译法”传统礼教之冲突的世界大战的硝烟，已经弥 漫在欧洲的上空和整个世界，一场“世纪之战”已无法避免。<br>　　“学得”-“获得”之辩<br>　　<br>　　 什么是“Second Language Acquisition第二语言获得”，为什么说它与“学得”不同？关键在“获得Acquisition”这个字上。“学得”派认为外语靠理性学习，“获 得”派认为语言能力应该是下意识自然获得的，理性学习不正确，尤其不能实现交流。这一字之争一直进行到今日。但此概念在进入中国时，居然被学术界翻译成了 “第二语言习得”，恨得我经常口出恶言。啥叫“习”呀？子曰：“学而时习之。” “习”不但是“学”，还是“反复练”。这简直完全违背了“自然获得”的初衷。这两天一直在犹豫怎么能在此文中在谈到该理论的中文翻译时改个名字，但又能让 专业人知道我在指什么就好。周末和母亲聊天，她建议我用“悉”字。“获” 即“悉”嘛，而且和“习”谐音。妙啊！老太太七十多可真不糊涂。在下就叫它“二语悉得论”了。老妈伟大！<br>　　<br>　　 “学得”和“获得”的交锋从表面上看是关于外语是“学习”Learn会的还是通过自然“获得”Acquire实现的之争，但实质上是两条路线的斗争。美国 语言学家乔姆斯基（Noam Chomsky）在50年代中以“国际语法”首先掀起了革命，冲击了结构语言学的支配地位，再由语言学泰斗克拉申博士(Stephen Krashen)，在七、八十年代将SLA推上了顶峰。从此SLA所向披靡，在与传统派的许多较量中节节获胜，根据地从美国传遍了欧洲和世界。传统势力对 老克的仇恨和惧怕使他们用劲各种手段攻击博士本人，甚至反动同盟们还专门建立了一个网站叫作Krashenburn.com。现在已做灰飞湮灭，剩下个别 遗老遗少把它搬到了“个人空间”中保存，估都计欠费上不去了。<br>　　<br>　　 克拉申所创立的SLA，是当今世界影响最大的语言学理论。尽管他的很多理论至今存在一定争议，但它的先进性，合理性，科学性和革命性是广泛得到认可的。许 多目前先进的语言学成果，都是在他的理论基础上发展而来。对他的语言学理论的了解，会让我们用科学武装自己的头脑，对掌握语言的实践有非常重要的指导作 用。很遗憾，过去我们中国的同学们几乎很少有听到过他的名字和理论的，甚至连有些外语教学工作者也没听说过他，以至于让许多“土棍”出来混世，这不能不说 是我们长期闭门造车的恶果。克拉申的理论朴实无华，深入浅出，初学者一点都不觉得深奥难读。在下到这里当然要介绍克氏的理论。大家读懂后，已经可以成为半 个方法专家了，大家之前提出的一些问题，看完就已经能有答案了。<br>　　<br>　　克氏理论<br>　　<br>　　 克拉申认为：简单来说，语言的掌握，无论是第一语言还是第二语言，都是在“可理解的”真实语句发生（即我们前面探讨的有效的声音，也就是可以懂意思的外 语）下实现的；都是在放松的不反感的条件下接受的；它不需要“有意识地”学习，训练和使用语法知识；它不能一夜速成，开始时会比较慢，说的能力比听的能力 实现得晚。所以最好的方法就是针对以上语言实现的特点来设计的。他的理论由以下五大支柱组成，被他称为五个“假说”。五个假说不分先后，但分量不同，下面 一一说明：<br>　　1.悉得——学得差异假设（The Acquisition-Learning Hypothesis）<br>　　　　<br>　 　　　成人是通过两条截然不同的途径逐步掌握第二语言能力的。第一条途径是“语言悉得”，这一过程类似于儿童母语能力发展的过程，是一种无意识地、自然而 然地学习第二语言的过程。第二条途径是“语言学习”，即通过听教师讲解语言现象和语法规则，并辅之以有意识的练习、记忆等活动，达到对所学语言的了解和对 其语法概念的“掌握”。悉得的结果是潜意识的语言能力；而学得的结果是对语言结构有意识的掌握。<br>　　<br>　　 该假设认为，成年人并未失去儿童学语言的能力。克拉申甚至认为，如果给予非常理想的条件，成人掌握语言的能力还要比儿童强些。他同时还认为，别人在旁帮你纠正错误，对你的语言掌握是没有什么帮助的。这一点中国同学值得注意。<br>　　<br>　　2.自然顺序假设（The Natural Order Hypothesis）<br>　　　　<br>　 　　　这一假设认为，无论儿童或成人，语法结构的悉得实际上是按可以预测的一定顺序进行的。也就是说，有些语法结构先悉得，另一些语法结构后悉得。克拉申 指出，自然顺序假设并不要求人们按这种顺序来制定教学大纲。实际上，如果我们的目的是要悉得某种语言能力的话，那么就有理由不按任何语法顺序来教学。<br>　　<br>　　初学时的语法错误是很难避免的，也是没必要太介意的。<br>　　　　<br>　　3. 监检假设（The Monitor Hypothesis）<br>　　　　<br>　 　　　一般说来，下意识的语言悉得是使我们说话流利的原因；而理性的语言学习只起监检或“编辑”的作用。换句话说，当我们开口说话时，话语由“悉得”系统 产生，经“学得”系统监检后成为“真言”而吐露出口。语言学习的这种监检功能可能在我们说话或写作之前，也可能在其后。<br>　　　　<br>　　　　在口头交谈中，人们往往没有时间去考虑斟酌语法。语法规则如果不是悉得而是背出来的，也用不上。但在事先准备的正式发言和写作中，语法的使用能提高语言的准确性，为演讲或文章增添色彩。<br>　　　　<br>　　 这一条可以说是克拉申对语法知识的用处做出的最大让步。<br>　　<br>　　4. 输入假设（The Input Hypothesis）<br>　　　　<br>　 　　　输入假设也是克拉申第二语言悉得理论的核心部分。只有当悉得者接触到“可理解的语言输入”（comprehensible input），即略高于他现有语言技能水平的第二语言输入，而他又能把注意力集中于对意义的理解而不是对形式的理解时，才能产生悉得。如果你的现有水平为 “i”，那么就要给你提供“i+1”水平的输入。这种“i＋1”的输入并不需要人们故意地去提供，只要悉得者能有足够的理解输入时，就自动地提供了。克拉 申认为，理解输入语言的编码信息是语言悉得的必要条件，不可理解的（incomprehensible）输入只是一种噪音。按照输入假设，说话的流利程度 是自然达到的，是不能直接教会的。<br>　　　　<br>　　 对输入假设的理解关键点就是comprehensible input “i＋1”。+ 1 就是在自己现有水平上加了“一点点”难度。换句话说，我们正是因为有了这一点点难度才提高的。其实大家寻找的答案，最主要的出处就在这一条上。我们之前对 一系列误区的分析，很多都能从这一假设中找到依据。我们今后掌握的最重要的技术就是不断自己创造这一条件。稍后我们详细说明。<br>　　<br>　　 另外有一个非常重要的“沉默期”(Silent period)的概念，是在这假设里引入的。克拉申认为，无论成人或儿童，在掌握说话能力前，都会有一个相当长的沉默期，直到听懂的量达到一定程度而有足 够的自信时，才可能说话。这一沉默期是正常的同时也是必要的。所以大家不要急着上来就想说，说的能力要来得慢，同时它是自然到来的。<br>　　　　　　<br>　　5. 情感过滤假设（The Affective Filter Hypothesis）<br>　　　　<br>　 　　　情感过滤假设认为，有了大量的适合的输入的环境并不等于学生就可以学好目的语了，情感因素起着促进或阻碍的作用，心理上的因素影响着他悉得语言的速 度和质量。这些因素是：1）动力。学生的学习目的是否明确，直接影响他们的学习效果。2）性格。比较自信，性格外向，乐于把自己置于不熟悉的学习环境，自 我感觉良好的学生在学习中进步较快。3）情感状态。在第二语言或外语的学习中，焦虑较少的人容易得到更多的语言输入。同样，心情放松和感觉舒适的学生在较 短的时间内显然学得更好。<br>　　　　<br>　　 这一假设有点偏语言教学经验谈，它的重要性也常被忽视。（后来人们通过实验发现，人在试图说外语而又说不出来时因焦虑而在脑部产生的电流，可以电死一只老鼠，可见学外语时的焦虑程度之高。）<br>　　<br>　　可理解输出 Comprehensible Output<br>　　<br>　 　 后来语言学家又发现如果仅有输入条件而缺乏输出体系，学生就会听得懂但说的能力差。广东话中有一句：“识听不识讲。”说的就是这一现象。于是斯韦恩 （Swain）在1985 年提出了“可理解输出理论”，即在输出时尝试做一些高出他们目前水平的练习。因为输出的过程可以促使学生积极寻找合适的形式来表达他们所要表达的意思，当 他们碰到一些不知该如何表达其意思的困难时，就会去努力尝试，在这个过程中他们可以自己尝试总结一些新的规则，从对方的反馈中总结经验，最终形成比较稳固 的体系。<br>　　<br>　　 这一理论是对克氏理论体系的补充。本人认为到此，“二语悉得论”框架到此已经比较完整了。<br>　　前面这些讨论， 一直是在学习语言方法的“战略”层面。大家最容易忽略“战略”而急着进入“战术”层。而战术上的偏差和错误可以弥补和纠正，战略上的失误会导致全盘皆输。 下面这句话是美国西点军校学员必须背诵的：“Every Battle Is Won or Lost Before It Is Ever Fought.”大家仔细看一下，可以感到自豪了。这是中国古代军事战略家孙子的名言。<br>　　<br>　　 有了“二语悉得“的理论结构，就可以制定战术了。聪明的同学这时已经自己独立做了，下面我帮大家搭个架子，并讲一些以往的经验和观察，大家可以共同探讨。 对与学习者来说，可以按照制定出的战术具体实践，对于教学者而言，要根据正确的理念设计课程和教学模式。我们先谈学习者的战术制定。<br>　　<br>　　实践篇<br>　　<br>　　“先听说，不读写”<br>　　<br>　 　 这是一个外国语言学家不太讨论（因为对他们来说是常识）而中国同学却常常误解问题，即听说读写之间的关系。对于中国同学来说，认为这四个方面的区别比较明 显，而且我们常常把“听说”归在一类，把“读写”归在一类。这和中文的特殊性有关。中文的“听、说、读、写”是分家的，大家会“听说”交流后，并不会认 字，要去“学习”认字。因为中国的汉字确实是需要通过“学习”的方法掌握，也就是主要用记忆的方法。不学习，汉字是无法掌握的（新的脑神经学研究还发现中 国人在辩认汉字时大脑使用了特殊的区域，以后再给大家介绍）。而英文，和许多其他的拼音文字一样，读音和文字是紧密相连的。会了“听说”，只要掌握了读音 规律，拼写自然就会了。所以严格来讲，外国小孩上学不学习“认字”，而是学“拼音规律”。英文叫做Phonics。（我们有时翻译成“弗尼斯”。）关于这 个规律，以后我再给大家详细分析。<br>　　<br>　　 我们已经明确了“建立英文思维主要是建立英文声音的思维”这个概念，结合“二语悉得”的理论，再根据母语掌握的规律，可以先明确这一理念：“先听说，后读 写。”大家笑了，就这呀！早就听过这个老生常谈（Cliché）了，而且知道母语学习都是这个顺序。其实很多人并不真正明白它的含义，也不照着做。它的实 际含义是叫你在你学会“听说”之前，不要急着学“读写”。所以本人说得过分一点，把它称为：“先听说，不读写”。到高阶段再说。我把著名语言学家保罗•比 斯勒博士(Pimsleur)的关于“阅读”应实现于“听说”的语言能力掌握之后的论述给大家参考：“Reading has been defined as “decoding the graphic material to the phonemic patterns of spoken language which have already been mastered when reading is begun.” To put it another way, reading consists of coming back to speech through the graphics symbols. In short, meanings reside in the sounds of the spoken language. Speaking a language is the necessary first step to acquiring the ability to read a language with meaning. ——Paul Pimsleur”<br>　　<br>　 　 对大多数中国同学而言，主动回避“文字”更十分必要。因为大多数中国同学，只要上到大学程度的，多半是“视觉学习型”（Visual Learning Style）。而“听觉学习型”(Audio Learning Style)和“动作学习型” (Kinesthetic Learning Style)的同学，一般会被我国这种教育体制淘汰掉。“视觉学习型”的同学，建立英语思维时，很容易受到“文字”的干扰，忍不住看文字，甚至先想一下文 字，再过度到含义。成了“声音”—“字型”—“含义”的路线。应该避免想到字型，直接将“声音”和“含义”建立联系。<br>　　<br>　　 关于学习类型的问题以后有机会再说，我会告诉大家如何测试自己的类型和针对不同学习类型如何调整语言学习，现在继续往下进入到“建立英文思维”的具体手段。<br>　　<br>　　“感冒药再来一包”<br>　　<br>　 　 小时候听江昆说相声，文革时有个草包医生给大家看病，无论病人啥症状，都一个方子，说：“全心全意为人民服务，感冒药一包。 揪下一个！”这种感冒药在掌握外语时可不能用。每个人的现阶段水平，所处环境，资源情况等不同，解决方法当然不一样，但宗旨是一样的，就是参考语言学的研 究成果制定解决方案。而设计方案是根据目前的级别高低而定。<br>　　<br>　　一般语言学家会把外语学习过程的能力阶段分为四到五个。简单点，我们分四个。<br>　　<br>　　1． 早期（Early Stage）或初始理解期(Pre-production/Comprehension Stage)。<br>　　2． 提高期(Upping the Ante)<br>　　3． 增长期(Getting Serious)<br>　　4． 高级期(Scaling Everest)<br>　　<br>　　每个阶段情况不同，每个人的英语现有能力情况也很不同，应用的方法也不同。<br>　　<br>　　<br>　　一、早期（Early Stage）<br>　　 如果单纯从零基础开始，早期（Early Stage）应该是一到两个月（由于英语与中文差异比与其他语言大，中国同学至少两个月，但也不应过长。我们的经验是一般中国同学会拖长时间。）具体实施方法建议如下：<br>　 　大量使用视觉辅助工具，直接建立“画面”与“声音”在大脑中的“联系”。最典型的手段有两个，一个是“看图识音”（不是看图识字，这是两个完全不同的概 念）。在看图片的同时听与图片相关的英语声音；另一个是我们以前谈到过的“全身肢体反应”(TPR)。在这一时期，有几个严格的要求：<br>　　1． 避免使用中文翻译，充分建立条件反射；<br>　　2． 不要试图说英语，只练听力；（还在沉默期内）；<br>　　3． 不要看任何拼写，把拼写的学习完全放弃；（不认识字母又和妨？）<br>　　4． 如果有外教参与，外教可多用肢体语言或用手画图协助这一过程，不要教课；<br>　　5． 不要怕听错，要放松和有信心；<br>　　<br>　　 这一过程结束时，应该达到1000个左右的词汇+短语量。（没问题，这个量大多数人在这期间内都达的到）。顺便说一句，以前学过一种外语的同学，再尝试这种方法时会出奇的快，而且发现跟以前学的其他语言一点不会混淆。<br>　　<br>　　下面说明“看图识音”和“TPR”的具体操作技术。<br>　　看图识音（简单说法，实际原理还是挺复杂的）<br>　　<br>　 　 为了“看图识音”，需要准备相当多的照片。要自己准备是有一定难度的。但因为科技发展到了今天，数码相机可以低成本，快速方便地拍实景照片，自己制作素材 册。我见过有同学做照片集，相当不错，缺点是背景有些乱。比如要拍一辆车，就拍一辆普通车，不要把背后复杂的背景广告牌等都拍进去，画面信息太多不利于形 成声音与图象的准确对应。拍了图象后还要想法加声音，还有按一套特定的原理排出画顺序和重复点。如果有外国老师就好解决，但没有外教就不建议自己制作了， 因为自己加声音有点难。所以我只给大家介绍使用原理和技巧，大家有兴趣的自己制作素材，嫌麻烦的去找这个软件“罗塞达石碑”。这个软件在中国没有销售公 司，推荐它没有为商家宣传的嫌疑，（有同学有办法免费下载）所以这是本人唯一的为大家直接推荐的“英语教学产品”。其他的再好都不再推荐，大家如果明白了 方法论，自己就会选择和判断了。<br>　　<br>　　 罗塞达石碑（Rosetta Stone）一词原指一块致使人类破解了古埃及文语言的特殊石头。1799年拿破仑远征埃及时，他手下的一个士兵偶然在尼罗河河口的小城罗塞达附近，发现 了一块石碑。石碑是黑色玄武岩，高 114 公分，厚 28 公分，宽 72 公分。这块石碑是公元前196年底比斯祭司为歌颂埃及国王托勒密五世即位而制作的。石碑上的文字非常奇特：上面刻的是古埃及的象形文字，中部是古埃及的俗 体文字，下面则是古希腊文，用这3种不同的文字记述相同的赞美词。于是法国的埃及学家商博良在19世纪初用它做“钥匙”破解了古埃及象形文字。用这个词命 名外语学习软件真是很妙。<br>　　<br>　　 该体系的设计原理就是典型的“看图识音”，当然远不止“看图识音”这么简单就能概括它。目前已经有几十个语言的学习系统了。它的使用过程是：<br>　　<br>　 　1．程序会每次给四个不同的画面，大家猜测听到的“声音”可能是哪个画面。如果是真是零基础，有75%可能会猜错。但没关系，猜错了也是猜了，系统会给 你一个回馈，让你知道是否对。正确的反馈声音美妙，同时出现一个小笑脸符号以鼓励；错误的话“嘣”的一声很难听，再给个小哭脸。猜错了换，最多四次，总会 对嘛。大家把自己的情绪调整好，准备随时接受鼓励。<br>　　<br>　　2．第二轮四个图象出现，会包含前一轮的一两个图象。因为你刚猜对过，所以有印象，用排除法，很容易猜到新声音对应的画面，然后进下一轮。<br>　　<br>　　3．该程序会自动按一个科学的重复和替换次序，不断重复，变换和推出新图片。你会越猜越快，越来越会猜。关键点就是随时观察图象，把它和听到的声音一起印在大脑中。<br>　　<br>　 　 但象所有的“单一”产品的通病一样，它把自己包装成一个“感冒药” ，试图用一个方法解决所有阶段的问题，当然是不可能的。而正是这一点，使它受到了广泛的批评和质疑，以至于降低了它的信誉。本人认为，它在我们说的早期 （Early Stage）中使用，甚至到提高期的开始部分，它是非常出色的解决方案。当然，正是因为它所犯的毛病，所以有些问题，不应该完全按它说的做，而且开始阶段 的“名词图片”太少了。另外大家在这阶段，不要试图说，同时不要打开字幕，把“说”和“阅读”练习部分统统跳过。大家最多在听时小声重复一下就好。再有就 是大家不要“想中文”。（所以建议大家尽量不用中文菜单的界面，它可选用英文界面）<br>　　<br>　　 这样几十小时一个级就能完。大家一定不要拖，非得“全会”不可那就麻烦了。觉得70分以上就好了。第二级如果从零基础直接这么上来有点费力，但有一点基础 的同学没问题。一共两个月，每天也就一小时吧，我们的（Early Stage）就成功了。（这要靠以前传统学法，非一年不可。）<br>　　<br>　 　 不是零基础的同学也强烈建议过一遍该系统，把自己脑子里的只有中文解释而没条件反射的单词这样在脑子里加上画面，形成思维。这一过程的脑神经原理是赫博 （Donald Hebb）提出的”Neuron Cells Fire together, wire together”。 大脑在同时接受到相关联的“声音”和“图象”刺激，会促使你大脑中的某个负责声音细胞和某个图象的细胞同时激发而同时将神经纤维结合在一起。（学术届对 “同时”有争议，有人认为是一先一后。也有人反对该理论。但在语言现象上，支持还是挺明显的。）<br>　　<br>　　 如果是有外教的条件，外教应该是应用这一原理和流程，辅助学生实现这一过程。效果是一样的，只是跟真人稍有趣些。在这一阶段，无论自学还是用外教，都要用标准发音。听非标准音的时候还没到呢。<br>　　<br>　　T．P．R<br>T. P. R. (Total Physical Response)<br>　　<br>　 　 TPR“全身反应法”是上世纪60年代（那个语言学“火红的年代”）由美国心理学教授James Asher提出的。他分析研究母语实现的过程，倡导把“语言”和“行为”联系在一起，通过左右脑的共同协调训练建立语言思维，达到掌握外语的目的。具体实 现方式是：通过语言学习者听到一个外语指令，用身体动作对它做出对相应的反应，从而使听者逐渐自然建立语言能力。最典型的例子就是当听到“Stand Up”就从坐位上站起来，听到“Touch your nose”就去摸自己的鼻子。应用更多的手势和简单实物教具，TPR完全可以展示动词的不同时态以及复杂的句子形式。<br>　　<br>　　T.P.R是典型的符合二语悉得基本理念的一个非常有效的教学体系。它的特点符合SLA的关于语言形成的各项假说和建议：<br>　　1． 主张学习者通过“可理解输入”先建立听力能力，不强迫学生开口说；<br>　　2． 降低学生紧张情绪；<br>　　3． 左右脑协调使用，共同实现语言能力（左脑负责接受指令，右脑负责做动作）；<br>　　4． 模仿真实的语言环境；<br>　　5． 不教语法知识，也不急于学读写；<br>　　<br>　 　 TPR一般需要由有经验的教师辅导学生完成，特别是零基础者。但有一些基础的同学可以在学友之间甚至自己（先把指令录下）完成。本人认为有一点基础的同学 也要自己尝试一下TPR。通过TPR的经历，可以很好地帮助建立英文思维。所以同学们不要认为：我懂Stand up的意思，不用做了。知道你懂了，但可能它只是一个记忆中的知识或中文的解释，它还不是你思维的一部分。直到重复过几遍，最后能迅速对指令不假思索地作 出反应后，才逐渐实现融入自己的思维。大家可以想象这对咱们今后听复杂句子的“反应速度”会有多么重大影响。<br>　　<br>　　 大家要注意“Response”的意思是作出反应，所以是听指令反应。最理想的状况是大家一起做游戏，听一个人发“指令”，大家都照做，要快，最慢的和做错的“出局”或“受罚”。<br>　　<br>　　 各国的对比实验和测试都表明，这种学习方式比传统外语教学方式效率高出几倍，还不用说它实现的是“外语思维”这一根本区别。<br>　　<br>　 　 但是（大家已经开始习惯了这种思路了），任何单一的方法都有适用范围，不能又成了“感冒药”。TPR的最大局限是很难表达抽象的事物和太过复杂的句式，甚 至复杂的时态。如果勉强为之，理论上可以实现，但反到降低了这种方式的有效程度，甚至已经超出了它的基本方式。后期在TPR基础上衍生出的TPR- B，TPR-O和TPRS都有类似的问题。但这几个变种在我们的下一阶段“提高期”中可以应用，我们下阶段再做详细分析。<br>　　<br>　　 本人认为应用TPR的典型词汇应该在1000个左右，不能太多。下面给大家一个TPR常用500词和短句表中的100个，大家先体会一下，更全的表以后给大家，或大家可在网上找。当然最好的是自己根据自己的环境制作一个。<br>　　TPR WORD LIST：<br>　　General Body Movements<br>　 　stand up，sit down，walk，stop，turn left，turn right，turn around，walk backwards，jump，hop， bend over，squat，walk 3 steps, 5 steps, etc.， face <strong>_ (face me; face the wall, face the door, etc.)，lift up your right leg (left leg, right arm, etc.)，lower your leg (left leg, right arm, etc.)， shake my hand，kiss me (on the cheek!)，make a fist，clap your hands，wave。<br>　　<br>　　Facial things<br>　 　smile，cough，laugh，cry，sneeze，open your mouth，close your mouth，stick out your tongue，put your tongue back in，wink，blink，wiggle your nose<br>　　<br>　　General verbs you can use with objects<br>　 　where is， touch，show me，pick up，put down，put it back (return)，drop， move，give me (give him)，take it back，throw，catch，turn over (flip)，put the ___</strong> on (under etc.) the <strong>__</strong>，push，pull， lift<br>　　<br>　　Kitchen table stuff<br>　　cup， plate， bowl， knife，fork，spoon， napkin / tissue， dish，big round serving tray，tray you’d serve tea or coffee on，table，chair<br>　　kitchen stuff<br>　　pan， oven，stove，sink，faucet，counter，cupboard，refrigerator<br>　　basic foods<br>　　flour，sugar，bread，tea leaves，coffee grounds，rice，nuts，yogurt，candy, etc.<br>　　drinks<br>　　water，milk，juice，soda，yogurt (drinking)，coffee，tea<br>　　fruits/vegetables<br>　 　apple， banana， orange， plum， grapes， fig， dates， raisons， lemon，pomegranate，tomato， cucumber， zucchini， onion， carrot， eggplant， small eggplant，potato， garlic， parsley， lettuce， grape leaves， celery， mint，cabbage, etc.<br>　　　大家已经能分析得出，“看图识音”和“TPR”正是婴儿掌握母语时所处的理想环境的“提纯”版。扔掉 婴儿在语言环境中听到的一些“无效声音”（其实那对婴儿来说，除了熟悉语音外，也是浪费时间的。比如听到大人之间对话的一些内容等），优化了理解条件，同 时提供轻松的氛围。所以从理论上，如果成年人能够应用这一系统，对一个新语言的掌握，不应该比婴儿慢。这两个系统实际是有很多相重叠的部分，简单讲“看图 识音”是从名词出发逐渐与“动作词”等结合，“TPR”是从动作词出发，逐渐结合动作中能够联系上的名词。其核心技术，就是提供“可理解的输入”让使用者 通过“猜测”而非记忆来掌握。大家一定要时刻围绕着“猜测”这一核心技术，猜错了都是进步的过程（既然是猜，必然有可能错，否则就不叫猜），千万不要因为 有可能猜不到就去看答案，那就又反回“学习”了。举例而言：两个老师都要教学生学会door 和window。前一个老师不断 让学生重复This is a door. That is a window. 而后一个老师问学生Where is the door? 让学生猜。这么一个简单的问题，两老师的教学方式不同，学生对语言掌握的机制天壤之别，实现的效果明显不同。（有的英语老师看到这儿该冒汗了。我曾经就 是。）两个都是很优秀的系统，建议大家都尝试一下。<br>　　<br>　　 在这一(Early Stage)阶段，大家是在很直观的系统中进行的语言思维训练，在此系统下，一般以前的旧习惯和自己的母语干扰的程度比较小，效果显著，学生也比较“老 实” 。很快，“小学”神速毕业了，第一阶段PASS了，就要进入第二阶段“中学”阶段了。大家的思想快要开始“不老实”了，系统的控制力也会逐渐减弱，成长的 “快乐”与“烦恼”都会同时大量出现。如果我现在是好的老师，更应该去引导大家，指出成长的道理和做人的原则，让大家根据自己不同的情况去分析和体会，而 决不能说“用这个方法！你应该这样做！”好了，下面就把这些第二阶段的“原则”先发给大家，然后再“引导”吧。<br>　　<br>　　提高期(Upping the Ante)<br>　　<br>　　（大家别急啊，还没写出来呢，需要些时间，先玩一下TPR吧。）<br>　 　　大家已经能分析得出，“看图识音”和“TPR”正是婴儿掌握母语时所处的理想环境的“提纯”版。扔掉婴儿在语言环境中听到的一些“无效声音”（其实那 对婴儿来说，除了熟悉语音外，也是浪费时间的。比如听到大人之间对话的一些内容等），优化了理解条件，同时提供轻松的氛围。所以从理论上，如果成年人能够 应用这一系统，对一个新语言的掌握，不应该比婴儿慢。这两个系统实际是有很多相重叠的部分，简单讲“看图识音”是从名词出发逐渐与“动作词”等结 合，“TPR”是从动作词出发，逐渐结合动作中能够联系上的名词。其核心技术，就是提供“可理解的输入”让使用者通过“猜测”而非记忆来掌握。大家一定要 时刻围绕着“猜测”这一核心技术，猜错了都是进步的过程（既然是猜，必然有可能错，否则就不叫猜），千万不要因为有可能猜不到就去看答案，那就又反回“学 习”了。举例而言：两个老师都要教学生学会door 和window。前一个老师不断 让学生重复This is a door. That is a window. 而后一个老师问学生Where is the door? 让学生猜。这么一个简单的问题，两老师的教学方式不同，学生对语言掌握的机制天壤之别，实现的效果明显不同。（有的英语老师看到这儿该冒汗了。我曾经就 是。）两个都是很优秀的系统，建议大家都尝试一下。<br>　　另外，这两个系统对在没有自然外语环境下教小孩子学外语是十分正确和有效的，家长们最好连 软件都不用，可以直接和孩子互动（顺便把自己也提高了）。只是对家长发音要求要准一些，不要求十分纯正，不是太差就好。以后提供给小孩听纯正的标准音的机 会，他们自己会修正。关于小孩子学外语的情况，我们在后面专找篇幅讨论。<br>　　<br>　　在这一(Early Stage)阶段，大家是在很直观的系统中进行的语言思维训练，在此系统下，一般以前的旧习惯和自己的母语干扰的程度比较小，效果显著，学生也比较“老 实” 。很快，“小学”神速毕业了，第一阶段PASS了，就要进入第二阶段“中学”阶段了。大家的思想快要开始“不老实”了，系统的控制力也会逐渐减弱，成长的 “快乐”与“烦恼”都会同时大量出现。如果我现在是好的老师，更应该去引导大家，指出成长的道理和做人的原则，让大家根据自己不同的情况去分析和体会，而 决不能说“用这个方法！你应该这样做！”好了，下面就把这些第二阶段的“原则”先发给大家，然后再“引导”吧。<br>　　提高期(Upping the Ante)<br>　　Upping the Ante？这可是第四阶段的词。没办法，Greg Thomson用这个词代表第二阶段，看着喜欢，继续沿用。<br>　 　 经过两三个月的“图象+声音思维”训练，已经掌握了1000个左右的“声音”，它们会在很多英语句子中频繁出现，而且大部分是句子的“骨架”。虽然这时听 整句子还不懂，但已经不再是完全莫名其妙的声音了。而且经过了TPR等条件反射式的训练，对很多“声音”的反应速度还是相当好的。这时，我们要开始提高 了。首先明确目标：<br>　　1． 要学会听懂单句子，建立整句的英文思维；<br>　　2． 达到能听懂简单的，可能是慢语速的整段英文；<br>　　3． 在提高期后期开始尝试简单“说”英语，实现简单沟通；<br>　　4． 开始引入阅读材料（不是学习如何阅读）；<br>　　<br>　　 另外还有，很小声地说：“要了解一点英文语法。”我们先谈这一点，省得有人激动。再重申一遍：是了解一点英文语法，它的一些语法现象以及与中文的不同点。这是本人对语法知识在整个外语掌握中能容忍的最大限度，还是因为我们中文造成的。<br>　　<br>　 　 我们中文的语法，是全世界各种语言中最简单的，这也是造成汉语是世界上好学的语言的原因之一。怎么汉语是世界上最好学的语言了？不是听说汉语天下最难吗？ 谁跟你说的呀？又是人云亦云的误区。大家可能认为中国文化丰富，语言古老美丽，想必很难。其实正相反，而是巧妙而简洁。另外以前说汉语的外国人少，感觉一 定因为它难学。其实并不是因为难，因为人家不爱学，中国太落后，学它没用。现在中国富强了，学汉语的外国人越来越多，大家发现身边中文好的老外越来越多 吧。<br>　　<br>　　 一个外国人，在中国生活一年左右，就能把“生存汉语”掌握的不错，听着还不怎么犯错误。而一个中国人同样到了外语环境下一年，尽管以前还学过多年英文，对 英语的掌握程度也比外国人低，而且还错误不断。这一现象，在与来华后许多掌握了中文的外国专家一起分析后，发现是由两个主要原因造成的：<br>　　1． 汉语对话是世界上最好学的，只要你不太计较“四声”的准确度，那学中文对大多数其他国家的人来说，是最容易的。在美国和加拿大的中国同胞们，如果有机会接 触摩门教的传教士（加拿大非常多。在街上看到两人一组白衬衫黑裤子的年轻人就是。他们教会要求他们为不同民族人传教使用对方的语言而不说英语），会对他们 身在美国加拿大的英文环境下从零基础，仅用半年多就掌握相当流利的汉语交流能力感到惊奇的。当然他们一定会跟你说是上帝帮他们的。尽管要认中国字时可就没 那么快了。<br>　　2． 外国人在中国能找到的语言环境非常特殊的而且是“非常理想”的，其中包含太多的通过语言环境自然掌握语言“有利条件”，而中国同胞在国外是很难找到的相似 的环境。一会儿我们重点分析为什么会这样并重点分析这些条件是，看我们如何能“提纯”出比这更好的条件帮我们掌握语言。所以外国人来中国后，在中文环境中 学中文比较容易。<br>　　听力内容设计<br>　　 这一时期听力训练的材料准备是最关键的问题，也是平时和同行讨论最多的问题。先把原则告诉大家：<br>　　 关键还是要提供“可理解性输入i+1”。这时，材料最理想还应该是有视觉辅助的，最重要的是其新增内容的出现（+1）是在我们现有水平（i）下 “可预测”(Predictable)的。<br>　　介绍一个比较理想的学习条件，它可以是如下形式：（我们先分析理想条件可以是什么样的，后面会分析如果在缺少资源的情况下怎么办？其实就是如何模拟或寻找理想条件的替代品。我希望最后能帮助大家的是达到自己会判断分析如何能让自己接近理想状态的能力。）<br>　 　大家的水平(i)已经有1000个左右的“声音”在脑子里了，“可理解性”的实现难度降低了。这时候，一个比较理想的学习体系可以由两个部分组成。第一 个部分，顺序也是在先，叫做“续列法”(Series Method)，第二部叫做“生成对话”(Dialogue Generation)。两部分可单独使用，一起用最理想。第一部分从某种意义上说，是TPR的发展和延续，需要外教的参与。<br>　　1．续列法 (Series Method)<br>　　外教用简单英语结合肢体语言，实物和实景向你描述你日常生活中很熟悉的一个连续动作，难度控制在有（+1）为大约为10%-20%的新词汇（用1000个左右的词汇描绘这类动作很容易做到）。这种连续动作典型的是：<br>　　如何泡茶？如何开车？如何用钥匙打开房门？如何刷牙等等一些生活经历的全过程，用全程动作和实物配合来边说边完成。<br>　 　比如如何开门：“First you take out your keys.（拿出钥匙） This is the key.（晃晃钥匙） Then you find the lock on the door. （找到锁）Use your key to unlock it.（用钥匙开锁） Turn the doorknob this way.（拧门把手） Then you push the door open,（推开门） enter the room,（进屋） and then close the door behind you. （回身关上门）。”<br>　　有第一级基础的同学，结合老师动作完成听这个难度没问题。又形象，又直观。这种训练进行一段时间，很快就能听懂各种与生活经验相关的简单句了。<br>　　上面这种训练还是单人的“独角戏”，达到一定熟练程度就可以进入接下来第二部的 “生成对话”(Dialogue Generation)。<br>　　2．生成对话 (Dialogue Generation)<br>　 　大家注意，“生成对话”不是自己试着对话，还是听人家对话。对话只是指从“续列法” (Series Method)中的单人独白式的解说，变成了有交流，有反应的实景对话。对话的背景先用“续列法”同样方式单人介绍完毕，让你已经对对话的程序和大致内容 了解，然后听对话。比如“如何打车”。先由“续列法”开始：First, walk to the street. Then hold out your hand when you see an empty taxi. If the taxi stops, you get on to the back seat. Say hello to the driver and tell him where you want to go. Make sure he has reset the meter. When you arrive, pay the amount shows on the meter and say good bye. Then close the door behind you. （当然不一定为此真打一趟车，可用教具模拟）然后听对话：一个人拦住了出租车，司机问“去哪里”，答“去…，离什么著名大楼或什么街很近”。路上人多车 多，司机颇有怨言，“周末会好些…”到站了，“多少钱？”“多少多少”“给你100”“找钱50”，“拿好发票，别忘了东西”“再见”。 这一对话可以再来一段，程序差不多，内容不同，句子不同。但由于背景熟悉，程序限定，所以很容易“预测”对话内容。几个回合下来，这种场景的对话就非常熟 悉了。生成对话的制作可以都用真人，但也可以找到一段对话的录音，再由外教把背景介绍和对话程序按上述方法表述出来加在对话前先听，再开始听对话。<br>　　这两部听力练习的原则大家要掌握的是：<br>　　1． 使用生活经验中熟悉的情景或经验能够预测的情景；<br>　　2． 尽量使用视觉或动作代替语言解释，全过程都用“亲身经历”完成；<br>　　3． 启始难度控制在第一遍听能到80%~90%能懂；<br>　　4． 注意听，不要试图说话；<br>　　5． 绝对禁止阅读和记笔记；<br>　　6． 可以把过程录音以后听。<br>　 　 美国、加拿大有一电视节目“Yan Can Cook”，一个著名华裔电视厨师Yan教大家做中国菜。他一边幽默地叨唠一边切菜、炒菜，几乎把每个菜、原料，制作过程的每个动作等，全部同步地用英文 仔细地叙述一遍，当时惊叹为理想的“可理解性输入”体系！只是没好意思介绍给周围人，怕他们说我拿他们开逗。<br>　　纽约人在北京v.s北京人在纽约<br>　　<br>　 　 看到了这阶段理想的体系的应该的样子，也就不难理解中国同学在国外自然英语环境中学习效率很低，而外国人到中国后很高的缘故。抛开两种语言特点的区别不 谈，外国人在中国是很容易找到这种理想的“提高期”环境的。大家都观察到的是外国人来到中国，在中国人中生活和工作，是非常受到周围中国人的关注和欢迎 的。尤其是咱们的年轻人，对外国朋友不但友好，还很愿意和他们交朋友，很多人以有外国朋友为骄傲。现在中国发达到了今天的地步，“崇洋媚外”的心态已很少 见，大家这样做的原因主要是对外国文化，外部世界和外国人感兴趣，甚至有人也希望能这样提高一些外语能力。于是，当这些外国人在开始听中国人跟他们讲中文 时，发现中国同学既耐心，又聪明，并努力调整自己的语言难度和速度，通过各种手段力求让听的外国人能理解（可理解性输入Comprehensible Input），而且从不嘲笑外国人的理解错误或很友好和开玩笑式地指出错误。（情感过滤Affective Filter）当他们能听懂或说对一两句中文时，受到的鼓励是如此另人感动，很多外国朋友都因此感到心里无比的温暖。没人给他们讲语法，也没人说你必须认 识中国字才能学中国话。典型的“续列法” (Series Method) “生成对话 ”(Dialogue Generation)条件随时随地都存在。有的外国人这样描述：身边常有不是一个，而是一群中国朋友。开始时觉得奇怪怎么他们中有的人讲的中文有的好 懂，有的难懂？后来发现是有的人善于自动调整和自己说中文时的速度和难度，而且通过各种方法巧妙的演示意思，所以才好懂。于是这些外国人很快先和这些“友 好的交谈者”接触较频繁，而随自己汉语水平提高后，才和其他人到后来花时间多接触。这种“友好的交谈者”在语言学中有个名词，叫做 (Sympathetic Speaker)或叫做 (Care-taker Speaker)。父母教婴儿说话时，不就是最先成为这样一个角色的吗？关于这个角色的任务我们下一阶段会集中论述。<br>　　<br>　　 再看我们中国同学到了国外，那里的环境是怎样对他们的。首先，美国加拿大的当地人大多并没有什么兴趣特地去交中国朋友，不以见到华人为奇，甚至认为华人的 英文好是应该的，因为当地的“华裔”英文是和他们一样好的。所以当他们见到我们中国同学时，并不调整自己的难度，而是用和当地人一样难度和速度的话跟你讲 英文，其中充满了大量听不懂的（无效的）成分（我们以前举过的房东的例子）。当他们发现你的语言程度低时，有的人是会调整一下自己的难度，赶快把事情说清 楚就走掉了，很少有人会耐心继续跟你用调整后的英语继续交流，甚至有些人连临时调整一下的耐心都没有。（以前每次在美国过海关时，总看到中国一些年纪较大 的中国父母们去探亲，在通关时言语不通很着急，每次我都赶快要求去帮忙翻译，有时一下帮几个。但经常发现的是，这些父母很多并不是一点英文都不会，有的甚 至是大学退休教授，可这些美国海关官员就是没有耐心稍微调整一下自己的语言或有其他动作图画等方式让这些简单的问话变得能懂。当我帮忙后，他们会假装客气 地对我说个谢，但那份不耐烦是写在脸上。）所以大部分的中国同学在国外是处在一个不适合自己的程度，有效成分少，但又没有任何辅助手段让这些“无效”的东 西变“有效”的艰苦环境中。所以这个自然的外语环境对掌握外语是很不理想的。当然不是一点都没用，每天还是能遇到一些“有效”成分的。（注意完全能听懂的 也不是有效成分，因为那是以前会的。我们指的有效成分是原来不懂，但通过观察，推断和猜测能“变得懂了的”部分，这才是理解输入的要素。）所以一般需要5 年的时间，有效成分加起来才够用。而在国外的中国同学的英语交流能力的另一个特点是：在一个语言阶段内有提高，然后就停住了。比如从几乎完全不懂到懂一点 基本交流（仍第二级内），或从只简单交流到基本能用英文工作（仍第三级内），很难跨几个级提高。原因当然主要跟国外自然语言环境有关，还有一个原因是这些 中国同学达到了一个能应付交流的某个程度后，就拼命用这个能力去应付生活，而且可以勉强应付。于是守住这种“舒服”的能力，不再去提高了。有人甚至不承认 需要再提高。经常观察到一些中国同学很自信地和外国人交流，讲的还很快。当遇到有难度的东西时，装作懂或忽略不听，继续急着往下交流，直到双方误会到实在 进行不下去的程度。这一现象令很多外国人觉得难以理解。把“语言”和“自信”也联系得太紧了吧。我想从这一点上讲，有些个别同学自己在态度上也有些问题 吧。<br>如果能创造这些理想的“条件”，学习效率大幅度提高，时间大量节省，那么学习外语绝对没有那么难，也不该那么难，更不应该把外语学习神秘化。<br>　　<br>　　 下面分析大家应如何寻找这样的理想系统。大家一定要明白道理才会选，所以在下还是不能偷懒，要认真给大家分析，大家也不要嫌烦。<br>　　分析清了上面的问题，大家可以清晰几个问题：<br>　 　1． 在自然外语环境下是否掌握外语快，跟具体是什么样的环境，提供给你的是什么难度，什么内容，如何通过各种“暗示”手段帮助你理解不懂的东西决定的。所以我 们已经学会不再简单地说“关键要有语言环境”，而是如何找到理想有效的语言环境的问题。很明显，国外的自然语言环境，对第二阶段甚至第三阶段的同学效率并 不高。（第四阶段的效率最高）<br>　　2． 除了“关键期”的区别外，儿童所处的自然母语语言环境，或者儿童是到了国外后的自然外语环境，实际跟成人的语言环境非常不同。儿童的自然语言环境实际上是比较多地符合我们上面提出的“理想”条件。<br>　 　稍微分析一下儿童的语言环境：首先他们有Care-taker Speaker用简单的语言，有耐心地指着实物同Baby讲话。“这是猫猫，猫猫。”（Comprehensible Input i+1, where i=0）下次又见到猫，大人马上抱着baby跑过去，一边指一边说：“看，猫猫。”婴儿的大脑原来一片空白，既没有对猫的认识，也没有“猫”这个语音。但 经过几次这样的经历后，“猫猫”这个声音是什么就掌握了。当尝试说的时候，如果说对了大人会欣喜地给以鼓励（Affective filter），这一正面刺激又强化条件反射。说错了不予鼓励，慢慢就弱化刺激。逐渐，语言能力开始增长，care-taker speaker也随着提高自己的语言难度。成人之间的成人语言对话对Baby来说，尽管他们在听，也有一点点其他作用，但在初期基本上是没有意义的（让 baby听新闻联播显然是无意义的）。设想如果不让baby见到猫，仅用解释的方法，那他们永远也不明白什么是猫。盲童在掌握语言时遇到的挑战可想而知， 家长们必须把猫抱来让他们触摸，他们只能通过触觉和听觉构建“猫”的概念并把它和“猫”的词相联系，但他们的这种能力是惊人的，反应出他们内心对了解世界 的强烈愿望。聋哑儿童遇到的挑战来自另一面，他们可以观察到事物，但没办法建立与声音符号的联系。他们的办法是使用手语，把事物的同某个手型代码建立联 系，建立特点同样符合正常人的规律，同样也有关键期。所以家长们要对有这些障碍的孩子有格外的耐心，抓紧时间帮助他们建立另一种符号进行的语言思维。语言 专家曾对海伦.凯勒的特例进行过分析。在既无听力又无视力的情况下，如何建立语言能力？分析结果是除了安.莎力文的格外耐心和海伦仍在关键期外，跟海伦并 非天生盲聋有直接关系。即和在一岁之前，她对世界的观察和语言的接触有关。尽管那时她还不会说话（Silent Period），但语言对她起的作用已经起了作用。关于在这一时期起的这种神奇作用，我们以后有机会再聊。<br>　　<br>　　 所以儿童到了国外，他们所处的环境也是和我们很不同的，比如幼儿园里的小朋友们大家在一起做游戏，有大量的图象和肢体语言等等。而相反，成年人的语言环 境，几乎是纯“对话”的环境，对话的内容和对话当时周围的情景大部分情况是没有关联的。比如同样谈论猫，成年人不需要指着猫来交谈，大家随便什么时候都可 以进行没有情景的纯对话（情景在对话者的脑子里，通过语言符号的交换，实际是交换了头脑中的情景，比如他家那个可爱的猫长什么样子，有什么行为等，你随着 听他的描述，展开想象，得到了他头脑中的描述的情景还原）。<br>　　<br>　　 我们讨论上面这些的目的是：既然成人的语言环境不理想，而且儿童的语言环境也是只有部分因素起作用（只是比成人多），那么理论上是可以“提纯”这些自然环 境中起作用的因素，紧密地编辑在一起，让使用者高效率地建立语言能力。答案当然是肯定的，这也就是我们上面层提到的各个研究层所努力的目的。只是由于第四 层“语言产品设计者”普遍与上两层“语言教育学”和“语言学”严重脱节，才造成大量的语言学习产品充满错误理念，直接影响使用者的学习效果和速度。在中国 这一现象由于大家对掌握语言的基本理念认识过底，这种脱节严重到了让人担忧的程度，出现很多拍脑门出来的“学习方法”。加上大家比较着急，往往没搞清自己 的情况和如何学习，就急着去实践“一个方法”，得出“就得背这个，就得练那个”的结论。而很多人尝试了各种方式收效不高时，得出结论“学外语没办法，就是 要刻苦，多听、多读、多背、多练”的结论，把是否练得有效完全放在一边，把学习外语搞得难了。（先不谈学语言，大家都熟悉的健美。比如要训练增长肌肉。如 果是“越多举重物”越好，那应该搬运工最健美。大家知道当然不是。应该是在“举适当重量的杠铃，每个动作8-12次，做几组”的条件下效果最佳。重量选择 一般是刚好能举这12次的。太轻了，多练多练多练，效果也差。太重，一次都举不起，完全无效。）<br>　　<br>　　第二阶段“提纯后理想体系”应该的样子的简单描述：<br>　　<br>　 　 这样一个系统，能在这一阶段语言难度下，由简单句组成的，对带有画面的故事情节进行连续的语言描述。故事最好是连续的，情节和画面的设计，应该是通过我们 的观察，现有语言成分的掌握，与实际生活经验的联系以及故事情节的发展和上下文的关联，“预测”得出每句话的含义。下面详细分析具体的技术环节。<br>　 　随着科学技术的发展，尤其是多媒体技术的发展，人工模拟真实情景成为了可能，甚至可以作到比真实场景的条件设计得更加科学合理。计算机辅助语言学习 Computer-Aided Second Language Learning (CALL)就可以从技术上实现我们的要求，提供这一理想条件。如果设计得符合语言学的要求，可能会比真人环境和教学好得多的。在真人教学中很难找到的教 具（比如猫，总不能抱着猫去上课吧？大象怎么办？）而多媒体实现这个太容易了。另外，在我们听真人说话时，有时听得并不十分清楚，但戴上耳机效果可就不一 样了。（而且一般人右耳分辨率高些。所以电话听着费劲时，就用右耳。有些人下意识一直在这么做。观察一下，有时被迫左手拿着手机时，一会儿非要用左手饶着 脖子往右耳上放。很有意思。）另外一般来说，跟多媒体学焦虑度较低（Affective Filter）。多媒体唯一的问题是跟它说话的时候它无法反馈，可理解性输出（Comprehensive Output）不好实现，但好在这一阶段初期，我们还不用着急说英语呢。国际CALL协会和许多专家对应用多媒体技术进行语言学习做了许多研究，下面把和 我们寻找系统最相关的最佳条件的技术细节列出：<br>　　1． 每个画面最好是静止的。因为人在观察画面同时听与其有关的声音进行理解时，我们大部分的注意力放在眼睛上（70%左右），而对听觉的依赖很低。固然通过画 面帮助我们理解了意思，但对耳朵的刺激程度是不够强的。而我们的眼睛在观察剧烈运动的图象时，是很不老实的，一直在追逐画面。这方面的理论很复杂，但我们 已经知道必须降低视觉的注意力而把注意力转移到听力上。最直接有效的办法是固定画面，变成了“连环画”式的情景。<br>　　2． 画面要求简单，信息尽量少，相素要低。因为即使画面静止了，我们的眼睛还是不老实。我们不可能盯住画面而不动眼珠，那样做除了一个点，什么其他信息都收不 到，所以眼睛必须不断地快速跳动来回“扫描”画面才能获取画面上的信息。每次眼睛跳动的时间大约是五百分之一秒。这样一来，我们又“累着”了，注意力还是 在眼睛上偏高，耳朵上偏低。所以只有通过减低画面的信息量，去掉没用的东西，降低图象像素，甚至要特意用计算机处理“模糊掉”背景图象，只要能明白是什么 环境就好。有的设计者用简单的卡通画或flash来设计画面，理念是非常正确的，只是到了比较抽象的词语，需要依赖人物表情的细微处去体会时，卡通画显然 不太合适，所以最好在人物的脸部用真实照片，同时人物的表情要做得比较夸张。<br>　　3． 故事情节应该是连续的，故事人物，背景，故事的发展要有很强的相关性。不必每个场景上述要素重新来过。连续的故事才有助于提高听者的“预测”能力。（top-down 原理，以后论述）<br>　 　4． 根据情况，有的声音要稍先于画面出现，让听者先试听猜测，然后再用画面“证实”，有的情况需要声音后于画面出现，靠画面带动理解声音。具体的技术相当复 杂，需要好的语言教学专家参与。这一点大家不用太深揪。凡事无绝对，不可能有100%理想的情况，我们也不必了解太细，否则又复杂了。<br>　　5． 难度非常缓慢地逐渐加大。每个小段落完成后，有简单的重复练习和小测试。练习的方式最好是刚听过的内容稍变个形式再重复出现，别完全是原句子。另外80分 万岁，打倒100分！得了100分只有两个可能，一是太容易了，需要调整难度，另一个是本来应该很快掌握80%，但为了从80到100，多花了几倍的时间 （跟把空调从26度改到25度需要多花一倍的电力一个道理）<br>　　6． 在这一阶段，应该使用标准发音，多种非标准音下一阶段才用。<br>　　7． 不要阅读，所以不必有英文字幕（当然更不能有中文字幕）。在该阶段后期才建议尝试说英语。但这阶段可以跟读每个句子，但不必尝试说。<br>　 　见到同行很高兴。先回一下楼上Khxia老师的体会吧。Khxia老师说的很中肯，而且有一点说得非常对，即不能够使对汉语干扰的情况变成“焦虑”，那 反而不利。您的许多观察和思考，也都是来源与实践的真实经验。我们做语言教育的工作者，应该总结和应用实践经验，但个人觉得应该对经验深入分析，结合前人 的研究成果，才能使经验有理性的升华而再回到实践，否则有时会，有时会产生一些偏差。在下的一些分析供参考：<br>　　1． 关于“英语思维”的事实，由于近年无论是脑神经学，语言学还是教学实践都已经证明是事实，已经争议不多。但在这一点上，有一个名言可以参考：“世界上唯一 绝对的事就是绝对没有绝对的事。”对将英语作为第二语言的人到底能将英语思维达到什么程度，倒是可以探讨。比如您举的演讲的例子正说明了这一点。即兴说话 没有英文思维是明显说不好的，但演讲不同。用母语演讲一般尚须提前准备文字，用英文当然也如此。而且因为我们的中文思维要流利和方便得多，用英文演讲前先 用中文思考表达的意思，再去转成英文是比先开始就用英文思考打稿子容易的多。写过英文报告的中国同学也经常先写个中文再开始英文。在达到极高的英文水平之 前，大部分人都可以这样做，无可厚非，但不能因此证明英文思维的错误。<br>　　2． 您的第二条中的所有分析在下基本都是支持的，以后在第三阶段时会有分析，有些结论跟您的比较相近。<br>　 　3． 关于第三点的观察，是事实但原因不能归于“与英文思维无关”。这一问题的主要原因来源与语言学中的“文化库”(Culture Bank)问题，是个很典型的问题，我们刚好在第三阶段时会重点分析。大家在第二阶段，还很少会碰到这类问题。我们才学到如何听整段英语描述“用钥匙开 门”，这种描述没有太多的文化差异。<br>　　关于“认为汉语对学习英语的正面作用被大大低估了，而负面作用则被高估了”的观点，更是分析十分的精辟。 Khxia老师分析到了“心理”因素，除此之外，还有因为各种语言的共性，语言经验等等许多的因素都支持这一论点。有趣的是，克拉申这一“自然下意识获得 语言”的倡导者，更是强烈捍卫母语对外语学习的重要作用。这一点我们以后也可再探讨。所以从这一点来说，又为成人的外语学习可能会超过母语学习的速度提供 了支持。<br>　　 另外这一点，Khxia老师说得也非常好：“不要浪费时间，根据自己的目标，一步步多学多练，量的积累达到质的飞跃。没有任何神秘，没有任何玄虚。”我们 现在所做的所有讨论，都是围绕这一主题的：如何让大家不浪费时间？避免进入误区，尽量减少无效的练习，才可以节省时间。一步步练习是省不掉的，我们是希望 大家不但要坚持练习，更主要的是要练习得有效。有苦干的精神好要有巧干的办法，我想天下许多事都符合这一规律，学语言也不例外吧。如果就一句话“大家刻苦 背书吧。”那大家的差异也就不会存在了，语言学研究人员也可以改行了。<br>　　 语言教育工作者对如何教书育人，应该是仁者见仁，智者见智。现在很多甚至偏远地区的小学外语教师，都在利用课余时间研究语言学的知识和应用，是十分另人钦 佩的。大家如果有兴趣翻看一下一些外语学习杂志上一些老师发表的文章就会看到这一现象。但同时也应该看到另一方面的问题，一是有些外语老师只凭自己的感觉 而轻易得出一些结论，出现偏差的可能性太大。至于有人完全不研究语言科学，直接拿自己的“体会”包装成“XX法”进行宣传甚至商业炒作，这明显是不负责任 的做法。Khxia老师对此的评论在下也是很支持。任何神话个人的行为，不论在语言学习还是其他任何领域，都是应该引起大家警觉的。 还有一个现象，即很多老师因为手边信息和资料有限，自己努力重复做了一些前人已经做过的研究和实验，对时间和精力的浪费是很可惜的。这一现象目前在中国其 他研究领域也有。在下到现在对很多理论和现象进行了分析，大多都是很多年前国内外语言学研究的现成理论，本人自己并没有自创什么理论，主要希望对这些现有 的理论和实践的分析，使大家对语言学习的轮廓更加明了，给学外语的同学提供方法论上的资料，也给更多比我还有经验的老师们提供一些参考，大家共同使外语无 论是“教”还是“学”变得更加容易和有效果。<br>分析完了以上最佳条件的一些重要细节，大家可能觉得有点复杂。其实回到根本上就是一个原则：能否提供 在本人现有水平上的“可理解性输入i+1”的条件。大家本着这一原则，就基本会判断如何选择了。而且上述这些条件，完全都能做到的产品几乎没有，但有一些 做到了比较相近。这一方面是由于语言学和语言产品设计的一些断层造成，但另一方面，即使有的产品对语言学原理应用得十分充分，在真正设计产品时，要针对大 多数人而不能根据每个使用者的个人特点来调整，也使得它无法完美。比如这第二阶段的体系，对完全零基础而是用我们上面推荐的第一阶段方式学上来的同学，和 以前有些“学习基础”而直接可以从第二阶段开始的同学，情况显然不同。但产品设计只能折中，不太可能同一内容设计两个路线。另外，语言产品的设计为了统一 结构和形式，甚至在各阶段的学习方式上几乎相同。比如几乎无一例外地在各阶段都有“读，说，写”的练习。这些练习不是不能做，而是时机未到，练习效果不如 放到后面好，甚至有的同学反而因此放慢了听力形成的速度。<br>　　 所以完美的体系不存在，只能接近。但大家应学会排除明显有问题的产品。给大家举个具体例子：看原文电视剧《老友记》是否好？答案是，在这个阶段不好。先不 说这一级的同学听起来难度偏高，大家发现《老友记》中的英文大部分是以生活中成人之间的“对话”形式出现的，跟看到的图象情景关联度不大甚至完全没关系。 比如大家一起讲笑话，并没有通过演员的动作完全把该笑话的细节和情景“表演”出来，而是大家一听，从语言上就听懂了，所以哈哈一笑。再加上这一阶段的同学 对美国语言中文化的成分也缺乏了解，所以这种语言的“可理解性”很低。（只对更高阶段的同学比较起作用，因为英文水平到那时，很多东西的理解已经不主要依 赖于图象了，甚至许多抽象的词和概念，本来就是图象和动作无法展示的，而是靠其他条件，关于这些我们下在阶段会讨论）。<br>　　 有的同学找到的一些专门教语言的教程，是有带图象的。拿来一看，两个老外在画面上你一言，我一语地在进行英语对话，这些也是典型的“无效画面”，因为从影片中完全无法根据图象推断和对话内容有任何联系，跟回家听录音差不多。<br>　 　 还有一些最近出现的对传统教材的改良设计，应用了右脑辅助的功能，主动采用增加“图画”的方法。方向是对的，但难度比较大。因为很多传统教材当初并非是为 能够使用图画和设计，所以加图象的时候有些困难，有的图画看起来甚至比杨子荣上威虎山带的联络图还复杂，这显然有点搞过头了。<br>　　 好了，目前就对该阶段分析的判断产品的技术，先讲到这里，以后可以再详细讨论。大家只要把握我们说的有效原则，同时又能凡事不绝对化，在语言教学产品十分丰富的今天，还是可以收集许多“有效”成分的。下面我们回到这一阶段的学习和教学继续往下进行。<br>　末世圣徒<br>　　<br>　 　 耶稣基督末世圣徒会The Church of Jesus Christ of Latter-day Saints，是基督教的一个特殊的门派，教徒们称自己为末世圣徒，简称ＬＤＳ。该教会的的俗名叫做摩门教，原因是该教会除信奉普通的圣经外，还有一本更 受该派教徒重视和信奉的《摩门经》The Book of Mormon。该教派于十九世纪中起源于美国。第一任教主史密.约瑟Joseph Smith，称自己在丛林中两次见到了上帝。上帝（后来又被改说成一个叫摩罗乃的天使）传给他一本写在金叶上的遗失的古老经典《摩门经》，并启示他翻译这 一经典。据说该经由古埃及象形文字写成。大家还记得罗塞达石碑故事里的法国人商博良吧，他正好在当时刚通过罗塞达石碑破译了埃及象形文，但显然这一消息还 未来得及传到美国，史密.约瑟就称自己在上帝的指引下，通过一个水晶球看过去，翻译了埃及象形文的经典。翻译完后，他说金叶原著被天使收回了，所以我们见 不到原著。《摩门经》主要讲述了犹太人的另一枝，数千年前来到了美洲大陆，建立了灿烂的美洲文明，修建城市，发动战争。战争一直持续到距今400年前。真 比欧洲的故事还丰富多彩。后来这里的人们惹恼了上帝，上帝将他们的皮肤变黑以示惩罚，于是他们很多人因此变成了皮肤深色的印地安人。该教会自称拥有教徒约 1000万，分布于世界各地，但主要集中在美国犹他州的盐湖城。该教派由于这本缺乏证据支持的《摩门经》和赞成一夫多妻制，为基督教其他教派所排斥，有时 还被称为邪教。但一般摩门教徒生活行为检点，也并不闹事，所以在信仰自由的美国与大家相安无事，特别又集中在偏远地区，到也乐得清净。所有教徒都会把自己 收入的十分之一奉献给他们的教会，所以据说该教会每年有十亿美圆的收入，所以很富有，大量盖教堂。大家如果看到顶上有个吹金色号角天使的建筑，那就是摩们 教堂了。<br>　　<br>　　 这样一个特殊教派想要在提他主流教派统治下发展新信徒，一定需要大批志愿的传教士。他们的办法相当有效。由于可以免兵役和保送上杨百翰大学（没错，大家熟 悉的杨百翰大学正是摩门教会大学），很多年轻人很愿意传两年教。于是19到25岁的年轻摩门教徒（男生为主），都踊跃报名当传教士。有意思的是，传教士们 都是二十出头，却被称成为“长老”Elders。“长老”们都先集中到一个犹他州传教士培训中心Missionary Training Center (MTC)进行两个月左右的培训，然后两人一组，奔赴世界各地去传教。传教工作的一个严格要求，就是必须使用当地语言而非英语传教。而这些传教士在开始培 训前，完全不知道可能被派往的国家和需要讲的外语，而且对这些外语是完全零基础的。要求他们马上到一个全新的国家或美国加拿大的外来移民中，而且还要用全 新的语言传教，听起来几乎是天方夜谈。但他们不但全都做到了，而且掌握外语的速度和水平十分惊人，甚至成为他们成功发展教徒的最有利的工具和“见证”。他 们会用这个能力告诉那些发展对象，是上帝和《摩门经》的力量帮助他们神奇地实现外语能力。这一能力对那些在美国加拿大的英语环境中苦苦挣扎而对学习英语几 乎绝望的外国移民来说，无疑是个重大打击，同时也是巨大的吸引。很多移民被他们拉入了教，一方面是为他们的语言能力所折服，另一方面是由于语言能力低，社 交圈小而很孤独所致。现在终于有外国人说着他们熟悉的语言和他们耐心的交谈和关心他们了，而且自己的外语仿佛也有希望了。所以这种方式上门传教对中国等国 的移民相当有成效，而相反另一个类似方式传教的教会“耶和华见证人(Jehovah’s Witnesses)”，因为没有这个能力，在传教方面显然落后。那么这些传教士是通过什么方式，在美加这种英文环境下，迅速掌握外语能力的呢？<br>先 看一下这些“长老”们的外语水平提高的速度：第一个星期，简单外语语音、语法知识的讲述。后几个星期，听说练习。九个星期后，能够达到“生存外语”的能 力，就出发了。半年左右，已经可以简单交流并尝试用外语传教。一年左右，已经达到流利的外语交流而独立进行用外语的传教工作。一年以后，已经开始带新人 了。用传教士培训中心总监Mark Jarman的话说：“一般我们的传教士在三天学的外语，比在一般在学校里两年学得都好。”副总监Gene Hill还公开在新闻发布会上宣部这一结论。这一言论在某一方面是过分夸大，三天学的内容量当然无法和两年相比，但另一方面是事实，即他们三天掌握的交流 能力，比传统学习两年都多。这些传教士外语掌握速度之快，水平之高，往往让美国中央情报局锁定和招募退役传教士去工作。美国中情局锁定这一目标人群了理由 是：1，他们一般是土生土长的美国人，以白种人为主，不太可能受民族因素影响而偏向其他国家；2，一般在国外呆得时间短，每天就是传教，不太有机会培养和 外国的其他复杂联系和被“策反”。作为在加拿大和美国学中文的传教士更是如此；3，外语水平高超，其他经过培训很难做到如此效果。<br>　　<br>　　外语传教历程：<br>　　<br>　 　 告别了家人，未来的“长老们”就带着行李来到了“传教士培训中心”报到，开始了两到三个月的培训。几万名学员在一起，除了每日的传教培训外，最主要的就是 外语培训。在开始学习时，大家并不知道自己要派往的国家。等到分配语言训练时才知道大概要去的目标。被分到学欧洲语言甚至亚洲部分语言的的学员都沾沾自 喜，知道将要到欧洲或亚洲遥远的国度去体验新奇。而被分配学中文的同学一个个愁眉苦脸。一方面知道中国不许传教，所以他们的命运是被分到美国和加拿大，负 责在中国移民中传教。这两个国家对他们来说，实在没有任何新奇感。另一方面，大家这时候还认为中文很难学。（等到一年后他们学会了中文后，他们就又都不这 么想了。一方发现中文没他们想象的那么难，另一方面，又都十分庆幸自己掌握了如此有用的语言。）语言训练的种类达50种之多。第一周，先对外语做一般性了 解，发音规律，语法规律等。对学中文来说，还要学一个汉语拼音。（汉语拼音对美国人来说，除了四声外，实在是非常容易的，几天就掌握了。因为我们的拼音是 从英语的拼音规律中借鉴来的。）然后开始听力训练。在有些培训中心还建有“语言屋”。曾有个学员兴奋的说：“传统课堂上可以学到的是复杂的语法知识，但没 人教会我上厕所如何问别人要手纸。”学员们需要大量听住在里面的语言教师在生活中如何使用该语言。很多都是退役传教讲外语，学员还规定必须经常和他们一起 做饭等。很多形式的TPR或Series Method得到普遍实践，入门效果十分明显。<br>　　<br>　　 掌握了“生存外语”，长老们上路了。开始时是跟着“老长老”一起访问教民的家。他们穿好整洁的白衬衫，黑裤子，胸前戴着一个写着他们的姓氏和职称的黑色塑 料牌，比如“Elder Smith”（中文就会被叫做史长老）。来到了移民的家，礼貌地敲开门，然后“老长老”面带微笑，用流利的外语说：“我们是耶酥基督末世圣徒会的传教士， 为您带来了上帝的福音。可以跟您谈一谈吗？”这些移民们，除非对教会极端反感，一般都会有礼貌地让这些流利地讲着自己民族语言的人进屋谈谈。毕竟平时可交 流的人不多。然后大家开始家长里短地谈起来。而这些几乎只听得懂零星几个字的实习长老，仔细地观察和聆听老长老与教民的交谈。交谈过程包括与教民聊家庭生 活，并经常可以通过他们的一些动作实现理解，比如一起看家庭像册来讲述家庭成员，一起作饭，逗小孩子玩儿和辅导小孩子功课等（Series Method 和Dialogue Generation）。天聊完了，老长老们开始传教。长老们用外语开始讲圣经，特别是摩门经，实习长老在一旁静听。尽管经书上的语言，这时对实习长老来 说难度过高，但一个特殊因素让这些内容的“可理解度”变得很高，那就是这些实习生对经书内容非常了解，只要能抓住几个字，就知道讲到哪里了。通过听单纯讲 述和听有关此话题的提问和对答，十分有效地迅速跨越了这第二语言阶段而同时进入第三阶段。（当然这里还应用到了几个语言学的其他要素，比 如：Parsing, Culture Bank, Top-down vs. Buttom Up等等，我们后面会详细讨论。）不用太多分析，大家已经发现他们就是能够充分使用我们分析的第一阶段，第二阶段中提到的各种“最佳条件”，所以速度快。<br>　　<br>　　偏要当文盲<br>　　<br>　 　 在此需要特别提到的是：传教士们在学其他大部分语言时，对文字的掌握而并太不费力，就算是放在实现交流之后学习，也没有引起大家多大注意。而在学习中文 时，大家一年多的时间达到了流利的程度，大部分人根本不认识中文字，因为他们根本不学认中文字，只学汉语拼音，一心就想着赶快成为汉语的文盲！翻开他们手 中的圣经和摩门经，居然是用汉语拼音写成的。这一点实在是太精彩了！这刚好反映出摩门教对外语实现过程理解的正确性，深刻性，也正是他们语言掌握效率高的 主要原因之一。这一点，也正是最值得中国同学深思的一个现象。因为中文的特殊性刚好能够说明这一点。大家发现无论是长老们，还是咱们身边的会讲中文的外国 人，很多都是不认识汉字的。（有人是因为学着觉得很困难，有人干脆懒得学。而学汉字的外国人在学习汉字速度上表现出明显的差异，正和他们个人的“学习能 力”有直接关系。）这一简单现象背后逻辑关系还真比较饶人，我们慢慢地解套。<br>　　<br>　　前提：语言的本质是思维，更准确地说，是以声音为主 的思维，所以语言能力，首先建立的是用这种语言的声音交流的能力；一般其他语言里文字的掌握，是通过学习“字母如何代表声音”来实现的对文字的掌握，除了 中文以外，都是声音的符号，本质上是不学习“认字”的；惟独中文是特例，几乎是世界上唯一在使用的象形文字，跟声音没有太多关系；而中文的识别，是需要通 过努力学习才能会的。非常不同于识别其他文字的原理，甚至使用了大脑不同的部位。<br>　　<br>　　结论：掌握任何语言，都应该先掌握其语音的交流，然后在学习文字；一般语言的文字，是可以根据语音的规律自然掌握，不需要学认字。而学认英文字，对中国同学来说，是实在太容易的事情。<br>　　车轱辘话半天，大家云里雾里，我们先看个报道吧：<br>　　<br>　 　 2005人民日报报道：教育部设在解放军306医院的认知科学与学习重点实验fMRI脑功能成像中心与香港大学合作的最新科研成果揭示，使用表意象形文字 的中国人与使用拼音文字的西方人的大脑中，语言障碍区不在同一个地方，中国人有独特的语言区。研究发现，使用拼音文字的人，常用的是后脑的威尔尼克语言 区；但使用中文的人，此区几乎用不到，常用的是前脑的布鲁卡区。中文的语言区更接近于大脑运动功能区。由于中文语言功能区与运动区紧密相连，要想学好中文 要多看、多写、多说，靠 “运动”来记忆，而学习英文则应注重营造一个“语音环境”，注重多做听说的练习，因为英文的那一个语言功能区更靠近听力区。现在很多人学了多年英文却是 “哑巴英语”，因为用学习中文的方法来学习英文是行不通的。该研究成果已在世界科技类最具权威的刊物美国《自然》杂志上发表公布。<br>　　这一报道已 经点明了中国同学不太了解英语的本质是“语音”这一情况（我们前一阶段主要在分析到底什么样的语音环境最有效和最佳），但可惜，因为我们说过上面的逻辑比 较饶，该报道就有一点饶住了，并没说完全明白。应该是这样说：汉语的本质也是语音交流，只是到了文字的部分，中国人才使用了特殊的大脑部位来记忆。学中文 “字”，需要多看，多写，靠“运动”来记忆。而英文的“文字”部分，常用的是后脑的威尔尼克语言区，而威尔尼克语言区更靠近听力区。所以英文无论语音和文 字，并不是靠多看，多写和记忆。所以用学习中文的方法来学习英文是行不通的。<br>　　<br>　　 大家都快看烦了吧，我们还是回到第二期的“悉得”吧。使用了Series Method 和 Dialogue Generation，听的能力逐渐提高。这时候千万不要着急，还差得远。能力有一定的了，但还太局限，到第三期才会增长和拓展。第二期的总时间跨度每个 人会比较不同。如果能够达到理想状态，专家分析应该是三到六个月可以完成。我们还是保守一些，至少六个月吧。在进入第二期的后段，我们可以开始可以试着说 一点我们熟悉的外语了（错了没关系，既不要着急，也不要忙着更正）。然后可以开始接触文字了。接触文字的目的完全不是为了学习拼写，而是在下一阶段，可能 学要文字资料帮助我们掌握英文理解能力。因为我们说过，英文是不需要学认字的，会说就会认，而且中国人都是认字高手。在我们就这一问题讨论之前，我们先讲 一下那个被历史遗忘了的人的故事吧。<br>　　<br>　　 倔强的拉丁文教师<br>　　<br>　　 在十九世纪的法国，有一个拉丁语教师，他有一个很普通的法国名字，叫做弗朗索瓦(Francois Gouin)。在法国教拉丁文教得好好的，突然在1878年的某一天，觉得自己应该学习德语了，于是决定停薪留职一年，到德国汉堡去学德语。当时正是在语 法-翻译法统治的时代，而且因为自己是学习拉丁语的大行家，于是他认为最好的学习德语的方法当然是背诵德语语法书和248个不规则动词啦。于是他把自己关 在一个房间里整10天。弗朗索瓦太有才了，10天的时间他背会了整本语法书和全部动词，于是他兴奋地奔向德国大学的课堂，来测试他的德语能力。“哎呀！怎 么一个字都听不懂？怎么任何语法结构都辨认不出来？怎么没听出一个刚背过的动词？”老弗没放弃，咱是语言专家呀，连希腊语都学过。想起希腊语的词根了，于 是老弗又背会了800个德语词根，当然还有各种相关词汇。他觉得这回至少“基本的德语”应该差不多了吧。于是他又跑到了大学课堂…“哎呀！怎么还是一个字 也不懂呀？”这回这个可爱而倔强的老弗终于放下他语言专家的架子，开始上街上学德语去了。可他的语言能力实在太低，啥也听不懂（无效声音），说的德语还遭 到了那些老外的嘲笑，于是羞愧难当，又回到的自己的房间里，开始翻译歌德和习勒的作品（够猛的）。结果还是“哎呀！”又花了数星期背德语对话，结果还是 “哎呀！”于是又花了几个月的时间，背下了三万字的德语字典，结果怎么还是“哎呀！”在德国一年期满，老弗没有学会说德语。他觉得好郁闷，还是啥语言专家 啊。<br>　　<br>　　 老弗回国了，见到了久别的故乡和亲人，也见到了一年不见的刚满三岁小侄子。一年不见，小侄子已经是个可爱的，一直说个不停的小话匣子了。记得去年自己出国 走的时候，他还只能咿咿呀呀胡比乱画呢，怎么才一年就成这样儿了。他一定有个学习语言的秘密！老弗开始意识到语言教师可能“都搞错了”，外语也许不该这样 学。于是他开始天天泡小孩子了，观察和分析他们掌握语言的奇特本领。倔强有时是有回报的，弗朗索瓦提出了续列法Series Method，一个直接从听力对话入手，不学语法知识，不背单词，不要翻译的方法。但倔强有时又限制人的发展。老弗不擅长推销自己，1900年的人们并不 了解和广泛使用他的方法，他的发明的续列法Series Method倒是被狡猾的同事贝立兹给“拿来主义”了，创立了著名的贝立兹学校而名利双收，结果很少有人还记得这位说“教师都搞错了”的老弗的功劳。但无 论如何，这位倔强的拉丁语老师的痛苦没有白费，一个比较合理的语言教学方法诞生了，弗朗索瓦向传统的语法-翻译法进行了一个人的战争。今天这场战争在全世 界已经取得了全面的胜利，但在某些地区至今仍阴魂不散。只要语法-翻译法还存在一天，弗朗索瓦那孤独的火炬将永不熄灭！<br>　　第二阶段的策略讲到此处差不多了。总之，这一阶段的主要任务是练习听力，而关键是找“可理解性的入。”这种输入可以来自老师，来自多媒体教程，来自外语环境的某些特定场景，等等。关键点再给大家总结一下：<br>　　1， 千万不要着急学文字，语言掌握的关键解决“声音”。<br>　　2， 不依赖语法知识和中文翻译，重点是“猜测”着听。<br>　　3， 参考Series Method, Dialogue Generation。<br>　　4， 在后期能听懂简单段落和简单对话时，可以模仿和重复一些句子并尝试自己说。<br>　　5， 最后，可以开始阅读一些与听到的对话有关的文字。注意一定要在听之后才能读，千万不能一发现听不懂马上去翻看文字来帮忙。<br>　　<br>　　 这一阶段的结束，应该可以听懂生活中简单的语言。如果非要与词汇量挂钩，应该是2000到4000。用知识量来衡量，应该也就是高中毕业左右的量，当然听力程度相对高。<br>　　<br>　　 在进入第三阶段之前，有两个迟早要讲问题先探讨一下吧。一个是单词，一个是拼写。<br>　　<br>　　最香、最亲、最爱，也最臭、最烦、最恨<br>　　<br>　　 大家对英语单词就是这一感觉，听着跟有的女孩子对老公的感觉似的。大家对单词的感情实在太复杂了。<br>　　<br>　 　 不过到了这里，谁还再问：“那到底要不要背单词啊？”或还在说：“背单词很重要！”就太不应该了。因为到现在应该知道“背单词”这一说法本身就存在问题。 背单词指什么？如果是指单纯背英文单词的中文解释，词性和拼写的话，那是在背知识，结果一定是哑巴英语，背多少又有什么意义？弗朗索瓦在100多年前都证 实过了。如果“背”下来的是这些单词的全部“声音”（可不是音标）和实物或概念的直接联系，那对交流才可能有帮助。但大家已经知道这种能力不是靠背来的。 但无论如何，单词是语言的基本组成单位，对单词有正确的了解有助于语言的掌握。<br>　　<br>　　 英文到底有多少单词呀？韦氏字典上是四十五万个，牛津字典上五十万个，英国伯明汉大学曾编纂的单词集有两千万个。这就是英语的特点，单词量巨大。那一般 Native Speaker掌握多少单词？有人认为是50000，这显然有问题。让一般Native Speaker考GRE单词，才20000以内，大部分人已经很困难了。一般认为Native Speaker应该在15000到30000单词量之间。跨度如此之大，跟个人受教育程度十分有关联。这一点很有意思：在中国，尽管个人文化程度有差异， 很少会出现在交流中听不懂对方词汇的现象（专业术语不算），而这在英文中是常发生的事情。另外在中文中，谁要是使用了一个文雅的词汇或成语，听者大多都能 懂，也没人会有意见。在英文中确不同，说一个“大词”，经常有人听不懂，不是让别人感到惭愧，就是让人反感，有人还会不客气地说一句：“English please！”。另外我们看中文小说，很少有不认识的字或词，但Native Speaker看英文小说，碰到不懂的词是常事。我们一般能有15000以上的单词量，应该算可以了。当然Native Speaker除单词外还掌握了大量的短语，这一点我们先不讨论。这15000左右的单词，出现频率和非常不同。某个统计资料显示:<br>　　<br>　　最常用的200个单词，出现几率或使用频率达10%。<br>　　<br>　　最常用的2000个单词，出现几率或使用频率达80%。<br>　　<br>　　最常用的前5000个单词，出现几率或使用频率达97%。<br>　　<br>　　最常用的前10000个单词，出现几率或使用频率达98.5%。<br>　　<br>　　最常用的前15000个单词，出现几率或使用频率达99.5%。<br>　　<br>　 　 统计的背景和条件不同，这一数据会有所不同，但大致比例如此。大家发现单词量越大，使用频率增长百分点越小。经常有同学说：“一般英语交流就使用5000 个单词。”从某种意义上说是有道理的。一方面是使用中97%的单词就是这5000个，另一面是假如你就流利使用就这5000个单词组合的句子，完成复杂交 流也应该没有任何问题，但阅读还有困难。<br>　　<br>　　 最前200个单词，虽然量少，使用率最高。这些单词是：hello, bye, good, bad, this, that, he, she, is, are, come, go, before, after, on, in等。这些词汇太基本了，使用频率太高，相信大家就算当初是背的，也基本上换成自己的思维了(he和 she可能还没有)。有的MBA课程上甚至还教给学生，在去国外谈生意之前，最好能掌握这类外语词汇，在社交场合很有用，特别是去日本，会得到格外的尊 重。<br>　　<br>　　 第二层2000个单词，应该是高中英语范围内的。如果能流利使用，已经可以听懂简单生活对话了。第三层的5000单词（包括那2000），是无论对话和书 面，使用最频繁的单词，达97%了。所以这5000单词，一定要建立“声音的思维”，否则交流困难。大家常说的“哑巴英语”现象的表现之一就是已经掌握这 5000单词的知识而没有建立“声音的思维”。建立方法我们已经在第二阶段讨论了简单形象2000到4000左右的单词。还有一些，特别是一些抽象的词汇 怎么办，我们到第三阶段讨论。<br>　　<br>　　该背时就背吧<br>　　<br>　　 从5000到15000这10000个单词，数量巨大，但使用频率低。要依在下的意见，您愿意背就背吧，不用管什么“英文思维”了。在下的“实用主义的情 节”，在此可以泛滥一下。凡事不可绝对化。出现几率这么小的词汇，建立英文思维的条件太不容易实现，强迫自己实在不必要也不现实，反而会降低效率。设想听 到的大段英语中，每100个词才出现三个是靠中文翻译“背”下来的词，就算先从记忆中提取，在脑子里再翻译一下，对理解速度的影响实在是太小了。甚至即使 没想起来意思，也基本上不影响整体理解。要是再抱着严格执行“英文思维”的要求死教条，那就有走上“极左”错误路线的危险。所以大家就开背吧。好消息是， 这10000个词汇，实在太好背了，最多三个月就好了。“背单词”尽管不能解决交流，但“背单词”本身实在是件容易事，怎么老有人喊难呢？俞老师的方法大 部分同学知道，而且很多人手里有老俞的“红宝书”。在下只是为重申“认为背英文单词难的观点是个误区”，再讲一下好了。这一讲，就又要讲革命史了。<br>　　<br>　　威廉大帝<br>　　<br>　 　 威廉于1027年出生在法国诺曼底城镇法雷兹。因父亲罗伯特于1035年意外丧生，威廉八岁时就当上了诺曼底的公爵。但从幼年起，一直身一个朝不保夕的危 险境况之中。长大成人的威廉，在与诺曼底的封建诸侯进行了长期连绵的战争以后，牢固控制住了他的公爵领地。后来威廉决定通过武装入侵英国来强行夺取英国王 位，于是1066年，在法国境内组建了一支海军舰队和一支陆军部队。 本来8月初就作好了启航的准备，但是由于呼啸的北风使出征日期推迟了。而正在此时，挪威国王哈拉尔德•哈德雷德横过北海入侵英国。英王哈罗德不得不把他布 署在英国的南部准备对付威廉挥师北上对付挪威的进攻，9月25日在斯坦福大桥之战中打败了挪威军队，挪威国王被杀。就在两天之后，英吉利海峡上的风向变 化，于是威廉率领数千军队，迅速穿过英吉利海峡。哈罗德没读过孙子兵法，竟以疲惫之师南下抗击威廉。1066年10月4日两军在哈斯丁斯大桥交战，威廉以 逸待劳，用骑兵和射手成功地击退了盎格鲁撒克逊部队，哈罗德国王自己首身异处，两个兄弟也被杀，剩下来的英国领袖中谁也没有能力招募新军或与威廉争夺王 位。当年的圣诞节，威廉在伦敦登上英国王位。<br>　　<br>　　 诺曼底侵略者虽然数目较小，但他们的征服，不仅为威廉及其继承人摘下了英国王冠，也深刻地影响了随后整个英国的历史。诺曼底征服以前的五、六个世纪中，英 国文化基本上是条顿族文化。诺曼底族本身就是北欧海盗的后裔，其语言和文化属于法国。因此诺曼底的征服起到了使法国文化和英国文化密切交往，结果在英国产 生了一种法国与盎格鲁撒克逊相溶的混合文化。而这一混合的一个重要结果，是发展了一种新的英国语言。大量的新词进入了英语之中，其数量是如此之大以致于在 现代英语词典中源自法语或拉丁语的词比从原来盎格鲁撒克逊语派生出来的词要多。而且在诺底征服以后的三四个世纪里，英语的语法很快就发生了变化，大体上是 朝着更简单的方向变化。要不是威廉大帝，今日英语可能同低地德语以及荷兰语只有细微的差别。威廉的一个人的行为，致使一种主要的语言以完全不同的形式存 在。有趣的是，威廉自己只会讲法语，而且是个目不识丁的文盲。（当然他的法语交流能力还是很强的。我们已经知道不会阅读并不影响语言能力）。<br>　　<br>　 　 这一历史对我们的影响在于，大量的英语单词变得十分好背，因为大多是由法语，拉丁语的词根构成的。了解和掌握这些词根，可以成倍加快背单词的速度。用俞敏 洪老师的话讲：“如果巧妙地采用词根记忆的方式，10000个单词应该在100小时以内解决，很多同学只用大约60小时。”我们大多数考过GRE的同学都 作到了，他们是在大约200小时的时间里背下了20000个新单词。不考G的同学根本用不着这么多，再有10000个单词就是高手了。简单重复一下词根记 忆的原则和方式：<br>　　<br>　　1， 大家希望掌握的英语单词中，80%以上由词根构成，而且刚好是大家现在不会的复杂词（2000个基础词以上）。越简单越不用词根，比如this, that, big ,bag.<br>　　2， 同一词根使用的单词在几个到几十个之间，会一个就会了一串；<br>　　3， 常用英文词根有几百个，大家只需要250个左右就可以了。而且这250个中，有大约100个大家已经认识了，可能没意识到；<br>　　4， 每天不要贪多，用30分钟就记100个，再用10分钟稍微看一下昨天的。三个月一到，10000个拿下，才花了60小时。<br>　　<br>　　 方式嘛，举一组词根大家玩一下吧：pel 推, tract 拉. pro向前或向上, er/or 人或机器, re再次或往回, dis 离开, com/con 一起, ex 出, at去。<br>　　Propel, propeller, repel, dispel, compel, expel.<br>　　Protract, tractor, retract, distract, contract, extract, attract. 十几个即使都是生词，三分钟足够了。<br>　　<br>　 　 社会上很多快速记单词的课程或书籍，大多是这一方法的变种。个别走得太偏的还有给每个单词讲故事，大家可千万别跟着跑。还有人讲什么词头，词尾，词中，词 节，词根，词缀，搞得好复杂，一个简单的方法，把250个小玩意分6类，实在没必要。当然有的词根和词的意思稍有一点远，但关联性还是比较强，稍饶一下， 还是很好记的。(大家可以参考蒋争老师那本258个词根9000多单词的那本英语词汇奥秘和俞敏洪的红宝书)<br>　　在这里赞一下俞敏洪老师对中国同 学加速背单词作出的贡献。大约18年前，中国同学还在为出国的各种英文考试中天文数字般的英文单词而发愁时，社会上并没有出现巧背单词的方法，只有蒋争老 师那本蓝色封皮的词汇奥秘孤独地摆在书店的角落，没有引起多少人的注意。俞老师在教TOEFL和GRE课时，率先在课堂上使用词根记忆法。当他开始告诉同 学们一小时内能背100个单词没问题时，课堂上发出的是哄笑。老俞耐心地辅导大家如何使用词根，并亲自录下词根的录音发给大家听。考虑到可行性，老俞说： 即使告诉你们每天就半小时，估计有些同学也不去做，还是我亲自在课堂帮大家背单词吧。于是每次课上加讲讲1小时，大约能讲七八十个单词，大家发现居然下了 课全记住了，于是信心大增，这种方式也逐渐开始在国内流行。俞老师后来又按词根排列，呕心沥血地编写了32000单词的著名“红宝书”。该书对单词的词根 记忆讲解既生动又简洁，绝不故弄玄虚，反映出优秀教师的素养和品质。比如centipede一词，老俞这样描述：“cent，centi是一百的意 思，ped, pede是脚的意思。Centipede， 100只脚的东西——百足虫——蜈蚣。”只要花半分钟看一遍这解释就记住了，几乎不需要再看第二遍。当然只要这两个词根别忘了，总共就那么多，而且使用这 些词根的词还很多，很不容易忘。比如cent，centi一百，有percent, century, centennial centimeter； ped, pede脚，有pedal, impede, expedition, pedestrian, pedestal<br>　　<br>　　 好了，关于“背单词”就先谈这些。大家千万别激动，还要要嘱咐大家的是：“背单词”并不提高您的交流水平，所以单词不应该这样背。但因为“背单词”本身很 容易，尤其是几千基础单词以上的单词，愿意背就背吧。而且这些频率低词，即使是用中文记忆的，也不太影响大家的听力和交流。比如就说centipede一 词。本人在国外居住，工作和读书许多年，从未在任何场合听到过这个词。出现几率太小了，centipede这一词估计也没有能够建立英文思维。但就算偶然 听到，因为知道它的读音，应该不会听不懂，在脑子里翻译一下也无所谓。但如果因为出现几率小而放弃认识这个词，还是不应该的。下面讲阅读和拼写问题。<br>　　<br>　　美国文盲4000万！<br>　　<br>　　 这是一个超级有意思的问题，也是一个超级昂贵的问题。美国每年就花费150亿美圆试图解决这一问题，而他们至今万万没有想到的问题是，这对中国人来说这一问题根本不是问题。我们来分析一下，之后中国同学该对自己的大脑感到自豪了。我们还是先回顾历史。<br>　　大家先看下面这段英文：<br>　 　“We set out early with Intent to Run round the sd. Land but being taken in a Rain &amp;it Increasing very fast obliged us to return. It clearning about one o’Clock &amp; our time being too Precious to Loose we a second time ventured out &amp; Worked hard till Night &amp; then returned to pEnningtons we got our Suppoers &amp; was Lighted in to a Room &amp; I not being so good a Woodsman as the rest of my Company striped my slef very orderly &amp; went in to the Bed as they call’d it when to my Surprize I found it to be northing but a Little Straw-matted together without Sheets or any thing else but only on Thread Bear blanket with double its Weight of Vermin such as Lice Feas &amp; c. Had we not have been very Tired, Ia, sure we should not have slep’d much that night. I made a Promise not to Sleep so from that time forward chusing rather to sleep in the open Air before a fire as will Appear hereafter.”<br>　　<br>　　 上面的拼写以及大小写错误不是我打错的，是原作者就这么写的。写这段文字的人，是美国的开国总统乔治.华盛顿。不用专家评判，大家也可以发现他老人家拼写 和认字有问题。专家对他的评价是典型“诵读困难”或叫“失读症”(Dyslexia)。在英语国家，“不识字” (Dyslexia)的问题至今仍是非常普遍，而且根本不是受教育条件差学的缘故。1988年美国“成年人识字调查”(National Adult Literacy Survey)简称NASL的结论是：21%-23%的美国成年人有严重诵读困难，只达到甚至低于Level 1程度。（Level 1的标准是指会写自己的名字，从一段文章中可以找出一个国家的名字，在驾照上可以找到有效期，在银行存钱时可以看懂存款总数。）这一调查意味着，美国有 21%-23%名副其实的文盲，而英语国家其他读写字有相对困难的人更多。大家熟悉的 “失读症”名人，除了乔治.华盛顿，还有丘吉尔首相，Cher, Orlando Bloom, Tom Cruise。大家在欣赏Tom Cruise屏幕上精彩对白时，没有想到的是因为不识字，他根本无法读剧本，全靠听事先录下的对白录音来记台词。他们可不是上不起学，而是无法学会掌握识 英文字。（当然，这些人的英语交流水平还是相当高的，很多还是国际著名的演说家，还靠口述写书。再一次显示语言水平的本质是声音的思维，可以完全不依赖阅 读文字，写作内容跟说话内容本质上是一回事。）<br>　　<br>　　 美国，加拿大，英国，南非等政府，为了消灭不识字现象，每年花费大量资金做各种研究。1992年克林顿拨出27亿美元作为该课题教育专款，并动员100万 教育人员参与。10年后布什政府用于此项研究的教育专款上升到50亿美元。解决该问题的政治态度，已经成为历届美国总统竞选时的重要砝码。但经过这么多年 高额经费支持的研究后，美国的文盲率居然还在25%左右徘徊，根本没得到解决。<br>　　<br>　　 美国专家们目前对解读英文字的结论是这样的：“解读密码的性质是个令人着迷的理论性问题。我们不知道它到底是什么，但是我们知道怎样去测试它：孩子们是否 掌握了该密码直接反映在他们是否会认读“假词”<em>的能力上…我们认为英文解读密码不是能教出来的，只能靠孩子们自己去发现。”这算啥呀？每年几十亿美圆的 结果就是这个：只能靠孩子们自己琢磨去！可有25%的人琢磨不出来呀！2002年小布什总统访问中国时曾在清华大学演讲，有一个同学当场尖锐地向他提这一 问题，小布一脸难堪地回答说：这是我们国家的一个危机……对我们国家来说，最悲伤的事实是，有相当数量四年级的学生存在英语阅读障碍……对于这些学生，他 们没有能力进入高等学校接受教育。……我们可以想象一个四年级不能阅读的孩子，到了中学同样不能阅读。如果一个在中学还不能阅读的孩子，高中毕业以后很可 能不会阅读足够的东西，所以也很难上大学。非常遗憾在美国会是这样一种情况。<br>　　<br>　　 我们中国同学可能不太理解这一现象，咱们继续分析。了解了这一问题，对我们中国同学学习英文会很有启发。<br>　　（</em>笔者注：“假词”的意思，如果真词掌握了规律会念了，比如会念pig，那么符合这一规律的“假词”也应该会念，比如gip，尽管这不是真英文词。这样来判断是否真的会认字了）。<br>　　<br>　　“字母读音法”大战“整体语言法”（Phonics vs. Whole Language）<br>　　<br>　　 英语国家对阅读和拼写英文字的教学系统，主要有两大派别：<br>　　1， 字母读音法Phonics<br>　 　Phonics指的是先学会英文26个字母，知道每个字母所代表的发音，然后通过建立英文字母(letter)与语音(sound)之间的对应关系，达 到看字母就可以直接读出该词的发音，解决单词会读，会拼的问题。（外国孩子不学国际音标学认英文，也决不是背下几万个单词的拼写！）<br>　　2， 整体语言法Whole Language<br>　　Whole Language有时又被叫做“Look and say”。理念是学习阅读者应该通过看英文字的整体来识别该字，而不是通过字母发音用声音“拼读”而识别字的。教学者应该提供学生大量阅读资料让他们通过多看，自然学会阅读和拼写。<br>　　<br>　 　 举例来说明吧。比如学认family这个英文单词，Phonics的办法是：通过分析该词中的每个字母应该发的音，family 中的6个字母，（在下只能用中文近似发音表示意思了啊。只是为了说明问题，正确音可不是这么读的，大家别挑眼。）f 应该读“夫”，a读“啊”， m读“摸”，i读短“伊”, l读“乐”，最后 y读短“伊” 。连起来读就是“夫，啊，摸，伊，乐，伊”，听着不是单词，老师叫学生：“再加快速度。” “夫-啊-摸-伊-乐-伊”。“再加快！” “夫啊摸伊乐伊”“再加快！”噢，有的学生读出来了，是family。呵呵，对许多外国同学来说，学这套技术太难了。而且有人最后还是怎么都读不出，到最 后仍然是“夫-啊-摸-伊-乐-伊”不知所云。<br>　　<br>　　 Whole Language的教师可不讲这一套方法，他们靠认为字母“凑”这也太难了，长字咋办？他们认为既然掌握语言交流都应该通过“避免学习语法知识和翻译”而 自然实现，那认字也应该象学说话一样“自然”掌握嘛！提供给学生整个单词family，告诉他们这是什么字，让他们通过熟悉字型和猜测自然掌握。结果也是 有人能做到，更多的人做不到。有人甚至指责Whole Language纯粹是让人“背”上万个英文单词的拼写，是不可能实现的。<br>　　<br>　 　 一直以来，美国各学校都是在使用Phonics法的。但因为效果不好，不但学生学起来很吃力，而且有25%的人学不会。于是开发Whole Language的学者开始鼓噪，要求Phonics下台，开始使用Whole Language。于是各种学术研讨，报纸媒体，政坛辩论，打了个不亦乐乎，成了美国的焦点问题。打得太凶，最后终于在美国最富有的加州开始试行 Whole Language。十年过去了，结果是“哎呀！”，加州学生的不识字率涨到50%了。于是Phonics奋起反扑，把Whole Language骂了个狗血喷头，许多曾支持Whole Language的学者和政治家都为此名声扫地，其中包括大家熟悉的克拉申博士。克拉申这个SLA的泰斗，终于因搅了这滩浑水而晚节不保。仔细分析老克之 所以被牵连，是怪他自己犯了“右倾经验主义”的错误。老克的SLA核心理念是反对“翻译语法知识”的理论灌输而自然下意识地建立语言能力，在取得广泛支持 后，对下意识自然掌握语言的理念坚信不移。等到了“学认字”这一明显不是自然形成的能力而应该是知识成分时，还教条地认为要“通过自然实现”，这显然有问 题。而Whole Language主张的就是自然实现阅读，跟这一教条理念相符，于是被老克大力吹捧。在Whole Language全面失败的今天，他仍不放弃此观念，每天在报纸媒体上发表文章支持Whole Language。本人在Krashen的 mailing list上多年了，收到他近几年匆匆写的文章，多是找一些Whole Language成功的个例来证明自己的观点，显然是掉进了confirming evidence的逻辑误区。该误区大家很容易犯。比如研究表明了一个普遍规律，但反对者忽略普遍证据，而只注意找一些能证实自己原来观点的个案来作为自 己的论据。比如说我们会经常听到这样的言论：“你们研究结果发现普遍是这样，可我认识的一个谁谁谁，他怎么就是那样的？你不对。”或者是：“我认识的一个 谁谁谁是这样的，所以我认为普遍规律也应该是这样的。”哎，老克老矣！历史上多少英雄人物都落得如此境地，看来年纪大了真应该更老成持重，没事就不要出来 多讲话了。<br>　　<br>　　 那到底问题出在哪里了？好，给大家讲一下。咱作为一个中国人，为什么会在认识英文字上成了专家了？其实给大家讲完，大家也就专家了。大家还记得前面提过的 语言专家Pimsleur 对文字阅读的评述吗？他的原话是这么说的：“Reading has been defined as “decoding the graphic material to the phonemic patterns of spoken language which have already been mastered when reading is begun.” To put it another way, reading consists of coming back to speech through the graphics symbols. In short, meanings reside in the sounds of the spoken language. Speaking a language is the necessary first step to acquiring the ability to read a language with meaning.”大家要深刻理解。他说的是：“阅读的定义是按说出的语言的声音规律进行图象材料的解码，而该语言的声音在阅读开始前就应该已经掌握了。 换句话说，阅读是通过图形符号再回到声音说话。简而言之，含义是存在于说的语言的声音里面。掌握一个语言阅读能力的前提，是必须先能说一个语言。”关于语 言的能力本质是“声音思维和声音交流”这一基本概念我们已经反复强调了，这里看一下文字和声音的关系。全世界大部分的语言的文字，都是通过字母符号来“代 表声音”或说是“表音的”（目前主要只有中文是例外）。而大部分西方语言，是通过罗马字符体系表音的。字母和语音之间是紧密相关的，有的语言是可以字母和 声音“一一对应”的。比如俄语，会读字母就会读俄语。但很多西方语言，比如法语和英语，字母和发音之间不能达到“一一对应”，但关系度很高。通过对这种关 系的研究学习，就可以很容易学会读文字。这就是Pimsleur想要表达关于文字阅读和语音的关系，也就是Phonics的思路。<br>　　<br>　 　 英语国家的统计数字表明：97.4%的英语单词符合发音规则，即英语音形之间有内在的phonics规律。可在实践上，却遇到了明显困难。其中的一个主要 原因是：人的大脑短期记忆有问题。关于短期长期记忆原理，我们先不讨论，直接看结论。比如还是上面那个family单词。Phonics的办法是让学生读 每个英文字母应该代表的发音。它的规律性很强。（辅音很好办，一般简单字一个辅音字母就发一个音，比如f。单元音一般也不太难，一般是两个音，一个是字母 本身的读音，比如常见的开音节词，另一个是变音。单元音就只有一个变音，我们注意一般没有第二个。比如a除了字母本身读音，还有一个扁嘴的“啊”比如 bag，没别的。大家如果念出了别的音，一般是错的。）family所以外国孩子很容易念出“夫，啊，摸，伊，乐，伊”来。但问题是这几个音很难连到一起 去。人的短期记忆一般一次同时只能处理四个元素，超过了就把前面的忘了。（大家还记得我们前面说过，如果一边听英文，一边在脑子里翻译中文，一般只能翻译 处理三到四个字就跟不上了的事吧，这儿同理。）有的人可以不自觉地把他们连起来了，但仍有很多人“夫，啊，摸，伊，乐，伊”了半天，念了前面忘后面，念了 后面忘前面，怎么都连不起来，所以有人只能勉强辨认和写四五个字母以下的字。（大家在看一眼华盛顿写的那段话）。但大部分英文单词是四个字母以上的。所以 Phonics有无法解决的问题。但Whole Language的出现，确实也是有人可以掌握通过辨认字型认字，但更多的人则是更摸不着头脑了。这回卡住了，没解了。以至于弗吉尼亚大学教授 Tom Estes这样说：“Whoever can solve this problem will be like Jesus walking on water.”<br>　　<br>　　中国人都是“字林高手”<br>　　<br>　　 这样一个困扰了西方专家多年的问题，对中国同学来讲，却根本就不是问题。中国同学有哑巴英语的，却几乎没有任何英文“失读症”的。不会发音是另一回事，凡 是学会的英文字，我们必然认得出来。这又是为什么呢？哈，其实跟我们的大脑结构特殊还真有关系。不过大家不要认为中国人天生聪明，种族主义在语言上同样没 地位。我们的大脑天生和外国人是一样的，但我们会说中文后，开始有些不同了。再学了中文字，就更不同了。我们前面已经跟大家汇报过科学家发现中国人在阅读 中文字时，使用大脑的不同部位，所以辩识中文字的原理与读英文不同。但其实我们中文的读音特点，也是不同的。这两个原因的同时存在，却让我们中国同学把 Phonics 和Whole Language两种能力，居然轻易地给一锅端了。即，无论是使用Phonics 还是Whole Language的学法，中国同学都全部可以掌握英文字的辩识（除非极个别真有生理和心理障碍的）而没有“失读症”，而且中国同学在认英文字时，最后是这 两个技术一起使用的。这是怎么话说的？先看Phonics，中国同学因为中文全部是单音节字，往往是一个辅音加一个元音，所以我们习惯这种把一个中文字的 整体发音当成一个“单元”。比如“发”这个字，我们习惯它就是一个音汉语拼音组单元fa，而不是两个f“夫”和a“啊”两个分开的音。所以当我们辩识 family一词时，如果使用汉语拼音Phonics技术，我们是把它念成“发”“眯”“力”三组音，而不会念成“夫，啊，摸，伊，乐，伊”。英语单词一 般都在四个音节以内，所以我们的短期记忆可以很容易处理。于是我们中文的发音规律，再加上汉语拼音的知识，使英文Phonics对中国同学成了不学而会的 系统。大家会汉语拼音，再稍微了解一下英文的发音规律（比我们的拼音稍微复杂一点点），认英文字实在是太容易了！记得几年前我在每次外出的时候，无法查家 里的email，打电话回家让老妈给念。老妈就按汉语拼音来念英文，每封信可听得是明明白白的。好了，Phonics搞掂。再看那另老外更头疼的 Whole Language，真是不用再和中国同学玩儿了。我们一辈子都靠辨认中文的形状认字的，行、草、隶、篆样样来得，凭形状认点儿英文字，简直太开玩笑了。 Whole Language根本就是我们的拿手菜。最后，中国同学在读英文字时，是两手一起使，尤其长字辨认上，我们才懒得用Phonics呢，一看字型就认得了， 速度那叫快。所以很多中国同学的阅读英文速度，是超出外国人的。<br>　　<br>　　 Family 这词不要把音分六组，分三组念fa,mi,li不就成了？这么点破事儿，难道老外就不能来中国看看吗？难道就没有中国人告诉过他们吗？其实有的。我们有位 中国人李博士，就曾经在美国推行过中国式的Phonics，效果非常好，两星期就治好了很多失读症，很多学生家长感激涕泠。但这触及了美国关于这一问题的 政治敏感。美国人花了多少亿都解决不了，怎么你中国人倒能解决呢？而且很多政治家还要靠“拿住Phonics研究权”来竞选呢（25%美国孩子有这问题， 家长们想必会支持高喊解决这一问题的议员），所以这一“中国式”的Phonics法到了市政府一级就被封杀了。有的人明知是好，也不能冒政治风险险推广。 学术问题演化为了政治问题，美国人只好自尝苦果了。<br>　　了解了一些有关背单词和英文拼写的一些背景知识，我们可做如是想：<br>　　1， 背英文单词本身并不难。用比较巧妙的方法，大部分英文单词很快可记下来。<br>　　2， 常用的5000以下的单词，对英文思维要求很高，要达到听到后马上反应的是该词表达的事物本身而非中文解释，否则听力障碍太大。<br>　　3， 因为5000个常用词以上的单词，出现的几率较小，就算用先中文记忆也没有太大关系，效率反而高。大家不要在这些单词上追求立即达到英文思维。熟悉后有机会再慢慢转就是了，不必钻牛角尖。<br>　　4， 英文字的阅读和拼写，对中国同学来讲是很容易掌握的，大家以后找个有关英文和拼写读音规律的解说，看一下就好，一共也就两三页。在开始阶段，要把精力重点花在掌握声音上，不要依赖读文字，也不要抄写。<br>　　5， 将来如果有哪个中国的投资者愿意去国外投资办教育，咱们可以跟李博士到美国去教他们识字去，给他们一些color see see。<br>　　<br>　　第二阶段小结：<br>　　<br>　 　 第二阶段大致要用6个月左右的时间完成。我们描述了一下比较理想的学习条件大致应该是什么样子的，以及为什么应该是这个样子。介绍了符合这阶段特点的 Series Method 和Dialogue Generation。介绍了弗朗索瓦的经历。了解了如何作到符合二语悉得的基本原理，实践起来只要尽量遵循这些原则就好。我们既不应该认为要跟外教去 “学”外语，也不要缠着老外瞎聊。如果有好的学习材料，能够提供符合这一阶段特点的有效输入，其实并不需要外教，尤其这一阶段还不用开始说太多英语，外教 的用处不大。我们也介绍了比较理想的材料的大致特征，供大家参考。现在好的系统越来越多，大家可以自己评判了，本人就不做任何产品宣传了。这一阶段的重点 就是听力。在这阶段需要听标准发音（还没到纠正口音的时候），而且尽量要带耳机听。不要急着开始说，也不要开始读和写。最后，我们再带着对单词量，背单词 和英文拼写的一些认识，其实已经开始进入下一个阶段了Getting Serious了。<br>　　<br>　　 对于教英语的同事们，下面提供些国外符合这阶段特点的教学方式供参考，有机会可以在课堂上尝试。<br>　　<br>　 　 我们介绍过TPR，知道它在入门阶段和有效。在课堂实践中，它是可以延续到第二阶段的。我们以前介绍的TPR中的主要方法，细分可叫做“TPR-B” （TPR with Body），主要是指听到英文指令后，身体做出反应。还有其他一些变种，都比较接近Series Method。<br>　　<br>　　TPR-O (TPR with Objects)<br>　 　 大家在桌子上放一些生活中的实物（Objects），可以是随意找到的东西，比如apple和banana。然后教师让大家听与这些物品相关联的动作和行 为等的简单描述。 This is an apple. Where is apple? 用动作指出。做动作表示Smell it, bite it, give it to me, roll it, peel it等相关句子。TPR-O的关键是将表示动作的动词和实物名词相关联用动作表述。<br>　　<br>　　TPR-P (TPR with Pictures)<br>　 　 教师用英语对一些照片或画面中的物品，人物，动作，情景等进行描述。这一方式有些象“看图听音”的进一步拓展。比如照片上一个男人在吃苹果。可以从 This is a man. Where is the man? He is eating. What is he doing? He is eating an apple.等不断扩展，直到可以更复杂地对其他背景信息进行描述。比如穿的服装，年龄职业，周围环境等等。<br>　　<br>　　TPR-S (TPR with Stories)<br>　　 由Blaine Ray首先在教学中开发使用的该方法在美国学校中被广泛采用。主要方法是教师用学生基本可以理解的词汇，通过动作和道具表演一个简单的小故事。关键点是要生动和有趣。也可以先让学生熟悉故事内容以帮助理解，然后再开始表演。<br>　　<br>　　 以上几种教学形式可以组合使用。关键点是不要使用中文解释。有很多老师自己开发了一些类似的方式，都是满有效的，而且学生学习兴趣很浓厚，比枯燥的讲课效果强太多了。<br>　　<br>　　十分感谢大家的支持和鼓励，也感谢大家提出的意见。在下会继续努力。<br>　　<br>　　<br>　　写在第三阶段开始之前：（现在看来本应该写在全文之前）<br>　　<br>　 　 从外部来看，学习外语的成功要素主要有三个，一是方法，二是愿望，三是自律。这三个要素中任何一个的提高，都会加快目标的实现。当然如果要在同样时间内实 现目标，三个要素其中一个要素的增高，也就同时降低对其他两个要素的要求。比如方法有效性提高，对自律和愿望的要求会降低。如果自律极大提高，对好方法的 要求会降低。但我们发现很多中国同学甚至老师由于不了解如何提高学习效率，采用的策略大多是鼓励大家提高自律，也就是告诉大家学外语没有捷径，只有刻苦。 仿佛只有遵循“头悬梁，锥刺骨”的古训才是正道。<br>　　<br>　　 其实很多的同学通过自己的方式成功地掌握了外语，我们身边也一定有这样的人。他们大多并不了解语言学的原理也成功了，但大家掌握外语的速度是非常不同，达 到的效果也不同。这些成功者在掌握外语的过程中，有的时期采取的做法非常有效，提高很快，有时期采取的方法效率低，提高慢。有的同学碰到效率低的时候比较 会分析总结，能自觉调整策略变得更有效。有的同学是不自觉地放弃觉得比较困难的方式而采用比较巧的办法。有的同学则是比较刻苦，碰到困难咬牙坚持过去了， 比别人多花了时间，但积少成多也最后成功了。更多的同学则是经过一些努力还是收效甚微，试过各种其他人的方法但总不成功，还在苦恼中甚至放弃了。已经取得 成功的同学，如果会分析总结自己学习过程中成功的地方，同时告诫其他学习者不要走自己曾经走国的弯路就好。如果只是告诉人家“就要多听多练刻苦学，我当年 就这么学的，没捷径，你想找窍门儿不可能。”显然是没有达到帮助别人的效果。当然，就算采用一个效率低的方法刻苦学，比如全靠刻苦“背句子”吧，最终也是 可以成功的，但需要的时间太长，也就是对自律要求太高。笔者和一些老师认为需要9000小时以上（刚看到“来星香”同学提到专家研究要10000小时，结 论差不多）。大家熟悉的钟道隆老师就是这样成功的。钟老师每天听英文广播平均10小时以上（有一段住院三个月甚至每天十几个小时以上），共听坏了17个收 录机，数个复读机和收音机，每天用A4纸抄写英文20页，抄满了整柜子。两年多的时间取得了成功。不算以前的基础，就这两年多也达到10000个小时了。 所以钟老师说学外语的“捷径”就是“刻苦”，把自己成功的经历叫做“逆向法”，寓意“逆水行舟”式的刻苦学习。钟老师真是非常了不起，他的刻苦精神值得大 家学习。但如果要求大家都这样学习外语，那能获得成功的同学肯定太少了。大家计算一下，学习10000个小时的概念是，一天一个小时，需要三十年的时间。 一天三小时，需要十年的时间。当然一天十小时，三年就够了。著名逆向学员李国锋同学，平时每天学外语五六个小时，周末十二三个小时，一年以后考托福拿到了 很高分，两年后外语水平已经很高了。但显然大多数同学不可能这样做。还是拿钟老师成功的例子来分析。钟老师的一个主要方式是听写。大量听广播。听广播本身 并没有对与不对。但听的方式上，有没有办法使效率提高而不用每天十小时？听写本身也没错，但是否真应该这样一直大量写？哪个阶段动笔最适合？钟老师告诉大 家不要放过每一个不懂的东西，而西方大部分教育专家告诉大家掌握语言时实在不会的先放过，到底哪个对？钟老师举了一个他学习中的事例：有一次听广播，他听 到了Khmer Rouge这个词，听了很多次怎么都听不懂（无效），问周围别人也都不懂，好像一时还查不到。这个问题一直困扰了他数个月，直到有一天，他看到一个卖化装 品的，产品品牌是Rouge。钟老师觉得好像是这个词吧，于是问销售员这品牌是啥意思。销售员说是红色的意思。当时钟老师就想了，“红色”，那可能 Khmer Rouge就是“Khmer红色”或“红色Khmer”。噢，一定是“红色高绵”！因为记得当时听的新闻是有关柬埔寨的，柬埔寨有红色高绵嘛。于是兴奋地 把此成功经历记录到自己的学习经验中。成功了，效率如何？这一词卡了几个月才懂，是否有办法不用这么长时间呀？又有一次听到tarmac一词，这回可无论 如何搞不明白了。后来遇到一位德国工程师，告诉他说这是“柏油碎石地，特别是机场上的地面那种地”的意思，才恍然大悟，几个月又过去了。那有多少是最终也 没听明白，又有多少是经过了很长时间刻苦才搞明白的？<br>　　<br>　　 作为独立的学习者，要求自己刻苦学习无可厚非，这种精神我们也应该学习。但作为老师如果要求大家这样学外语，本人认为是没尽到责任。再反过来用弗朗索瓦 100年前的眼睛看一下，明明儿童掌握语言并不痛苦，时间并不长，不学语法，不背单词，也不背句子，不抄写也不喊，不复习也不预习，而且小孩子智力，学习 经验甚至记忆力都不如成年人，那他们为什么学得既轻松又快捷呢？他们成功的道理是什么呢？通过研究他们的母语掌握过程，是否能帮助成年人加速掌握外语呢？ 语言学家和语言教育者的一个重要任务就是分析怎样做能把掌握语言的效率高，提高的原因是什么，从感性的观察和认识，到理性的分析和科学实验，总结出理论再 返回去指导实践。我们花力量分析的目的是让大家大致了解语言学家多年研究的成果，通过对掌握语言方法论的整体认识和误区的分析，来根据自己的具体情况指定 合理的，有效的学习策略，从而减少痛苦，缩短学习时间。从大的方面讲，只有这样才可能有更多的人成功而不是集中只在非常刻苦的少数人。<br>　　<br>　 　 在第一，二阶段，我们分析了一些有效的途径。在这两个阶段，我们提供给大家参考的一些具体方法还是比较明确的。现在能听懂一些简单英文，一些速度缓慢而且 短句子了。如果尽量不依赖中文翻译，就算是打好了基础，自然进入了增长期。在第三阶段的同学数量最多。到了这一阶段，要求大家按照一个统一的明确方法来提 高外语，不但是错误的，也是不可能的。正像我们上面刚提到的，大家需要根据自己的情况来制定高效率的学习策略。我们下面的讨论，主要是分析这一阶段的学习 特点和与这一阶段相关的语言学概念和教学经验，甚至具体案例分析，目的正是为让大家正确制定最适合自己的有效学习策略而提供理论依据，成功经验分析和失败 教训的分析。换句话说，其实无论是谁，所有成功的地方，都是自觉或不自觉地符合了语言学的原理的。（我们听这句话很耳熟吧，当年中学上政治课，总结历史上 革命的成功和失败的经验时，我们老师是这样讲的“其实这些革命运动中任何成功的地方，都是自觉和不自觉地符合和运用了马克思主义的基本原理。”用这儿挺合 适。我们就是要学会自觉地运用。<br>　　<br>　　 如果到了第三阶段，还在等着用听到的某一个具体“实用技术”来使自己成功的同学，这时也应该看出点眉目来了：并没有一个几句话就可以概括的实用方法，也没 有一个统一的方法。最好的方法就是，在对语言学的基本原理和对其他人掌握语言的经验的分析和理解的基础上，根据自己的具体情况和不同的学习阶段而制订的正 确学习策略。对语言学习的整体理解越透彻，这个策略就制定得越成功，尽量能够避免进入误区，成功所需要的时间和精力就会最少，实现的速度也就快些。当然对 掌握语言的整体理解并不是很容易的事，也就是我们为什么会讨论了这么多的原因。下面摘录二语悉得大师Rod Ellis在二语悉得概论中的一段关于研究悉得理论目的的话和大家分享：<br>　　<br>　　SLA is not a uniform and predictable phenomenon. There is no single way in which learners acquire a second language. SLA is the product of many factors pertaining to the learner on the one hand and learning situation on the other. It is important, therefore, to start by recognizing the complexity and diversity that results from the interaction of these two sets of factors. Different learners in different situations learn a second language in different ways. Nevertheless, although the variability and individuality of language learning need to be emphasized, the study of SLA assumes interest only if it is possible to identify aspects that are relatively stable and hence generalizable, if not to all learners, then, at least, to large groups of learners. The term‘second language acquisition’is used to refer to these general aspects.<br>　　增长期 Getting Serious<br>　　<br>　 　 这一时期的主要任务是语言难度和量增长。重点还是听力，但可以开始有针对性地说英文，同时需要进行阅读（但主要并不是为了学习如何阅读）。这一阶段结束 时，可以说已经能够进行正常交流和阅读了。（外企一般职位面试，出国求学，国外生活和从事一般技术型工作等可以应付。一般听英语新闻困难不大，看原版电影 可听个大概）。在这一阶段初、中期的中国同学数量比较多，但往往时间拖得过长，同时遇到的困惑也比较多。我们前面刚提到，尤其在这一阶段，每个人必须根据 自己的情况，制定最适合自己的学习策略。学习策略的好坏，直接关系到学习效率和成功与否。<br>　　<br>　　 如何制定有效语言学习策略的方法和技巧，是近年语言学研究最关注的课题。语言研究出现的两个趋势，第一个我们前面已经涉及，即外语学习跟二语学习区别逐渐 被缩小。本来一个是指语言学习者在国外的外语环境中学习目标语言，另一个是指在自己母语环境中学习第二语言。但研究者逐渐意识到随着社会的发展，二者之间 的差异逐渐减少，而两者的共性却是最令人为关注的问题。比如我们提到的出国人员数量的增多，而到了国外外语环境中的成年人，在自然语言环境学习外语时碰到 的困难依然很高，甚至很多都是跟原来在母语环境中的情况是相同的；而另一方面，在母语环境中的学习第二语言者，随着语言资料的日渐丰富，计算机技术的发 展，影视产品的增多，互联网的普及，在自己母语环境中接触多种形式外语表现方式的条件也越来越好，在自己国家掌握二语的形式和手段也越来越丰富。所以本文 根据这一情况和一些新的研究趋势，以及对在国外同学学习语言遇到的困难进行分析，不对外语和二语做严格区分，更着重分析共性问题，同时分析应如制定学习策 略。<br>　　<br>　　 从七十年代开始的第二语言学习策略研究，使语言教学者的关注从以教师为中心的“如何教”转变为以学生为中心的“怎样学”。最新的语言学习方法 Learner-Strategy Approach，更是一个以学习者为中心，了解每个学习者不同阶段特点，以分析和“制定学习策略”为核心语言教学方式。语言学习策略的研究，通过对语言 学习成功者和不成功者的大量实验数据，给语言学习提供了非常具体而参考要素，直接指导教师和学生成功制定语言学习策略。其实简单来说，还是要在遵循语言悉 得的原则的基础上，根据自己的学习特点指定最佳方案。个人的年龄，个性，文化背景，思维习惯，学习方式等因素都直接造成个体外语学习的方法的巨大差异。<br>　　<br>　　你是什么“学”型？<br>　　<br>　 　 每个人都有自己独特的学习方式。尽管二语悉得并不提倡有意识的“学习”外语而应该更多通过可理解性输入，下意识掌握语言能力，但“学习”能力对成年人掌握 外语的影响既无法避免，也不应该成为敌对因素。成年人正是因为学习能力强，所以应该充分利用该特点对掌握外语起促进作用。<br>　　<br>　　对学习类型有各种分类法，但简单来讲是这三大类型：<br>　　<br>　　视觉类型Visual Learner<br>　　<br>　　 学习者在借助看到视觉学习时效果最好。这种学习类型的人比例最多，高达70%。他们的一些外部特点是:<br>　　<br>　　很专心盯着老师的脸；<br>　　喜欢通过看文字，图表来获取信息；<br>　　很容喜欢通过“看”来“认出”文字<br>　　喜欢记笔记和用笔写出自己的思路<br>　　通过回想在某内容书页上的具体位置和形式来回忆信息<br>　　<br>　　听觉类型Auditory Learner<br>　　<br>　　通过听觉学习效果最好。这类学习者大约占20%。他们的一些特点是：<br>　　<br>　　喜欢老师用讲话来描述事情<br>　　喜欢对话，讨论和表演<br>　　通过“说”来理清思路和解决问题<br>　　通过声音和旋律来回忆信息<br>　　<br>　　运动类型Kinesthetic Learner<br>　　<br>　　通过肢体运动学习效果最好。这类人大约有10%。特点是：<br>　　<br>　　通过各种活动学习效果最好<br>　　长时间坐着不动很困难<br>　　使用动作辅助记忆<br>　　<br>　 　 关于上述比例是否在总人口中是否如此存在一些争议，而且学习类型本无优劣之分，但是我们的学校教学系统和考试方式很容易把运动型学生最先淘汰掉，纯听觉类 型者也有一些困难，所以视觉类型的学生数量较多。当然，很多人并不是绝对只有某一学习类型，或者是某一类型的学习者有时也采用其他学习形式，但运用各形式 的自如度明显有区别。<br>　　<br>　　 测试自己的学习类型方法比较简单，一般通过问卷调查就可以判断。请大家上网去测试一下自己的Learning Style。（Learning Style免费测试网站很多，一般都是英文的，但很好懂。有的20题，有的上百题，还细分小类别，但基本上是以上三个类别。找个容易的做就好了。）了解了 自己的“学”型，为以后选择学习方式做好准备，我们后面会用到。<br>　　<br>　　增长期听力特点和应对策略<br>　　<br>　　 句子长了，速度快了，内容多了，听力难度明显增大。而且开始出现一些抽象词汇，仅通过图像和动作已经不能完全体现这些内容的具体含义。这时解决听力的问题 必然要靠多种策略。听力困难不能简单用“不熟”或“单词不会”来概括。造成听力困难的原因主要有以下几个。当听力困难时，可能是下面其中一个问题，也可能 是多个同时存在：<br>　　<br>　　1， 内部声音库和声音辨别的问题：(acoustic reason)<br>　　听到的声音与自己头脑中建立的词汇库中的“声音”相对比，是否可以找到对应的“声音”。如果声音库里没有找到或自己的库中声音不准，就算认识这个单词的拼写，也是不可能辨别出这个声音的。<br>　　<br>　　2， 解析过程 (Parsing)<br>　　单个的单词可以听懂，但听句子时需要对听到的几个单词的组合的行意思的解析，解析过程出现难度。原来是主要通过视觉辅助帮助解析的，现在可能继续需要视觉辅助，但还需要其他方式的帮助。<br>　　<br>　　3， 文化知识库 (cultural knowledge bank)<br>　 　因使用语言的文化和知识背景不同而对理解产生的困难。大家不要把这里的“文化”概念想得太大，这里不是指“中西方文化差异”那种文化，而主要是指语言表 达方式的差异。比如 “You’ve lost me.” 不能用字面翻译听成“你丢了我。”有的中国同学还有一个习惯是总把这样的语言归结为“俚语”，把听不懂的短词组说成是“俚语”，甚至把英语中大量的类比和 比喻analogy，metaphors等也说成是“俚语”，说自己交流能力差是不会“俚语”不会造成的，这种理解偏差很大。（俚语是指地方性特殊土语， 甚至每个城市都不同。即使自己一个俚语不会，其实对交流也基本不会有影响。）<br>　　<br>　　4， 头脑中的“母语翻译”<br>　　习惯性在头 脑中用中文翻译听到的英文字，结果必然是跟不上正常速度。而且从上一条大家已经了解两种语言不可以逐字逐句一一对应翻译。如果再在头脑中转两次意思，就更 跟不上了。语言学家对母语听力速度测试表明，在正常说话速度四倍速度的情况下，我们还是可以听懂母语。但如果借助头脑中的翻译，慢一倍的速度都很困难。<br>　　<br>　　听力过程和认知策略<br>　　<br>　　 针对以上述问题，可以制定听力策略了。听力训练的原则仍然是需要遵循大量提供“可理解性输入i+1”的原则，不可以太难，也不可以全都会。然后可以采取以下听力策略：<br>　　<br>　　1，“从上至下”的听力处理 (Top-down Processing)<br>　 　 从上至下的方式是在听一个听力内容前，先对整段内容的题目，大致内容做了解，甚至可能是自己以前非常熟悉的内容。这样做有助于听者对全文的理解而不至于 “迷失”，同时可以根据听懂的部分去“预测”其他不熟悉部分的意思。这要求听者应用自己的生活经验，文化背景和知识参与“预测”过程。在这一点上，成年人 有明显的优势。我们前面提过的传教士，由于对经书的熟悉度高，“从上至下”地理解听到的经文讲述甚至通过阅读（如果是拼音的文字，所以还是可以有声音）内 容，提高“可理解性”。我们有的同学发现在听熟悉的话题或熟悉的新闻时，听力困难比较小，再转到体育频道或其他题目时，同样的语速就不容易懂了，是同样道 理。<br>　　<br>　　2，“自下而上”的处理过程 Bottom-up Processing<br>　　 自下而上的方式主要是通过听单个音到单个词的声音的辩识，再到字组的解析再到整个句子的理解。是从部分到整体的处理。听懂单词是这一过程最重要的部分。在 初期听力程度较低的同学，往往对“自下而上”的处理过程比较偏重，同时对语言的清晰度，背景环境噪音和语速等要求比较高。<br>　　<br>　　 往往Bottom-up的内容难度一般需要比Top-down低。Bottom-up更注重细节的识别，而Top-down更关注对全文的理解能力。我们在练习听力时，应该同时运用以上两个策略。<br>　　<br>　　应用实例：<br>　　<br>　　问：听英文广播学习效果是否好？<br>　　<br>　　 我们已经会分析了。听广播本身并没有好坏之分（当然您可千万别苦练听写），而且Audio Learner也很适合这种形式。关键是是否有足够“可理解性输入”，所以需要具体分析。基本经验是：<br>　　<br>　　1， 听力材料的速度和句子难度是否适合？如果能理解一半以上才可以听，否则基本上是在浪费时间。原则上听不懂的东西应该是“无效输入”，永远也不懂。<br>　　<br>　 　2， 在适当的难度前提下，如果又对听的话题或内容非常了解，而且从前文可以预测后面的意思，语音清晰（建议带耳机），速度适合，那会是比较有效的方式。特别是 有些同学平时就喜欢听新闻，对时势的变化很熟悉。听英语新闻时，不久前刚听到的头条新闻可能一天之后又以另一非头条，而简短形式重复出现，效果更好。最好 能快速慢速结合听，这样做效果显然比较显著。<br>　　<br>　　3， 没懂的部分别着急。在调查过很多用这种方式提高听力的同学的普遍经验是，个别没听懂的地方不要急，先放下，也许换一种方式再出现时就自然理解了。如果出现 次数很多，再想办法查一下吧，否则就放过。其实母语学习的过程也是如此，怎么能每碰到一个不懂的就非过不去呢？非都搞懂并没什么害处，可学习效率就没了。<br>　　如果做得不得法，很多同学听了很久，提高都不大。有的同学没事儿就开着英语新闻听，其实几小时过去了，几乎没有听进去。<br>　　<br>　　问：看原版英文电影好不好？<br>　　<br>　 　 原理与上面的问题相同，还是要注重“可理解性输入”。电影比广播的优势是有连续的情节，发展的故事主线，视觉辅助理解和趣味性，有助于对语言的理解。比如 警察拔枪 “freeze!”罪犯僵住了。 “Drop the gun!” 扔枪了。“On the floor!”趴下了。 “Cuff him!”被拷了。“Read him his rights!”实习警察过来宣读：“ You have the right to remain silence, anything you said….”一连串的可理解输入。缺点是一般影片大部分对白难度偏高，跟在国外自然英文环境的感受有些象，不可理解的无效成分太多。所以关键点又是如何 通过以上策略提高“可理解性输入”上。基本经验是：<br>　　<br>　　1,尽量找动作多于坐在那里说话的影片。大部分老片，情景喜剧和法庭辩论等影片多半没有办法提供有效的视觉辅助，大量是纯对白，就能看到演员的嘴在动，不能帮助提高理解。<br>　　<br>　 　2,对于大部分Visual Learner来说，一个重要可行手段是看电影前，先提前读英文剧本（很多可以下载）。这样会大幅度提高听力的理解性。这里阅读的用处开始显现，主要是在 帮助听力理解，不是在学阅读。注意的是要提前读，不会的可以问或查字典。阅读如果有困难，也先放过，不要停下来仔细研究剧本中的难点。<br>　　<br>　　3,开始看影片的时候不可以一边看一边翻看剧本，当然也不要开英文字幕，否则会养成依赖看字的习惯，特别是Visual Learner。<br>　　<br>　　4,最好是同一个电影看几遍。在看某个影片熟了之后，甚至可以随电影同时念叨台词，能象我们小时候跟着电影里老松井那样同时念“李向阳又进城啦？”那样就更好了。<br>　　<br>　　5,任何时候千万不要打开中文字幕。一方面是会依赖中文，不利于建立英文思维，另一方面中文字幕的错误实在太多，甚至连电影院放的原版电影的字幕中的低级错误都不少。<br>　　<br>　 　 这里顺便说一下家长给小朋友看英文动画片是否好？判断原则是一样的。一般的原版动画片语言太复杂，那是给母语是英语的人看的，并不因为是动画片语言就简 单。而且近几年动画大片的语言都非常复杂。即使对成年人来说，大部分也都应该算是作为我们第四阶段的语言教材（比如Finding Nemo, Madagascar等）。所以要找那种一看表演，不听英文都能大致知道在说什么内容的片子。否则小孩子根本不能理解，并很快失去兴趣。<br>　　<br>　 　 以上听广播和看电影的两种方式被大家采用的非常普遍，以看电影的形式比较容易让大多数人接受，而且适合多中“学”型的人。但运用的是否符合“悉得”原则和 策略，对学习效率有成倍的影响。如果没有辅助和准备就开始听和看，大量时间都是在“无效的声音”中度过，非常浪费。另外不要动笔写的主要原因一方面是效率 高，最主要的是防止学习者，特别是Visual Learner容易养成“声音――文字――含义”的认知路线，而应该直接将“声音――含义”建立关系而避免文字。在看电影的形式中，因为速度和图象场景的 影响，比较容易不自觉地在运用英文思维，习惯比较良好。<br>　　<br>　　 应用英文思维本是一个已经不太被争论的问题，在前两阶段应用TPR， Series Method等方式学习对英文思维建立是比较明了的，但到第三阶段就比较复杂了，既有抽象词汇，又有自己母语经验和通过母语获得的知识参与，情况比较复 杂。本应继续讨论建立英文思维的过程和经验就好了，结果发现很多同学在英文思维这件事上还存疑，下面就语言思维问题多罗嗦两句吧。<br>　　<br>　　双语和多语者如何对思维语言选择　Choosing the Language of Thought<br>　　双语和多语者如何对思维语言选择　Choosing the Language of Thought<br>　　<br>　　什么叫做“用语言思维”？<br>　　<br>　 　 语言学在“语言思维”的课题里，我们仅可以讨论“用语言做载体的思维”这一层面，包括用默想，用语言声音思考和自言自语。因为思维本身很复杂，而且不单纯 是“语言的思维”，有图象，符号，感觉等非语言的成分，有时没有语言，有时还会是在“半语言状态”（quasi-language）等各种“内语” (inner speech)状态。但使用语言的声音的思维(think out loud)，不但被大家明确意识得到，同时可以在语言交流的现象中观察到。当然，某种语言的能力不同，使用该语言的思维程度会不同。我们前面讨论过MIF 和语言条件反射，这两个与思维有关的问题大家可以回顾一下。其实语言的交流，就是将一个人的思维用语言符号传递给接受者，接受者将其映入自己的思维再现发 出者的思维，除抽象的概念的思维外，其中也经常包括比较容易观察的对所描绘图像的再现。<br>　　<br>　　 举一个与MIF相关的现象的例子。比如听到“来人身高八尺，面如重枣，三绺须髯胸前飘洒，身披金甲绿罗袍，跨下赤兔胭脂马，掌提青龙偃月刀”。说者是在试 图传递这一具体和生动图像，而听者也在通过语言描述接受这一生动的图像，这样的语言描述的作用是使形象具体化，有戏剧效果，也比较有故事性。如果仅说“关 羽来了”，听者也可以接受该思维表述的含义，其实听者也知道这个关羽的形象是红脸绿袍骑BMW拿大刀，但这时仅有一个飞快闪现的MIF，还是关羽形象但迅 速闪过未清晰化，思维概念被接受了，形象传递了，交流实现，只是形象并未具体化，缺乏的是些趣味性和戏剧效果。无论如何，语言思维的一些特点可以观察到 了。老看京剧的人，听到“曹操”一词时，想必很多人会在脑子里迅速闪过一个白脸奸臣的形象吧。专家对此类现象的评述是：“Linguistic forms and imagess are reciprocally accessible and in interactive functioning can be mutually constitutive.”<br>　　<br>　　 对于“流利使用任何语言流利交流的前提是必须使用该语言进行思维”，无论是脑神经学的发展还是教学和实践经验的证实，语言学界已经不存在太多的争议了，而 且各种新的语言教学体系和方法基本上都是围绕着“建立外语思维”的核心理念来设计的，甚至大部分都是绝对禁止使用母语翻译和语法知识教学的。但尽管大家承 认母语有干扰建立目标语言思维的作用，但在如何建立目标语言思维的实现过程，何时和应该如何使用目标语言进行思维，是否应该绝对地禁止使用母语帮助掌握外 语的问题上，还是有很多的争议和讨论的。其实我们也完全不必绝对化，而且很多时候，条件也不允许我们在掌握外语的过程中绝对禁止使用母语，更不可能象有些 人断言的需要“忘掉母语”。我们关心的问题正是如何建立外语思维和如何避免母语的干扰，甚至能使母语帮助我们掌握外语。<br>　　<br>　　选择思维语言<br>　　<br>　 　 关于二语悉得研究领域中的“如何对思维语言选择”Choosing the Language of Thought这一题目本身有一个值得商榷的地方，即“选择”这个词。双语人（指会用两种语言思维当然也是会用两种语言流利地交流的人）在使用哪种语言进 行思维时，大部分人往往不是主动进行“选择”的，一般是不自觉地根据情况适当采用某一种语言进行思维，甚至是被迫使用某一种语言进行思维。所以语言研究时 经常被使用的Choosing一词表示主动选择并不太准确。但非常有意思的是，当某种语言（当然是外语）思维能力还很低时，使用者往往更主动地“选择”使 用何种语言思维。正因为“选择”一词有争议，对把“使用何种语言思维”与“如何制定外语学习策略”相联系的研究方法曾受到一些人的质疑。质疑者认为：既然 使用者在用哪个语言思维身不由己，如何制定如何使用和和如何的学习策略？笔者认为这种质疑存在严重问题。因为如果分析一下使用者“使用哪种语言思维身不由 己”的原因，就会发现这正是在不同情况下必须使用其中某一个语言思维而无法使用另一个造成的，并是可以随时随地任意地选择。比如在正常速度的听力和交流 时，一定要使用目标语言思维才有可能实现正常交流。而在某些情况下又正相反。所以二语悉得专家A.Cohen等把选择语言思维列为外语学习策略研究的一个 非常重要组成部分显然是合理的。<br>　　<br>　　在应用外语时，何时会使用母语思维？<br>　　<br>　　 在正常使用外语时，只有在阅读和写作时，才有可能使用两种语言中的任一种进行思维。当然各种研究结果已经清楚显示，即使因为时间允许，在外语阅读中可以使 用母语思维，阅读的速度也会因此而放慢，同时对外语的掌握是不利的。有研究结果显示，用母语思维读外语，尽管存在许多“害处”（英文用的是 detrimental一词），但有可能会提高对文章的理解深度。这一点当然是不可否认的。所以大家在实际阅读的工作应用当中，不妨使用母语思考和帮助理 解，但在掌握外语的路程上，阅读中要尽量避免使用“翻译”的过程。另外很多的研究显示，在用外语写作时，使用母语思维不但普遍，而且对构造文章有很大帮 助。许多人在用外语写作时，先用母语构思，然后翻译成外语。这一过程被成为“心译”(mental translation)的过程。这一点与有的老师同学举的例子相符合，但听说的过程中是不可以的。<br>　　<br>　　 尽管使用mental translation有利有弊，但这一过程也只有在阅读和写作中才可能使用，在听和说时不但没有什么使用的价值，而且它正是听和说的重大障碍。当然准备 演讲内容时当然可以使用“心译”mental translation甚至先用母语起草演讲稿，因为时间允许而且提前用母语考虑内容会对有些人会更方便快捷和更有思路，但如果无准备的即兴讲话“心译” 是基本做不到的。我们常提到的“哑巴外语”现象，不是想使用的外语知识不具备，而是就当前掌握的外语知识不会听说和使用。这种现象的一个原因可能是不知道 文字的“声音”，另一个主要问题是：即使知道发音，由于“翻译”和“语法”的捣乱，跟不上正常速度，无法直接理解，也无法说完整句子。之所以讨论何时可以 采用何种语思维，目的也并不是为了禁止在某些场合使用母语思维，而是因为在高阶段正常交流中，这跟本做不到。所以一些外语思维程度较低的同学，在听外语时 自觉或不自觉地使用母语思维，结果是在不断“翻译”的过程中，除了刚翻译过来的信息外，其他语言的信息大量丢失了。在说外语时采用翻译过程，不但速度慢到 无法正常交流，而且句子语法结构更加会混乱。<br>　　<br>　　特殊情况下对语言思维的选择<br>　　<br>　　 实验和实际经验表明，在对某种需要特定知识的情况下，思维语言的主动选择，往往是根据当时获得这种特殊知识时使用的是哪种语言。比如大家在数学计算时，无 论我们的外语思维达到何种流利程度，我们基本上都是在用自己的母语思维的。比如听到外语How much is seven times eight? 我们几乎立即转变为母语思维进行思考，“七八-五十六”，毕竟乘法口诀表我们是用中文背的，英文的还真不会，然后我们再用英文说答案。有个别研究者以此作 为使用在外语交流中可以使用母语思维的证据，显然是以偏盖全了。反之，如果某一领域知识完全是在外语流利后用外语学会的，在应用这一领域知识时，用母语思 维反而很困难甚至不可能。我们在国外学习的许多留学生大多有同样经历，甚至完全不知道该知识中许多概念在母语中应该是哪个中文。许多在国外学完商科的同学 回国后都有这一体会：因为财务，金融等学科是后来在国外学习的，所以在回国后，用母语讨论这些领域的话题时先要用英文把问题想通，然后再需要努力把英语往 中文翻，还经常翻不出。特别是在一些投资公司中，几个留过学的中国高管往往在一起时用英文开会讨论业务反而方便。在写商业计划书时，也先要想英文和写英 文，然后再写中文版。倒不是因为英文水平太高了，而是上面所说的原因。Mars China曾有一位IT经理，是刚回国的中国同学，但因为是在国外学的计算机专业，当年出国时计算机还未普及，所以根本不知道有关计算机的英文中任何相对 应的中文。回国工作后，平时大家都用中文交流，但开业务会议时，大家都需要费力地使用英文交流。有一次在试图跟大家用中文讲“计算机显示器”时说：计算机 中的放在桌子上的长得象电视的那个东西。一时传为公司笑话。<br>　　<br>　　母语在二语悉得过程中的作用<br>　　<br>　　 上面的各种使用母语的特殊情况，都没有否认掌握外语必须建立外语思维的事实。但在这一阶段，在掌握外语过程中可以主动使用母语的主要作用，是帮助使接触到 的外语变得“可理解”。主要是使用母语介绍和了解即将听到的外语的题目和主要内容(top-down processing)。当然在实际过程中，我们不必要完全禁止用母语来解释难懂词汇或句子等的含义，简单说就是母语翻译和分析帮助理解。但应该十分清楚 的是，一定不要将这一翻译过程当作学习或教学过程，它的作用是帮助理解，是使输入变成“可理解性”的然后再用外语进行输入和掌握。如果非要禁止母语的使 用，尽管学习理念正确，但效率又失去了。在这里又要“实用主义”一下了。如果非要用外语解释外语，初级时难度太大，效率一定非常低。我们前面分析的在初级 阶段使用英-英字典或在国外碰到用英文解释英文的困难，就是典型的例子，理念正确，但缺乏可行性。我们只要关键掌握：即使用翻译的方法可以帮助实现可理 解，但尽量少使用。即使使用了，最后还需要作到能够用它的外语声音建立思维就好。只要最后融入在这一阶段中的有效的学习步骤就可逐渐实现。<br>　　<br>　　语法知识的用途<br>　　<br>　 　 现在有的研究和实验认为，语法知识的学习，在这一阶段外语学习中，还是有些正面作用的。对这一现象，克拉申曾在2004年欣慰地说：“我很高兴现在有人正 在进行的这种实验。至少说明了我们原来曾认为的“必须进行语法教学”的信条，现在已经变成为了“试试是否还有作用”的假设了。”（What was once an axiom is now a testable hypothesis.）在目前大多数语言教学者都已经同意“语法是通过可理解性语言的输入，下意识地掌握的潜规律而非主动有意识学习的知识”，但克拉申 还是给这一学习阶段语法的学习留了一定的地位，认为它在外语学习到了高级阶段后，可以填补一些由以前的输入可能会遗漏的 “空隙”(to fill gaps left by incomplete acquisition)。所以是如果从零起点按我们建议的路线达到在这一阶段的同学，在本阶段后期，了解语法还可能有这么一点用处。但对我们这些已经过 多地学习了英语语法，以至于我们英文语法知识都超过了中文语法知识的大部分中国同学来说，实在不必再为语法知识不够而担心了。即使在各种考试中，也不需要 语法知识，也不会有任何考语法知识的题目。决不会有题目让我们指出哪个是定语，哪个是代词。一般都是选择，填空，改错等。知道了正确的“说法”，根本不需 要知道是什么语法知识，甚至连错误答案都懒得看，直接找到“念着顺嘴儿”的答案就好了，答得又快又对。现在应试考试还有两个趋势，一是题目灵活化，很难分 析语法现象。另一是出题者常把两个语法陷阱放在同一题里。全靠语法知识来考试的同学，越来越感到困难了。总之，语法知识是给语言专家用来分析和总结语言用 的，而不是给大家掌握语言用的。<br>　　<br>　　对语法错误的纠正<br>　　<br>　　 多年来的各种研究已经清楚地表明，“纠正语法错误”的做法几乎不起任何作用，下次还在同一处错。比如纠正he,she的错误，其实都不用别人纠正，有时自 己就发现了，但下次还错。那如何才有可能变正确？其实还是思维的作用。只有当你头脑中的关于男人的MIF和he挂上了钩，女人的MIF和she联系上后， 才可能少犯错。（大家回去试一下，一见到男性图象或真人就说一遍he,一见到女人就念叨一遍 she，经过一段时间he, she, he, she对应练习就会强化这一形象思维与声音的联系。以后尽管不会完全不出错，但会改进很多。）其实对语言中任何错误的纠正都是如此。目前发现的纠正语言错 误的最大效果是体现在对写作的纠正上。但即使这样，改进的效果也很不理想。所以结论是老师和学员都不必花时间纠正错误，而是要多接触正确的形式。对小孩子 的母语建立更是如此，幼教专家明白“纠正”的作用很小，而且经常还起反作用。所以到现在还有“要多跟外国人交流，至少外国朋友能帮自己纠正错误”的想法的 同学应该对此不抱太高的希望了，其实根本不必这样做。另外一但开始纠正错误，正常交流就实现不了了。没建立好英文思维的同学，如果急于尝试交流，甚至会发 现几乎句句都有错。<br>　　<br>　　油条的故事<br>　　<br>　　 给大家出一道关于中文普通话的语法题大家思考一下我们是否会中文语法知识吧：“油条——”， “面条儿”，“薯条儿”，三个词在普通话中，有的要带“儿”，有的不带。不可以说“油条儿”，那成四川话了。也不能说“面条、薯条”，听着象台湾人说话。 但为什么有的词儿要加“儿”，有的不加？首先说明这跟“油”字儿没关系，因为“油饼儿”需要加“儿”，实际是跟“条”有关系。那什么样的条加“儿”？有什 么语法规定？大家一般都说没有。其实这里面有很严格的语法规定。大家先观察一下，这些条有何不同？原来是形状不同。油条粗，所以不带“儿”，面条薯条细， 所以带“儿”。所以关于“条”字儿话音的语法规定第一是：由条的粗细决定是否应该加“儿”。那究竟多细才开始带儿？没界定，但一般以拇指粗细判断。所以一 个语法规定是首先由条的形状属性决定。可如果是这样，那“车条”很细，为什么又不带“儿”，“布条儿”不一定细，为什么又带儿？原来还有第二个语法规定： 硬的不带儿，软的要带儿。车条硬，布条儿软。所以还要根据条的材料属性确定。有两个主要属性。但如果两个属性相矛盾怎么决定？比如一个条粗但很软，或细但 很硬，那该如何判断是否应该儿话？笔者曾读到此领域一位专家总结出了一个公式，给每个属性一个参数值，如果有两个属性出现，用第一属性参数乘以第二属性参 数的平方，看计算结果是否大于某个常数。在语言研究领域这够专业的，可要让咱们这样掌握中文，绝对是开玩笑了，难道我们答此题还需要计算器？再说“油条” 就这样复杂了，换成“油饼”又变了，不再是粗细软硬问题，而是薄厚大小，脆与不脆的问题了。据分析，我们高中学的英语就出现了2000个语法点，要到真正 高阶段，一定上万了，先不说是否需要掌握这么多英语语法，谁能都搞清楚并都记住呀？明明您不会中文关于油条的语法知识，您又是怎么把它说对的呀？大家自己 琢磨吧。<br>　　<br>　　这一阶段的学习策略的制定和理想学习体系特点的描述<br>　　<br>　　插个话吧：<br>　　 大家争论和质疑都是有益的，无论是否同意彼此的观点，相信对我们都有启发。大家的目的也是探询提高外语的解决途径，所以不必吵架。有些基本点希望大家思考：<br>　　<br>　 　 本文中提出了一些语言学习的基础理论，都不是本人提出的理论，咱没这个水平，并未提出任何新理论。而提供的是这么多年国外（和近年国内）对语言教学的现有 研究成果和根据这些成果观察和分析的一些现象。如果有人说：“文中列出的这些理论没什么新鲜的，也不够深入，简直就是个扫盲水平的二语悉得概论的描述。” 这样的评论算比较客观。如果说文章结构有些散了倒也是事实，让大家见笑了。<br>　　<br>　　 二语悉得在国外成型已久，在国内才刚刚开始。我们仅仅介绍了一些最简单和基本的原理，而且都是已经被证实了的和没有太多争议的结论。比如：<br>　　1， 需要建立外语思维： Able to think in the target language<br>　　2， 语言的掌握不是通过翻译和记忆，而是与思维，概念或图像建立直接联系：Through association, not translation or memorization<br>　 　3， 语法的掌握是下意识的过程，不应该通过有意识地学习： An implicit subconscious learning process rather than explicit conscious learning or active instruction.<br>　　4， 要注重理解和含义而非结构：Meaning-focus instead of form-focus.<br>　　5， 语言环境和掌握语言的关系：Linguistic environment and language acquisition<br>　　6， 关键是提供可理解输入条件 Comprehensive input i+1<br>　　<br>　　看到有些同学对这些基本结论还在质疑，尽管并没什么不可以的，但有些不必要。语言教学争论的焦点已不在这里了。<br>　　<br>　 　近几年语言教学的研究焦点是：知道了以上的结论，那在每个阶段应采用什么手段实现？如何针对每个人不同特点定学习策略？这个课题是很难的，也是还存在讨 论和争论的。因为又不能打开人的大脑看，大家同用某一方式，效果确不同，具体在他们大脑中发生了什么变化，很不好说清楚，只能靠外部的观察，经验和实验去 侧面证实。建议有成功经验的同学或老师，多从这一方面去思考。比如有同学举的某成功案例，某人是靠看电影和听广播提高的，但具体实现过程并非这一句话可以 总结出的。理不通则法不明。比如一个最具体的问题：当遇到听不懂部分的怎么办？光多听肯定还是不懂。（极端的例子是大家听阿拉伯语广播，如果光刻苦听，一 辈子也不可能听懂一个字。）那是用什么方法把它变懂的？专业的说法是如何成为“可理解性输入的”？这一问题并不好回答，很多成功者也没意识到是如何做到 的。把握好这些关键才会提高有效性。所以建议有深入观察的同学能具体结合语言学习的基本原理，分析出在用某一个方式实现过程中，哪些手段有效了？哪些地方 耽误时间了还可以改进？最后再结合个人的特点，找到适合我们自己的路线和方式就好了。<br>　　<br>　　条条大路通罗马，但路有近有远<br>　　<br>　 　用什么方式学都可以成功，这一点错儿都没有，也根本不必争论。本文没有否认这一点，也没有说非得怎样做才可以。但如果不讲策略，只是简单一句：刻苦学， 多听、多看、多用，那大家也就不必讨论了，不用任何专家或理论，狂听广播，狂看书，狂看原文电影，狂背文章，狂喊都行，只要回去刻苦学10000小时就成 了。那还做语言研究干什么？大家稍微静想一下，为什么这些刻苦成功的人一般都这么知名，倍受宣传？主要原因还是这样的成功来得太不容易了，这样成功的人也 太少了，所以成功了另人格外羡慕和称道。很多人也照着相同方法做过，但大部分没做成，各种原因都有，这才是我们更关心的问题。个人觉得从外语教学的角度 看，核心的问题之一应该是如何提高学习效率。如果宣传靠刻苦来弥补低效率，并不是刻苦学本身有什么问题，结果是大部分的人做不到。近几年的研究显示，如果 学习策略正确和条件理想，达到流利外语的时间应该在1000小时左右，与母语学习只有约200到300小时的差距。如果是学和母语相近的外语（比如英语和 法语），应该在500小时以内实现。我们的目的就是努力从10000小时向1000小时靠拢，而不建议大家努力用刻苦来体现自我价值。<br>　　<br>　　理通则法明<br>　　<br>　 　那费力气去了解语言学习原理是否是耽误时间？绝对不会。“理通则法明。磨刀不误砍柴功。” Krashen 2004年在13届国际语言教学图书大会上发言中关于学习者需要在学习语言前了解语言学习理论的部分，原文如下：One component of EFL (English as a Foreign Language) needs to be orientation. A brief explanation of language acquisition theory. Our goal is to develop independent, or autonomous acquirers. Knowing how language is acquired will help ensure that this will occur. It is also important to tell students something about the philosophy underlying our practice because the approach outlined here is radically different from traditional approaches; we need to justify our pedagogy to students and in some cases to their parents. 他不但提出了学习者了解语言学习理论的必要性，也点明了目的是就培养大家成为“独立的擅学者”，而没给大家一个放之四海皆准的具体“方法”。<br>　　<br>　　在这里给大家介绍了一些基本理念的一个目的，是把这些“理”交给大家分享，省得大家花时间自己去四处寻找，本人最多是能根据经验指个大致方向或提供一个分析框架而已。这“理”需要大家自己去“通”，“法”还要靠自己去“明”。<br>　　　Narrow Input<br>　　<br>　 　 把输入材料限制在一个较窄的话题范围内，效果明显要比涉及面宽要好。原因是窄范围题材的材料比较容易利用很高的熟悉度帮助增加理解性并保持很高的连贯性， 从而能集中力量提高听的能力。当整体能力达到一定高度时，再拓宽题材范围。大家根据自己的喜好和手边接触到的材料，集中听一个或几个人声音的，同一题材和 话题的讨论等。另外这样做对听力障碍之一的knowledge/cultural bank也先容易避免，同一话题对此要求低和容易逐步建立与就这一话题相关的knowledge/cultural bank。开始时一旦着急拓宽题材，很快会降低可理解度同时造成时间浪费。<br>　　<br>　　 具体来说：比如有人喜欢听新闻，就应该在这一段时间集中依靠不断听新闻来提高听力水平。喜欢看原版电影或连续剧，就集中看一套剧或同一风格的电影。如果有一套适合的听力教材，也是就集中学一个而不要同时接触太多的。<br>　　<br>　 　 理想的学习体系跟我们描述的第二阶段的理想体系的特点很类似，大家可以参考第二阶段的内容。但现在增加了一些难度，并从多个人描述的语言转为多对话的语 言。故事还是要有连续性，图像辅助也还是必要，但语言的内容应该是不仅能靠图像才能明了，而是根据故事的发展，上下文的联系，前后逻辑关系和自己熟悉的知 识，生活经验等实现能够“预测”含义，并且能经常在后面以不同的形式反复出现。这一阶段与前阶段最大的区别是表现在学习形式上，由原来单纯的听，变成了听 说读的循环配合。<br>　　<br>　　A Sample Acquisition Cycle<br>　　<br>　　1， 先听整段原文，段落长短控制在正常速度10钟内放完。难度选择应该是控制在第一遍能听懂的程度是70%上下。不要看文字或字幕。这步的目的主要是先熟悉要学的内容或说是该内容的声音。<br>　　2， 开始分句模仿跟读，每句约三遍，（听一遍跟一遍，不是听一遍读三遍）不懂的也跟读，别着急查意思。是否全对或是否全会不必太介意，可以看字幕但尽量不看，一边模仿，一边猜测不明白部分的含义。关键技巧是“猜测”。<br>　　3， 不看字幕分句跟读一遍，把原声和自己读的声音都录下来。<br>　　4， 放第3步的录音，努力听每句自己读的和原文有何区别并再次感受刚才的过程，可看字幕帮助核对。<br>　　5， 分句自己先说，然后再听原文。第一次可看字幕，后两次尽量不看字幕。<br>　　6， 自己回想该段剧情，试着复述说刚才每部分的句子。<br>　　7， 如果有测试题，可以测试一下自己对上一段掌握的程度，还是80分就好。<br>　　8， 下一段开始，重复上面同样的程序。<br>　　<br>　 　 对于Visual Learner来说，看字幕一定要谨慎。如果在循环初期读字幕是为了增加理解度，还可以这样做，但后面几步要控制自己不看字幕专心听。Audio Learner倒不必太介意。Kinesthetic比较麻烦，需要用自己的手势帮助加强理解和模仿。在本人教过的学生几千中，纯Kinesthetic 学型的比例非常少，但曾有个这样学型的学生叫Benjamin，学习困难一直比较大，最后大家探讨了很久后，他决定采用站着听，一边听一边想象自己是剧中 人，打着手势表演和模仿，结果发现一下进步快了很多。一些其他“学型”的同学也照他这样做，发现也有很大帮助。大家的体会是，除了动作帮助加深印象，把自 己融入剧中让自己更容易用情绪帮助体会出现该语句的情景，重要的是这样能帮助逐渐用听到的英语去“思考”该场景。这一经验很值得大家尝试。<br>　　<br>　 　 上面是个小悉得循环的大致样子，该循环可以每段新内容一直参照使用。每步有各自的目的和用途。但主要途径是听和模仿。其实仔细看每一句从听一遍到最后试着 说，中间经过几次不同方式的同内容对比和模仿过程。这一模仿过程在纯听广播，新闻或看影片时往往难以实现。所以单纯听广播或新闻，在后期听力达到很高程度 时，往往说不利落。有人达到听新闻几乎滴水不漏的程度，说的话与听力差距比较大，其中一个原因是缺乏这一模仿和重复对比过程，另外的原因是要到第四阶段才 可以解决的。大家如果纯靠听，需要同一材料听几遍，利用再听的机会进行模仿和同声重复，采用的技巧叫做Simultaneous Repetition. 但大家模仿和重复后，并不要急着找真人说。除非有人能够专跟你用英文讨论刚学过的完全相同内容的句子，否则没有太多帮助。<br>　　<br>　　 在这一阶段的初期，大家就自己学，不需要外教，也不需要找外国人交流。 因为此时不但能交流的内容有限，容易造成瞎聊乱说，而且交流的帮助不大。仔细想，交流中主要的提高来自别人跟你说的内容，而非你跟别人说的内容。自己说的 话纯粹是输出而没有增加新内容。（The contribution of conversation to language acquisition is what the other person says to you, not what you say to them.）但别人跟你说的话如果不是控制在“可理解输入i+1 ”的程度，不是在 Narrow Input的范围，那无效成分会太多，还不如用非真人的系统性的语言资料效率高。到了后期，因为“可理性解输出” （Comprehensive Output）有一定作用，所以可以开始把已经通过有效输入掌握的，有一定可交流量程度的内容拿来说或写就可以起作用了。而“输入”和“输出”的比例时间 投入非常悬殊，输出所需的时间几乎达到可忽略的程度。有的同学在没有任何交流机会的情况下，靠偶尔自己跟自己说也达到目的了。<br>　　<br>　　<br>一直都很欣赏khxia老师参加讨论。Khxia老师分析深入，以理服人，尽管大家观点有不同处，但很令在下尊重。而且理是越辩越明的。辩到最后就算我们自己未改变观点，但整个辩论过程是无论我们自己还是观察者都从能思考中受益的。再次谢过。<br>　　<br>　 　 您转贴的李玉陈的文章，是个非常好的讨论机会，大家不妨稍回顾分析一下。显然李教授是在捍卫“语法-翻译法”，而在下是旗帜鲜明地反对“语法-翻译法”。 这是两条路线斗争的问题，没有什么可含糊的。在全世界大部分地区普遍已经辩明的这一问题的今天，中国几乎是“语法-翻译法”尚存的最后堡垒，但近几年已经 开始分崩瓦解。必胜的仗也还是要打的。分析一下让大家更清楚。<br>　　<br>　　 有些同学指出了李教授的态度有问题，我们不必对此评论，就对其论点论据进行分析就好了。<br>　　<br>　 　 李教授支持语法-翻译法的第一个道理是：“语法是实现交际不可缺少的要素”。这是什么意思呀？交流需要使用语法吗？他可能是想说正常的语言交流需要把语言 的语法说正确。这没错。我们大家说话写文章，当然要把句子语法按正确的方式表述，但并不需要提前把“语法知识”学好，更不是因为学了“语法知识”才会把句 子说对写好的。大家基本上并不有意识地知道我们中文的“语法知识”，而是我们通过交流下意识地掌握了正确的说法，而自然下意识地正确应用，并不是通过语法 教学学会的。我们反对的正是“机构化的语法知识的教学”。其论据明显概念不清或有意在偷换概念。<br>　　<br>　　 李教授的另一个理由是：“翻译则是语言交际最常见的形式和过程。”我们大家平时在一起交流时不翻译呀？他应该是在说：如果交流的双方语言不通，需要译者来 帮助交流，通过“翻译”的形式和过程来实现交流。这又是指代不清。我们反对的是“翻译法”教学，同时指出的是：如果在听说外语时不停地在头脑中做“翻 译”，就会跟不上正常的语速同时达不到流利的程度。那么翻译工作者呢？他们是在“翻译”是在翻译，但这是结果不是过程。尤其在口头翻译过程中，无非是听一 个语言，再用另一个语言说出。译者在听一个语言接受信息时，是在使用头脑中激发和使用这一语言区，进行思维和理解（另一语言区不使用），理解后，再启用另 一个语言区进行思维和控制，说出另一个语言，把自己刚接受并理解的信息用另一语言描述出来。这一过程已经被近几年的脑神经研究证实了。我们前面提到了纽约 时报和《自然》的相关报道。（有兴趣的同学可以还找到相关的两个语言区使用时的fMRI图看一下）。其实我们单从实际现象就已经可以说明了。高水平的口译 不但是必须如此，而且还要根据自己对已经掌握的对双方不同文化的了解，将一方带较强地域文化成分的信息，经理解处理后，用另一种语言表述出来。跟大家分享 一个故事：中美建交初期，我国一文艺代表团随领导人访美，其中一个任务是向美国人民介绍中国的文化艺术。在一次在有美国政府官员，联合国官员，当地企业 家，媒体和海外华人等参加的汇报演出会上，由我们的著名京剧表演艺术家介绍京剧中的人物特点和动作，我们的翻译同志在一边翻译。当介绍到京剧中的步法时， 京剧大师一边踱着方步，一边说：“这叫方步。”说到这里，一些华人都觉得这怎么翻呀？总不能说“square steps”吧？只听翻译同志随口说了一句：“This man works in the UN.”一句话引起了满场笑声，随即响起了热烈的掌声。无论在场的华人还是外国人，无不赞叹翻译人员的高超的翻译水平和绝妙的效果。如果翻译人员不是对原 文充分理解，在通过理解应用恰当的外语表述，而楞从字面翻译的话，显然无法达到这样的效果。在不同语言中，高级阶段的表达方式十分不同，根本不可以硬性翻 译，尤其是在成语，类比和比喻的使用上。而英文交流时类比的使用量非常大。<br>　　<br>　　 李教授在严格区别外语和二语概念，但其动机在通过否认语言悉得的目的和作用，而为外语“学习”和“教学”辩解，把严肃的二语悉得理论贬低为“时髦的皮 毛”。除了盲目否认世界范围的语言学的研究的成果外，更主要的是其出发点的问题。在他看来，语言学习要靠“以老师教为中心”的教学，而根本不理解现代语言 教学早已发展到了应该是以“学生为中心”的时代。对学生的具体学习特点，具体困难根本不理会，不同意因材施教。而其为传统教学辩护的依据居然是：二语学习 是为了应用，而中国人学外语的目的是升学和考试，好比是帮人“存钱”，除此之外学外语根本“没有其它用处”。我想大家学外语的目的应该主要是应用吧。最后 他还将教学质量不好怪在老师质量差上。如果真是这样，那为什么会缺乏好老师？这些老师又是在什么样的系统下才被变成不好的？不要说国内已经加入国际行列开 始了很正规的语言悉得研究，就算是只有国外有研究成果，我们为什么要否认这些成果？难道中国人就不适合接受科学？<br>　　<br>　　 上面这些站不住脚的论点实在是很容易驳倒的，没什么挑战性。其实现在关于语言课堂教学和二语悉得的争论是存在的，主要是两个方面：第一是“可学性假设” (Learnability hypothesis)，即学习者无法跨越学习阶段，于是制约了课堂教学。只有当某阶段的语言悉得已经实现时，该阶段课堂教学才可能有一定促进作用；第二 是“有意识的语言学习”的某些知识，是否可以通过一定方式转变为语言交流时的“下意识”的悉得系统？即所谓的有无“接口”(Interface)问题。一 般观察是有意识学习对语言悉得有“帮助”，但对如何帮助的并不清楚。有一个证据对“有接口”(interface position)论不利的是，支持和反对者都发现，无论采用什么次序有意识地教授语法知识，学习者对语法的掌握和运用和不学语法知识的人，都是一个掌握 顺序，和教授顺序无关，似乎主动教授不直接对掌握语法起作用。这两个问题研究起来深度较高，分析清楚不容易，也尚未有统一的结论，倒是值得和那些支持语言 教学的各位老师们探讨。但无论语言教学是否可以对语言悉得有作用，它明显已经是从属地位，不但因为我们的主要目的是要悉得和应用语言，现在发现即使是应 试，也是真实能力高才能考得好。<br>　　<br>　　 当然，除了李教授对语言悉得缺乏理解和基本出发点的问题外，有一个重要的客观原因造成了他坚持其观念，倒是大家应该谅解的。那就是对很多老师来说，不用 “语法-翻译法”教学，那又该怎么办？因为基本没有其他办法可选。在没有适合，科学的，充足的和支付得起的二语悉得教学材料和条件时，“语法-翻译法”成 了最直接的选择。因为当一句英语出现时，如果学习者不理解，只能靠“翻译”成中文。如果看到句子结构跟中文不同时，那也只有通过对语法知识的解释来告诉大 家为什么不同。有一些老师对此方法的辩护也原于此，不这么做甚至认为是没了章法。这一点是中国目前语言悉得无法推广症结之所在，而不是语言悉得不适合中 国。我们前面曾提到过，语言脑神经学，语言学，语言教学和语言学习产品之间都有很大断层，而对教师和学习者最实用的角度而言，最大的断层出现在语言教学和 语言学习产品之间，这也正是我们语言教学工作者最着急的地方。我们分析了正确的语言悉得策略，理想的系统和材料的特点和使用方法。国外有一些较好的体系， 但一般都十分昂贵和难以在一般学校这种环境中实现。结果这一难题留给了同学们。我们前面分析，如果从零起到第三阶段初，如果每天一小时，最少的学习时间也 已经一年了，再加上第三阶段的一年多左右，两年的学习资料数量相当大。本人也无法给大家直接提供。当然，本人的最高理想是能够有机会给开发一个大家都负担 得起的，在学校也能使用的，包含各阶段的二语悉得产品。<br>　　<br>　　 传统课堂外语教学，对于成年人来说，还有个“是否起些作用的”的问题可以探讨。但对与儿童来说，课堂外语教学的问题十分严重。因为儿童的心理和学习特征不 适合课堂式语言教学，儿童的理解力和记忆力，知识和经验都不如成年人。本来是在最适合掌握外语的“关键期”，但却被放在最不适合的记忆式课堂教学中，如果 再教他们语法知识的话，那一定会让他们更加糊涂。全国中小学外语教师学会主席汪老师曾无限感慨地说：真是不该教孩子学英语。如果是学英语的话，年纪大一点 会学的快，何必让他们受罪？在下十分赞同。小学六年学的全部英语内容，成年人几个月就都能“学会”。但如果能提供母语式二语悉得方式，儿童学外语当然最理 想的了。所以儿童掌握语言，更应该采用自然的方式。难点同样是在学习产品上。关于儿童掌握外语，在下的儿童外语教学的实践经验有限，不够给大家提供深入分 析，到后面可以简单讨论一下学习策略。我们还是继续讲成年人的语言悉得。<br>　　　Khxia老师讲得好，我觉得在这一问题上咱们两个实际讲到一起去 了。这也正是中国目前外语教学的困难之处。因为没有很好的悉得体系，完整的悉得资料和教学方法，大部分老师不但得不到悉得方法的训练，甚至没有理解就急功 近利去实施的做法也常有。所以个人认为吾辈的责任一是广泛推广语言悉得的基本理念和教学方法，二是开发和提供语言悉得的材料和系统，并逐渐转变以“纯教师 为中心”的教学模式为“以重点学生为中心”的自主学习模式。教师的作用更应该是辅导和引路人的地位，语言终究是靠自己掌握的。但不能因此而维护“语法-翻 译”法，因为就算维护它，结果是造成大部分人“哑巴英语”，所以它并不能解决目前的问题。解决的途径只有努力建立新科学的体系。目前这个体系还在萌芽状 态，当然会有很多问题，任重道远，但不能因为现在出现了问题而限制它的发展，很多老师的尝试和努力是取得了明显效果的，在国内各种语言教学的刊物和研讨会 上都能看到。全国政协委员，外语教育学会理事长龚亚夫老师对我国学生语言悉得的论述更是精辟。希望将来能和Khxia老师以及大家有机会合作共同开发、完 善和推广语言悉得系统和学习产品。<br>　　<br>　　 关于外语思维的问题的讨论咱们的讨论也相近。知道了目的和结果是必然是需要实现用外语思维，但实现的过程是慢慢来的，是从简单开始建立的，着急做不到，基 本上说一年以内都没什么感觉。很多时候是象有的同学说的逐渐转变的，每个人情况不同，有人有意识地转变，有人自然地转变，用语言学习的话说，是个“曝 光”exposure的过程。很象洗照片，影象是整体逐渐清晰和加深，并非先出了胳膊后出腿。大家可以尝试建立数字的英文思维，会发现就几个月以后才做的 到从有感觉到逐渐不依赖翻译。在实现过程中，不能对母语的干扰有恐惧，也不能说完全排斥母语的作用。我们已经说到了，在当图象，剧情，文化背景，生活经 验，上下文联系等都不能帮让我们实现“预测含义”时，更是要让母语变成帮助我们实现另英语“可理解”的助力。从实用的角度讲，本人认为出现几率低的单词， 开始时甚至可以完全忽略英文思维，就先背中文反而效率高。关键是不要用翻译的方式去学外语或依赖翻译，见到一个词非要想中文而造成流利交流无法实现。<br>　　<br>　 　 在语言学习上，本人支持应该采用实用主义的态度，不迷信某一个人或某个体系。就象罗素所言：“一个能自圆其说的完整体系，往往存在许多谬误；而一个不能完 全自圆其说的体系，往往真理性高。”世间的各种体系基本如此，而在语言研究领域这一特点更是非常普遍，人们总希望用一个完整体系去概括和解决全部问题，结 果往往是为了把最后20%的特例包含于体系中，而又使自己的体系膨胀了80%而变得十分复杂，没有实用价值。语法其实也是如此，应该用20%的精力介绍一 些最基本的几个时态变化就足以，没必要再复杂了，通过语言本身掌握就得了。其他的就象hzzasdf兄所讲：语法在高阶段还是有帮助的。Krashen的 类似分析是：完全悉得的途径会漏掉一些语法现象，所以高阶段要“填补空缺”。有一点贬低了语法的作用，但使用方式的分析还是对的。<br>　　<br>　　讲到这里，正好下面接着讲一下“连读”的问题，一个小问题居然中了让很多人中了同样的圈套。<br>　　　关于连读的误区<br>　　<br>　 　 到这一时期，听力语速加快，开始会注意到有许多连读现象。连读的概念解释起来很简单：英语在连贯地说话或朗读时,如果相邻的两个词前面的是以辅音音素结 尾,后面的以元音音素开头（不一定是元音字母，是要发元音）,就可以自然地将辅音和元音相拼,构成一个音节,这就是连读。如:not at all，连读时听起来就像是一个单词notatall。注意:连读只发生在句子中的同一个意群中。在两个意群之间即使有两个相邻的辅音和元音出现,也不可 连读。<br>　　<br>　　 知道连读的原理也就可以了，不知道也没关系，跟语法知识的道理一样，大家千万不要有意识地记住连读原理并试图理性地应用它，那样又适得其反，更加深听力障 碍和造成不会说话。无论掌握听、说的连读，都是个自然的过程，不要主动地学习连读和练习连读。很多同学又掉在这一误区中，被连读搞得很上火，甚至有人认为 自己的听力问题主要是“不会”连读。我们先分析一下听懂连读的听音原理是什么：<br>　　<br>　　 比如 Come in，连读后听起来是 “comin”，但之所以能听懂，并不是因为学过“comin”是 “Come in”的连读，而是个自然过程。除了能根据对话场景能知道该词的意思因素外，从bottom-up角度而言，主要原因有两个：<br>　　1， 对Come 和 in 两个单个单词的声音能清楚辨认并对含义十分了解；<br>　　2， 在自己头脑的“声音库”中，没有“comin”这个声音的词或自动排除该声音会出现在这里的可能性，于是下意识地自动就把“comin”解析为“Come in”了。一切过程都是在大脑中以千分之一秒数量级的速度迅速完成的，不需要主动思维和有意识分析的过程。<br>　 　所以对听连读的掌握，是在熟悉两个单个词的声音，同时能自信地自动排除被连读声音的基础实现的。而对说连读的掌握，是在读音实现自然流畅和连贯，同时说 话时思维的连贯能自然按意群表达意思而实现的。两个过程都决非可以用知识和意识可以控制的，否则不但乱了套，也跟本达不到流利的程度。英语尽管有连读，不 连读也不算错（法语不连读就不行）。<br>　　<br>　　 其实如果能对中文中连读现象的分析也就明白了。中文中的连读很少，因为中文字大部分以辅音开头，元音开头的字不多。另外，即使有辅音结尾的字，往往辅音并 不“闭口”，所以一般不能与后面的原因相连。比如中文的“三”和英文的“san”的音，除了元音发音不太相同外，最后那个n也不同，中文就“恩”就完了， 英文需要稍闭一下嘴，有个几乎不发音也不易察觉的“呐”音，再往下如果有元音就自然“呐”下去了。所以如果大家说这个时n音发到位，连读会自然实现。中文 的少有的连读就变成了元音间的连读。比如“西安”，连读就成了“仙”，“记忆力”连起来就成了“记力”。比如常见的连读之一是“天安门”，在普通话中，连 读起来成了“天门”。大家可以试一下： “去哪儿了？”回答就说两个字“天门。”听的人一定听得懂。原因相同：1，对“天”“安”“门”三个发音及该词含义和清楚。2，一听“天门”，下意识明白 没有叫“天门”的地方，于是自动识别了“天安门”的含义而不会误会为“天门”。反之，如果这两个前提被改变，连读就有了问题或不能再连读。比如北京又出现 了一个就叫“天门”的地方，那当被询问去哪里时，说的人还会自动强调：是“天-安-门”，把“安”音拖长以避免混淆，这一过程同样是迅速而自然的。那我们 在教外国人说中文时，当然不能让他们练习说“天门”。<br>　　<br>　　 回头看连读这件事，又是反映了语言能力自然形成的特点。其实婴儿学语言，是不需要连读知识的讲述和连读训练的，跟不需要语法知识讲解一样。在能力这件事上，好象应了文革时期的一句话：知识越多越反动。<br>　　　背诵式学习策略分析<br>　　<br>　 　 在这一阶段，不少同学都尝试过背诵英文，有很多人认为背诵是最好的办法，也有些人通过背诵取得了较好的效果，但并不是大多数人。作为老师的一个有利条件 是，可以观察到一个较大的统计人群(Sample)，所以能观察和分析出成功比例。不能因为有少数人靠背诵成功了就推广背诵的方法。产生效果差异的原因很 多，即使是靠这种方式成功的同学，实际情况也不是简单一句“背诵”就可以解释的。同样是背诵，也还有很多不同的背诵方式，都需要大家分析和理解。<br>　 　首先，我们前面提出了，语言的掌握从原理上不是简单的机械记忆，在大脑中也不是“储存”于记忆中，应该是在语言区中建立语言区块。简单的语言要素是条件 反射的建立方式，复杂和抽象的语言部分不能完全认为是条件反射，而是各种具体概念的抽象，概括和联系，但都不是简单的记忆。除了医学研究证明如此外，大家 普遍的观察也如此。比如有人丧失了记忆，但说话没有影响，并没有“忘记”说话，因为语言区没受影响。我们前面举过成龙演的“我是谁？”和The Borne Identity的例子。背诵在很多领域的学习中，早已经被证明是个效率很低的办法，在语言的掌握中更是如此。<br>　　<br>　　其 次，中国同学对“背诵”的热衷和认可，是受到我们中国的传统文化，心理和思维方式强烈影响的结果。中国同学普遍认可的记忆和重复的学习方式被称为Rote Learning，简称RL。西方学者分析发现，RL是中国同学对语言学习的典型观念(Watkins and Biggs 1996)。有的学者认为亚洲，特别是中国，背诵风气形成的原因主要是受儒家文化的影响（Horwitz 1999, Wenden, 1987）。在学习外语上，当然也同样存在普遍的认为背诵有效的错误认识。Gairns and Redman 总结了RL记忆式外语学习的特点：<br>　　1， 默读或出声朗读；<br>　　2， 写或重复写；<br>　　3， 制作单词表或记忆卡片以便随时可以拿出来背；<br>　　4， 背典型例句；<br>　　5， 使用翻译对照；<br>　　6， 使用详细定义和解释；<br>　　7， 分组、分对记忆；<br>　　8， 背诵不规则动词表；<br>　　<br>　 　 在2001年英国英语教师协会的英语教学学术会议上，对中国同学普遍相信记忆式语言学习的现象做了专门的研讨。RL的主要手段是记忆和重复，而不注重“理 解”。在科学发展到了今天，许多中国人仍然认为这种古代私塾式的教育方式有效，普遍存在强迫和鼓励小孩子背诵古文和诗歌等理解很困难的东西。一般的认识 是：小时候先背会，等以后再慢慢理解或以后自然会理解，关于这一错误认识我们前面关于记忆力的段落已经从一个侧面分析过。<br>　　<br>　　 现代语言教学的实践分析是：缺乏理解的RL背诵是没有什么效果的。即使有少数人通过背诵取得了进步，也决不是简单的机械记忆，而是这些人在背诵的过程中， 不自觉地应用了其他手段，甚至记忆本身也存在多种形式和实现方式。如果不加以分析而简单地让大家都“背诵”，必然只有少数人才成功。我们在此不对记忆再做 深入研究，先看一下少数能通过背诵提高的同学的特点：<br>　　<br>　　案例：背诵新概念<br>　　<br>　　 在这一阶段同学，最有代表性的是曾经在学校接受过传统英语教学，许多是曾经达到过英语四级水平但无法交流，寻找其他学习班或自学。和其他许多英语老师一 样，本人也曾教过这样的英语班，最常见的是教《新概念英语》。《新概念英语》最精彩的部分是96个小故事。对过了四级的同学来说，并不觉得难，大部分对语 法知识也掌握了，并不用多讲。但每次几个月教完一个班，发现普遍交流能力提高很小。最后很多老师总结提出发现最有效的方法是背下这些小故事有少数学生做到 背下了许多课文，但在尝试相似内容的听说时，有的人运用的还可以，有的人不行。按人数统计，用背诵取得显著提高的学生比例非常之少。但分析使用记忆策略成 功的几个学生的特点，对我们很有启发。他们成功特点是：<br>　　1， 使用联系式记忆：将新的内容与以前掌握的内容联系；通过故事情节记忆；<br>　　2， 使用图像和声音记忆：想象一幅图象或情景；使用画图辅助理解；记忆声音；<br>　　3， 复习时才使用记忆：不是在学习时采用，并且逐渐增加复习的间隔；<br>　　<br>　 　 具体反映在在背课文时，不是机械地背诵，而是根据英语描述的故事，在理解的基础上，联想和思考故事情节发展和句子的含义进行记忆。每次背出来时，明显从他 们的表情变化甚至情绪起伏都能感觉到他们的思维是随所背内容的故事发展而变化。Audio Learner学型的同学普遍靠背诵提高交流的比例比较大，而且发现他们都是通过多听录音或大声背诵实现的，感觉最后脑子里留有大量这些句子的声 音。（Visual Learner记忆时多半靠阅读，背诵时普遍有眼睛向天上看和思考文字和段落前后顺序的习惯，有的也可以背得好，灵活应用起来效果较差）。<br>　　<br>　 　 尽管有些人通过记忆实现提高，但实践结果是大部分人做不到背诵本身，而不完全是背诵的方法是否正确。本人曾经尝试过完全放弃讲课，将课堂时间全部用来带大 家一起背课文。结果每次都是自己背会了，学生背不会或下次就忘记了。怎么回家不复习呀？大家已经是花课余时间来上课了，再花多少时间复习呀？所以大家可以 尝试背诵，但尽量要避免上面RL中的那些现象而使用其他记忆的方式。如果发现效果差不要奇怪，本来效果好的同学就少，另外总体来讲背诵还是比较枯燥而且费 时间的。儿童在掌握语言时，是不需要背诵任何句子的。<br>很抱歉这一段忙了点，不过有机会跟陈琳老师交流了一下，还是满有收获的。先声明我可没说他支 持我啊，别指责我借他的名来证明自己对，主要是听他讲了些道理。陈老也认为在没有二语悉得输入的理想条件时，没办法可能背诵比较有效，当然会比较辛苦。在 下提出的是在当今的科技条件和媒体手段下，是自己可以创造比较理想的二语悉得条件的，甚至比国外的复杂的自然语言条件更科学合理。约好了近期再见面探讨， 很高兴。<br>　　<br>　　 看到大家开始分享自己或周围人成功的经验，非常高兴，大家这样会对我们都有启发的。我们提出过，成功的因素多是采用了符合语言悉得正确理念的策略，大家分析就会发现。一时来不急都回复，挑几个吧：<br>　　<br>　 　 夹克小猪问工作的成年人从基础到高级，如果学习方法科学有效，用多久：现在的最佳的实践情况是，在中、英文这种差距大的语言之间，实现时间大约总共 1000小时左右，但需要一两年左右，不可以把1000小时压缩到几个月。如果从英语法语之间，300-500小时就很好了。意大利语和西班牙语之间，太 容易了，不学也可以，反正听得懂对方。有个最佳实现方式下时间和水平的曲线图，找机会在后面贴出来。<br>　　<br>　　 八宝如意紫金钩同学说的那位老太，讲得朴素但有理，先成“英语文盲”实在比喻恰当，其实无非就是符合了语言学习的正确次序：听，说，再读，再写。大家中文都这么学的。在学外语时大家总是急于接触文字，其实也不是最终学不会外语，就是速度比正确顺序慢。<br>　　很多同学忙着装“石头”，其实“石头”对零基础的效果明显，中高级的同学会觉得太简单。建议大家可选个一点都不会的语言试一下，就体会到它的精妙处了。<br>　　<br>　 　 已经快得罪钟道隆老师了，还非要对李阳老师也评价呀？这么说吧：在下对两位老师都十分敬重，但就是坚决反对“刻苦学习”。如果要能作到这么刻苦学习，那啥 也别说了，大家都上张海迪老师的blog取经就成了，每天3小时，十多年后可以用英文写一篇文章，题目叫“美丽的英文”。<br>　　课堂教学实践——任务型语言教学介绍<br>　　<br>　 　 2001年，教育部制定出版了全日制义务教育普通高级中学英语新课标。近几年来，“新课标”、“任务型教学”和“用英语做事情”在中小学英语教学领域已经 变为热点，“任务型教学”成了主要的新型教学研究课题和实践。任务型教学是英语新课标中倡导的一种更接近语言悉得自然过程教学方法。<br>　　<br>　 　 任务型语言教学 (Task-based language teaching) 指的是：通过让学习者完成各种具体“任务”来掌握灵活熟练运用语言的能力。学习者通过观察，思考，表达、沟通、交涉、解释和询问等各种语言活动来学习和掌 握语言，完成各种各样的交际活动。大量研究表明，任务型的活动是培养学生运用语言进行交际的最佳途径之一。所谓“任务”，是自己或他人从事的一项简单工 作，如粉刷房屋、填表、借书、问路、预定机票等（Long, 1985）；“任务”是指由教师控制和调节，让学生获得信息并经过思维加工，最后输出语言的一个活动； “任务”是指练习和理解语言的一个行动或活动，如听录音画图等；“任务”是指一系列语言学习的计划，它具有特定的目标，恰当的内容，规定的程序和一系列结 果等基本特点。许多国家和地区的课程标准都采用了“任务型”教学模式。我国的“任务型”教学刚起步，这也是二语悉得科学体系“西风渐进”的直接成果。全国 政协委员，外语教育学会理事长龚亚夫老师，对在中国实践和推广“任务型”教学有系统的研究和论述，英语新课表专家组组长陈琳老师也大力支持任务型教学。<br>　　<br>　 　 任务型教学的采用，在中国首次开始改变学校课堂外语教学一向以教师为中心，老师传授知识，学生被动地学习passive learning的落后思想，而明确了“外语学习的首要任务是学而不是教”的正确理念。重“学”的概念也反映在新课标的内容标准中对有关如何培养学生学习 使用学习策略的目标描述。“教”，是为了达到“不教”的最高境界。作为外语教师们，首先应该明确的是：教给学生学习的能力，教会他们如何学习，远比传授单 纯的语言知识重要得多。<br>　　<br>　　 关于我国“任务型”语言教学有大量的研究文献和课堂教学实践的案例分析，大家很容易找到，所以不再做详细描述，只在这里分析它在语言悉得阶段中的应用。大 家其实可以在“任务型”语言教学的描述中已经看到了一些看图听音，TPR, Series Method的身影，所以它是基本符合语言学习的自然过程和顺序的。科德（Corder,1981）曾经说过，有效的语言教学不应违背自然过程，而应适应 自然过程；不应阻碍学习，而应有助于学习并促进学习；不能令学生去适应教师和教材，而应让教师和教材去适应学生。但本人认为该教学模式应在第三阶段比较适 用，或者说在第二阶段应用需要做调整。主要就是说的问题。“任务型”语言教学是很注重说的应用，但本人认为说得太早并不好。首先说本身主要是“输出”的过 程，并不是“输入”，其次，当听说的能力还很低时，过早的说容易使学习者产生挫败感和养成坏的说话习惯。语言掌握的“沉默期”Silent Period不但是自然过程的特点，同时也是加快语言掌握的手段。过早开始“输出”反而放慢了语言掌握的速度。所以在第三阶段可以大力推广，但第一、二阶 段，应用“任务型”语言教学时应该大量减少说的部分而强调听的练习。<br>　　<br>　　 其实“任务型”语言教学也是一种在二语悉得理论下的一个具体方法总结，教师们也完全可以在这一基本理念的指导下，根据手边的教材和教学条件自由发挥。比如 还是教《新概念》，首先应该放弃传统的“讲解”方式，可以把课堂安排成以学生为主角的“任务型”活动，老师作为导演，让学生进行表演，对话，提问。比如 A Private Conversation一课，完全可以让学生分组表演，把椅子摆在教室前模仿剧院，一个学生做故事主角，两个作为那一对看戏聊天的情侣，几个在“台上” 模仿演戏的演员。开始：演戏的同学开始表演，主人公上台讲故事了：Last night, I went to the theater, I had a very good seat. But I did not enjoy it. A young man and a young women were sitting behind me, they were talking loudly….全部故事情节都由学生通过动作，表情，使用简单教具(Props)，以表演的形式展示给大家，过程中完全使用英文描述和对话，甚至可以自 由插话。下面的同学可以提问：Can you hear what they were talking about? Why don’t you move to a different seat? 等等。演完一场还可以换一批演员再来一遍，尽量发挥同学的积极性。老师协调和辅助全过程，对学生语言的应用进行点评和鼓励。可以保证这样的课堂一定比枯燥 的讲解让学员印象深刻同时有学习兴趣。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/23/%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%E6%98%AF%E4%BD%A0%E5%BD%93%E4%BA%86%E8%80%81%E6%9D%BF%E6%89%8D%E7%9F%A5%E9%81%93%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/23/%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%E6%98%AF%E4%BD%A0%E5%BD%93%E4%BA%86%E8%80%81%E6%9D%BF%E6%89%8D%E7%9F%A5%E9%81%93%E7%9A%84/" class="post-title-link" itemprop="url">什么事情是你当了老板才知道的</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-23 23:20:34 / Modified: 23:22:01" itemprop="dateCreated datePublished" datetime="2020-04-23T23:20:34-04:00">2020-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>深深滴感到，工具人，尤其是技术员的悲哀</p>
<p>当了老板之后，我发现，技术人员，包括曾经的我在内，经常会犯的三个错误，而且是致命的三个错误，用小时候学的几个成语来概括，分别是</p>
<p>瞎子摸象，刻舟求剑，以及叶公好龙</p>
<p>一个个解释</p>
<h2 id="瞎子摸象"><a href="#瞎子摸象" class="headerlink" title="瞎子摸象"></a><strong>瞎子摸象</strong></h2><p>几个瞎子在摸大象，然后人们问瞎子，大象长什么样子啊？摸像腿的说是圆柱形的，摸大象身体的说是平的……</p>
<p>技术人员经常性滴瞎子摸象？</p>
<p>你能说出你老板靠什么赚钱吗？就你们公司的盈利模式是什么？是技术密集型还是资本密集型，还是劳力密集型，还是社会效益型？估计很多人是说不出来的</p>
<p>我当年也不懂</p>
<p>为什么不懂呢？资本家的阴谋</p>
<p>资本家也不想你懂得太多，工具 (人) 懂那么多干什么？</p>
<p>资本家把技术人员分成前端，后端和移动端，还故意让他们互相隔离，这样的好处就是</p>
<p>任何一个技术人员，做得再好，都无法架空资本家，就需要一个老板的角色来统筹规划，组织所有人干活，因为不管是前端还是后端还是移动端，单独拉出去，放到市场上去，都是死路一条</p>
<p>因为市场上的产品，都是这几个端紧密结合的结果，不是吗？现在哪个软件产品只有 app 没有 cloud？或者只有 cloud 没有 app？尤其是 to c 的产品</p>
<p>有一些比如 saas，那些都是 to b 的软件，但是 to b 真的卖的是技术嘛？一般需要销售人员来配合吧？技术人员在 to b 的领域，反而经常被销售架空，就像我们群里聊的，有人两次创业，都被销售架空了，人家单拿着，你爱做不做，你不做换个人一样做</p>
<p>所以瞎子摸象吧，就是你让一个后端去做前端，或者让一个前端去写移动端，他往往不会，会吗？你试试看</p>
<p>这里面稍微好一点的就是移动端，实践下来发现，移动端是能够转成真全栈最合适的群体，这个结果也很让我自己意外，我本以为后端或者前端应该最容易，结果却是后端表现最为糟糕</p>
<p>所以无法成就自我，最终都是沦为为他人造梦的工具人</p>
<p>如果说瞎子摸象有客观因素 (资本家) 的话，那么刻舟求剑和叶公好龙则更多的是主观因素</p>
<h2 id="刻舟求剑"><a href="#刻舟求剑" class="headerlink" title="刻舟求剑"></a><strong>刻舟求剑</strong></h2><p>楚国人，乘船过江，剑掉下去了，然后在船上刻了一道痕，说等船到岸了，从这里跳下去捞剑</p>
<p>你有没发现技术人员总是在用过去的案例来预测将来？线性外推</p>
<p>就过去怎样，将来就会怎样，几十年前姓马的怎么做，现在还怎么做，c++ 98，java 6 几十年不变</p>
<p>我一直奇怪的是，为什么总有人说过去的技术，对于技术问题，我们关心的是，这个技术现在怎样，能否解决掉我眼前的问题，而不是过去有多少人用了什么技术解决了什么问题，那个有啥好说的？都是翔，遇到了翔难道不是应该看一下现在有没有什么方式不再去吃这坨翔？而不是砸吧砸吧擦着嘴说，这坨翔我曾经吃过？</p>
<p>谁关心你吃没吃过？</p>
<p>过去有人用了某些技术解决了某个问题，属实，但是那是他的成功，成功是很难复制的，失败往往会重现，所以成功学都是骗人的，因为成功的人会把他成功的那一块市场给吃掉，如果你去重复别人成功的故事，多半不会成功，因为别人已经把饭吃完了，剩下的都是翔啊</p>
<p>大人，时 (shi) 代(da)变 (bian) 了</p>
<p>当然这么想有工具人的道理，因为现有市场占有率越高，工作机会越多，越容易找到工作</p>
<p>但是呢，新技术的诞生是不受此影响的，总有人在不断尝试推陈出新，旧的问题也在不断暴露并被解决掉，如果我们停留在过去的话，那永远不会进步</p>
<p>别搞错，你不进步，你的竞争对手将来会教你进步，或者说会迫使你进步，因为市场本身也在优胜劣汰</p>
<p>生产力中也包括科学，<br>劳动生产力是随着科学和技术的不断进步而不断发展的。<br>科学技术是第一生产力</p>
<p>做老板的话，思维方式要提升，就是不要太关心过去怎样，而多看看现在是怎样一个情况，然后新技术会的人多还是少，这个不重要，重要的是生产力是否得到了提升</p>
<p>能解决问题的工具就是好工具，而且新技术往往需要的人工比较少，对于成本的节约非常明显，可以让老板自身获得市场上的相对优势，这也是为什么国外强调创新的原因，毕竟生产力决定了生产关系，如果生产关系因为生产力的发展而发生了改变，那么这个趋势不可阻挡</p>
<h2 id="叶公好龙"><a href="#叶公好龙" class="headerlink" title="叶公好龙"></a><strong>叶公好龙</strong></h2><p>叶公喜欢龙是出了名的，所有人都知道，然后有一天，龙真的来了，叶公躲到床下，浑身哆嗦吓得半死</p>
<p>标榜自己爱好技术的人很多，但真正用来解决问题的少</p>
<p>经常看到技术人员各种抱怨，以 java 为例，无数的人在说 java 语法繁琐，gc pause，慢，ui 丑，等等</p>
<p>不可否认，他们说的都是事实，但问题是，他们只看到了问题，并没有多少手段去解决问题</p>
<p>说白了就是技术不行，无力解决，所以抱怨也不奇怪</p>
<p>但是很有意思的是，当你告诉他们，java 语法繁琐有 project amber 在解决，gc 有 zgc，shanendoah 在解决，慢有 aot，大有 native image，丑有 javafx，当你把这些解决方案罗列到他们面前的时候</p>
<p>很多人的表现居然是抗拒甚至愤怒，而不是尝试</p>
<p>因为他们突然发现，有新的东西要学了</p>
<p>这难道不是他们一直以来备受困扰的问题吗？当别人把免费的解决方案放到他手上的时候</p>
<p>居然吓得不敢用了？试都不敢试了？活脱脱的一个现实版的叶公</p>
<p>当然在工作中，我们还有千里之行，始于足下等故事的现实版，不一一列举，中小学教材里的故事都很有寓意，经常能够想起来</p>
<p>我把人生简单分为三个阶段，第一求学，第二工具 (人)，第三独立 (老板)</p>
<p>那几乎所有人都是从工具人出发，在求学阶段如果顺利一点，工具人的起点会高一点，比如薪酬会更高一点，但是从工具人要完成到老板的蜕变，并非所有人都能完成，工具人这个阶段更像是原始资本积累</p>
<p>当然当了老板之后可能收入反而变少了，这很正常，但是能做老板，能自己承担决策和决定带来的一切后果，这种自由度，不是做工具人时候能够做到的，输会输得很多，赢会赢得很大，所以决策很重要</p>
<p>而决定老板决策对错的，不是七嘴八舌的意见看法观点，市场会告诉你结果，很多时候，你做一件事，赞同者众，结果在市场上反而赔了进去。很多时候，你做一件事，亦有不少反对者，但是市场却给了你正向反馈，那你应该听市场的</p>
<p>而反对声音经常来自工具人，那为什么工具人会有这样的错误看法，该如何克服这些问题，那么总结出来，如果要从一个工具人蜕变成老板，那么需要克服上述的三个问题</p>
<p>有意思的是我发现我招的实习生，一个个表现得都跟小老板的一样，动不动就跑去接单，什么给留学生做 java 作业赚得比较多，都是他们告诉我的，可能这也是物以类聚，人以群分</p>
<p>我自己做工具人的时候，后来慢慢觉悟出来，如何做一个完美的工具人，就是要克制自己的欲望，要尽量去伺候好老板，尤其是要把技术问题，用非常通俗易懂的语言解释给老板听，就像皇帝身边的那些人</p>
<p>我能做这一点，但是呢我后来发现，这样非常浪费时间和力气，而且要应付老板的猜忌，老板始终会怀疑你在骗他，吃力不讨好，如果我有这个力气和时间，我为什么不自己试试呢？</p>
<p>老板资本宁有种乎？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/AugularJS%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/22/AugularJS%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" class="post-title-link" itemprop="url">AugularJS思维导图</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-22 19:19:04 / Modified: 19:19:25" itemprop="dateCreated datePublished" datetime="2020-04-22T19:19:04-04:00">2020-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="../images/AngularJS-7597561.png" alt="AngularJS"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/Angular%E5%8F%91%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/Angular%E5%8F%91%E5%B1%95/" class="post-title-link" itemprop="url">Angular发展</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-21 12:21:36 / Modified: 12:29:56" itemprop="dateCreated datePublished" datetime="2020-04-21T12:21:36-04:00">2020-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="前端黎明"><a href="#前端黎明" class="headerlink" title="前端黎明"></a><strong>前端黎明</strong></h2><p>HTML是一种标记语言，属于声明式编程范式，然而，声明式的缺点——复用性差，往往会制约着开发者对应用进行扩展。</p>
<p>早期的网页应用往往体量较小，加之用户体验不强，很多服务器直接将HTML作为数据处理，形成MVC的中介模式（脱藕）实现，model和view是两种不同的数据系统，中介controller则负责将不同的model输入映射到响应的view输出。</p>
<p><img src="../images/v2-33c6b0d61468c9c47096d927ba63a7f4_b.jpg" alt="img"></p>
<blockquote>
<p>中介模式<br>使用一个中介对象来封装两个系统之间的交互，使得各对象不用显示地相互引用</p>
</blockquote>
<p>但是随着前端交互越来越多，静态的HTML服务端处理根本不能满足交互需求，因此有实现将数据与视图的映射（MVC）迁移到前端，例如AngularJS，Backbone等。</p>
<h2 id="混乱大时代"><a href="#混乱大时代" class="headerlink" title="混乱大时代"></a><strong>混乱大时代</strong></h2><p>但是随着应用体量的不断变大，前端交互逻辑的不断复杂化，这类框架的Controller越来越复杂难以管理，加上浏览器的事件驱动模型（事件循环），使得前端开发步入了困境。</p>
<p>首先解决这一困境的是React，采用函数式编程语言中广泛使用的单向数据流，控制耦合数据的产生和事件的作用范围。</p>
<p><img src="../images/v2-c69ae47c13a33ae29258aaa4e5a746c1_b.jpg" alt="img"></p>
<blockquote>
<p>单向数据流<br>函数式编程（λ演算），例如LISP，采用的是不可变数据+态射变换的方式进行计算，最早由<em>阿隆索·丘奇</em>(Alonzo Church)提出，想象一个函数（函子）的参数是函数，返回值也是函数。（不可变数据本身也是函数，总是返回自身参数，即单位元，单位态射）<br>参考：<br><a href="http://link.zhihu.com/?target=https%3A//github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn">https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn</a><br><a href="http://link.zhihu.com/?target=https%3A//plato.stanford.edu/entries/category-theory/">https://plato.stanford.edu/entries/category-theory/</a><br>维持态射连续性，即形成unidirectional network（单向网络），输入单位元总使从计算系统的输入流向输出（想象一个工业生产线）<br>这样的做法的目的，也是函数式编程的优点之一（参考傻瓜函数式）：<br>因为FP中的每个符号都是final的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。<br>当然函数式的这一优势不仅仅用在前端领域，包括密集计算（模型能够运行则要求运行不出错，例如Haskell），军用（导弹巡航控制），核电站中控（安全要求高），气象等等领域。</p>
</blockquote>
<p><strong>但是React夹杂的私货，却也被混入了前端开发中，这便是MVVM</strong>。</p>
<p><img src="../images/v2-5c939ce85d3493b84228c4e9c42ddcfb_1440w.jpg" alt="img"></p>
<p>每一个设计模式，都有他的应用领域，MVVM是马丁·富勒的Presentation Modal（表示模型）的变体，由约翰·高斯曼提出，优点是<strong>不依赖于特定用户界面平台</strong>。</p>
<p>缺点呢？创造者约翰·高斯曼自己就提出：</p>
<blockquote>
<p>实现MVVM的开销对于简单的UI操作是“过度的”，对于更大的应用来说，推广ViewModel变得更加困难。而且，非常大的应用程序中的数据绑定会导致相当大的内存消耗。</p>
</blockquote>
<p>不仅如此，浏览器在实现视图绑定的阶段，往往伴随着性能开销，而采用VM到V的映射，<strong>往往伴随着大量的视图绑定和解绑过程</strong>，会造成相当的性能瓶颈。</p>
<p>React可以通过很多优化控制重绘的数量（diff）和时间（requestAnimationFrame，setTimeout），但是当应用体量越来越庞大的时候，它所提到的<strong>“Web UI中跨层级移动操作特别少”这个前置条件慢慢失效，而维护一个庞大的数据池带来的内存消耗和数据持久化问题也越来越突出</strong>。</p>
<p>但是React为什么还要采用MVVM而放弃掉MVC呢？</p>
<p>Facebook成立于2004年，而2005年WWDC大会上，苹果不仅发布了iPod nano这一音乐领域的飓风，还联合各家浏览器厂商，联合发布了围堵IE的<strong>WebKit</strong>，浏览器领域迎来了新的一波风暴。</p>
<p><img src="../images/v2-0b18db551fb28f22ec2b2a6144e314fa_b.jpg" alt="img"></p>
<p>当然，刚刚成立的facebook直到当年九月份才将高中版Facebook向大众开放，自然错过了浏览器之争的关键时机。但是作为以互联网产品为盈利主力的facebook，肯定不希望自己的产品被浏览器钳制，不可能因为浏览器的更新迭代甚至是恶意竞争而妨碍到自己的利益。并且在当时浏览器兼容问题严重的情况下，MVVM的平台无关也更加符合Facebook甚至是用户的切身利益。</p>
<p>另外，由于没有考虑到前端的复杂度会到达今天这样的地步，网景在设计JavaScript的时候，考虑利用函数式编程中“直观”的优势，以及异步带来的交互友好，将JS设计成了协程异步系统，这毫无疑问将编程要求提高到一个较高的层次，使得一线开发人员叫苦不迭。<strong>而MVVM又能有效地将异步的问题同步化（针对数据操作）</strong>，因此，选择MVVM这一模式几乎是必然的。</p>
<p>因此React在2011年开始用于facebook的newsfeed，而这一年正是浏览器竞争最为激烈的一年，不管是从开发效率还是从运行稳定性上来看，React都是最好并且最符合Facebook利益的选择，于是快马加鞭，于2013年正式向公众开放。</p>
<p><img src="../images/v2-1c6fb3d444a24b9d47da59aa59cf0e28_b.jpg" alt="img"></p>
<p>React的单向数据流思想，让组件化，工程化的进程不再受到阻碍，整个前端领域也迎来了大的发展期。</p>
<p>本来故事到这里就应该结束了的，不过，谁也没有想到会有另外一个公司出手，将前端领域带入了另外一个世界。</p>
<hr>
<h2 id="移动端大时代"><a href="#移动端大时代" class="headerlink" title="移动端大时代"></a><strong>移动端大时代</strong></h2><p>08年大家都印象深刻，乔布斯将手中的iphone4举向空中的那一刻，相信每一个人都心潮澎湃。而此时iOS的竞争对手Android加入了Google，开始了与iOS长达多年的拉锯战。面对发布会上乔布斯自豪的网页浏览功能，Android团队建议放弃KHTML，加入WebKit开发项目。</p>
<p>但是不知是不是早有预谋还是其他原因（毕竟08年Google已经有了v8），08年加入WebKit的Google从09年开始就成为了WebKit最大的代码提供者，而提交贡献相对较少的苹果却拥有最终决断权。</p>
<p>于是当2013年blink爆炸性发布时，苹果WebKit团队领头人Maciej Stachowiak说：</p>
<blockquote>
<p>我们在写任何WebKit2代码前就问了Google的人，他们愿不愿意将多进程架构的支持整合到WebKit中，他们的答案是否定的。在这种情况下，我们面临的选择是做一个怀有敌意的Chromium分支，或者写我们自己的多进程架构，或者继续使用单进程架构。我们选择了写自己的多进程架构。</p>
</blockquote>
<p>而凭借着多进程，v8，沙箱的三板斧，Chrome迅速侵占浏览器市场，终于在15年底，完成了对浏览器领域的垄断。</p>
<p><img src="../images/v2-9dc80c05224c32a8229415e5c5c7d24f_b.jpg" alt="img"></p>
<p>这时浏览器巨人再回过头看，<strong>看到的是“平台无关”的Happy Hacking代码肆意运行在它的浏览器上</strong>。</p>
<p>Don’t be evil?事实应该是Don‘t let anybody say I’m evil。涉及到利益之争，不可能不重视。早在2012年，当市场上风闻Facebook新项目时，Google就将其假象竞争对手AngularJS收入囊中，几乎是与blink同时布局。</p>
<p>开源世界的主导权竞争就是人才的竞争，谷歌早就深谙这一套玩法，为了更广大的互联网市场，Google开始了新一轮的降维打击，而这一布局的关键一环，就是——Angular。</p>
<hr>
<h2 id="只用一个平台的野心"><a href="#只用一个平台的野心" class="headerlink" title="只用一个平台的野心"></a><strong>只用一个平台的野心</strong></h2><p>Hack的思想，是如何在系统框架内部，实现对自己有利的功能，Facebook是一家富有极客精神的公司，因此，React的实现也颇有些无耐，没有浏览器，即便再Hack，都只是别人既定框架下的小聪明。</p>
<p>而这时，Angular在紧锣密鼓地计划中：</p>
<p>stage中的代码阻塞如何处理？工程界早有成熟的方式，可以采用多线程的方式，主线程处理不了的任务转化成事件，转交给从线程运行，保障高IO的进行——chrome 17支持了web worker。</p>
<p>前端开发调试，离线浏览，消息推送？没问题，chrome service worker为你提供保障。</p>
<p>提供了完整的性能监视，每个区域的重绘，fps，layer边界，都给你直观地展示，堪称世界上最完善的浏览器调试工具。</p>
<p>甚至是微软，经历了IE的失败，比其他人都更加意识到开源社区的重要，作为事件驱动windows系统中的长期经验总结，Rx的js版本Rxjs，顺理成章地被运用到同样处于事件驱动环境的浏览器中。</p>
<p>接下来，就是等待能够彻底压榨浏览器性能，用户友好，集成化的前端开发框架了。</p>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><blockquote>
<p>上回说到Google需要一款前端技术栈将它的浏览器性能完全发挥，并于其他浏览器拉开身位，阻击平台无关（MVVM）的各类框架。<br>如何能够让Google在浏览器制霸之后，将魔抓伸向应用层？<br>如何在渲染中发挥出浏览器最大性能呢？</p>
</blockquote>
<p>最近房价波动比较厉害，作为一个高薪程序员，新房大多地段不好，而购入一套离公司近的二手房，自然需要一个好的房地产中介。</p>
<blockquote>
<p>需要他联系买卖双方</p>
</blockquote>
<p>但是这时却有两种中介商：</p>
<ol>
<li><strong>所有买方跟我联系，我同意把你们愿意出的价格和需求报给卖方，最后把结果给你们双份分开展示</strong>（MVVM）</li>
<li><strong>你要买房？我单独联系卖方和你，你说啥，我就原封不动地传达给卖方，反之亦然</strong>（MVC）</li>
</ol>
<p>大家别急着选 2，想象一个场景，如果卖方那群人天天在变，一会儿这个看不上，一会儿那个瞧不起，房子也不停在变，早上 50 平晚上 100 平的，你会不会觉得第一种房地产中介要好一点呢？</p>
<blockquote>
<p>大哥我跟你说，这个卖家真的有毒，上次那房看的时候在 3 环，卖的时候带我们去 5 环，您看看这个，这个靠谱，他家房子是真的大。</p>
</blockquote>
<p>你也别急着调过头选 1，就算卖家不靠谱，1 中的中介每天下午 5 点才能将所有卖家信息汇总给你看，你婚礼在上午 8 点，未婚妻说：</p>
<blockquote>
<p>不干！什么时候买房，什么时候结婚！</p>
</blockquote>
<p>这个时候你又怎么办？另外即便未婚妻能等到下午 6 点，中介从 5 点开始翻记录就翻到了 6 点半，你又怎么办？</p>
<p>对的，浏览器也遇到这个问题，js 中的 dom 操作是买方，而页面渲染则是卖方。</p>
<hr>
<p>React 作为一个出色的前端框架，通过 MVVM 做到了平台无关，facebook 相关产品在任何浏览器上打开都能有不错的性能，甚至能够进军原生终端应用开发，这都是 MVVM 架构的功劳。</p>
<p>但是 vm 这一全局的 view 副本，始终在消耗着浏览器资源，项目小的时候看不出来，当项目无限膨胀的时候，弊病开始显现。</p>
<p>书接上回，Google 需要一个前端框架，这个技术栈<strong>不一定需要 Google 产品在其他浏览器上的体验与 Chrome 一样，但一定要在 Chrome 上有极致的性能</strong>。用纯数据的方式保留一个 view 副本？不可能也不需要这么做。</p>
<p>Angular 框架采用 TypeScript 开发（工程化会另有文章讨论），其中一个优点便是代码易读，打开源码<code>angular/packages/core/src/linker</code>,里面有许多抽象类，方便了解大致的 Angular 渲染机制。</p>
<ol>
<li>templateRef: 用户声明模板</li>
<li>viewRef: 自定义视图</li>
<li>elementRef: 原生 Dom 元素</li>
<li>viewContainerRef:自定义挂载点</li>
<li>componentFactory: 组件工厂函数</li>
<li>moduleFactory: 模块工厂函数</li>
</ol>
<p>举例说明两个重要类：ComponentRef 和 viewContainerRef。</p>
<p>ComponentRef 需要确定和视图的关系，以及相关的变更检测，依赖注入等（变更检测在 M 中进行而非 vm 中）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;https:&#x2F;&#x2F;github.com&#x2F;angular&#x2F;angular&#x2F;blob&#x2F;master&#x2F;packages&#x2F;core&#x2F;src&#x2F;linker&#x2F;component_factory.ts</span><br><span class="line">&#x2F;&#x2F; 组件引用</span><br><span class="line">export abstract class ComponentRef&lt;C&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 宿主元素</span><br><span class="line">  abstract get location(): ElementRef;</span><br><span class="line">  &#x2F;&#x2F; 依赖</span><br><span class="line">  abstract get injector(): Injector;</span><br><span class="line">  &#x2F;&#x2F; 组件实例</span><br><span class="line">  abstract get instance(): C;</span><br><span class="line">  &#x2F;&#x2F; 宿主视图</span><br><span class="line">  abstract get hostView(): ViewRef;</span><br><span class="line">  &#x2F;&#x2F; 检测树</span><br><span class="line">  abstract get changeDetectorRef(): ChangeDetectorRef;</span><br><span class="line">  &#x2F;&#x2F; 获取组件类型</span><br><span class="line">  abstract get componentType(): Type&lt;any&gt;;</span><br><span class="line">  &#x2F;&#x2F; 组件销毁</span><br><span class="line">  abstract destroy(): void;</span><br><span class="line">  &#x2F;&#x2F; 组件销毁回调</span><br><span class="line">  abstract onDestroy(callback: Function): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>viewContanerRef 需要实现对 viewRef 的挂载和删除，因此他的抽象类声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; angular&#x2F;packages&#x2F;core&#x2F;src&#x2F;linker&#x2F;view_container_ref.ts</span><br><span class="line">export abstract class ViewContainerRef &#123;</span><br><span class="line">  &#x2F;&#x2F; 针对每一个container 的锚点 element</span><br><span class="line">  abstract get element(): ElementRef;</span><br><span class="line">  &#x2F;&#x2F; 清除内容</span><br><span class="line">  abstract clear(): void;</span><br><span class="line">  &#x2F;&#x2F; 获取view</span><br><span class="line">  abstract get(index: number): ViewRef | null;</span><br><span class="line">  &#x2F;&#x2F; 获取view 长度</span><br><span class="line">  abstract get length(): number;</span><br><span class="line">  &#x2F;&#x2F; 创建嵌入式view（偷懒专用）</span><br><span class="line">  abstract createEmbeddedView&lt;C&gt;(</span><br><span class="line">    templateRef: TemplateRef&lt;C&gt;,</span><br><span class="line">    context?: C,</span><br><span class="line">    index?: number</span><br><span class="line">  ): EmbeddedViewRef&lt;C&gt;;</span><br><span class="line">  &#x2F;&#x2F; 插入view</span><br><span class="line">  abstract insert(viewRef: ViewRef, index?: number): ViewRef;</span><br><span class="line">  &#x2F;&#x2F; 移动view</span><br><span class="line">  abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;</span><br><span class="line">  &#x2F;&#x2F; 获取view 的 index</span><br><span class="line">  abstract indexOf(viewRef: ViewRef): number;</span><br><span class="line">  &#x2F;&#x2F; 删除view</span><br><span class="line">  abstract remove(index?: number): void;</span><br><span class="line">  &#x2F;&#x2F; 解绑但是不删除view</span><br><span class="line">  abstract detach(index?: number): ViewRef | null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意那个 move 移动方法，稍后会有讨论许多其他框架中“跨层级移动不会发生”的前置条件是否存在。</p>
<p>注：变更检测的简单声明在 angular/packages/core/src/change_detection/change_detector_ref.ts</p>
<p>如果<strong>组件绑定的 ChangeDetectionRef 发现了变更，标记为脏，则重新运行 Component 到 View 的渲染，官方称作渲染引擎</strong>。</p>
<p>这便是Angular的MVC架构：</p>
<p><img src="../images/v2-344b3bf052c0670d0961388783ca35e7_b.jpg" alt="img"></p>
<p>直接操作DOM，极大地减少了中间数据操作，提升了性能。</p>
<hr>
<p>Angular 4.0 更新了渲染引擎 Renderer2，将渲染操作封装成函数，方便大家进行渲染（直接使用有违背组件化的开发方式）。 而现在，官方已经放出了 Renderer3，也就是<a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/92e80af8751993879a1d0b4a5a029ededb973e4d/packages/core/src/render3/STATUS.md">ivy 渲染引擎</a>，将摇树优化，依赖，国际化等等操作融入到渲染层级，并且以“<strong>装饰器即编译</strong>”的理念作为中心思想。</p>
<p><img src="../images/v2-71e10093612ce44a2ec73dd802369055_1440w.jpg" alt="img"></p>
<p>更加恐怖的是，能够在 <strong>6.2kb</strong> 的大小下实现一个渲染的最小功能集。</p>
<hr>
<p>DOM 中有一个幽灵——</p>
<blockquote>
<p>良好用户体验的保证是 60 帧的刷新率，最好是120帧！</p>
</blockquote>
<p>然而在这 8ms 左右的帧时间中，一次 <strong>DOM 结构变更（appendChild,removeChild）会占用平均 4ms 左右的时间</strong>，因此——</p>
<h2 id="你得代码必须在-4ms-内执行完毕"><a href="#你得代码必须在-4ms-内执行完毕" class="headerlink" title="你得代码必须在 4ms 内执行完毕!"></a><strong>你得代码必须在 4ms 内执行完毕!</strong></h2><p>而且 DOM 结构变更是浏览器过程，浏览器会保证你单纯的 dom 变更操作绝对会有稳定的用户界面变更，但<strong>这个过程在 js 代码中不可优化！</strong></p>
<p>React 的解决办法，是利用浏览器 RquestAnimationFrame 或者自己统计时间（RequestAnimationFrameWithSetTimeout）,<strong>将需要执行的reconsiliation代码和提交的DOM变更依次安排在浏览器渲染结束的空隙里</strong>。</p>
<p>但这有没有真正解决问题，大家都有自己的判断。</p>
<p>Angular 采用了另外的方式：</p>
<p><strong>（一）MVC 的变更是响应式的，并且脏检查只针对数据（onPush）。</strong></p>
<p>渲染引擎在处理数据变更时，采用单向绑定（数据变更即更新）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; angular&#x2F;packages&#x2F;core&#x2F;src&#x2F;view&#x2F;util.ts</span><br><span class="line">&#x2F;&#x2F; 检测view是否变更</span><br><span class="line">export function checkAndUpdateBinding(</span><br><span class="line">    view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean &#123;</span><br><span class="line">  if (checkBinding(view, def, bindingIdx, value)) &#123;</span><br><span class="line">    view.oldValues[def.bindingIndex + bindingIdx] &#x3D; value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; angular&#x2F;packages&#x2F;core&#x2F;src&#x2F;view&#x2F;text.ts</span><br><span class="line">&#x2F;&#x2F; 以textNode为例，还有内联性能优化</span><br><span class="line">export function checkAndUpdateTextInline(</span><br><span class="line">    view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any,</span><br><span class="line">    v7: any, v8: any, v9: any): boolean &#123;</span><br><span class="line">    let changed &#x3D; false;</span><br><span class="line">      const bindings &#x3D; def.bindings;</span><br><span class="line">      const bindLen &#x3D; bindings.length;</span><br><span class="line">      if (bindLen &gt; 0 &amp;&amp; checkAndUpdateBinding(view, def, 0, v0)) changed &#x3D; true;</span><br><span class="line">      &#x2F;&#x2F; ...10个内联</span><br><span class="line">      if (changed) &#123;</span><br><span class="line">    let value &#x3D; def.text !.prefix;</span><br><span class="line">    if (bindLen &gt; 0) value +&#x3D; _addInterpolationPart(v0, bindings[0]);</span><br><span class="line">    &#x2F;&#x2F; ... 10个内联</span><br><span class="line">    const renderNode &#x3D; asTextData(view, def.nodeIndex).renderText;</span><br><span class="line">    view.renderer.setValue(renderNode, value);</span><br><span class="line">  &#125;</span><br><span class="line">  return changed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，单纯的数据的改变无法引起DOM的结构变更。</p>
<p>并且，<strong>DOM操作是会发生节点间的移动的！</strong>拖拽，弹框等等，如果设计大量复杂组建节点，一次DOM的移动操作伴随大量重绘。</p>
<p>这些问题，在Angular中也只是调用一个move方法，名正言顺地replaceChild。</p>
<p>但是当NgIf等发生时，还是会有结构变更怎么办，如果这个时候大量代码逻辑导致4ms内代码运行超时，卡顿还是会发生。</p>
<p><strong>（二）我不与你在这 4ms 中争抢性能，使用 webWorker 在另一个线程处理逻辑，最后通过指令告诉浏览器视图更新，在这 8ms 中尽情地完成你那平均 4ms 的渲染~</strong></p>
<p>这方法就是Angular在渲染性能领域的杀手锏，也是充分利用浏览器做到的极致性能，官网描述，源代码在<code>angular/packages/platform-webworker-dynamic/</code>，官网描述为：</p>
<blockquote>
<p>Achieve the maximum speed possible on the Web Platform today</p>
</blockquote>
<p>汪老师在翻译时，加了一个‘以及未来’:</p>
<blockquote>
<p>通过Web Worker和服务端渲染，达到在如今(以及未来）的Web平台上所能达到的最高速度</p>
</blockquote>
<p>为什么有个括号里的以及未来？因为webworker与浏览器强关联，<strong>技术平台只有在浏览器垄断的庇护下才能肆无忌惮地使用web worker，其技术架构甚至比绝大部分客户端程序的io性能还要高（因为webWorker是系统线程，不是用户态）</strong>。</p>
<p>这一点是如何实现的呢？</p>
<p><img src="../images/v2-0aae540aa681bf0b1f65ed3048d549fd_b.jpg" alt="img"></p>
<p><strong>组件逻辑代码完全与主线程相分离，在另一个线程处理数据，而在UI中只进行渲染有关操作。</strong>（不然你得Angular师傅叫你把代码写在service里面只是为了好看么？）</p>
<p><img src="../images/v2-bbd1c263d0558f50140f00b10fb0afe8_b-20200421122638731.jpg" alt="img"></p>
<p><strong>通过ServiceMessageBroker提交变更，渲染引擎在客户端获取变更数据，进行视图渲染。</strong></p>
<p>正如<a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DKz_zKXiNGSE%26t%3D4s">ason Teplitz演讲</a>所言，所有如下的操作：</p>
<p><img src="../images/v2-4df3c92e9e36f88ff2b1469e3b39d2d1_1440w.jpg" alt="img"></p>
<p>都不会对你的视图渲染造成任何影响，<strong>V与M在前端实现了真正的分离</strong>！</p>
<hr>
<p>是的，Angular实现的（设计目标更严谨），是浏览器中的最强渲染性能，强大的浏览器后盾允许他这么做。</p>
<p>但是采用了MVC的方式，会不会导致AngularJS一代那样的异步错乱和数据意外耦合变更的问题呢？</p>
<h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p><img src="../images/v2-9b71342a3832a85b2bb4d5215cbf6552_r.jpg" alt="Angular物语（三）ReactiveX（1）"></p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a><strong>动机</strong></h2><blockquote>
<p>如果你觉得你没有必要用Rxjs，那你就不要用</p>
</blockquote>
<p>这个说法很万金油，可以避免很多不必要的争论，但是并没有什么建设意义——什么时候会觉得有必要用呢？</p>
<p>先给一个结论，大家可以参考参考：</p>
<blockquote>
<p>在一个<strong>事件驱动系统</strong>中处理<strong>复杂异步</strong>，<strong>必须</strong>使用ReactiveX或者类似工具</p>
</blockquote>
<p>必须？是的，必须！</p>
<p>就是这么绝对，毕竟先抛出一个绝对的概念，大家讨论特殊情况的时候才能言之有物不是？</p>
<p>这个武断中有一下几点需要特殊说明——</p>
<ol>
<li><strong>事件驱动</strong></li>
<li><strong>复杂异步</strong></li>
<li><strong>必要性</strong></li>
</ol>
<p>我们一个个说明吧~</p>
<hr>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a><strong>事件驱动</strong></h2><p>XXX驱动，一般指的是你代码逻辑运行的原因。</p>
<p>如果你代码运行是因为某种事件或者消息——事件驱动。</p>
<p>如果是因为数据的改变——数据驱动。</p>
<p>首先声明这不是一个编程概念，因为你很容易在非编程领域看到这些概念——比如市场分析可以采用事件驱动和数据驱动的方法——但是他却是在编程概念之上更高层级的思想方法，<strong>很多种模式的不同实现就是来源于这两种不同的思想</strong>（例如MVC，MVVM）。</p>
<p>举例说明一个随时间变化的数据系统：</p>
<p><img src="../images/v2-815e8fe27815962eaf4b9e19e70af166_b.jpg" alt="img"></p>
<p>你如果注重数据，注重代码实现（代码的目的就是将事件消息翻译成数据变更）而不在意时间方向上的变化——数据驱动：</p>
<p><img src="../images/v2-cc7b18b07476255ecd2edf30f42ddc19_b.jpg" alt="img"></p>
<p>你如果注重事件，注重服务而不在意单一时刻的数据变化——事件驱动：<img src="../images/v2-45789737110cc75ba130a034da041d93_1440w.jpg" alt="img"></p>
<p>有什么区别呢？</p>
<p>我们先来看数据驱动：</p>
<ol>
<li>每一时刻只需要考虑数据的变更，而不需要考虑数据为什么变更，又会引起怎样的变更——<strong>耦合性低，不可回溯</strong></li>
<li>状态的迁移需要由编程人员或是系统发出的消息驱动——<strong>即时性差</strong></li>
<li>总是由一个状态迁移到另一个状态，方便时间旅行——<strong>可回退</strong></li>
</ol>
<p>惊喜的是，事件驱动就像它的另一面一样，优缺点完全互补：</p>
<ol>
<li>需要考虑特定事件会引起怎样的变更，多个事件极容易出现耦合，但是容易定位数据变更的原因——<strong>耦合性大，可回溯</strong></li>
<li>状态的迁移是由事件决定的，事件逻辑不受阻挡——<strong>即时性强</strong></li>
<li>单一时刻数据不确定，很难进行时间旅行——<strong>不可回退</strong></li>
</ol>
<p>因此两种思想方法的口号也就容易理解了——</p>
<blockquote>
<p><strong>数据驱动——人类不善于处理逻辑，但善于处理数据</strong><br><strong>事件驱动——一切以最大化服务为优先</strong></p>
</blockquote>
<p>数据库事务，浏览器DOM，游戏帧画面渲染都是数据驱动，他们之间有一定的共性——</p>
<ol>
<li>对数据准确定有要求</li>
<li>状态迁移没有额外开销或者开销很小（文件存储读写，或者直接渲染一帧即释放）</li>
</ol>
<p>服务器IO，浏览器接口，游戏逻辑都是事件驱动，他们之间也有一定的共性——</p>
<ol>
<li>需要对用户操作或者请求及时响应</li>
<li>全部状态迁移几乎不可能或者开销极大，只能通过消息进行</li>
</ol>
<p><strong>所谓的前端层面有名的伪概念之一——数据驱动适合前端开发——完完全全就是错误的！</strong></p>
<p>并且，浏览器为了快速响应用户操作可是采用的事件驱动模型，为此还在单线程中实现了协程，这一方向在可见的未来不会改变。</p>
<p>那怎么处理这个复杂的，即时性要求如此之高的系统呢？如何优化其耦合性大，不可回退的缺点？实现高可用呢？</p>
<p>数据驱动模式一般如何解决不可回溯的缺点？</p>
<p><strong>将事件作为数据存储——flux，redux模式</strong></p>
<p>点到为止，应该很多前端都很熟悉这样的概念，其实这样的概念和redis缓存，sql语句操作数据库没有什么本质区别，都是消息——事务——数据变更的模式。</p>
<p>同理可得，如何处理事件驱动中的耦合性问题呢？</p>
<p><strong>将数据也作为事件发出——stream模式</strong></p>
<p>对的，这就是ReactiveX定义中的“<strong>数据流</strong>”。</p>
<hr>
<h2 id="复杂异步"><a href="#复杂异步" class="headerlink" title="复杂异步"></a><strong>复杂异步</strong></h2><p>浏览器给了你异步的代码能力，但是怎样实现异步，怎样处理异步，却没有告诉你行之有效的方法。</p>
<blockquote>
<p>异步怎么可能复杂，不就是async await么？</p>
</blockquote>
<p>好吧，那你坐好了，我给你看看异步到底有多复杂：</p>
<p><strong>性能问题</strong></p>
<p>大部分所谓的异步代码比同步代码还慢（需要调度时间）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">await A; await B; awaitC;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">await Promise.all([A,B,C])</span><br></pre></td></tr></table></figure>

<p><strong>竞态问题</strong></p>
<p>发出多个请求，以最先返回的数据为准？（别急着打产品经理）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await Promise.race([A,B])</span><br></pre></td></tr></table></figure>

<p>嗯，这些好像Promise也能做，不急，还有其他问题呢。</p>
<p><strong>组合问题</strong></p>
<p>需要一次异步紧跟上一次异步，即时处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const result_1 &#x3D; await Promise.All([A,B,C])</span><br><span class="line">const result_2 &#x3D; await D(result_1[0])</span><br><span class="line">&#x2F;&#x2F; 异步耦合，也是耦合</span><br></pre></td></tr></table></figure>

<p><strong>并发问题</strong></p>
<p>需要进行节流和去抖。</p>
<p><strong>撤销问题</strong></p>
<p>需要必要的时候撤销回调，防止空置错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await A;</span><br><span class="line">if(componentDestroied)&#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异常问题</strong></p>
<p>需要统一处理异步异常，捕获异步异常以便让异步顺利进行，处处try catch？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    await A;</span><br><span class="line">    await B;</span><br><span class="line">&#125;catch(err)&#123;</span><br><span class="line">    &#x2F;&#x2F; error handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调度问题</strong></p>
<p>这个promise只有micro一种调度模式，你如果需要用其他调度方式，恭喜你扑街：</p>
<p><img src="../images/v2-bf04a0b5908d27db992f7c591bba4ad7_b.jpg" alt="img"></p>
<p>micro和macro都有可能导致页面渲染阻塞（前者推迟，后者导致逻辑帧挤压物理帧），想要更加流畅的效果？试试animationFrame？</p>
<p>更或者，你是希望用到webworker多线程渲染（主线程只提交patch），那就得自己实现调度器了~</p>
<p>这些还只是冰山一角，还有循环变更，事件过滤，事件侦听，多播等等问题，信息交换会遇到什么问题，异步能把他们都走一遭~</p>
<p>别紧张，这些问题有没有简单的可以解决的办法呢？哈哈，你算是找对人了！</p>
<hr>
<h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a><strong>必要性</strong></h2><p>不过很多有后端经验的朋友肯定会反驳我——<strong>解决异步耦合问题不是可以用面向对象么？</strong></p>
<p>是的，类和对象的思想就是<strong>封装数据和事件（行为）</strong>，理论上数据驱动的问题和事件驱动的短板都可以用面向对象来弥补。</p>
<p>但是，面向对象需要复杂的结构信息来声明依赖，当异步过于复杂的时候，你需要维持一个异常庞大的结构，这样就回到了该用库还是该自己实现的问题上——不过以事件驱动系统中遇到的异步问题复杂度，自己用面向对象实现很不可靠。</p>
<p>不信问问用NodeJs的小朋友，最多做做可读可写流的连接，用人处理过race，combine，mergeAll？</p>
<p>当然，如果你觉得完全没有使用Rxjs的必要，那么可能存在以下几种情况——</p>
<ol>
<li>处于一个完全数据驱动系统下（React），状态迁移是由固定消息驱动的。如setState，将所有数据流订阅之后再打平成数据，然后setState？这有意义？那自动订阅然后setState呢？那就请小心处理并发问题（diff可是个性能无底洞）。</li>
<li>不需要处理复杂的异步问题。比如博客，官网等产品，数据来源确定，前端往往只有展示的需求。</li>
</ol>
<hr>
<h2 id="Rxjs和Angular"><a href="#Rxjs和Angular" class="headerlink" title="Rxjs和Angular"></a><strong>Rxjs和Angular</strong></h2><h2 id="Angular是数据驱动么？"><a href="#Angular是数据驱动么？" class="headerlink" title="Angular是数据驱动么？"></a>Angular是数据驱动么？</h2><p>这么说某种程度也对，毕竟class的变量和elementRef的绑定是数据驱动的（数据改变会引发响应逻辑），但是也仅仅停留在一个Component声明内部，并且是响应式实现（getter，setter），本质不是变量改变，而是触发了新的事件。</p>
<p>另外提一句，vue也是如此的原理，但是getter，setter没有暴露给你，用watch和computed配合Rxjs说不定是个很好的思路（但是它是diff实现，同样也要考虑性能问题，虽然diff只是局限于component内部）。</p>
<p><strong>全局来看，Angular触发视图变更的原因，有且只有zone拦截的事件！，并且是响应式变更至template，是一个不折不扣，200%的事件驱动系统，和浏览器实现高度吻合！</strong></p>
<p>数据驱动有什么问题？毕竟都流行那么多年了？</p>
<p>因为前端的大环境改变了，我也希望大家能清楚地明白这一趋势。</p>
<p>数年前前端的主题是跨平台，因此数据驱动的MVVM大行其道可以理解，但是<strong>DOM diff消耗性能阻塞协程，状态手动迁移导致异步性能极差</strong>，是无论如何无法被忽视的。</p>
<p>而浏览器平均patch时间是4ms左右，现代浏览器普遍60-120hz的刷新能每个事件循环你有10ms左右的时间处理逻辑。</p>
<p>好像时间挺宽裕的，别忘了，历史的洪流在不断向前——</p>
<p>5g时代如果VR大行其道，低于240hz产生的栅栏效应将严重影响用户体验，这种情况下——<strong>你已经完全没有了在渲染线程处理业务逻辑的时间</strong>。<br>再加上万物互联和1ms延迟导致的呈几何倍数增长的异步问题，届时如何为用户提供服务？</p>
<p>platform-webworker提供了多线程渲染的新的解决办法，服务将渐渐凌驾于实现之上，面对着新的产业升级，<strong>这波车，你上不上？</strong></p>
<hr>
<p>明白为什么要使用Rxjs了么？</p>
<p><strong>更快（快速无阻塞响应服务），更稳定（数据流约束耦合），更方便（函数式避免复杂结构）</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/%E7%BE%8E%E5%9B%BD%E4%BA%BA%E6%80%A7%E6%A0%BC%E7%89%B9%E7%82%B9%E8%A7%82%E5%AF%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/%E7%BE%8E%E5%9B%BD%E4%BA%BA%E6%80%A7%E6%A0%BC%E7%89%B9%E7%82%B9%E8%A7%82%E5%AF%9F/" class="post-title-link" itemprop="url">美国人性格特点观察</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-20 21:23:10 / Modified: 21:29:12" itemprop="dateCreated datePublished" datetime="2020-04-20T21:23:10-04:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对美国军队和美国人性格特点的观察，早在70年前就从抗美援朝的战俘营里开始了。"><a href="#对美国军队和美国人性格特点的观察，早在70年前就从抗美援朝的战俘营里开始了。" class="headerlink" title="对美国军队和美国人性格特点的观察，早在70年前就从抗美援朝的战俘营里开始了。"></a>对美国军队和美国人性格特点的观察，早在70年前就从抗美援朝的战俘营里开始了。</h2><p><strong>前辈们观察之细致，记录之详实，令我十分感慨。</strong></p>
<p>志愿军俘管人员或许没有公知大v们人均985的高学历和出色的理论功底，他们虽然只是受过启蒙级共产主义教育的农民战士，</p>
<p><strong>但是从他们的观察和分析中看到的美军特点，再结合当下美国诸多乱象，好像都有了解释——</strong></p>
<p>出自西虹（原抗美援朝创作组成员、战地记者）的第一手回忆录《抗美援朝战地日记》</p>
<p><strong>外俘主要思想特点：</strong></p>
<h2 id="高度的自私自利（说白了就是精致的利己主义者）："><a href="#高度的自私自利（说白了就是精致的利己主义者）：" class="headerlink" title="高度的自私自利（说白了就是精致的利己主义者）："></a>高度的自私自利（说白了就是精致的利己主义者）：</h2><blockquote>
<p><strong>“美俘特别明显，腐化堕落，不爱劳动，脑子里尽是金钱，女人，吃喝玩乐。”</strong></p>
<p>“班里有病号，我们的人照顾病号，<strong>他们说：“他与我无关。”病号还未死，他们就摘了人家的手表、钢笔据为己有。”</strong></p>
<p>“俘虏们在笔记本上，尽是记着一些<strong>爱吃的糖果、酒名、菜单、食谱、黄色下流的音乐诗歌</strong>等。”</p>
<p>“吃饭时，绝对平均，剩一块肉也要切开分，大家看着分菜。<strong>发的烟和烟纸绝对不给别人一点，</strong>病号的药不吃，留着换美金。”</p>
<p>“在汉城、日本，美英士兵嫖妓、吃酒，<strong>为此争吵打架，英美宪兵各帮助自己的士兵打对方。</strong>美兵上了战场，<strong>恨不得班长、排长等马上死了。班长是中士，薪水多，他们死了他可以较快升级，多拿钱。</strong>”</p>
<p>“衣服脏了，丢在外面不管，没衣服穿就围个毯子坐着。”</p>
<p>“<strong>他们身上带许多裸体女人照片，皮肤上刺着龙、花纹、女人。</strong>”</p>
<p>“<strong>他们的官兵都在日本或南朝鲜嫖妓，</strong>有的军官在南朝鲜雇用朝鲜妇女，每月50美金，一面当佣人服侍他，一面把她作为发泄兽欲的工具。<strong>士兵在后方常常带上妓女去看电影、喝咖啡、跳舞。</strong>”</p>
<p>“今年春天准备遣俘时，他们已列好了回家后的菜单，今天吃什么，明天吃什么，还写信给美国定旅馆，有人还想搞一辆汽车。<strong>他们偷东西，赌博，用扑克牌赌钱。</strong>”</p>
<p>“到处便溺，脏得很。”</p>
</blockquote>
<h2 id="民族优越感，歧视少数民族："><a href="#民族优越感，歧视少数民族：" class="headerlink" title="民族优越感，歧视少数民族："></a>民族优越感，歧视少数民族：</h2><blockquote>
<p>“轻视黑人，轻视波多利格人，认为美国人顶好，<strong>把美国人分了好多等，说他们是第一等。”</strong></p>
<p>“还说总统可竞选，人人有发财机会，美国生活方式好，他们觉得很优越。 ”</p>
<p>“<strong>白人到一定年龄可升大官，黑人不能升大官，</strong>认为黑人是劣等民族。不同黑人坐一个车，去一个馆子吃饭，住一个房子。”</p>
<p>“战俘和我们一样吃高粱米，<strong>土耳其人很快吃了起来，美俘军官布斯说‘在二战中，我们对德国俘虏还给他们面包吃，你们怎么能把这种东西给我们吃，这不人道！’</strong>我带着他看了志愿军伙房，他看我们吃的都一样，方才作罢。”</p>
<p>“在这里，白人围火取暖，黑人都被挤在一边，黑白人之间的仇视还很深。<strong>打篮球，黑人白人分开打，黑人有球法好的，白人不服气。”</strong></p>
</blockquote>
<blockquote>
<p>“黑人至今还不忘金宏浩教员拯救溺水俘虏的事。他们说：“金教员，我们永远不会忘记，你这样软弱的身体还跳到河里去捞救他，<strong>在美国，是谁也不会在乎一个黑人死掉的。”“黑人过去从没有被这样平等地待遇过。”</strong></p>
</blockquote>
<h2 id="普遍的反tg反苏："><a href="#普遍的反tg反苏：" class="headerlink" title="普遍的反tg反苏："></a>普遍的反tg反苏：</h2><blockquote>
<p>“说苏联是“铁幕”，苏联人民没有自由，生活坏，tg就是侵略的，<strong>他们从小就受到这种反动教育。”</strong></p>
<p>“他们希望和谈早日达成，早日回家，再不想当兵了。一些人急躁不安，不愿学习，愿早日见到父母妻子。<strong>有些人见和谈拖延，情绪低落，不愿学习，怕被送到西伯利亚做苦工，一辈子回不了家。我们解释责任不在我方，叫他们不要急躁。</strong>”</p>
</blockquote>
<h2 id="狭隘的民族主义思想："><a href="#狭隘的民族主义思想：" class="headerlink" title="狭隘的民族主义思想："></a>狭隘的民族主义思想：</h2><blockquote>
<p>“美国这样也好，那样也好，说不好就不行。 他们都有文化程度，读过初中、大学的很多。<strong>他们学习的东西很浮浅，不扎实，不了解政治，</strong>其中有些人比较好。”</p>
<p>“英兵有绅士派味道，稳重，不爱喊叫，自尊心很强；美兵爱吵闹，轻浮，英兵看不惯。美兵打篮球，英兵就踢足球。吃饭时各自在一边吃，不乐意在一块。<strong>英国配给鸡蛋，一人一天一个，美兵说自己国内随便吃几个就吃几个，讥笑英国。”</strong></p>
<p>“美兵下汽车后，带的东西常丢，不想带。上了战场爱偷子弹。<strong>撤退时，互相抢汽车，美国兵上了车，不让英兵上，其他土耳其、菲律宾等小国家的士兵也不让上，抢汽车抢得打起架来。</strong>”</p>
<p>“现在他们好多了，新来的俘虏看见老俘虏不顺眼，说他们都变成共产主义者了。老俘虏也看不惯新俘虏。”</p>
<p>“俘虏中涌现了一批积极分子，认识了美国政府的反动性。<strong>积极分子受少数落后分子的打击，中间分子比较多，有明哲保身的态度。</strong>他们内部已经起了分化，我们做工作是扩大积极分子的面。”</p>
</blockquote>
<blockquote>
<p>“组织战俘用黄豆磨豆腐，<strong>土耳其俘虏去推磨，美俘不动，</strong>说他们是奴隶，活应该他们干。”</p>
</blockquote>
<h2 id="这些真实的历史记录，刷新了我对《血战钢锯岭》等等好莱坞电影里的美军士兵的认知。"><a href="#这些真实的历史记录，刷新了我对《血战钢锯岭》等等好莱坞电影里的美军士兵的认知。" class="headerlink" title="这些真实的历史记录，刷新了我对《血战钢锯岭》等等好莱坞电影里的美军士兵的认知。"></a>这些真实的历史记录，刷新了我对《血战钢锯岭》等等好莱坞电影里的美军士兵的认知。</h2><p>只不过在过去一段时间，公知美分们把这些记录当成所谓的“洗脑宣传”，让许多人以为美军真的是救世主式的白玉无瑕了。</p>
<p><strong>而士兵眼里观察到的士兵，又更为真实。因为同是军人，“男人最了解男人”。</strong></p>
<p><strong>这份记录，很真实。</strong></p>
<p>“土耳其俘虏推磨，美俘不动，说他们是奴隶，活应该他们干”<strong>这不就是美国社会当下对待华裔、拉美裔、东南亚裔的现状么？</strong></p>
<p><strong>美军“烟和烟纸不给别人一点”“病号还没死就把人家的手表据为己有”的同时，我们在生命垂危的上甘岭还把一个苹果一人一口。</strong></p>
<p>而反观当下，多少人在被公知美分鼓吹西方的那一套价值观时，<strong>无形中被洗脑成了美俘那样精致的利己主义者和享乐主义者？</strong></p>
<p><strong>个人主义，白人优越，精致的利己主义，以及过度娱乐化之后产生的知识体系不健全，即便受过高等教育，也很肤浅，</strong></p>
<h2 id="最终形成一个自私，傲慢，充满偏见和对立的社会。"><a href="#最终形成一个自私，傲慢，充满偏见和对立的社会。" class="headerlink" title="最终形成一个自私，傲慢，充满偏见和对立的社会。"></a>最终形成一个自私，傲慢，充满偏见和对立的社会。</h2><p>这种坑我们不能被美分香蕉人给拉进去。</p>
<h2 id="时至今日，我们有些人，却把美国电影里的美军用巧克力钓女人嫖妓、收集纪念品（其实就是抢劫）、偷东西赌钱、酗酒作乐等等行为，当成“帅气”“牛叉”“真实人性”“这才是军人”！"><a href="#时至今日，我们有些人，却把美国电影里的美军用巧克力钓女人嫖妓、收集纪念品（其实就是抢劫）、偷东西赌钱、酗酒作乐等等行为，当成“帅气”“牛叉”“真实人性”“这才是军人”！" class="headerlink" title="时至今日，我们有些人，却把美国电影里的美军用巧克力钓女人嫖妓、收集纪念品（其实就是抢劫）、偷东西赌钱、酗酒作乐等等行为，当成“帅气”“牛叉”“真实人性”“这才是军人”！"></a>时至今日，我们有些人，却把美国电影里的美军用巧克力钓女人嫖妓、收集纪念品（其实就是抢劫）、偷东西赌钱、酗酒作乐等等行为，当成“帅气”“牛叉”“真实人性”“这才是军人”！</h2><p><strong>当年我们高度纪律性的前辈们，亲眼目睹了美俘的龌龊，现在有些后辈却把这些行径深以为然，</strong>你说说这些人的价值观被歪曲到了什么地步。</p>
<p><strong>你自己被美国人洗脑了你自己都不知道，还把教育你学好当成“洗脑”。</strong>你说可不可笑？</p>
<p>真是黑白不分了。</p>
<h2 id="个人看法，看一个国家的本质特点，看它这个国家的军队基层士兵群像就可以了。"><a href="#个人看法，看一个国家的本质特点，看它这个国家的军队基层士兵群像就可以了。" class="headerlink" title="个人看法，看一个国家的本质特点，看它这个国家的军队基层士兵群像就可以了。"></a>个人看法，看一个国家的本质特点，看它这个国家的军队基层士兵群像就可以了。</h2><p><strong>因为一个国家的军队基层士兵，往往是能代表这个国家的普遍现象的。</strong>因为士兵的组成大多数是国家的底层、中层，而非高层的精英人士。</p>
<h2 id="他们的素质，最能代表国家的大多数。"><a href="#他们的素质，最能代表国家的大多数。" class="headerlink" title="他们的素质，最能代表国家的大多数。"></a>他们的素质，最能代表国家的大多数。</h2><p>反观中国人民志愿军的高素质和纪律性，不仅深受朝鲜人民拥护尊敬，连对手也为之一惊。</p>
<blockquote>
<p>“临别前布斯要把他的钢笔送给我做纪念，我婉言谢绝。”</p>
<p>一个美国战俘说：“德国人是信奉天主教、基督教的，他们不但不给我们过圣诞节，而且虐待我们。中国人不信宗教，但为我们筹备一个隆重的圣诞节，<strong>我们深深感到中国是世界上最讲文明的国家。</strong>”</p>
</blockquote>
<p>以至于双方在换俘时，碧潼的联合国军战俘与我军俘管人员握手惜别，而巨济岛的志愿军战俘把美国临时发的“新衣服”纷纷脱光甩在地上，以示抗议：<strong>“回来前才给每个人发了一套新衣服，想叫我们给他们撑面子”。</strong></p>
<p>（被美军挖掉双眼的朝鲜人民军战俘金井元）</p>
<p><strong>如此鲜明的对比，令在场的中外记者震惊不已。</strong></p>
<h2 id="所以到底谁才是对平民无差别轰炸的恶霸，谁才是救生命于水火、伸张正义的超级英雄？"><a href="#所以到底谁才是对平民无差别轰炸的恶霸，谁才是救生命于水火、伸张正义的超级英雄？" class="headerlink" title="所以到底谁才是对平民无差别轰炸的恶霸，谁才是救生命于水火、伸张正义的超级英雄？"></a>所以到底谁才是对平民无差别轰炸的恶霸，谁才是救生命于水火、伸张正义的超级英雄？</h2><p>被志愿军官兵奋斗主义、吃苦耐劳、谦虚有礼的高素质感化的美军相当多，</p>
<p><strong>而被美国“享乐主义的生活方式”吸引的志愿军却没有。</strong></p>
<p><strong>甚至许多俘虏在志愿军的战俘营里完成了“初级启蒙教育”：</strong></p>
<blockquote>
<p>美俘小伊利亚斯说：“<strong>我一辈子也忘不了得到中队长为我犯错误而给予我的忠告。</strong></p>
<p>我偷过两次东西，第一次偷了同班俘虏的一双靴子，想把它拿去换酒喝，被发现后，受到批评，自己答应不再犯同样的错误；</p>
<p>第二次看到储藏室有酒，就去偷偷地把它弄了出来，后来又被发现了。</p>
<p>中队长要我坦白，我怪不好意思，撒了个谎，但并没有瞒得过去，于是我给关进了反省室，要我好好反省。反省期间同样的有饭吃，分量也很多，<strong>我觉得他们处处都是为了我好。</strong></p>
<p><strong>当我被放出来的时候，我已说不出对志愿军的感激，我只能说，我要听从他们的劝告，不再犯这样的错误。</strong>”</p>
</blockquote>
<h2 id="这就是美国军队，都不会给自己的士兵一个基本的思想道德教育，反而要对手中国人民志愿军去教！"><a href="#这就是美国军队，都不会给自己的士兵一个基本的思想道德教育，反而要对手中国人民志愿军去教！" class="headerlink" title="这就是美国军队，都不会给自己的士兵一个基本的思想道德教育，反而要对手中国人民志愿军去教！"></a>这就是美国军队，都不会给自己的士兵一个基本的思想道德教育，反而要对手中国人民志愿军去教！</h2><h2 id="而美国军队，特别是抗美援朝是抓到的美军俘虏，来自各个部队、各个社会阶层，这是对美国人整体素质最好的抽样调查范例了："><a href="#而美国军队，特别是抗美援朝是抓到的美军俘虏，来自各个部队、各个社会阶层，这是对美国人整体素质最好的抽样调查范例了：" class="headerlink" title="而美国军队，特别是抗美援朝是抓到的美军俘虏，来自各个部队、各个社会阶层，这是对美国人整体素质最好的抽样调查范例了："></a>而美国军队，特别是抗美援朝是抓到的美军俘虏，来自各个部队、各个社会阶层，<strong>这是对美国人整体素质最好的抽样调查范例了：</strong></h2><blockquote>
<p>“一团千多人，一半美军一半英军。二团是李伪军。三团是美军，还有新近送来的。四团是军曹队，多是参谋人员、事务人员，年纪大，比较坏。二大队是军官队，英美的都在内，包括尉以上、校以下，最大的是上校，还有空军人员。细菌战犯另有地方安置。收容俘虏的地点在遂安有两个。五团是美俘、黑人、土耳其人、英军及部分附庸国的俘虏。分工是朝方管李伪俘，我们管外俘，李伪俘比较好教育。”</p>
</blockquote>
<p><strong>再延伸到当下美国疫情的乱象，公知大v口中所谓的“美国人高度自律”“高素质”都成了笑话。</strong></p>
<h2 id="而这一切，早在70年前就被中国人民志愿军看的清清楚楚。只不过公知美分横行，许多人被公知蒙蔽了。"><a href="#而这一切，早在70年前就被中国人民志愿军看的清清楚楚。只不过公知美分横行，许多人被公知蒙蔽了。" class="headerlink" title="而这一切，早在70年前就被中国人民志愿军看的清清楚楚。只不过公知美分横行，许多人被公知蒙蔽了。"></a><strong>而这一切，早在70年前就被中国人民志愿军看的清清楚楚。只不过公知美分横行，许多人被公知蒙蔽了。</strong></h2><p>同样，方方之流和当今网络乱象，也被70年前的文艺工作者看的清清楚楚。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E6%96%B9%E6%96%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E6%96%B9%E6%96%B9/" class="post-title-link" itemprop="url">如何评价方方</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-19 22:49:48 / Modified: 22:51:21" itemprop="dateCreated datePublished" datetime="2020-04-19T22:49:48-04:00">2020-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作协极左监狱里关着3个人，他们彼此聊起坐牢的原因。</p>
<p>A：我支持斯大林，他们说我是极左。</p>
<p>B：我支持托洛茨基，他们说我是极左。</p>
<p>C：我支持东条英机，他们说我是极左。</p>
<p>AB：你支持二等兵，为什么还被说是极左？</p>
<p>C：我反对方方。</p>
<ul>
<li>…, 一名方方的支持者在公告栏的大字报中如是写到。</li>
<li>“东条内阁有赤化风险”</li>
<li>[惊喜]在方方眼里abc支持的是一路人</li>
<li>每当我搞不清楚自己的意识形态倾向，就去方方微博领一顶极左籍，腰也不酸了背也不疼了思想也不困惑了[惊喜]</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%A5%BD%E5%A4%9A%E4%BA%BA%E9%83%BD%E8%BF%9B%E5%85%A5%E4%BA%86%E4%B8%96%E7%95%8C%E9%A1%B6%E5%B0%96%E5%A4%A7%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%A5%BD%E5%A4%9A%E4%BA%BA%E9%83%BD%E8%BF%9B%E5%85%A5%E4%BA%86%E4%B8%96%E7%95%8C%E9%A1%B6%E5%B0%96%E5%A4%A7%E5%AD%A6/" class="post-title-link" itemprop="url">如何看待好多人都进入了世界顶尖大学</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-18 14:23:19 / Modified: 14:24:09" itemprop="dateCreated datePublished" datetime="2020-04-18T14:23:19-04:00">2020-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先是因为中国的内卷太严重了，我常和朋友戏称是无限竞争模式。为什么呢？但凡成绩好一些，经历过高考的人，回想高中的努力程度，都会多少脊背发凉。我也参加过高考，为了方便理解，换成750分制的高考省例如安徽/河北等，我的成绩应该是高于一本线100+分，基本上属于头部211，二线985的水平吧。而高中的我做了一件什么事呢？考完得知分数在家大哭了一场，因为确实是我考的最差的一次，我觉得自己是个loser，甚至想要复读，觉得再也没脸见我respect的同学们，现在分析一下当时可谓内卷本卷青少年。哪怕是正常发挥，无非也就是再高30分，去个Top10的985，怎么才能让当时的我满意呢？C9里的那七所吧，而我周围的很多同学，基本上也是和我一样的心态。后来出国，但凡去的学校比较OK的，我的本科同学一些也不太主动说自己就读的本科是哪里。觉得，害，没去C9至少也要去个天大/武大吧，自己这成绩只能算上过学，根本不足为外人道也。</p>
<p>直到有一天，我闲来无事，去查了查中国和外国以及北上的录取率对比，说老实话，那是我第一次客观认识到国内的残酷竞争。之前只是主观感觉太累了。澳洲本科录取来说，全澳洲本科最好的大学，悉尼大学/UNSW，如果是工程学的话，大概你的澳洲高考考到前7-8%就可以就读（往往实际录取要求更松一些），这在中国的绝大多数省，是一本线。大家没感觉，我这样直观描述一下：即，你考到一本线就有机会就读于清华大学计算机系。如果想要就读类似于北大光华管理学院这样半个院都是状元的最顶级学院，类似于国外的法学院，澳洲的commerce/law的双学位，实际上也就是国内普通985的录取难度，如果你能考取重庆大学，那么你在澳洲就能就读于类似北大光华的最顶级学院。我看有加拿大的写了清华和多大的录取率对比，在发达国家考上顶校的概率是中国的250倍，个人觉得有点夸张，但我觉得10-20倍是绝对有的。而北京、上海大概5倍左右，我耳闻有上海local问身边新人：你上海绿卡弄的怎么样了？</p>
<p>澳洲学校的本科，有录取中国高考“滑铁卢”学生的作用，比如悉尼大学，大部分省份一本线就可以就读，加上申请确实简单，很多考到一本的同学来读，其中当然也有一些考到211/985的同学来，大多是不喜欢自己原学校的专业。这些同学我认识的很多都成为了学校里比较顶级的选手。天津高考就读于某985的同学，悉尼大学本科first class毕业去了Yale，上财/西南财经本科转学来澳洲本科的honours毕业都去了Lse,暨南大学本科转学各种成绩Hd dean’s letter,中国药科大学转学来的直接变成男神，各种offer，如果想申请顶校也是易如反掌，还有很多师从大牛的本校Phd candidate，无一例外你会发现，他们只要在中国考上了985/211，在澳洲顶级学校本科，只要努力学习，专业前10%基本上问题不大。而专业前10%的出路大多非常非常好，哪怕没有去藤校/G5，佛系在澳洲读书，比如经济系里读Phd，很多学生基本上在导师的推荐下，也会毕业直接去澳洲央行做分析师。我看过他们的毕业后去向，不得不说真的都不错。一个和他们智商水平差不多的川大毕业生，去央行总行的概率是怎样的呢？去了全球top10学校回国后，他们很多人也会进入一线的互联网/金融公司等，周围的人很多都是清北复交里的佼佼者，其中滋味你们自己细品吧。</p>
<p>想起来再加一Part吧，有人说这是因为澳洲本就是留学链低端，行吧，我再举A level的例子吧，很多人是国际高中通过A Level来到我们学校的。A level悉尼大学本科录取基本上和Ucl冷门专业差不多，A level 每门考试的A率如果我没记错的话是大于5%的，全A申请G5这样QS能排到全球前十的还是稳的，基本上也就是等同于中国重庆大学的高考难度（注意是录取难度，非学校质量）。英本的申请难度不在于智商，而在于孩子父母的眼界和远超越一般家庭的财力。</p>
<p>尤其国内的朋友看完会说：就这？说明澳洲太垃圾了…我其实想说的是，其实是真的大家都已经很优秀了，只是没有足够的土壤和资源让大家成长。而导致了所谓的丧文化和佛系文化。留学对于大部分还算聪明的人来说，确实是一个很好的跳板，且越早出国，杠杆效应越大。比如无论在哪，都是本科生嫌弃学校里的研究生质量，但在出国这一part,在国内读出来的同学，单论智商，还真不一定是谁比谁强，毕竟我举了很多例子，如果一个高考还算优秀的人来读海本，基本上是碾压。但鄙视链总归是有内因的，这个内因已经不在个人能力上，而是在社会阶级上的，整体而言是越早出国家庭条件越好，而家庭资源的合理倾斜也给很多人更多的机会。</p>
<p>如果你是国内的一名同学，我希望你自信一些，其实你很好，如果你是一名海外读书的同学，我觉得大家不要再抱怨环境和歧视等，其实你已经获得了比国内同学多很多的机会。</p>
<p>这个世界，同样是工作八小时每天，有人日进斗金，有人月薪6000。智力上的差距有那么几何倍数的大吗？并没有，选择比努力重要太多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/17/%E5%90%83%E7%89%9B%E8%82%89%E7%9A%84%E5%A5%BD%E5%A4%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/17/%E5%90%83%E7%89%9B%E8%82%89%E7%9A%84%E5%A5%BD%E5%A4%84/" class="post-title-link" itemprop="url">吃牛肉的好处</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-17 20:04:34 / Modified: 20:06:08" itemprop="dateCreated datePublished" datetime="2020-04-17T20:04:34-04:00">2020-04-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>主要是牛肉含有丰富的蛋白质，氨基酸组成比猪肉更接近人体需要，能提高机体抗病能力，对生长发育及手术后、病后调养的人在补充失血和修复组织等方面特别适宜。</p>
<p>寒冬食牛肉，有暖胃作用，为寒冬补益佳品。</p>
<p>中医认为：牛肉有补中益气、滋养脾胃、强健筋骨、化痰息风、止渴止涎的功能。适用于中气下陷、气短体虚，筋骨酸软和贫血久病及面黄目眩之人食用。</p>
<hr>
<h3 id="1-牛肉富含肌氨酸"><a href="#1-牛肉富含肌氨酸" class="headerlink" title="1.牛肉富含肌氨酸"></a>1.牛肉富含肌氨酸</h3><p>牛肉中的肌氨酸含量比任何其它食品都高，这使它对增长肌肉、增强力量特别有效。在进行训练的头几秒钟里，肌氨酸是肌肉燃料之源，它可以有效补充三磷酸腺苷，从而使训练能坚持得更久。</p>
<p>说人话：持久！</p>
<h3 id="2-牛肉含维生素B6"><a href="#2-牛肉含维生素B6" class="headerlink" title="2.牛肉含维生素B6"></a>2.牛肉含维生素B6</h3><p>蛋白质需求量越大，饮食中所应该增加的维生素B6就越多。牛肉含有足够的维生素B6，可帮你增强免疫力，促进蛋白质的新陈代谢和合成，从而有助于紧张训练后身体的恢复。</p>
<p>说人话：回血快！</p>
<h3 id="3-牛肉含肉毒碱"><a href="#3-牛肉含肉毒碱" class="headerlink" title="3.牛肉含肉毒碱"></a>3.牛肉含肉毒碱</h3><p>鸡肉、鱼肉中肉毒碱和肌氨酸的含量很低，牛肉却含量很高。肉毒碱主要用于支持脂肪的新陈代谢，产生支链氨基酸，是对健美运动员增长肌肉起重要作用的一种氨基酸。</p>
<p>说人话：大house都是其次，吃这个练一天顶699社畜吃鸡胸肉鸡蛋跑十天。</p>
<h3 id="4-肉含钾和蛋白质"><a href="#4-肉含钾和蛋白质" class="headerlink" title="4.肉含钾和蛋白质"></a>4.肉含钾和蛋白质</h3><p>钾是大多数运动员饮食中比较缺少的矿物质。钾的水平低会抑制蛋白质的合成以及生长激素的产生，从而影响肌肉的生长。牛肉中富含蛋白质：4盎司瘦里脊就可产生22克一流的蛋白质。</p>
<p>说人话：生长激素和蛋白质你识得？</p>
<h3 id="5-牛肉是亚油酸的低脂肪来源"><a href="#5-牛肉是亚油酸的低脂肪来源" class="headerlink" title="5.牛肉是亚油酸的低脂肪来源"></a>5.牛肉是亚油酸的低脂肪来源</h3><p>牛肉中脂肪含量很低，但却富含结合亚油酸，这些潜在的抗氧化剂可以有效对抗举重等运动中造成的组织损伤。另外，亚油酸还可以作为抗氧化剂保持肌肉块。</p>
<p>说人话：口感好，不长胖，不比你吃猪油包子，馒头配稀饭强？</p>
<p>人家壮阳吃牡蛎羊腿喝牛奶</p>
<p>699吃口烤韭菜都犹豫点两份耐吃还省钱</p>
<p>真有用西地那非早停产了。</p>
<h3 id="6-牛肉含锌、镁"><a href="#6-牛肉含锌、镁" class="headerlink" title="6.牛肉含锌、镁"></a>6.牛肉含锌、镁</h3><p>锌是另外一种有助于合成蛋白质、促进肌肉生长的抗氧化剂。锌与谷氨酸盐和维生素B6共同作用，能增强免疫系统。镁则支持蛋白质的合成、增强肌肉力量，更重要的是可提高胰岛素合成代谢的效率。</p>
<p>说人话：不仅块大，力量也强。蛋白粉这种东西能比？</p>
<hr>
<p>对于敌法师来说，吃牛肉和吃米饭一样便宜。那是人家有的选，</p>
<p>人在有得选的时候，</p>
<p>一切都好说，毕竟站着说话不腰疼，就算腰疼还能去做理疗呢，而理疗又有好多套餐可以选，一步小心选了个998的套餐呢？总之都不是事。</p>
<p>但一旦没得选，就要小心。鸽子笼都买不起，还想要大豪斯？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1436668936&auto=0&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">157</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
