<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/02/%E4%B8%BA%E5%95%A5%E6%84%9F%E8%A7%89%E7%BE%8E%E5%9B%BD%E7%8E%B0%E5%9C%A8%E6%81%A8%E4%B8%8D%E5%BE%97%E4%B8%AD%E5%9B%BD%E5%BD%BB%E5%BA%95%E5%BA%9F%E6%8E%89%E6%89%8D%E7%94%98%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/02/%E4%B8%BA%E5%95%A5%E6%84%9F%E8%A7%89%E7%BE%8E%E5%9B%BD%E7%8E%B0%E5%9C%A8%E6%81%A8%E4%B8%8D%E5%BE%97%E4%B8%AD%E5%9B%BD%E5%BD%BB%E5%BA%95%E5%BA%9F%E6%8E%89%E6%89%8D%E7%94%98%E5%BF%83/" class="post-title-link" itemprop="url">为啥感觉美国现在恨不得中国彻底废掉才甘心</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-02 23:05:41 / Modified: 23:10:30" itemprop="dateCreated datePublished" datetime="2020-05-02T23:05:41-04:00">2020-05-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个威胁非常现实，就隐含在网友们常常说的“白菜价”里面。</p>
<p>很多网友总是津津乐道说，什么产品如果中国人会做了，就能把它做成白菜价。例如碳纤维，中国人不做的时候，价格贵得离谱，中国一旦技术突破开始量产，就变成了白菜价。类似的著名例子还有盾构机等一系列产品。</p>
<p>大家有没有想过为什么？难道中国厂家真的就是毫不利己专门利人，不想挣钱只想为全人类做贡献？</p>
<p>怎么可能？</p>
<p>事实是，“白菜价”不是我们定的，是欧美的厂商定的。目的是打死我们的企业。企业要获取新技术，尤其是关键技术，没捷径可走，只能是投入大量的时间和经费进行研发。一旦研发成功，必然需要收回成本。而这个时候，就是这家企业最脆弱的时候 —— 研发的经费往往来自于贷款等融资手段，一旦后续的销售不能收回研发成本，企业就会破产倒闭。</p>
<p>欧美之所以能够长期垄断先进技术，不是因为其他国家的人笨，而是他们有先发优势。他们的研发成本已经收回了，现在卖的钱是纯赚的。一旦发现竞争对手出现，他们立刻降价，自己不过少赚一点儿（而且是暂时的），但是对手就被低价格压死了。</p>
<p>所以，一旦发现竞争对手，就用白菜价杀死他们，这是欧美企业的惯例。中国以前没少吃这种亏，过去有过一次很著名的维生素 C 降价事件，就是欧美的老牌药厂在中国国产维生素 C 准备大量出口的时候突然降价，硬生生把中国的企业坑了个头破血流。</p>
<p>如果中国只是一个普通国家，欧美的这一招绝对是万试万灵 —— 因为欧美不断散布和宣传的经济自由主义学说，世界上大多数发展中国家的政府都很少干预市场经济，也因此无力在关键时刻拯救被欧美白菜价打压的企业。在这样的国家，你安安心心的给欧美打工，做点儿人家不想干的脏活累活是没问题的，想搞产业升级绝对是痴心妄想。</p>
<p>什么是“中等收入陷阱”？这就是！不是说老天爷挖了个坑在那儿等着中等收入国家，这个陷阱纯粹是欧美国家制造出来专门用来消灭竞争对手的。</p>
<p>但是中国不一样。中国有国有企业，有政府扶持龙头企业的政策，企业研发新技术的资金很大部分来自于政府的投资。当中国的某家企业取得了关键性的技术突破时，欧美国家施展“白菜价”打法，中国这家企业能顶得住！而且，中国拥有全产业链优势，有全球最大规模的工业，更有全国一盘棋的总体规划。因此，哪怕这家企业被欧美坑了，但是他的下游企业却因此得到了巨大的实惠 —— “白菜价”在打击了一家企业的同时，却为许许多多的其他企业节约了大量的成本。中国制造业的总体收益不降反增。</p>
<p>欧美长期保持高高在上的绝招失效了，你说他们恨不恨？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/%E6%89%93%E9%80%A0%E8%89%AF%E5%A5%BD%E4%B9%A0%E6%83%AF%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/%E6%89%93%E9%80%A0%E8%89%AF%E5%A5%BD%E4%B9%A0%E6%83%AF%E4%BD%93%E7%B3%BB/" class="post-title-link" itemprop="url">打造良好习惯体系</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-01 18:41:23 / Modified: 18:42:22" itemprop="dateCreated datePublished" datetime="2020-05-01T18:41:23-04:00">2020-05-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>波士顿医院一初级保健医生，通过改变餐厅环境里摆放饮料的方式，让医院用餐的人减少碳酸饮料摄入、改喝矿泉水的饮食习惯。甚至没有与他们交谈去改变他们的意志力、了解他们的原动力。所以想养成好习惯、戒掉坏习惯，也许不是你的意志力不够，而是你的环境让你深陷囹圄。</p>
<p>环境是塑造人类行为的无形之手。尽管我们有独特的个性，但在特定环境条件下，某些行为往往会反复出现：在图书馆我们倾向于低声说话，在黑暗的小道里我们的警惕性也会提高。我们被周围的世界所改造，也深受环境的影响。如何设计和建立更好的系统、养成更好的习惯呢？《原子习惯》提出了4个原则。</p>
<blockquote>
<p>提示触发渴求，渴求激发反应，而反应则提供满足渴求的奖励，并最终与提示相关联。这四个步骤一起形成了一个神经反馈回路——提示、渴求、反应、奖励，提示、渴求、反应、奖励——并最终让你养成自然而然的习惯，由此构成完整的习惯循环。</p>
</blockquote>
<h3 id="4步构建良好习惯体系"><a href="#4步构建良好习惯体系" class="headerlink" title="4步构建良好习惯体系"></a>4步构建良好习惯体系</h3><h4 id="1⃣️Make-It-Obvious-提示要明显"><a href="#1⃣️Make-It-Obvious-提示要明显" class="headerlink" title="1⃣️Make It Obvious 提示要明显"></a>1⃣️Make It Obvious 提示要明显</h4><p>如果手机上卸载社交软件（或者开启路径很长），而电子书阅读器就在底部栏怎么滑手机都会看到，我们也更容易打开软件看书；如果丢掉房间里的零食、可乐，换成水果、柠檬水，饮食习惯也会不知不觉改变；如果睡前就在床头摆了一保温杯热水，早上醒来更习惯随手拿起来喝；如果在家门口摆了运动鞋或健身装备，下班回到家踢到也会想到今天的运动计划。</p>
<p>也可以尝试这两个策略来为习惯创造鲜明的提示：<strong>明确执行意图：我将于[时间]在[地点]做[行为]。</strong>当出现某个<strong>[时间]</strong>或处于某个<strong>[地点]</strong>时关联上新的行为。比如一醒来就拿 Kindle 而不是手机，一坐到工位就打开今日 todo list。事实上我们在同一个地方会时时受到与老习惯相关联的提示的干扰。所以我最近开始尝试在咖啡馆专注工作：走到咖啡馆，点上一杯 Chai Latte ，喝上一口绵密的奶泡，作为郑重其事的<a href="https://anobody.im/article/deep-work-rules/" target="_blank" rel="noopener">开工仪式</a>。<strong>习惯叠加：继[当前习惯]之后，我将[新习惯]。</strong>在已有的习惯上叠加新的习惯，也会更容易接收到提醒。比如泡脚，即使我出门旅游一周回到家，临近睡前还是会烧热水准备泡脚，那我在端洗脚盆的时候也就想到这也是我的看书时间。</p>
<h4 id="2⃣️Make-It-Attractive-动机要诱人"><a href="#2⃣️Make-It-Attractive-动机要诱人" class="headerlink" title="2⃣️Make It Attractive 动机要诱人"></a>2⃣️Make It Attractive 动机要诱人</h4><p>大多数时候，我们宁愿跟着大众一起犯错，也不愿特立独行坚持自我。我们生活的文化环境决定了哪些行为属于正常行为，我们也倾向于模仿这类行为，比如朋友都抽烟，也很容易染上烟瘾；而崇拜的偶像喜欢跑步，也就更倾向跑步而不是有氧锻炼。所以为了培养更好的习惯，我们能做的最有效的事情之一就是靠近这个群体（或个人）：我们想要养成的习惯在这个群体是自然而然的行为，而当我们在这个群体中因为这个行为收获赞美、尊重、认可时，我们就会认为它很有吸引力。</p>
<p><strong>欲望是现状与想象中的理想状况之间的落差</strong>，越是缺少什么，我们就越渴望得到。但不一定要成为更好的自己这类宏伟的目标，肤浅一点，仅仅为了拍一张好看的打卡照 PO 到网上，也能作为健身的动力；想要学好英文跟外国人交流、跟国人装逼，反而更有动力；想要一本印上自己名字的书，也能成为写作的动力。但其实<strong>多巴胺的分泌，**</strong>不仅发生在行动带来的结果，而且在你行动本身并期待这个行动带来的结果时，也能感受到快乐**。</p>
<h4 id="3⃣️Make-It-Easy-行动要简单"><a href="#3⃣️Make-It-Easy-行动要简单" class="headerlink" title="3⃣️Make It Easy 行动要简单"></a>3⃣️Make It Easy 行动要简单</h4><p>人类行为遵循最省力法则，我们天然地倾向于选择付出最少工作量的行为。</p>
<p>习惯的培养不在于时间长短，而在于重复的次数。所以不要过分追求完美的计划，行动要越简单越好。<strong>两分钟法则：**</strong>当你开始培养一种新习惯时，它所用时间不应超过两分钟。<strong>跑步半小时？不如试着改成在下班后换上跑鞋，或者拿出瑜伽垫换上瑜伽服。看书半小时？不如改成看5页小说，或者看一篇 Read-it-later 的存货。Start by starting，来自想要成为厉害的人的目标感的压力也不会那么大。即使中间失败了，</strong>不要中断超过两次，**试着尽快恢复固有的做事节奏。</p>
<p>从时间和空间两个角度，增加坏习惯的阻力，减小好习惯的阻力。健身房选在上下班的必经之路，到家之后再出门健身这个想法最后一般也躺在了沙发里。早起的闹钟要起身下床才能关掉，而不是转头又睡着了。</p>
<h4 id="4⃣️Make-It-Satisfying-奖励要愉悦"><a href="#4⃣️Make-It-Satisfying-奖励要愉悦" class="headerlink" title="4⃣️Make It Satisfying 奖励要愉悦"></a>4⃣️Make It Satisfying 奖励要愉悦</h4><p>除了获得赞美和奖励，感受到自己的一点点的进步也能给自己带来满足感。坚持跑步，体重可能并没有变化，但上楼梯不再喘气了，等的公交车来了也能跑几步赶上；每天练习听力，听一场完整讲座还是有压力，但一次练习所花的时间减少了，能听得出的生僻词多了几个了。感受这些 small wins，表扬自己，也能给自己坚持下去的动力。</p>
<p>追踪行为的执行并记录下来也有助于习惯的养成：创建视觉提示，提醒自己采取行动；内在激励机制，因为你清楚地看到了自己的进步轨迹，并且不想打断它；每当你记录下又一项成功的习惯实例时，你都会享受到满足感。 </p>
<h3 id="Personality-身份认同"><a href="#Personality-身份认同" class="headerlink" title="Personality 身份认同"></a>Personality 身份认同</h3><p>关于设定目标时我们常常听到<strong>结果目标</strong>和<strong>行动目标</strong>，前者关注的是减肥多少斤，后者关注的是养成一周三次健身的习惯。作者提出基于身份认同的目标，选择与自己天赋相匹配的习惯，适合自己的习惯而不是时下流行的习惯，更容易养成并维持。</p>
<blockquote>
<p>一种行为重复的次数越多，与之相关的身份就越是得以强化。事实上，身份这个词最初来源于拉丁语单词 essentitas 存在；identidem 反复。你的身份实际上就是你的“反复存在”。<strong>养成习惯的过程实际上就是成为你自己的过程。</strong></p>
</blockquote>
<p>确定自己是怎么样的人，用持续的行为作为证据，证明这个观点，认同这个观点，不知不觉我们就已成为这样的人。比如我认为自己是一个作家，每当我坐在电脑打出 500 字的时候，我就离这个身份更近一步；我认为自己是一个喜爱跑步的人，每当我穿上跑鞋跑了 3 公里，就是给自己的身份投了一次赞成票；我认为自己是一个自律的人，当我拒绝一次赖床，也是一次值得表扬的进步。如果你很难确定自己是不是适合某个特定的习惯，你可以试着问自己这些问题：“这个行为是否有助于我成为我希望成为的那种人？这个习惯是否支持我成为我想要的身份？”</p>
<p>性格特征的集合：</p>
<p>1．开放性：好奇、创造性 VS 谨慎、一丝不苟</p>
<p>2．自觉性：有条理、效率高 VS 随意性、自发性</p>
<p>3．外向性：活泼开朗、活力十足（外向型） VS 孤独、保守（内向型）</p>
<p>4．亲和性：待人友好并富于同情心 VS 挑剔、淡漠</p>
<p>5．神经质：焦虑不安、敏感多疑 VS 自信冷静、心态平和。</p>
<p>叔本华在《人生的智慧》里说到<strong>众生能得到的最大幸运只有自身的个性</strong>。这个世界是贫乏无趣的还是趣味盎然的都由个人意志所决定的。也就是说同一件事，有些人看起来有趣，有些人却感受不到乐趣；同样的一生，有些人感受不到幸福，这都是由我们的精神思想决定。所以想要成为一个有趣的人，不是别人眼中我有趣，不是给别人带去多少欢乐，而是我能在这个苦难、无聊的人间自得其乐。</p>
<p>从<strong>简单的行动开始</strong>，8:30之前醒来并在床上看书记为一次有效行动。<strong>醒目的点亮的方格</strong>的分布，一眼就能看到早起所占的比例；最后一列<strong>依据拟**</strong>定规则自动累加金额<strong>（8:30之前起床得2欧，8:00之前起床得4欧，7:30之前得6欧依次类推）</strong>，<strong>能看到自己打了多少怪了；</strong>自动绘制的柱状图<strong>，直观地显示了早起多出一大段的时间可以利用。而</strong>作为奖励的** <strong>iPad Pro</strong> 图，也能让自己明显感受到动力。而<strong>整个记录</strong>，清楚地展示了我每天一点一点的努力。从一月底开始记录这张表格，能明显感受到二月的有效行动越来越多。</p>
<p>对于坚持下来的习惯：看书、记账、写日记、与自己的情绪相处，完全不知道从何说起，因为它就是那么自然而然不需要花功夫和精力去维系的事情；而早起、运动，对于我来说，就是一个可望不可及的目标，花费很大的力气却一直在成功的边缘挣扎。希望有一天我也能轻描淡写地说一句：早起不就是一件很无聊的事情吗。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E7%BE%8E%E6%9C%80%E5%A4%A7%E8%82%89%E7%B1%BB%E5%8A%A0%E5%B7%A5%E5%95%86%E8%AD%A6%E5%91%8A%EF%BC%9A%E9%A3%9F%E5%93%81%E4%BE%9B%E5%BA%94%E9%93%BE%E6%AD%A3%E5%9C%A8%E4%B8%AD%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E7%BE%8E%E6%9C%80%E5%A4%A7%E8%82%89%E7%B1%BB%E5%8A%A0%E5%B7%A5%E5%95%86%E8%AD%A6%E5%91%8A%EF%BC%9A%E9%A3%9F%E5%93%81%E4%BE%9B%E5%BA%94%E9%93%BE%E6%AD%A3%E5%9C%A8%E4%B8%AD%E6%96%AD/" class="post-title-link" itemprop="url">如何看待美最大肉类加工商警告：食品供应链正在中断</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-30 14:45:18 / Modified: 14:46:41" itemprop="dateCreated datePublished" datetime="2020-04-30T14:45:18-04:00">2020-04-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>美帝二战的时候午餐肉罐头都是当垃圾扔，怎么会缺肉？八美元自助餐吃到吐，疫情期间还免费送餐赈济人民，每个城市搞个万家宴都绰绰有余。</p>
<p>但是，照着最近的疫情这么搞下去，地主家也没有余粮啊，再大的家业也会败光啊。</p>
<p>美国大农业就是大工业，什么都是流水线作业，屠宰猪都是上机器，大猪不要，小猪不要，切头切屁股，内脏也不要，最后要切出你认不出是什么部位的肉，才是美国人的猪肉。实际上，美国是世界上最奢侈浪费的国家，吃鱼吃猪吃牛吃鸡都是这样，大量的牲畜肉他们只取一部分，其他的内脏脑壳骨头都是垃圾———还记得“苏联用铁圈套中国鸡蛋”的故事吗？</p>
<p>美国的农业还是金融业，养牛养猪种粮食，每年都是要贷款的，美国农民一次就要借几十万贷款，整个生产销售环节结束后才能回本。</p>
<p>因为凶猛的疫情，现在的运输、销售环节都出了问题，牛奶运不到加工厂，只能倒掉；猪牛羊运不到屠宰场，一旦长得太大了，就进不了屠宰机器，只能自己处理；如果饲料出了问题，牲畜没有饭吃，同样要处理掉。</p>
<p>我常说，美国没有正经的工人和农民阶级，工人都是工贵，农民其实都是农业小资本家，他们躺在这个帝国的血库粮仓里吃的太饱了，过得太舒服了，全世界的资本供应着他们，全世界的市场喂养着他们，他们从来不担心未来会出现什么祸事。</p>
<p>所以，这个国家的存在，就是对全世界几十亿人民的无耻掠夺和剥削，这个国家的存在，是人类文明的癌症。此时此刻，当“精神美国人”，都有反人类、破坏世界和平与发展的嫌疑。</p>
<p>所以，我反对“就美国就是救X国”、反对“世界离不开美国”，世界早该离开美国，进步成一个新世界了，只有离开美国，全世界几十亿人民才有真正的出路。</p>
<p>当然，美帝家大业大，没那么容易完蛋。</p>
<p>谁都知道美国强大，美国富有四海，美国天下无敌。当年的大明也这样，嘉靖修仙炼丹几十年，严嵩盘剥几十年，内阁内斗几十年……就这样，嘉靖老儿还支撑了45年，大明还续命了78年，帝国就是帝国啊。</p>
<p>不来个万历，不来个崇祯，是倒不了的啊。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/%E4%B8%AD%E5%9B%BD%E4%B8%BA%E4%BD%95%E5%9C%A8%E5%9B%BD%E9%99%85%E7%A4%BE%E4%BC%9A%E4%B8%8A%E7%BC%BA%E4%B9%8F%E7%9B%9F%E5%8F%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/%E4%B8%AD%E5%9B%BD%E4%B8%BA%E4%BD%95%E5%9C%A8%E5%9B%BD%E9%99%85%E7%A4%BE%E4%BC%9A%E4%B8%8A%E7%BC%BA%E4%B9%8F%E7%9B%9F%E5%8F%8B/" class="post-title-link" itemprop="url">中国为何在国际社会上缺乏盟友</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-29 23:08:03 / Modified: 23:09:33" itemprop="dateCreated datePublished" datetime="2020-04-29T23:08:03-04:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>鹅城的百姓，谁赢他们帮谁，谁强他们是谁的盟友。</p>
<p>国际的国与国之间，更像一条街上不良青年之间的关系，有个词叫“打便宜手”，谁强他们帮谁，谁弱他们对谁打便宜手。———这就像一颗大树的根干树枝结构，和树叶叶脉形状之间的自同构，数学上叫分形。</p>
<p>很多人看不懂，在高端政治中，比如特朗普一边公开在国会讲话，后面民主党党魁故意对着摄像机镜头撕掉了特朗普递交的文件。或者有段时间俄日关系不好，安倍去俄罗斯见普京，公开国际场合，安倍晋三主动老远伸手做示好握手状走向普京，普京当着新闻媒体蹲下来玩儿他的狗，根本不接安倍的茬。……还有很多……</p>
<p>有人觉得，美国民主党主席和普京太没素质太没礼貌了，就像街头青年或者农村怨妇。这就是看不懂高端政治了，注意政治与一条街的分形。</p>
<p><strong>国际级老大和老二的争霸，是“全或无”的结果，赢了，就都是盟友；输了就都来分一杯羹；平时就都在观望，伺机而动。新冠期间，中国援助的国家，心理感激中国，看看美国的黑脸，都不敢明着表达对中国的感激之情。</strong></p>
<p><strong>所以，中国和美国争霸，决不能输，输了，不但美国来捡尸体，一帮其他国家就像秃鹫一样，一起刮干净骨头上的肉。</strong></p>
<p><strong>中国必须赢，到时候对于衰败的美国，会有一堆小国跳出来，先声明是中国的盟友，然后低三下四像只秃鹫一样，说“美国脚趾头上那点肉，让我捋捋？”。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/%E5%91%A8%E6%8A%A5%E7%9A%84%E9%80%BB%E8%BE%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/28/%E5%91%A8%E6%8A%A5%E7%9A%84%E9%80%BB%E8%BE%91/" class="post-title-link" itemprop="url">周报的逻辑</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-28 00:34:53 / Modified: 00:36:54" itemprop="dateCreated datePublished" datetime="2020-04-28T00:34:53-04:00">2020-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么要发周报？</p>
<p>行业内可能大部分的人都认为，周报就是流水账，是主管显示权力的手段。最后还就真把它给搞成了一封流水账，或寥寥数语。但这是错误的理解。</p>
<p>在职场中，有一条冷酷定律，叫做“如果主管不知道你做了某件事情，相当于你就没有做过这件事情。”听上去不近人情，其实完全符合实用逻辑。工作分很多类别，有结果容易显露出来的，比如策划案；有不容易显露出来的，比如市场调研和用户维护；有重复性较强的，比如内容审核和数据统计；还有种情况是任务周期较长，在这个过程中需要让别人了解进展情况。</p>
<p>大家并不是为了上司而工作，但对于工作的结果，我们都希望得到一个公正的评价。</p>
<p>各家公司里常有一些私底下的议论，比如说，谁谁谁天天围着上司转，谁谁谁很会搞上级关系等等。在今年的“畅游人事门”里，有自称畅游员工的人匿名抱怨道：</p>
<p>公司中马屁精当道，领导任人唯亲，认认真真工作而不会拍马屁的，几乎不太可能绩效被评为“A”。以刚结束的第一季度绩效评比结果为例，某部门天龙八部项目组成员，一共6个A级以上绩效的，5个都是整天围着领导转、天天往领导座位上跑，去“汇报”问题的。所以，在这里工作，跟对领导实在是太重要了~~如果你是一心做技术而不会拍马屁的，千万别到这里来。</p>
<p>对于这段“曝料”，我作为一个管理人员很不以为然。善于让上司发现自己的成绩，听到自己对项目的看法和建议，这当然是一种职场优势，难道让上司成天找你谈心询问工作详情？下级经常抱怨上司不重用自己，甚至不了解自己，但人和人之间的作用力是相互的。为了让上司重视和了解自己，你又主动做了什么？如果别人在这一点上比你沟通得更多，他可能就会更受赏识，继而变成你心目中的“马屁精”。</p>
<p>话虽如此说，考虑到主管的忙碌情况，以及职场中常见的内向与谨慎，每个人都和上司多多接触也不太现实。因此才会出现周报这种形式，方便主管用最低的成本掌握每个人的工作情况。</p>
<p>周报通常被拆分为三个部分，第一部分是本周工作进展。如果是上司已经知道的成绩，一笔带过即可（别记流水账）。关键是介绍上司可能不清楚的部分，比如器材数据库的更新情况、自定义分类的审核情况、VIP用户的维护情况、市场调研的进展、统计项整理的进度等等。如果你不讲，我连这个事情有做没做都不知道，多半要当你没做。结果你委屈，我也心里不踏实，觉得诸多事项怎么就没人管了，大家每天都在瞎忙些什么。</p>
<p>第二部分是下周任务安排。严格来说，这部分并不是给我看的，而是给自己看的，写在周报里只是为了向上司证明自己有计划，有妥善的安排。合理的计划决定时间管理水平，时间管理又决定工作效率的高低。这个浅显道理大家都懂。</p>
<p>第三部分是本周工作的感慨，包括对工作的思考/疑问/不满/建议等等。其实主管都爱看这部分，因为可以更深入地了解一个人，但大部分周报都不爱写这玩意儿，觉得犯傻气，没话说，如果平时发言也不多，更容易被当作是“不积极，没想法”。这时你可能又委屈了，甚至还悲愤了，但你不来主动沟通，我又从何得知你“很有想法”或是“有所不满”呢？管理者要做的事情很多很杂，没时间频繁找你开会或是私聊，周报是上下级之间高效率的沟通手段，也是你得到上司理解、帮助最便捷的工具。</p>
<p>所以我对新同事有硬性的要求，入职半年内必须发送周报，第三部分的感慨不低于300字。大家都知道我现在分管多头，特别忙，不一定能及时准确地掌握你的工作情况。周报可能是除了每周两次例会之外，我了解你和进一步帮助你的主要方式。未必长篇大论，写长了我看着也累，意思到了就行。</p>
<p>此外，养成每周定时进行自我总结，下阶段规划的习惯，其实也是件好事。借助周报的形式，每周拿30-60分钟出来做一次工作梳理与思考，对建立全局观，加强条理性有非常大的帮助。</p>
<p>周报是什么呢，它是一个管理上的怪胎。</p>
<p>首先，周报起源于管理者对下属的不了解，不信任。因为不知道你最近在做什么，接下来准备做什么，所以要给我一份汇报。又因为对你不是很信得过，所以用“每周一期”这样的高频度向我汇报。</p>
<p>了解和信任在职场中，其实是极为稀罕之物。别不开心，这是实话。上司每天站在身后盯着你工作吗？他在每台电脑里安装了监控软件吗？那他怎么知道你的工作进展——既然他不是跟梢或者黑客。</p>
<p>懂得跟上司主动沟通的人不多，即便有，也会被同事鄙夷为“马屁精”。大多数人都坦然地等着上司找自己来问话，你想想情景是不是很傻……XX，你最近的任务进展如何了？定期重复的问题会让两边都觉得厌烦，挨个问过来更是浪费时间。若把这环节放在周会上，不仅流程又臭又长，说不定又有点被公审的不快。</p>
<p>换个角度看，如果上司不了解你的工作进展，还有什么别的方式可以获得他的信任吗，难道他同意招聘你就应当无条件接受你吗？</p>
<p>职场有三条规律：</p>
<p>1、级别越高，获得信任感越多，于是降低了沟通频度的要求</p>
<p>2、沟通越充分，获得信任感越多，于是提高了沟通频度的要求</p>
<p>3、管理者掌握信息越全面细致，通常执行力也就越强</p>
<p>综合以上，中层对基层的管理必然重视高频度的沟通。作为一周事务的总结备忘，可靠存档，每人花二三十分钟写周报，主管花半个到一个小时浏览回复周报，是上下级沟通节奏感最佳的方法。按照完美逻辑，下属藉此定期整理自己的工作思路，上司藉此了解全局动向，倾听下属反馈。花费的时间少，效率高，堪称完美制度！</p>
<p>现实总是不如想象的那般完美。</p>
<p>从下属的角度说起。理解周报积极意义的，以我所见不足三成，能在周报里做好总结梳理，计划安排的不足一成。有的啰嗦，有的潦草，大多数记流水账，看起来相当之辛苦。我甚至武断一点讲，你能把周报写好，也就有做好主管的一半资质了，至少证明总结和计划到位，又对上级有起码的耐心与责任感。</p>
<p>可惜得很，90%的周报是达不到这个目标的，阅读它们既费力又无聊，接近于做无用功。原因一是不理解甚至憎恶周报，二是确实没有总结计划的能力，三是懒，嫌总结计划烦，能敷衍就敷衍过去。</p>
<p>而站在上司的角度呢，每周看大量的劣质周报是种折磨，真的，很受折磨。久而久之对周报也有生理性的厌恶。瞪大眼睛从满篇不知所云的流水账里，试图找出一些关键点来了解下属工作，却多是徒劳。甚至可以说，周报制度就是为10%像样的周报，以及10%的特殊情况(新人到岗或重大任务)，浪费剩下80%的读写时间。</p>
<p>因为80%的浪费委实可观，除了那10%的特殊情况外(触发条件反射)，上司在被烦到麻痹之后，看周报渐渐变成走过场，有可能连那10%“像样的周报”亦是草草对待。</p>
<p>另一个维度的弊端在于，上司其实并不打算深入了解每个人的工作。严格来说，他只对部分人的工作进度感兴趣，这“部分人”又呈动态分布。如某君这个月大受上级关注，下个月风平浪静按部就班。悲惨地讲，每个部门总有超过一半的周报被完整地浪费掉，上司漠不关心，还不能不写。难道要整个“周报排期表”一类的幺蛾子出来？</p>
<p>话说到这里，宛然打了一个死结。周报在理论上是高效率与高弹性的沟通制度，只是在执行中走样得厉害。既然走样无可修复，是否索性放弃周报呢？不行，其他沟通制度比周报更烂得多，或是适用情景有限。人和人之间的沟通是非常复杂的事情，越是感情生分，级别森严，利益纠葛，沟通就愈发困难。我见过不少人摇头叹气说：“沟通，主要是沟通出了问题。”“沟通，唉，沟通非常关键。”“我们得重视沟通，加强沟通。”他们真心诚意地讲这些屁话……反复讲，大声讲，形成回声！</p>
<p>如果不采用制度，仅仅靠上下级的交流意愿与技巧来加强沟通，则纯属一种意淫。一旦放弃了会议、汇报等管理手段，职场对话自由化，在稍复杂的工作环境里就会造成信息阻滞，引发混乱。用制度促进沟通是相当烂的做法，但啃树皮总好过饿死荒野对吧。哪怕生硬的沟通，敷衍了事的沟通，也比缺乏沟通更好，何况其中总有一小部分是有效的。而每个人每周就算浪费掉这二三十分钟，也不是什么了不起的损失。</p>
<p>所以你会看到周报成为大多数公司的常规制度，包括一家十几人的创业小公司，也有人笑着说，我们现在要写周报哎。语气颇不以为然。不过Boss只有一个，中间层的管理岗位又没有，不看周报，他怎么了解十来人的工作进展呢？周报也好周会也好，大都是令人厌恶的制度，也是管理人数增加，业务性质复杂后，无法回避的强制信息流通手段。</p>
<p>在这一点上，我的创业小队现在人数少，任务紧，士气旺盛，每天5分钟晨会更适合一些，但也仅仅匹配当前阶段而已。到了十几人，几十上百人，难免加入各种“令人厌恶的制度”。人生颇多无奈，渐渐习以为常。</p>
<p>沟通/理解/信任，是这蓝色星球上最为奢侈的东西之一。我们无法挑战人性中的缺陷面，只好用不完美甚至不合理，来解决另一些更要命的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E7%91%9E%E5%85%B8%E5%85%B3%E9%97%AD%E5%A2%83%E5%86%85%E6%9C%80%E5%90%8E%E4%B8%80%E6%89%80%E5%AD%94%E5%AD%90%E5%AD%A6%E9%99%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E7%91%9E%E5%85%B8%E5%85%B3%E9%97%AD%E5%A2%83%E5%86%85%E6%9C%80%E5%90%8E%E4%B8%80%E6%89%80%E5%AD%94%E5%AD%90%E5%AD%A6%E9%99%A2/" class="post-title-link" itemprop="url">如何看待瑞典关闭境内最后一所孔子学院</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 20:07:27 / Modified: 20:10:26" itemprop="dateCreated datePublished" datetime="2020-04-27T20:07:27-04:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>感谢瑞典政府为中国人民省下了点税收</p>
</li>
<li><p>法国孔子学院，以方方日记作为2020年4月举办的第三届翻译大赛的翻译材料。</p>
</li>
<li><p>喜闻乐见，瑞典终于做了一件让绝大多数中国人满意的事情。</p>
</li>
<li><p>上一代建州大儒的对明宣传：看，这是我们建奴的鱼皮衣服，这是我们建奴的野猪牙项链，这是我们建奴小孩儿跳的萨满抽疯舞，这是我们建奴特产臭鱼肉，好玩吧？端上来，给天朝官人们尝尝鲜。</p>
<p>江南大儒：口区！非人哉！化外满鞑果然恶心至极，根本不可能开化，实应马上安排一波犁庭扫穴，立刻马上！</p>
<p>本届建州对明宣传：白甲巴牙剌武士双层重甲安排上了，红衣大炮日产三十门，求问大明卫所兵的天灵盖平均厚度。</p>
<p>江南大儒发表时评：尊敬的多尔衮摄政王即日抵达他忠实的北京。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/%E5%AD%A9%E5%AD%90%E5%88%9A%E5%AD%A6%E4%BC%9A%E8%B5%B0%E8%B7%AF%EF%BC%8C%E6%98%AF%E5%90%A6%E8%AF%A5%E5%9C%A8%E8%AF%86%E5%AD%97%E5%90%8E%E7%AB%8B%E9%A9%AC%E6%95%99%E4%BB%96Python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/%E5%AD%A9%E5%AD%90%E5%88%9A%E5%AD%A6%E4%BC%9A%E8%B5%B0%E8%B7%AF%EF%BC%8C%E6%98%AF%E5%90%A6%E8%AF%A5%E5%9C%A8%E8%AF%86%E5%AD%97%E5%90%8E%E7%AB%8B%E9%A9%AC%E6%95%99%E4%BB%96Python/" class="post-title-link" itemprop="url">孩子刚学会走路，是否该在识字后立马教他Python</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 22:22:13 / Modified: 22:25:21" itemprop="dateCreated datePublished" datetime="2020-04-26T22:22:13-04:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>建议教 Rust. 理由：</p>
<p>1、由于 Rust 有 borrow checker，容易让你女儿养成借了东西按时还的好习惯。而如果你教了带 GC 的语言，可能你的女儿就变成被人催才还东西的人，不利于你女儿的人际交往。</p>
<p>2、Rust 有静态类型，可以让你女儿养成在做事前先对可行性进行基本检查的习惯。而如果你教了动态类型语言，可能你的女儿会鲁莽做事，做到一半才发现不可行，从而半途而废。</p>
<p>3、Rust 编译特别耗时，且编译时风扇特别吵，可以锻炼你女儿的忍受噪音能力以及耐心。</p>
<p>4、Rust 默认安全，但也允许程序员通过 <code>unsafe</code> 进行不安全操作。这有利于你女儿养成重视安全，但又不至于过度保守，该冒险时愿意冒险的性格。</p>
<p>5、Rust 支持 procedural macro，可以内嵌 DSL，方便您女儿使用该门语言应付作业。</p>
<p>6、Rust 不需要 runtime，能使您女儿养成不依赖别人的好习惯。</p>
<p>或者</p>
<p>请给孩子一个完整的童年，Java, c, c++,都上了吧！</p>
<p>语言先别急，计算机科学导论要先学</p>
<p>还有数据结构，编译原理，操作系统，计算机组成原理，</p>
<p>然后系统结构，汇编语言，微电子线路和ic设计，复变函数与积分变换，自动控制原理，信号与系统也很重要！ps来自评论区</p>
<p>要理解原理一定要数学跟上</p>
<p>高数一，高数二，线性代数，概率论，离散数学</p>
<p>对了，英语也很重要，才能不输起跑线，</p>
<p>英语4级词汇量起码3500个，每天100个单词，1个月达成，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/%E9%9B%8C%E6%80%A7%E6%85%95%E5%BC%BA%E4%B8%8E%E6%B0%91%E6%97%8F%E7%9A%84%E8%B5%B7%E6%BA%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/25/%E9%9B%8C%E6%80%A7%E6%85%95%E5%BC%BA%E4%B8%8E%E6%B0%91%E6%97%8F%E7%9A%84%E8%B5%B7%E6%BA%90/" class="post-title-link" itemprop="url">雌性慕强与民族的起源</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-25 17:39:35 / Modified: 17:40:41" itemprop="dateCreated datePublished" datetime="2020-04-25T17:39:35-04:00">2020-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们先从群居哺乳动物的共性谈起。</p>
<p>狮群模型：一只公狮打败一定区域内所有其它雄性，区域里的所有雌性都属于他；从而组成狮群。我们叫这只公狮为 1 号公狮。1 号公狮与狮群中的几乎所有的母狮交配，生下一些小狮子。公狮更多时候靠母狮群体捕猎获取食物，当狮群受到攻击时，公狮参与保卫狮群，比如抵御鬣狗群的袭击。</p>
<p>另一只雄狮 2 号崛起，它将与公狮 1 号决斗，<strong>母狮的立场是什么呢？**</strong>是慕强<strong>**。</strong>如果 2 号公狮与 1 号实力相当或者弱于 1 号，大量母狮会帮助 1 号一起撕咬 2 号，显然 2 号是必败的。<strong>母狮的参战是在最强基因与已有后代间找平衡</strong>，因为如果 2 号实力和 1 号相当，甚至实力只略高于 1 号，胜出的 2 号会遵循自然法则杀死所有的幼狮，逼迫母狮们重新发情。实力弱于 1 号、实力相当甚至实力略强一点点的 2 号，是一种资源的浪费，母狮会和 1 号一起去攻击 2 号。</p>
<p>但是，当 2 号公狮具有压倒性优势，自然界的另一个规律出现了，<strong>母狮们会袖手旁观</strong>，等待 2 号公狮打败 1 号并赶走它。接下来的杀死幼狮，虽然母狮不情愿，也会象征性的保护一下，但是会接受现实，等待自己孩子死掉，然后自己发情于 2 号公狮。</p>
<p>狮群的规律，依次往复。</p>
<p>而实际上，所有母狮一起上，不用 1 号公狮，这些母狮也足以把 2 号公狮咬死。<strong>但是大自然的法则不会这样，母狮们慕强于更有实力的公狮。</strong></p>
<p>到了猴群模型，出现了和狮群类似的情形，也就是<strong>母猴慕强</strong>，公猴嬴者通吃，占有一定区域内的所有母猴。新猴王为了满足自身性欲，如果发现母猴因为有前猴王的孩子，而不发情。也有杀幼的现象，只是通常没有公狮那么决绝而已。母猴们也是幕强而生，她们只站强者的位置，帮着强者打弱者，而不会帮着弱者打强者。</p>
<p>人类作为最高等的动物，会 “重演” 某些元祖 DNA 的外化行为模式片段，尤其是群居性社会性哺乳动物的很多行为模式。</p>
<p><strong>我们来看人类的殖民战争与雌性慕强。</strong></p>
<p>西拔牙殖民者杀死拉美印第安男性中勇于反抗的个体，在印第安女性的身体中注入西班牙的男性父系基因，制造了新的民族，就是今天的拉美民族。这些民族是混入了西班牙父系基因而继承了印第安母系基因的民族。在后来的这些民族国家，更高级的是纯种白人；其次是父系白人基因，母系印第安基因的人种（比如墨西哥白墨），然后是印第安父系基因占比更多的那些人（比如墨西哥的黑墨）。</p>
<p><strong>西方的殖民战争充分证明了，只要杀死一个民族敢于反抗的男性，留下精神太监以及该民族的女性，那么这个民族就算被灭了。**</strong>父系基因是一个民族得以存在的最后防线。**</p>
<p>和狮群、猴群类似，一旦 A 种族的男性杀死 B 种族中反抗者，只留 B 种族中的趴舔者，<strong>那么 B 种族的女性马上会对 A 种族的男性，发情。</strong></p>
<p><strong>雌性慕强是群体性哺乳动物的基本属性，人类也不例外。</strong></p>
<p>随着人类的社会发展，杀死某一种族的男性出现了两种基本形式，一种是真实的肉体消灭，一种是精神上消灭雄性，后者比如利用文化的去雄化，让一个民族的男性变成精神太监。——<strong>这就是 easy girl 的本质原因</strong>。人类史血淋淋的事实一次次证明了，一个民族男性不够强，他们种族的女性就会对她们认为强的民族男性，发情。</p>
<p><strong>而且这种强包括实际实力的强和精神的强两个方面</strong>。后者精神的强不受理性中立客观的影响；精神的强，更多是一种民族情绪感性的强，是不理性的强。<strong>哪怕极端的民族主义产生的情绪化男性之强</strong>，实际上对于抵制外族雄性入侵也是有很好效果的。比如外蒙古、哈萨克斯坦等经济落后，军事实力孱弱的国家；他们男性的极端情绪化的强，也会阻止外族男性对于本族女性的造次，同时他们国家的女性出现 easygirl 的几率也会大大下降。</p>
<p>因为自己种族的男性，丧失了自信、情绪化之强，以及对其他种族的暴力，<strong>丧失暴力便是丧失性能力的镜像</strong>，丧失暴力，性之不存，种之不存，所以中国自古形容那些在外族入侵面前无抵抗之心的男人，为之：<strong>没种</strong>。确实，同族的女性不会找没种的男人，她们慕强的本性硬肯去找外族。</p>
<p>都说中国有 easy girl，其实质原因是中国有种的男性不足，比如趴舔美国派华奸公知，他们没种，还特有宣传力，宣传自己在外族面前没种，因而，easy girl 的真正制造机就是那些被去雄化的精神跪族——华奸公知。</p>
<p>民族的真正起源，是建立在群体父系基因上的。国家是必须建立在一个核心民族之上。人类民族的本质是民族父系基因和雄性文化基因。国家的产生也确切是在父系社会产生之后的事。</p>
<p><strong>雌性是慕强而生的天然国际主义者，在人类历史上各种国家间征伐中，女性倒向更强的民族国家。</strong></p>
<p>民族与国家建立在父系基因之上的另一佐证就是民族聚居后的民族冲突。研究历史可以发现，如果一个地区引进的异族男性更多，这些男性一旦聚居和本族女性通婚，生下的孩子更多会跟着这些男性的文化走。随着聚居规模的变大，当区域人口比例发生颠倒时，种族冲突甚至种族仇杀是难以避免的。而现在为了争夺廉价劳动力的引进外民模式，更大比例的引入都是外族男性，这就为未来潜在的种族冲突埋下了祸根。可以看看美国的拉美人和欧洲的黑墨绿。这也是我极力反对中国大批量引进外国男性的原因；相反引进女性就不用担心发生暴动和骚乱的风险。</p>
<p>研究发现，通常男性更加固执，破坏性更强，文化更难以改变，成年男性学习新语言的能力弱于女性，而且男性的口音更加难变……</p>
<p>而女性，适应力更强，耐受力更强，学习新语言更快，更容易融入新的文化，口音也比男性易改……</p>
<p>生物的进化，留给男性的属性就是固执的征服者，留个女性的属性就是慕强而包容强者的世界主义者。——这些客观属性，带有明显的统计学意义，是刻在人类生物 DNA 和文化 DNA 中的。</p>
<p>种族基因是更本质的生物性里世界，文化基因是基于种族基因社会性外化出的意识表世界，是用一个问题的不同层次表达。</p>
<p>美国利用各种人文学科、媒体、电影艺术等各种文化手段对亚洲进行可怕的文化去雄化处理，就是要在精神上进行民族灭绝。文化上灭掉一个民族甚至一个种族的男性，这个种族的女人自然就是战利品了。</p>
<p><strong>一种文化去雄化方式是太监化</strong>：在美国文艺作品里出现的华人男性无论是恶贯满盈的傅满洲，还是坏蛋陈查理，都是一副阳痿的太监模样。傅满洲的阳痿形象，通过其不断暴力虐待片中的女性肉体得以表现。</p>
<p><strong>另一种文化去雄化方式</strong>，是把东亚的男性描绘成没有长开的男童，比如，各种日本、韩国以及中国的鲜肉男星。</p>
<p>Easy girl 是一个民族去雄化的结果，去雄化民族的女性，必然对异族雄性发情，必然产生 easy girl。</p>
<p><strong>任何的民族如果雄性不强，那么这个民族就会被淘汰，淘汰的不仅是这个民族的雄性文化基因，甚至是这个民族的父系生物基因。所以，对于我们中华民族的男性来说，我们别无选择！</strong></p>
<p><strong>我们要雄起，我们要团结，我们要呼唤那种情绪的强，我们要回归有种的文化！</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%A7%E8%83%BD%E8%BF%87%E5%89%A9%E4%B8%80%E7%9B%B4%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%87%BA%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%A7%E8%83%BD%E8%BF%87%E5%89%A9%E4%B8%80%E7%9B%B4%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%87%BA%E7%8E%B0/" class="post-title-link" itemprop="url">为什么产能过剩一直在中国出现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-24 23:35:59 / Modified: 23:36:38" itemprop="dateCreated datePublished" datetime="2020-04-24T23:35:59-04:00">2020-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工业就是过剩，过剩就是工业，过剩，是真理。</p>
<p>之所以出现在中国，是因为你有工业了。</p>
<p>思考这个问题前，先换一个角度：</p>
<p>把国籍给忘咯。</p>
<p>然后想，例如，这地球上的服装产能过剩吗？不用找资料你都能反应过来，肯定过剩；</p>
<p>那手机产能呢？不好意思也过剩了，17年就转入存量市场了。现在的产能，全球每人每两年换一部绝对没问题；</p>
<p>那建筑产能呢？全球每人至少一辈子一套房？哎，也过剩了。建筑产能自中国起来后，全球就算过剩了，稀缺的从来都是土地。</p>
<p>切换一下角度你会发现：这个地球上，有大量工业门类的产能早已处于严重过剩状态。没有进入过剩的，都是受其他资源禀赋的限制：例如地球上有多少矿、有多少能源、有怎样的技术。</p>
<p>归根结底，就是技术限制而已。</p>
<p>为什么过剩？因为工业的核心就是过剩。</p>
<p>工业的核心是什么？生产。现行的主流生产形态是什么？规模化流水线，俗称量产。</p>
<p>为什么选择量产？因为只有这种标准化大批量的生产模式，才能摊平每件产品的成本，把人员、装备、土地、水电等庞大的前置费用摊下去，摊出一个大众普遍能接受的产品定价。</p>
<p>而这种规模化流失线必然导致过剩。</p>
<p>为了通过更低的定价获得更大的市场份额，参与者都会在自己能承受的范围内进行量产优化竞争。</p>
<p>没有太强制的资源约束，整体市场呈现纯粹竞争状态，这种是最容易过剩的，例如服装。</p>
<p>垄断性竞争与寡头竞争也一样。日化用品是个典型的垄断性竞争环境，品牌及定价分层非常清晰；手机是典型的寡头竞争环境，所有参与者在定价上要谨慎思考对手的反应。</p>
<p>这俩行业为什么也过剩？因为在格局相对稳定的环境下，参与者都会设计汰旧机制，用技术和广告来刺激消费迭代，增加相同份额下的市场收益。</p>
<p>男生比较熟悉的有“科技以换壳为本”和“挤牙膏”，女生比较熟悉的有“化妆品的区别是广告和代言人”。</p>
<p>狠一点，直接缩短产品生命周期，例如灯泡。再狠一点的，库存一把火烧了，人为制造稀缺。</p>
<p>这些行为都极大地加深了产能过剩。民用电子工业之花手机过剩了，民用机械工业之花汽车也过剩了。统统过剩，听着离共产主义都不远啦。</p>
<p>说到共产主义，很多人想：娘的，计划经济总不过剩吧？完全垄断，还能过剩？</p>
<p>抱歉，还是过剩，而且往往是低水平过剩。</p>
<p>怎么个低水平法呢？就是这类产品市场需求已经在衰退，但是国有资本在官僚体制的影响下，依然盲目扩张产能。</p>
<p>实际上，你去翻翻我们和苏联的资料，你会发现我们不是没有轻工业制成品，只是我们有的，很多不是老百姓想消费的。</p>
<p>苏联人真不缺洗衣机，但那玩意长得像垃圾桶一样，真的很难看出是洗衣机。</p>
<p>社会主义国家当年的普遍匮乏，实际是国家将有限资源投入到了军重工业领域。民用工业的产能不足，背后其实是军重工业产能的严重过剩。</p>
<p>其实还是过剩。</p>
<p>讲到这里就能看出来，工业的过剩趋势是必然的。解决过剩的终极手段，只有信息穿透。</p>
<p>但这个穿透太难做到了。</p>
<p>你不仅要穿透你的消费者，你还要穿透你的竞争对手。哪怕你的员工人均尤里，所有人在他们面前都是透明的，你还要穿透这个世界。</p>
<p>因为你要预判各种波动，地震海啸疫病新技术爆发，这些都会干扰需求。可能吗？不可能。</p>
<p>只要信息迷雾存在，产能就一定过剩。就像只要A.T.field存在，人的感情一定过剩一样。</p>
<p>为什么不管姓资姓社，都关注社会化大生产与私有制之间的矛盾？因为必然导致产能过剩。</p>
<p>工业就这鸟样。</p>
<p>讲到这里，再回顾一下我们的过剩。</p>
<p>一直有学者强调我们的两种过剩：制度性过剩与结构性过剩。</p>
<p>前者主要指政府干预下的产能管理混乱，例如盲目扩张、强行保留、指标干涉等；</p>
<p>后者主要指各种我们不要的低端产业，例如服装、玩具、钢铁等等。</p>
<p>前者的过剩我认为是应当解决的：继续推行双轨制，战略产业和战略红线由国家兜底，例如芯片国家砸大钱、粮食化工等原材料国企保证基础供应。剩下的产能交由市场来决定，该关关。</p>
<p>但是有一票反复强调结构性过剩的，觉得中国以后就不要生产玩具衣服，也不要做眼镜水杯。这些东西污染大、利润薄、技术含量低，做来干嘛？</p>
<p>况且现在已经过剩了，转出去吧。</p>
<p>我对此强烈反对。所有国家，无外乎三个重心：资源、金融、制造。</p>
<p>资源要不要？废话都想要，可是要得到吗？问地壳运动和大西洋暖流去要啊？</p>
<p>金融要不要？要，我们也已经是全球金融资本体量第一了。但是能不能只要金融？不行。</p>
<p>美帝重点全转至金融，不到五十年已经问题多多。以我们的体量，重心金融，矛盾爆发不过十年。</p>
<p>那剩下的还有什么？只有制造了。</p>
<p>这也是为什么我们有全球最全的工业门类。谁特么想做流水线工人？还不是因为我们地大物不博，钞票外人又不认，想维持生活只能打工这样子。</p>
<p>既然我们注定是长期是以制造国为第一身份，也已经拥有了全球最全的工业门类和最大的工业产能，那这些门类的产能过剩必然在我们这爆发。</p>
<p>结构性过剩不是一个问题，因为这个结构长期存在。真正要解决的不是这个结构，而是过剩。</p>
<p>不大改结构，解决过剩的思路就俩，对外搞点势力范围，圈下来的地方输出你的产能；对内规划有效投资，把过剩产能投入到你的资产增值里。</p>
<p>前者是大英帝国，后者是罗斯福新政。</p>
<p>说实话这二者都无所谓，因为维系产能是关键。打通任督二脉固然好，不行的话，吸星大法也行。</p>
<p>但当下的问题，是几乎所有人讨论到中国的产能过剩，第一反应都是去产能。仿佛把低端工厂关了，工人就会找到更优厚的岗位，释放的资金就会去做产业升级，积累的技术就会自动互联网化了。</p>
<p>这脑回路不知道是怎么连起来的。</p>
<p>现实是：</p>
<p>相当多的产线工人无处可去，最后只能国家吸纳。国家要么是设立冗余岗位，要么是强行扩张国企产能来吸收，最后都是国家财政负担。</p>
<p>很多劳动力是进不了基建项目的。像纺织工业有大量女工，而且年龄颇大，怎么安置？包装、家具的大龄男工也多，怎么上工地？</p>
<p>不要说什么回老家种地，说这话的家里肯定没人种地。小农状态下种地收益太低，失业工人多数也没资本去买地，不如直接报贫困户。</p>
<p>释放的资金也没去做产业升级。资金背后是人，人看不懂这个行业他敢投吗？他长期做实体的信任那些金融机构吗？掉头还是去房地产。</p>
<p>房地产都是安分的，狠一点的直接搞地下钱庄，给还在做实业的同行放贷。无他，这业务他熟啊。</p>
<p>积累的技术和产线经验则是直接消失。工业知识是严重偏工程类的，需要海量实践为基础才有改进。航空发动机的参数大学课本都会写，造出来的工艺工序没个五十年你摸索不出来。</p>
<p>这还不是最致命的。最致命的，是大量已经成型的产业集群在加速消解。</p>
<p>中国的产线工人工资早就高于东南亚了，为什么这么多年转过去的还就是一些纺织厂和玩具组装线？因为你有产业集群在维护收益。</p>
<p>孟加拉的纺织厂坏一台设备，要从山东找技工来修；缺一种面辅料，要从广州中大进口；培训一道新工序，要从浙江请老师傅来教。</p>
<p>12年前我在尼日利亚，一个印度人开的锅厂，一个冲压机对一片钢板砸一下就完工的那种，印度人要年薪30万请个茂名的中专生在那待着。</p>
<p>而这一切，在国内任何一个纺织园区，都是一个电话一天解决的事。湖州织里生产了全球四分之一的童装，师傅、技工、面辅料，基本都在厂子的五公里范围内能找到。</p>
<p>这种高效灵活的产业集群，保证了在中国用工成本不断上涨的同时，还能以东南亚相近价格更高质量的优势来竞争。</p>
<p>而且，这种产业集群正是工业升级的坚实基础。</p>
<p>我们的工业软件很垃圾，和我们的产能相比简直是耻辱。以前国家为主动，中科院工信部做了一些努力，但效果一般；互联网一票人进来做点概念，效果更一般。</p>
<p>真正出成果出好苗子的，全是这些低端产能里的龙头企业自我逼迫升级，咬牙慢慢摸索出来的，简直和好莱坞早期一堆烂片堆一部经典一样。</p>
<p>如今一看是低端，又产能过剩，大手一挥，指望他们自己关停并转。</p>
<p>当年的关停并转也没啥好效果啊。</p>
<p>现在应对产能过剩的方法，好比做盆栽，拿着剪刀这里咔嚓一下那里划一刀，姿势好看账目数据漂亮，就算去产能成功。</p>
<p>这样的花花草草摆在风雨里，一天就得萎了。</p>
<p>要么你圈下一块市场，水肥管够，你们去长，谁长成参天大树谁牛逼；要么你没水没肥但地管够，你们也去长，土壤贫瘠一点，但长得壮也是本事。</p>
<p>现在是治一木之才者治一林。</p>
<p>减肥可以靠节食，但总归是要靠运动、睡眠和合理饮食。手术不改善根本体质，而且有危险，特别是当主刀医生连肥肉肌肉和内脏都分不清的时候。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/JS%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/JS%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">JS总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-24 09:32:51 / Modified: 13:48:25" itemprop="dateCreated datePublished" datetime="2020-04-24T09:32:51-04:00">2020-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>一、 变量类型</p>
<p>二、 深拷贝与浅拷贝</p>
<p>三、 原型与原型链</p>
<p>四、 继承与实现</p>
<p>五、 实现class与extends</p>
<p>六、 作用域、执行上下文与闭包</p>
<p>七、 this</p>
<p>八、 apply、call、bind实现</p>
<p>九、 同步与异步</p>
<p>十、 AMD、CMD、CommonJS与ES6模块化</p>
<p>十一、 script标签之async与defer</p>
<p>十二、 改变数组本身的api</p>
<p>十三、 window之location、navigator</p>
<p>十四、 ajax与fetch</p>
<p>十五、 WebSocket</p>
<p>十六、 短轮询、长轮询与WebSocket</p>
<p>十七、 长连接与短连接</p>
<p>十八、 存储</p>
<p>十九、 跨域</p>
<p>二十、 setTimeout与setInterval</p>
<p>二十一、 requestAnimationFrame</p>
<p>二十二、 事件</p>
<h2 id="一、变量类型"><a href="#一、变量类型" class="headerlink" title="一、变量类型"></a>一、变量类型</h2><h3 id="与"><a href="#与" class="headerlink" title="==与==="></a>==与===</h3><h4 id="对于-的判断"><a href="#对于-的判断" class="headerlink" title="对于==的判断"></a>对于==的判断</h4><ul>
<li>并不是那么严谨的判断左右两端是否相等</li>
<li>它会优先对比数据的类型是否一致</li>
<li>不一致则<strong>进行隐式转换</strong>，一致则判断值的大小，得出结果</li>
<li>继续判断两个类型是否为null与undefined，如果是则返回true</li>
<li>接着判断是否为string与number，如果是把string转换为number再对比大小</li>
<li>判断其中一方是否为boolean，如果是就转为number再进一步判断</li>
<li>判断一方是否为object，另一方为string、number、symbol，如果是则把object转为原始类型再判断</li>
</ul>
<h5 id="比较情况"><a href="#比较情况" class="headerlink" title="比较情况"></a>比较情况</h5><ol>
<li>数组 == 值，(值类型指的是原始类型)会先转成数值再比较，与字符串比较会先转成字符串再比较</li>
<li>引用 == 值，会把引用类型转成原始类型再比较</li>
<li>值 == 值，直接比较类型再比较值的大小</li>
<li>字符串 == 数字，则把字符串转为数值再比较</li>
<li>其他类型 == boolean，则把boolean转成数值再进一步比较</li>
<li>undefined == null，也会发生隐式转换，且2者可以相互转换，即2者相等，与自身也相等</li>
<li>对象 == 非对象，如果非对象为string或number，则返回ToPrimitive(对象) == 非对象，的结果；ToPrimitive方法的参数如果是原始类型则直接返回；如果是对象，则调用valueOf方法，如果是原始值再进行原始类型转换和大小对比；如果不是原始值则调用toString，且结果为原始值则进行原始类型比较，如果不是原始值则抛出错误</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下结果都为true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">5</span>]==<span class="number">5</span>,[<span class="string">'5'</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">name</span>:<span class="string">'5'</span>&#125;==<span class="string">'[object Object]'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>==<span class="number">5</span>,<span class="literal">true</span>==<span class="number">1</span>,<span class="literal">false</span>==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>==<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">5</span>,<span class="number">6</span>]==<span class="string">'5,6'</span>,[<span class="string">'5'</span>,<span class="string">'6'</span>]==<span class="string">'5,6'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大白话：优先比较类型，同类型，比大小，非原始，调ToPrimitive，为对象调valueOf，还非原始调toString，最后还非原始则报错，如果为原始则进行类型对比，如果不同类型再转换，之后对比大小。</p>
</blockquote>
<p>所谓==比较就是要转换成同类型比较，如果无法转成同类型就报错</p>
<blockquote>
<p>优先比类型，再比null与undefined，再比string和number，再比boolean与any，再比object与string、number、symbol；以上如果转为原始类型比较，则进行类型转换，直到类型相同再比较值的大小。这就是==的隐式转换对比，比较绕，给个图就清晰了！</p>
</blockquote>
<p>如下为判断步骤</p>
<img src="../images/1719d4f703af20a1.png" alt="img" style="zoom:200%;" />

<p>思考？如何判断此表达式（注意==!与!==） <strong>[]==![]</strong></p>
<ul>
<li>基于运算符的优先级此式会先运算![]的结果</li>
<li>!优先于==，且[]为真值(转成boolean，结果为true的就为真值，包括{}；转成false的就为假值)，![]结果为false，所以当前表达式转化为 []==false</li>
<li>通过之前总结的转换关系，任何类型与boolean类型比较，所以[]==false 转化为 []==0 比较</li>
<li>此时变为object与0比较，调用object的转换成原始类型的方法valueOf其结果还是valueOf</li>
<li>再调用toString结果为’’，再进行string转成number，则[]转成数字类型0</li>
<li>表达式进一步转换成0==0，结果为true。</li>
</ul>
<p>虽然过程复杂，记住判断的思路即可，非对象之间，先类型转换再比大小，对象比较则调用获取原始值方法再进一步比较。</p>
<p>如下为toString与valueOf转换</p>
<p><img src="../images/1719d4e8d3757d58.png" alt="img"></p>
<h4 id="对于-的判断-1"><a href="#对于-的判断-1" class="headerlink" title="对于===的判断"></a>对于===的判断</h4><ul>
<li>===属于<strong>严格判断</strong>，直接判断两者类型是否相同，不同则返回false</li>
<li>如果相同再比较大小，<strong>不会进行任何隐式转换</strong></li>
<li>对于引用类型来说，比较的都是引用内存地址，所以===这种方式的比较，除非两者存储的内存地址相同才相等，反之false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a=[]</span><br><span class="line"><span class="keyword">const</span> b=a</span><br><span class="line">a===b <span class="comment">//true</span></span><br><span class="line">---------------</span><br><span class="line"><span class="keyword">const</span> a=[]</span><br><span class="line"><span class="keyword">const</span> b=[]</span><br><span class="line">a===b <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="7大原始类型与Object类型"><a href="#7大原始类型与Object类型" class="headerlink" title="7大原始类型与Object类型"></a>7大原始类型与Object类型</h4><ol>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>BigInt</li>
<li>String</li>
<li>Symbol</li>
<li><strong>Object</strong></li>
</ol>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><h5 id="原始类型判断"><a href="#原始类型判断" class="headerlink" title="原始类型判断"></a>原始类型判断</h5><ul>
<li><strong>原始类型</strong>string、number、undefined、boolean、symbol、bigint都能<strong>通过typeof</strong>(返回字符串形式)直接判断类型，还有对象类型function也可判断</li>
<li><strong>除了null</strong>无法通过typeof(为object)直接判断类型(历史遗留)，包括对象类型，typeof把null当作对象类型处理，所以typeof无法判断对象类型，<strong>typeof也能判断function</strong></li>
</ul>
<h5 id="非原始类型判断-以及null"><a href="#非原始类型判断-以及null" class="headerlink" title="非原始类型判断(以及null)"></a>非原始类型判断(以及null)</h5><p>判断数组</p>
<ul>
<li>使用<code>Array.isArray()</code>判断数组</li>
<li>使用<code>[] instanceof Array</code>判断是否在Array的原型链上，即可判断是否为数组</li>
<li><code>[].constructor === Array</code>通过其构造函数判断是否为数组</li>
<li>也可使用<code>Object.prototype.toString.call([])</code>判断值是否为’[object Array]’来判断数组</li>
</ul>
<p>判断对象</p>
<ul>
<li><code>Object.prototype.toString.call({})</code>结果为’[object Object]’则为对象</li>
<li><code>{} instanceof Object</code>判断是否在Object的原型链上，即可判断是否为对象</li>
<li><code>{}.constructor === Object</code>通过其构造函数判断是否为对象</li>
</ul>
<p>判断函数</p>
<ul>
<li>使用<code>func typeof function</code>判断func是否为函数</li>
<li>使用<code>func instanceof Function</code>判断func是否为函数</li>
<li>通过<code>func.constructor === Function</code>判断是否为函数</li>
<li>也可使用<code>Object.prototype.toString.call(func)</code>判断值是否为’[object Function]’来判断func</li>
</ul>
<p>判断null</p>
<ul>
<li>最简单的是通过<code>null===null</code>来判断是否为null</li>
<li><code>(!a &amp;&amp; typeof (a) != &#39;undefined&#39; &amp;&amp; a != 0)</code>判断a是否为null</li>
<li><code>Object.prototype.__proto__===a</code>判断a是否为原始对象原型的原型即null</li>
</ul>
<p>判断是否为NaN</p>
<ul>
<li><code>isNaN(any)</code>直接调用此方法判断是否为非数值</li>
</ul>
<p>一些其他判断</p>
<ul>
<li><code>Object.is(a,b)</code>判断a与b是否完全相等，与===基本相同，不同点在于Object.is判断<code>+0不等于-0</code>，<code>NaN等于自身</code></li>
<li>一些其他对象类型可以基于原型链判断和构造函数判断</li>
<li><code>prototypeObj.isPrototypeOf(object)</code>判断object的原型是否为prototypeObj，不同于instanceof，此方法直接判断原型，而非instanceof 判断的是右边的原型链</li>
</ul>
<p>一个简单的类型验证函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWho</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// null</span></span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">'null'</span></span><br><span class="line">  <span class="keyword">const</span> primitive = [<span class="string">'number'</span>, <span class="string">'string'</span>, <span class="string">'undefined'</span>,</span><br><span class="line">    <span class="string">'symbol'</span>, <span class="string">'bigint'</span>, <span class="string">'boolean'</span>, <span class="string">'function'</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> x</span><br><span class="line">  <span class="comment">//原始类型以及函数</span></span><br><span class="line">  <span class="keyword">if</span> (primitive.includes(type)) <span class="keyword">return</span> type</span><br><span class="line">  <span class="comment">//对象类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(x)) <span class="keyword">return</span> <span class="string">'array'</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Object]'</span>) <span class="keyword">return</span> <span class="string">'object'</span></span><br><span class="line">  <span class="keyword">if</span> (x.hasOwnProperty(<span class="string">'constructor'</span>)) <span class="keyword">return</span> x.constructor.name</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(x)</span><br><span class="line">  <span class="keyword">if</span> (proto) <span class="keyword">return</span> proto.constructor.name</span><br><span class="line">  <span class="comment">// 无法判断</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"can't get this type"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、深拷贝与浅拷贝"><a href="#二、深拷贝与浅拷贝" class="headerlink" title="二、深拷贝与浅拷贝"></a>二、深拷贝与浅拷贝</h2><p>在项目中有许多地方需要数据克隆，特别是引用类型对象，我们无法使用普通的赋值方式克隆，虽然我们一般使用第三方库如lodash来实现深拷贝，但是我们也需要知道一些其中的原理</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ul>
<li><code>Object.assign({},obj)</code>浅拷贝object</li>
<li><code>obj1={...obj2}</code>通过spread展开运算符浅拷贝obj2</li>
<li><code>Object.fromEntries(Object.entries(obj))</code>通过生成迭代器再通过迭代器生成对象</li>
<li><code>Object.create({},Object.getOwnPropertyDescriptors(obj))</code>浅拷贝obj</li>
<li><code>Object.defineProperties({},Object.getOwnPropertyDescriptors(obj))</code>浅拷贝obj</li>
</ul>
<p>简单实现浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a原拷贝对象，b新对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  b[key] = a[key]</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(a)) &#123;</span><br><span class="line">  b[key] = a[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝</strong>只拷贝一层属性对于<strong>引用类型无法拷贝</strong></p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>通过<strong>JSON的2次转换</strong>深拷贝obj，不过无法拷贝<strong>undefined</strong>与<strong>symbol</strong>属性，无法拷贝<strong>循环引用</strong>对象</li>
<li>自己实现深拷贝</li>
</ul>
<p>简单深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单版深拷贝，只能拷贝基本原始类型和普通对象与数组，无法拷贝循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleDeepClone</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> b=<span class="built_in">Array</span>.isArray(a) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(a)) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> a[key]</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">'object'</span> || a[key] === <span class="literal">null</span>) &#123;</span><br><span class="line">      b[key] = a[key]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      b[key] = simpleDeepClone(a[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//精简版深拷贝只能拷贝基本原始类型和普通对象与数组，可以拷贝循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">a, weakMap = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">'object'</span> || a === <span class="literal">null</span>) <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">if</span> (s = weakMap.get(a)) <span class="keyword">return</span> s</span><br><span class="line">  <span class="keyword">const</span> b = <span class="built_in">Array</span>.isArray(a) ? [] : &#123;&#125;</span><br><span class="line">  weakMap.set(a, b)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(a)) b[key] = clone(a[key], weakMap)</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//js原生深拷贝，无法拷贝Symbol、null、循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSdeepClone</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!data || !(data <span class="keyword">instanceof</span> <span class="built_in">Object</span>) || (<span class="keyword">typeof</span> data == <span class="string">"function"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> data || <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">constructor</span> = data.<span class="keyword">constructor</span>;</span><br><span class="line">  const result = new <span class="keyword">constructor</span>();</span><br><span class="line">  for (const key in data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.hasOwnProperty(key)) &#123;</span><br><span class="line">      result[key] = deepClone(data[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较完善的深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝具体版，非完全，但大部分都可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClonePlus</span>(<span class="params">a, weakMap = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> a</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">null</span> || type !== <span class="string">'object'</span>) <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">if</span> (s = weakMap.get(a)) <span class="keyword">return</span> s</span><br><span class="line">  <span class="keyword">const</span> allKeys = <span class="built_in">Reflect</span>.ownKeys(a)</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Array</span>.isArray(a) ? [] : &#123;&#125;</span><br><span class="line">  weakMap.set(a, newObj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> allKeys) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = a[key]</span><br><span class="line">    <span class="keyword">const</span> T = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span> || T !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      newObj[key] = value</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> objT = <span class="built_in">Object</span>.prototype.toString.call(value)</span><br><span class="line">    <span class="keyword">if</span> (objT === <span class="string">'[object Object]'</span> || objT === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">      newObj[key] = deepClonePlus(value, weakMap)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (objT === <span class="string">'[object Set]'</span> || objT === <span class="string">'[object Map]'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (objT === <span class="string">'[object Set]'</span>) &#123;</span><br><span class="line">        newObj[key] = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        value.forEach(<span class="function"><span class="params">v</span> =&gt;</span> newObj[key].add(deepClonePlus(v, weakMap)))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newObj[key] = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        value.forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> newObj[key].set(i, deepClonePlus(v, weakMap)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (objT === <span class="string">'[object Symbol]'</span>) &#123;</span><br><span class="line">      newObj[key] = <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(value))</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    newObj[key] = <span class="keyword">new</span> a[key].constructor(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刨析深拷贝(个人思路)</p>
<ul>
<li>本人使用递归算法来实习深拷贝，由于使用递归，会让代码看起来更加易懂，在不触及调用栈溢出的情况下，推荐使用递归</li>
<li>深拷贝，其实考验的就是如何把引用类型给拷贝过来，还有Symbol类型比较特殊，如何实现一个比较完整的深拷贝就要涉及<strong>不同类型</strong>的拷贝方式</li>
</ul>
<ol>
<li>首先考虑简单的<strong>原始类型</strong>，由于原始类型在内存中保存的是值可以直接通过值的赋值操作，先判断传入参数是否为原始类型，包括null这里归为原始类型来判断，没必要进入对象环节，函数直接赋值不影响使用</li>
<li>经过原始类型的筛选，剩下<strong>对象类型</strong>，取出所有对象的键，通过<code>Reflect.OwnKeys(obj)</code>取出对象自身所有的键，包括Symbol的键也能取出</li>
<li>由于对象有2种体现形式，<strong>数组</strong>和<strong>普通对象</strong>，对于这2者要单独判断，先生成一个拷贝容器即newObj</li>
<li>接下来就可以开始遍历 步骤2 中获取到对象所有的键(仅自身包含的键),通过for..of 遍历，取出当前要拷贝的对象a，对应于当前遍历键的值，即a[key]</li>
<li>对a[key]值的类型进行判断，此值类型的可能性包括所有的类型，所以又回到步骤1中先判断原始类型数据；如果是原始类型可以直接赋值跳过这一轮，进行下一轮遍历</li>
<li>经过上一步的筛选，此时剩下的只是对象类型,由于对象类型无法通过typeof直接区分，所以可以借用原始对象原型方法 <code>Object.prototype.toString.call(obj)</code> 来进行<strong>对象具体类型</strong>的判断</li>
<li>toString判断的结果会以’[object xxx]’，xxx为对应对象类型形式体现，基于这种转换可以清晰判断对象的具体类型，之后再对各种类型进行相应的深拷贝即可</li>
<li>以上并未使用递归，由于上述的拷贝，还未涉及多层次的嵌套关系并不需要使用递归</li>
<li>接下来将要判断<strong>嵌套类型</strong>数据，(此顺序可变，不过出现频率高的尽量放在前头)首先判断普通对象和数组，如果是，则直接扔给递归处理，由于处理数组和普通对象的逻辑已经在这之前处理好了，现在只需重复上面的步骤，所以直接<strong>递归调用</strong>就好，递归到最后一层，应该是原始类型的数据，不会进入无限调用</li>
<li>接下来是判断2种<strong>特殊类型</strong>Set和Map，由于这2种类型的拷贝方式不同，进一步通过if分支对其判断，遍历里边所存放的值，Set使用add方法向新的拷贝容器添加与拷贝对象相同的值，此处值的拷贝也应该使用深拷贝，即直接把值丢给递归函数，它就会返回一个拷贝好的值。Map类似，调用set方法设置键和值，不过正好Map的键可以存放各种类型</li>
<li>到了拷贝Symbol环节，这个类型相对特殊一点，Symbol的值是唯一的，所以要获取原Symbol所对应的Symbol值，则必须通过借用Symbol的原型方法来指明要获取Symbol所对应Symbol的原始值，基于原始值创建一个包装器对象，则这个对象的值与原来相同</li>
<li>筛选到这里，剩余的对象，基本上就是一些内置对象或者是不需要递归遍历属性的对象，那么就可以基于这些对象<strong>原型的构造函数</strong>来实例化相应的对象</li>
<li>最后遍历完所有的属性就可以返回这个拷贝后的新容器对象，作为拷贝对象的替代</li>
<li>基于循环引用对象的解析，由于循环引用对象会造成循环递归导致调用栈溢出，所以要考虑到一个对象不能被多次拷贝。基于这个条件可以使用Map对象来保存一个拷贝对应的表，因为Map的键的特殊效果可以保存对象，因此正好适用于对拷贝对象的记录，且值则是对应的新拷贝容器，当下次递归进来的时候先在拷贝表里查询这个键是否存在，如果存在说明已经拷贝过，则直接返回之前拷贝的结果，反之继续</li>
<li>由于Map存放的键属于<strong>强引用类型</strong>，且深拷贝的数据量也不小，如果这些拷贝后的拷贝表不及时释放可能会造成垃圾堆积影响性能，因此需要使用到<strong>weakMap方法代替Map</strong>，weakMap存放的键为<strong>弱引用类型</strong>，且<strong>键必须为对象类型</strong>，正好之前的newObj就是对象类型可以存放，使用弱引用的好处，可以优化垃圾回收，weakMap存放的是拷贝表，此拷贝表在拷贝完成之后就没有作用了，之前存放的拷贝对象，经过深拷贝给新拷贝容器，则这些旧对象在销毁之后，对应于拷贝表里的对象也应该随之清除，不应该还保留，这就是使用弱引用来保存表的原因。</li>
</ol>
<p>以上就是本人在实现过程中的思路，可能讲的比较啰嗦，但是我还是希望使用通俗的话让各位明白，表达能力有限，望谅解。</p>
<p>接下来让我们看看WeakMap的好处</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    age: [&#123;</span><br><span class="line">      who: <span class="string">'me'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">deepClonePlus(obj, wm)</span><br><span class="line">obj=<span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.dir(wm) <span class="comment">// No properties 即为空</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出如果原拷贝对象被清空那么WeakMap保存的拷贝表也将被清空，总的来说方便一点，总比麻烦一点好</p>
<p>看看这种情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    age: [&#123;</span><br><span class="line">      who: <span class="string">'me'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'start'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  deepClonePlus(obj, wm) <span class="comment">// wm为手动传入的weakmap</span></span><br><span class="line">  <span class="comment">// 此处为了与下面对比，这里故意重置weakmap存储的拷贝值</span></span><br><span class="line">  wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'start'</span>) <span class="comment">// 耗时2645ms</span></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">let</span> m</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'start'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  deepClonePlus(obj, wm)</span><br><span class="line">  <span class="comment">// 此次为对照组，也执行创建WeakMap但是不重置之前拷贝的wm</span></span><br><span class="line">  m = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'start'</span>) <span class="comment">// 耗时73ms</span></span><br></pre></td></tr></table></figure>

<p>从以上对比可以看出如果是多次拷贝同一对象，最好使用WeakMap来存储拷贝表，那么之后的每次拷贝只需从拷贝表中取出值即可，由于是浅拷贝所以时间较短(<strong>注意：不过这种直接从WeakMap中取出的值属于浅拷贝，使用同一个wm对象拷贝出来的都是浅拷贝，如果每个都需要深拷贝那么只能每次重新创建WeakMap</strong>)</p>
<h2 id="三、原型与原型链"><a href="#三、原型与原型链" class="headerlink" title="三、原型与原型链"></a>三、原型与原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>只有对象类型才有原型概念</li>
<li>普通对象(即使用对象字面量或者Object构造器创建的对象)的原型为<code>__proto__</code>属性，此属性其实是个访问器属性，并不是真实存在的属性，或者可以使用es6的<code>Reflect.getPrototypeOf(obj)</code>和<code>Object.getPrototypeOf(obj)</code>方法获取对象的原型，其关系<code>Reflect.getPrototypeOf({}) === Object.getPrototypeOf({}) === {}.__proto__</code></li>
<li>普通函数有2个属性，一个是是<code>__proto__</code>(与普通对象类似)，还有一个是函数专有的<code>prototype</code>属性，因为函数有双重身份，即可以是实例也可以是构造器，所以关系比较特殊</li>
<li>不是所有的对象都会有原型，比如对象原型<code>Object.prototype</code>的原型<code>Object.prototype.__proto__</code>就指向null，字典对象的原型也为null(把对象的<code>__proto__</code>设置为null，或者使用<code>Object.create(null)</code>创建一个没有原型的字典对象，但是这个对象还是属于对象类型)，所以原始对象原型(Object.prototype)就是最原始的原型，其他对象类型都要继承自它。</li>
<li>箭头函数虽然属于函数，由Function产生，但是没有prototype属性没有构造器特性，所以也就没有所谓的constructor，就不能作为构造器使用</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>这里会详细介绍原型、原型链、实例、构造器的关系 先看最原始的关系</p>
<p><img src="../images/1719d5011fdf60d7.png" alt="img"></p>
<p>由如上关系可以验证<code>console.log(Function.prototype.__proto__.constructor.__proto__.constructor === Function) //true</code></p>
<ul>
<li>所有函数都是由Function函数构造器实例化而来</li>
<li>所有实例的原型都指向构造它的构造器的prototype</li>
<li>每个构造器自身特有的方法就是<strong>静态方法</strong>，原型上的方法可供所有继承它或间接继承它的实例使用</li>
<li>构造器也是函数，也是被Function实例化出来的，所以构造器的<code>__proto__</code>就是Function，但是构造器的prototype属性指向的原型，是此构造器实例化出来的实例所指向的原型；简单说构造器的prototype就是作为它的实例的原型</li>
</ul>
<p>看看函数的原型链</p>
<img src="../images/1719d5061a3d5f66.png" alt="img" style="zoom:200%;" />

<ul>
<li>在js中函数有多重身份，函数可以作为类就是构造器使用，定义静态方法，作为普通函数调用，</li>
<li>只有由原始函数构造器(Function)实例化的函数才拥有直接使用函数原型(Function.prototype)上面的内置方法，创建函数只能通过原始函数构造器生成，</li>
<li>普通函数作为构造器使用(new)时相当于类(class)使用，类的prototype就是实例的原型，我们可以给原型添加属性，给类添加属性时就相当于给构造器添加静态属性</li>
<li>普通函数在创建实例的时候，会生成一个实例的原型，此原型指向Object.prototype即原始对象原型，也就是继承对象原型，这么一来实例也继承了对象的原型，则实例也属于对象类型</li>
</ul>
<h2 id="四、继承与实现"><a href="#四、继承与实现" class="headerlink" title="四、继承与实现"></a>四、继承与实现</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>所谓继承一般说的是原型继承，一个原型上面定义的方法一般都是基于其实例的用途来定义的，也就是说，原型的方法应该是实例经常用到的通用方法，而构造器方法一般是特定情况下可能会用到的方法，可按需调用，原型方法只能供其实例来使用</li>
<li>继承可以让原型链丰富，根据需求定制不同的原型链，不会存在内存浪费的情况，原型只会保留一份，用到的时候调用就行，还能节省空间</li>
</ul>
<img src="../images/1719d50d1a53785a.png" alt="img" style="zoom:200%;" />

<ul>
<li>可以看出原型一般是一些共有的特性，实例是特有的特性，继承的越多越具体，原型链的最顶端是最抽象的，越底端越具体，这样一来我们可以根据需求在恰当位置继承来实现个性化的定制属性，统一而又有多样化</li>
</ul>
<h3 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h3><ul>
<li>通过es6的extends关键字来继承原型</li>
<li>手动实现原型继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//貌似这个方法就能实现原型继承，不过由于使用__proto__访问器是不推荐的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.v = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vv = v</span><br><span class="line">&#125;</span><br><span class="line">boo.prototype.__proto__ = foo.prototype</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> boo(<span class="number">3</span>)</span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="comment">//采用这种方式可以实现原型的继承，也是直接修改原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.v = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vv = v</span><br><span class="line">&#125;</span><br><span class="line">boo.prototype = <span class="built_in">Object</span>.create(foo.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: boo,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> boo(<span class="number">3</span>)</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment">//借助一个空构造器来实现原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.v = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vv = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">o.prototype = foo.prototype</span><br><span class="line">boo.prototype = <span class="keyword">new</span> o()</span><br><span class="line">boo.prototype.constructor = boo</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> boo(<span class="number">3</span>)</span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="comment">//class的extends会将子类的__proto__设置为父类</span></span><br><span class="line">如果实现类似extends的继承还需加上</span><br><span class="line">boo.__proto__ = foo</span><br></pre></td></tr></table></figure>

<p>实现构造器原型的继承，无非就是父构造器原型赋值给子构造器原型的原型，还有需要保证子构造器原型不能含有父构造器的属性</p>
<h2 id="五、实现class与extends"><a href="#五、实现class与extends" class="headerlink" title="五、实现class与extends"></a>五、实现class与extends</h2><h3 id="实现class"><a href="#实现class" class="headerlink" title="实现class"></a>实现class</h3><ul>
<li>es6加入的class其实是为了开发者方便创建类，与其他语言在写法上尽量一致，但是js原生并没有类这个东西，为了实现类的效果，可以通过js的构造器来实现，class使用new关键字生成实例，构造器也是通过new来实例化，那么可以推断class本质也是个构造器</li>
<li>手动实现class</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Class = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加原型方法</span></span><br><span class="line">  Constructor.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'原型方法getName:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加原型属性</span></span><br><span class="line">  Constructor.prototype.age = <span class="string">'原型属性age'</span></span><br><span class="line">  <span class="comment">//添加静态方法</span></span><br><span class="line">  Constructor.log = <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是构造器的静态方法log'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加静态属性</span></span><br><span class="line">  Constructor.isWho = <span class="string">'构造器静态属性isWho'</span></span><br><span class="line">  <span class="keyword">return</span> Constructor</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> i = <span class="keyword">new</span> Class(<span class="string">'我是实例'</span>)</span><br></pre></td></tr></table></figure>

<p>实现class语法糖，只需封装一层函数。</p>
<ul>
<li>返回的Constructor就是实例的构造器，其prototype是个空白的对象这是由于Function造成的</li>
<li>new后面调用的函数必须是一个构造器函数，用于构造实例，此构造器的this指向实例</li>
<li>构造器内部需要实现依照传入的参数设置实例的属性</li>
<li>定义Class时需要实现原型属性和静态属性的挂载</li>
</ul>
<p>以上只实现class的定义，接下来要实现能够兼容继承的写法</p>
<h3 id="实现extends"><a href="#实现extends" class="headerlink" title="实现extends"></a>实现extends</h3><ul>
<li>继承需要满足原型的继承</li>
<li>还需要满足可调用父类构造器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">const</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  Constructor.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Constructor</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">const</span> Class = (<span class="function"><span class="keyword">function</span> (<span class="params">_Parent = null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_Parent) &#123;</span><br><span class="line">    Constructor.prototype = <span class="built_in">Object</span>.create(_Parent.prototype, &#123;</span><br><span class="line">      <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Constructor,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    Constructor.__proto__ = _Parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    _Parent ? _Parent.call(<span class="keyword">this</span>, age) : <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  Constructor.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Constructor</span><br><span class="line">&#125;)(Parent)</span><br></pre></td></tr></table></figure>

<ul>
<li>实现原型继承，可以使用之前的继承写法，注意class形式的继承，会把父类设为子类的<code>__proto__</code></li>
<li>在构造函数内判断是否有父类，如果有就要调用父类的构造函数，把当前的this传入，这样才能生成父类构造器中定义的属性，这才算是真正的继承。继承不单继承原型还能实现继承父类构造器中定义的属性</li>
<li>对于原型方法和静态方法也是类似定义，注意定义的方法如果用到this需要使用function关键字定义函数，不可使用匿名函数，否则this无法指向调用对象本身</li>
</ul>
<h2 id="六、作用域、执行上下文与闭包"><a href="#六、作用域、执行上下文与闭包" class="headerlink" title="六、作用域、执行上下文与闭包"></a>六、作用域、执行上下文与闭包</h2><h3 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>所有未定义的变量直接赋值会自动声明为全局作用域的变量(隐式全局变量可以用delete删除，var定义的则不行)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span> <span class="comment">// 隐式全局变量 严格模式报错</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="number">2</span> <span class="comment">// 显式全局变量</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b) <span class="comment">//1 2</span></span><br><span class="line"><span class="keyword">delete</span> a  <span class="comment">// 严格模式报错</span></span><br><span class="line"><span class="keyword">delete</span> b  <span class="comment">// 严格模式报错</span></span><br><span class="line"><span class="built_in">console</span>.log(b,a) <span class="comment">// 2   a is not defined</span></span><br></pre></td></tr></table></figure>

<p>window对象的所有属性拥有全局作用域</p>
<p>内层作用域可以访问外层作用域，反之不行</p>
<p>var声明的变量，在除了函数作用域之外，在其他块语句中不会创建独立作用域</p>
<p>let和const声明的变量存在块语句作用域，且不会变量提升</p>
<p>同作用域下不能重复使用let、const声明同名变量，var可以，后者覆盖前者</p>
<p>for循环的条件语句的作用域与其循环体的作用域不同，条件语句块属于循环体的父级作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下语句使用let声明不报错，说明为不同作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment">// 此语句报错，说明循环体为条件语句块的子作用域</span></span><br><span class="line"><span class="comment">// for循环执行顺序为：条件语句块1-&gt;条件语句块2-&gt;循环体-&gt;条件语句块3-&gt;条件语句块2 依次类推</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i=x) &#123; <span class="comment">// x is not defined</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ul>
<li>作用域链也就是所谓的变量查找的范围</li>
<li>在当前作用域引用变量时，如果没有此变量，则会一路往父级作用域查找此变量，直到全局作用域，如果都没有，在非严格情况下会自动声明，所以是undefined，在严格条件下则会报错</li>
<li>变量的查找路径依据的是在创建这个作用域的地方向上查找，并非是在执行时的作用域，如下 b变量的值为2。可以看出当执行到需要b变量时，当前作用域下并没有b，所以要到定义这个b变量的静态作用域中寻找，即创建时候的作用域链上查找b的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义b，找到</span></span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用到b，当前作用域并没有，向上找</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = a()</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">s() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>作用域在脚本解析阶段就已经规定好了，所以与执行阶段无关，且无法改变</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul>
<li>执行上下文在运行时确定，随时可能改变</li>
<li>调用栈中存放多个执行上下文，按照后进先出的规则进行创建和销毁，最底部的执行上下文，也就是栈低的执行上下文为全局上下文，最早被压入栈中，其上下文中的this指向window，严格模式下为undefined</li>
<li>创建执行上下文时，会绑定当前this，确定词法环境，存储当前环境下函数声明内容，变量let与const绑定但未关联任何值，确认变量环境时，绑定var的初始值为undefined</li>
<li>在var声明之前，调用var声明的变量时值为undefined，因为创建了执行上下文，var声明的变量已经绑定初始undefined，而在let和const声明之前调用其声明的变量时，由于只绑定在了执行上下文中，但并未初始任何值，所以在声明之前调用则会抛出引用错误(即TDZ暂时性死区)，这也就是函数声明与var声明在执行上下文中的提升</li>
</ul>
<p>这里了解一下函数、变量提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(foo) <span class="comment">// foo()&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">5</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console.dir(foo) // undefined</span></span><br><span class="line"><span class="comment">var foo = 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">------------------------------</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.dir(foo) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>从以上代码结果可以得出结论：</p>
<ul>
<li>上面代码块能够体现，在解析阶段会将函数与变量提升，且函数的优先级比var声明的变量高，因为打印的是函数声明，如果var声明的优先级高，那么应该是undefined</li>
<li>从下面的代码块中可以看出foo在代码执行的时候被赋值为5，而函数声明在解析阶段已经结束，在执行阶段没有效果</li>
<li>还有一点 个人认为在解析阶段，函数声明与变量声明提升之后在代码块中的位置顺序没什么关系</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>所谓闭包就是函数与其词法环境(创建当前作用时的任何局部变量)的引用。闭包可以使内部函数访问到外部函数的作用域，当函数被创建时即生成闭包</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'hi'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line">fn1()() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>当你从函数内部返回一个内部函数时，返回的函数将会保留当前闭包，即当前词法环境</p>
<p>闭包只会保留环境中任何变量的最后一个值，这是因为闭包所保存的是整个变量的对象</p>
<p>闭包的作用域链包含着它自己的作用域，以及包含它父级函数的作用域和全局作用域</p>
<p>当返回一个闭包时，保留此闭包下的所有被外部引用的对象</p>
<p>闭包之间是独立的，在闭包环境下可以创建多个不同的闭包环境暴露给外部，从而实现不同的效果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>暴露闭包的方式不止返回内部函数一种，还可以使用回调函数产生闭包环境，或者把内部函数赋值给其他外部对象使用</li>
<li>闭包在没有被外部使用的情况下，随执行结束销毁，如何产生闭包并且保留闭包环境的关键就在于不让其环境被垃圾回收系统自动清除，那么就要使内部环境中的引用被外部保留，这样才能保留闭包</li>
<li>闭包虽然方便我们操作和保留内部环境，但是闭包在处理速度和内存消耗方面对脚本性能具有负面影响，除非在特定的情况下使用</li>
</ul>
<p>这里看个有趣的东西</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a=&#123;<span class="attr">name</span>:<span class="string">'me'</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> b=&#123;<span class="attr">who</span>:<span class="string">'isMe'</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> wm=<span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)  <span class="comment">// a被闭包保留</span></span><br><span class="line">    wm.set(b,<span class="number">1</span>) <span class="comment">// 弱引用b对象</span></span><br><span class="line">    <span class="keyword">return</span> wm <span class="comment">//wm被闭包保留</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wm=foo()()</span><br><span class="line"><span class="built_in">console</span>.dir(wm) <span class="comment">// No properties 即为空</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a=&#123;<span class="attr">name</span>:<span class="string">'me'</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> wm=<span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    wm.set(a,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> wm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wm=foo()()</span><br><span class="line"><span class="built_in">console</span>.dir(wm) <span class="comment">// 保存了对象a与其值1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从上块代码中可以看出，bar被return到外部环境，所以其内部形成闭包，bar中使用到的变量(a,wm)都会被保留下来，但是最后打印wm的时候为空？这是因为外部并没有引用到b对象，只是通过wm弱引用保存b的值，从wm为空可以看出，闭包内部的b被清除，所以wm也自动清除b的弱引用，可以论证之前所说，闭包只保留外部用到的变量</li>
<li>从下块代码能直接看出a就是闭包中的a，bar在外部执行时需要用到a与wm所以保留了下来</li>
<li>有人可能会不解，为什么上块代码中的b也被wm.set(b,1)引用，但是最终就没有呢，那是因为WeakMap中保留的是b的弱引用，可以理解为，wm中的b是依赖原函数中的b而存在，当wm被return时，闭包中的b，没有被任何外部所依赖，而是别人依赖它。可以这么理解 b牵着别人走，因为b没有被外面人牵着走，所以b这个链子就被断开，也影响到b牵的人一块丢了</li>
</ul>
<h2 id="七、this"><a href="#七、this" class="headerlink" title="七、this"></a>七、this</h2><p>先看一张图</p>
<img src="../images/1719d51548402b0f.png" alt="img" style="zoom:200%;" />

<p>this的绑定在创建执行上下文时确定</p>
<p>大多数情况函数调用的方式决定this的值，this在执行时无法赋值</p>
<p>this的值为当前执行的环境对象，非严格下总是指向一个对象，严格下可以是任意值</p>
<p>全局环境下this始终指向window，严格模式下函数的调用没有明确调用对象的情况下，函数内部this指向undefined，非严格下指向window</p>
<p>箭头函数的this永远指向创建当前词法环境时的this</p>
<p>作为构造函数时，函数中的this指向实例对象</p>
<p>this的绑定只受最靠近调用它的成员的引用</p>
<p>执行上下文在被执行的时候才会创建，创建执行上下文时才会绑定this，所以this的指向永远是在执行时确定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下undefined</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//非严格Number对象，严格模式 5</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>严格与非严格模式下的this指向是不同的，非严格总是指向一个对象，严格模式可以为任意值</p>
<img src="../images/1719d51c276f0ae3.png" alt="img" style="zoom:200%;" />

<p>执行后</p>
<img src="../images/1719d51da155695f.png" alt="img" style="zoom:200%;" />

<p>以上2图可以使用chrome开发工具来进行查看程序执行时的相关数据，可以看到严格模式下简单调用的函数内部的this指向undefined</p>
<h3 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h3><h4 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h4><p>在没有明确调用者情况下函数内部this指向window，严格模式下都为undefined，除非绑定函数的this指向，才会改变this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  boo()</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 取出对象中的函数，再进行调用</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = obj.foo</span><br><span class="line">foo()()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 直接通过对象调用函数，再调用返回的函数，可以看出this的指向随调用对象改变</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//obj,严格下 obj</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = obj.foo()</span><br><span class="line">foo()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 基于回调函数也是如此</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="基于调用者以及不同调用方式"><a href="#基于调用者以及不同调用方式" class="headerlink" title="基于调用者以及不同调用方式"></a>基于调用者以及不同调用方式</h4><p>函数调用也就是在函数名后面加个()，表示调用，如果函数名前没有加任何东西，那么默认为<strong>简单调用</strong>，在严格与非严格环境下，简单调用的函数内部this指向undefined与window，但是全局环境下的this永远为window</p>
<p>基于对象</p>
<p>当函数作为<strong>对象的方法</strong>调用时，不受函数定义方式或者位置影响</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数this指向调用者对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// obj1,严格下 obj1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window,严格下 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    boo()</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">obj1.boo = obj.foo</span><br><span class="line">obj1.boo()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 不同调用对象时，this指向调用者</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// obj,严格下 obj</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    boo() <span class="comment">// window,严格下 undefined</span></span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">obj1.boo = obj.foo()</span><br><span class="line">obj1.boo() <span class="comment">// obj1,严格下 obj1</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// this指向最近的调用者</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  obj1: &#123;</span><br><span class="line">    name: <span class="string">'obj1'</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>.name) <span class="comment">// obj1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.obj1.foo()</span><br></pre></td></tr></table></figure>

<p>基于new关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于new关键字调用的函数内部this指向实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// foo实例</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> foo) <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo.prototype.isPrototypeOf(<span class="keyword">this</span>)) <span class="comment">//true</span></span><br><span class="line">  that = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> that</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> foo()</span><br><span class="line"><span class="built_in">console</span>.log(that === f) <span class="comment">// true</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 嵌套函数内部this与调用函数所在环境的this无关</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// foo实例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window,严格下undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  boo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> foo()</span><br></pre></td></tr></table></figure>

<p>基于定时器与微任务</p>
<p>微任务中的简单调用的函数this指向window严格下指向undefined，而<strong>定时器中的回调函数不管在严格还是非严格环境下this永远指向window</strong>，说明一点，调用window对象的方法时this指向window也就是全局对象，换句话说，简单调用的函数如果属于window本身自带的方法那么这个方法的this指向window</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步任务中简单调用的函数都是进入队列，最后由全局环境调用</span></span><br><span class="line"><span class="keyword">const</span> id = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 window</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 window</span></span><br><span class="line">    clearInterval(id)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">&#125;);</span><br><span class="line">----------------------------------------------</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> boo()</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// window ,严格下 undefined</span></span><br><span class="line">&#125;)()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 定时器的回调最终都会被作为简单函数被执行，定时器属于window对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//window ,严格下window</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">foo.call(<span class="number">5</span>)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 函数内部的this就是指向调用者，并且可以看出简单调用的回调函数中的this也指向window</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo(callback) &#123;</span><br><span class="line">    callback()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo === obj.foo) <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj) <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//window ,严格下undefined</span></span><br><span class="line">&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 通过arguments调用的回调函数中的this指向调用者，注意严格与非严格下的arguments对象有所不同</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo(callback) &#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo === obj.foo) <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj) <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//arguments对象 ，严格下 arguments对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>es6引入的箭头函数，是不具有this绑定，不过在其函数体中可以使用this，而这个this指向的是箭头函数当前所处的词法环境中的this对象，可以理解为，this在箭头函数中是透明的，箭头函数包不住this，所以函数内部与外部的this为同一值</p>
<ul>
<li>判断箭头函数的this指向，我们可以把箭头函数看成透明，其上下文中的this就是它的this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看出箭头函数中的this就是其所在环境的this，箭头函数无法固定this，由其环境决定</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window ,严格下还是window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 可见对象中的this指向window，箭头函数中的this指向对象中的this。由于只有创建执行上下文才会绑定this指向，而除了全局上下文，只有函数作用域才会创建上下文环境从而绑定this，创建对象不会绑定this，所以还是全局this</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  <span class="keyword">this</span>:<span class="keyword">this</span>,</span><br><span class="line">  foo:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//window ，严格下 window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.dir(obj.this) <span class="comment">//window ，严格下 window</span></span><br><span class="line">obj.foo()</span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="comment">// 对象方法内部嵌套箭头函数，则此箭头函数的this属于外部非箭头函数this。当调用obj.foo时foo函数创建的执行上下文中的this绑定对象obj，而箭头函数并不会绑定this，所以其this属于foo下的this，即对象obj</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">//obj ，严格下 obj</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()()</span><br></pre></td></tr></table></figure>

<h3 id="如何改变函数的this指向"><a href="#如何改变函数的this指向" class="headerlink" title="如何改变函数的this指向"></a>如何改变函数的this指向</h3><p>最简单的方法通过apply、call、bind来给函数绑定this</p>
<ul>
<li>apply方法中第一个参数为被调用的函数中的this指向，传入你想要绑定的this值即可，第二个参数为被调用函数的参数集合，通常是个数组</li>
<li>call与apply方法基本一致，区别在于传入参数形式不同，call传入的参数为可变参数列表，参数按逐个传入</li>
<li>bind方法与以上不同的是不会直接调用函数，只是先绑定函数的this，到要使用的时候调用即可，此方法返回一个绑定this与参数之后的新函数，其传入参数形式同call</li>
<li>通过变量保留指定this来达到固定this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过变量保留父级this，进行对_this变量修改也就达到修改原this的效果</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      _this.name = <span class="string">'OBJ'</span></span><br><span class="line">      <span class="built_in">console</span>.dir(obj.name) <span class="comment">// OBJ</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()()</span><br></pre></td></tr></table></figure>

<h2 id="八、apply、call、bind实现"><a href="#八、apply、call、bind实现" class="headerlink" title="八、apply、call、bind实现"></a>八、apply、call、bind实现</h2><p>这3者的实现其实差不多，bind实现可能会有点不一样，都要实现this的改变</p>
<h3 id="手动实现apply"><a href="#手动实现apply" class="headerlink" title="手动实现apply"></a>手动实现apply</h3><ul>
<li>思路就是想办法使函数被传入的thisArg调用，那么函数的this就指向调用者</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.Apply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, args = Symbol.for(<span class="string">'args'</span></span>)) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>)            <span class="comment">//this为这个方法的调用者=&gt;foo函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>)      <span class="comment">//生成一个不重复的键</span></span><br><span class="line">  thisArg[fn] = <span class="keyword">this</span> || <span class="built_in">window</span> <span class="comment">//把foo函数作为传入this的一个方法</span></span><br><span class="line">  args === <span class="built_in">Symbol</span>.for(<span class="string">'args'</span>) </span><br><span class="line">  ? thisArg[fn]()</span><br><span class="line">  : thisArg[fn](...args)       <span class="comment">//调用这方法，传参</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]           <span class="comment">//使用完删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">age,height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) <span class="comment">// obj</span></span><br><span class="line">  <span class="built_in">console</span>.log(age)       <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(height)    <span class="comment">// null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  age: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo.Apply(obj,[obj.age,<span class="literal">null</span>])</span><br></pre></td></tr></table></figure>

<h3 id="手动实现call"><a href="#手动实现call" class="headerlink" title="手动实现call"></a>手动实现call</h3><p>基本思路同apply，就是传参形式改变一下,这里通过arguments获取参数列表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.Call = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>)            <span class="comment">//this为这个方法的调用者=&gt;foo函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>)      <span class="comment">//生成一个不重复的键</span></span><br><span class="line">  thisArg[fn] = <span class="keyword">this</span> || <span class="built_in">window</span> <span class="comment">//把foo函数作为传入this的一个方法</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">  args.length ? thisArg[fn](...args) : thisArg[fn]()  <span class="comment">//调用这方法，传参</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]           <span class="comment">//使用完删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动实现bind"><a href="#手动实现bind" class="headerlink" title="手动实现bind"></a>手动实现bind</h3><p>bind函数要能够返回严格绑定this与参数后的函数，调用这个返回的函数时有可能还会传入参数，那么需要拼接参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.Bind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>)       <span class="comment">//生成一个不重复的键</span></span><br><span class="line">  thisArg[fn] = <span class="keyword">this</span> || <span class="built_in">window</span>  <span class="comment">//把foo函数作为传入this的一个方法</span></span><br><span class="line">  <span class="keyword">const</span> f = thisArg[fn]         <span class="comment">// 负责一份函数</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn]            <span class="comment">//删除原来对象上的函数，但是保留了this指向</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arg = args.concat(...arguments)</span><br><span class="line">    f(...arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">age, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)       <span class="comment">// obj</span></span><br><span class="line">  <span class="built_in">console</span>.log(age)             <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(height)          <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  age: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo.Bind(obj, obj.age)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="九、同步与异步"><a href="#九、同步与异步" class="headerlink" title="九、同步与异步"></a>九、同步与异步</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul>
<li>基于js的单线程同时只能处理一件事情，而同步即是在主线程上排队执行的任务，只有当前任务执行完成，才会进入下一个任务。同步执行的函数会在预期得到结果，也就是可以清楚什么时候能得到返回值</li>
<li>所有同步代码只会进入调用栈，同步代码会阻塞主线程的执行，而且会优先与其他非同步代码执行</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul>
<li>异步是指当前执行的代码会进入异步线程处理之后才会再由主线程处理回调</li>
<li>异步的结果不是马上能够得到，而是会在将来的某个时间点获取到</li>
<li>通常异步代码所要经过的步骤比同步代码多，由于异步代码不是直接放在调用栈中执行，而是要派发(可能不需要)给其他线程处理，等处理完成后的回调放在某个地方存储(比如任务队列)，等到同步队列执行完成之后才会取回异步回调代码进行执行</li>
</ul>
<h4 id="异步、单线程与EventLoop"><a href="#异步、单线程与EventLoop" class="headerlink" title="异步、单线程与EventLoop"></a>异步、单线程与EventLoop</h4><p>先看一张图，有个大体架构</p>
<img src="../images/1719d5330a5a1b7f.png" alt="img" style="zoom:200%;" />

<ul>
<li>js主线程处理当前正在执行的代码，它会执行当前调用栈栈顶的执行上下文，从堆空间(一般是存储对象)和栈空间(一般存储非对象值以及对象引用)取数据，进而处理当前调用栈所用到的数据</li>
<li>所有的同步代码会按照代码顺序压入调用栈中等待主线程执行，如果代码中遇到了异步代码，则会根据异步类型抛给异步线程执行</li>
<li>异步类型，主要分为微任务与宏任务</li>
<li>任务队列其实本质就是一块内存空间，里面的任务是依据FIFO先进先出的规则来执行，所有异步代码执行完毕的回调都是加入到异步任务队列中等待主线程的调用</li>
<li>异步可以提高cpu的利用率</li>
</ul>
<h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><ul>
<li>微任务队列与宏任务队列的区别就在于，主线程对于其中的任务调度的区别，主进程会优先执行微任务队列中的全部任务，当微任务中的全部任务执行完毕才会进而转到宏任务执行</li>
<li>微任务可以由这些方法关键字调用产生Promise、async、await、MutaionObserver、process.nextTick(Node.js环境）</li>
<li>如果调用微任务方法时，方法内部包含其他线程干预处理时，会抛给指定线程执行，而主线程继续执行下面的代码，等到其他线程处理完成之后，如果有回调函数则会把回调加入到指定异步类型(这里为微任务队列)的队列中排队等待主线程执行</li>
<li>微任务与宏任务的主要区别在于，主线程优先执行全部微任务，待执行完成之后才会挨个执行宏任务</li>
</ul>
<h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><ul>
<li>一般的宏任务队列存放的是WebApis的回调，WebApis中包含许多线程，GUI渲染线程(与js主线程互斥不能同时执行)、事件触发线程、定时器线程、异步网络请求线程</li>
<li>宏任务存放由异步WebApis产生的回调函数，但优先级低于微任务</li>
</ul>
<h5 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h5><ul>
<li>js单线程设计之初就是为了简化代码，解决DOM冲突，如果js为多线程语言，那么有可能产生多个线程同时操作DOM的情况，那么将会导致js操作同个DOM引起冲突，介于多线程的锁机制来解决冲突，但又使得js的代码复杂度提高</li>
<li>基于js单线程的设计，进而引出异步执行的方式，使得js具有类似多线程程的效果，但不管异步还是同步，js永远都只有一个线程在执行</li>
</ul>
<h5 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h5><ul>
<li>事件循环机制是针对于主线程的调度方式</li>
<li>可以理解为主线程在寻找任务执行的过程就是事件循环，其寻找方式就是调用机制</li>
<li>先了解一下浏览器是如何执行js代码的<ul>
<li>通常浏览器在最开始运行js代码的入口就是html中的script标签所涵盖的代码</li>
<li>当GUI渲染线程解析到script标签，则会把标签所涵盖的js代码加入到宏任务队列中</li>
<li>首先js引擎(如V8引擎)先取第一个宏任务，即script的代码块，然后主线程在调用栈中解析js代码</li>
<li>等所有代码解析完成之后开始运行js代码</li>
<li>如果遇到同步代码直接执行</li>
<li>遇到异步代码，如果是宏任务类型即异步WebApis处理的异步代码，那么将会通知WebApis在对应的线程中处理异步任务，此时js主线程继续执行下面的代码，在其他线程处理完毕之后如果有回调函数，则异步线程会将回调函数加入到宏任务队列尾部，</li>
<li>如果是微任务类型的异步代码，也同宏任务处理，只不过是把回调函数加入到微任务队列中，其执行的优先级高于宏任务队列</li>
<li>当同步代码全部执行完成，主线程将会一直检测任务队列，如果有异步微任务则执行完全部的微任务</li>
<li>进一步执行浏览器渲染进程绘制页面，之后就是开始下一轮的事件循环，就又回到取宏任务执行</li>
<li>这里注意，所有的微任务都是由宏任务中执行的代码产生，一开始只有宏任务队列有任务</li>
</ul>
</li>
</ul>
<p>以下展示的是事件循环大致流程</p>
<p><img src="../images/1719d53968ef6d36.png" alt="img"></p>
<p>以下为主线程判断逻辑</p>
<img src="../images/image-20200424115518421.png" alt="image-20200424115518421" style="zoom:50%;" />

<h3 id="前端异步的场景"><a href="#前端异步的场景" class="headerlink" title="前端异步的场景"></a>前端异步的场景</h3><ul>
<li>前端异步主要用于代码可能会发生等待，而且等待过程不能阻塞主线程运行的情况</li>
<li>通常WebApis接口都是异步调用的，由于需要其他线程的处理，就需要等待其返回结果，那么js主线程就没必要一直等待，这样就需要使用异步来进行处理</li>
<li>比如定时器任务setTimeout、setInterval、ajax请求、图片动态加载、DOM事件触发这些都属于浏览器执行的异步任务；如js中的Promise、async、await属于js语言自身的异步操作这些都可以实现异步</li>
<li>当需要动态加载图片的时候就需要用到异步；当需要执行的js的同步代码需要长时间占用的主线程时可以使用异步方式拆分为多个步骤执行，这样可以避免浏览器页面长时间无响应或者卡顿</li>
<li>当需要执行很长一段时间才能得到结果的代码时也可以使用html5中的Web worker在浏览器渲染进程下新开一个线程用来专门执行此代码，通过postMessage来返回运行结果这样也不会占用js主线程，但是这个线程无法操作DOM和BOM</li>
</ul>
<h3 id="WebWorker多线程"><a href="#WebWorker多线程" class="headerlink" title="WebWorker多线程"></a>WebWorker多线程</h3><ul>
<li>基于js单线程的局限性，如果执行一个很耗时间的函数，那么主线程将会被长时间占用，因此导致事件循环暂停，使得浏览器无法及时渲染和响应，那么将会造成页面崩溃，用户体验下降，所以html5支持了webworker</li>
<li>webwork简单理解就是可以让特定的js代码在其他线程中执行，等执行结束后返回结果给主线程接收即可</li>
<li>比如在js中需要实现一个识别图片的算法，而且此算法需要很长的计算时间，如果让js主线程来执行将会导致上述发生的事情，那么正好可以使用webwork技术来实现。</li>
<li>创建一个webworker文件，其中写入算法代码，在最后调用postMessage(result)方法返回结果给主线程，js主代码中通过w=new Worker(文件路径)来创建一个渲染进程的webworker子线程实例，通过w.onmessage=function(e){console.log(e.data)}给其添加一个事件监听器，当webworker中传递消息给js主线程时会在此回调函数中执行，通过调用w.terminate()终止webworker线程</li>
<li>webworker线程与js主线程最大的区别就在于webworker线程无法操作window与document对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.html(主线程)</span></span><br><span class="line"><span class="keyword">const</span> w= <span class="keyword">new</span> Worker(<span class="string">'postMessage.js'</span>)</span><br><span class="line">w.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;</span><br><span class="line">w.postMessage(<span class="string">'b'</span>) <span class="comment">// b is cat</span></span><br><span class="line">w.terminate() <span class="comment">// 手动关闭子线程</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// postMessage.js(worker线程)</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">this</span>.postMessage(e.data+<span class="string">' is tom'</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>: <span class="keyword">this</span>.postMessage(e.data + <span class="string">' is cat'</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:  <span class="keyword">this</span>.postMessage(e.data + <span class="string">" i don't know"</span>)</span><br><span class="line">    <span class="keyword">this</span>.close() <span class="comment">// 自身关闭</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="十、AMD、CMD、CommonJS与ES6模块化"><a href="#十、AMD、CMD、CommonJS与ES6模块化" class="headerlink" title="十、AMD、CMD、CommonJS与ES6模块化"></a>十、AMD、CMD、CommonJS与ES6模块化</h2><p>模块化的引入主要是用于解决命名冲突、代码复用、代码可读性、依赖管理等</p>
<h3 id="AMD异步模块定义"><a href="#AMD异步模块定义" class="headerlink" title="AMD异步模块定义"></a>AMD异步模块定义</h3><ul>
<li>AMD全称Asynchronous Module Definition异步模块定义</li>
<li>AMD并非原生js支持，是RequireJS模块化开发当中推广的产物，AMD依赖于RequireJS函数库，打包生成对应效果的js代码</li>
<li>RequireJS主要用于解决多个js文件之间的依赖关系、浏览器加载大量js代码导致无响应、异步加载模块</li>
<li>RequireJS通过<code>define(id?,dependencies?,factory)</code>定义模块，id可选，为定义模块的标识，默认为模块文件名不包括后缀，dependencies可选，是当前模块依赖的模块路径数组，factory为工厂方法，初始化模块的函数或者对象，如果为函数将会只执行一次，如果是对象将作为模块的输出</li>
<li>通过<code>require(dependencies,factory)</code>导入模块，其中dependencies为需要导入的模块路径数组，factory为当模块导入之后的回调函数，此函数的参数列表为对应导入的模块</li>
<li>通过require.config(配置对象)配置各模块路径和引用名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="CMD通用模块定义"><a href="#CMD通用模块定义" class="headerlink" title="CMD通用模块定义"></a>CMD通用模块定义</h3><ul>
<li>CMD全称Common Module Definition通用模块定义</li>
<li>同AMD，CMD也有一个函数库SeaJS与RequireJS类似的功能</li>
<li>CMD推崇一个文件一个模块，推崇依赖就近，定义模块<code>define(id?,deps?,factory)</code>，id同AMD，deps一般不在其中写依赖，而是在factory中在需要使用的时候引入模块，factory函数接收3各参数，参数一require方法，用来内部引入模块的时候调用，参数二exports是一个对象，用来向外部提供模块接口，参数三module也是一个对象上面存储了与当前模块相关联的一些属性和方法</li>
<li>通过<code>seajs.use(deps,func)</code>加载模块，deps为引入到模块路径数组，func为加载完成后的回调函数</li>
</ul>
<p>AMD、CMD的主要区别在于</p>
<p>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><ul>
<li>CommonJS模块规范，通常用于Nodejs中的模块化</li>
<li>拥有4个环境变量modul、exports、require、global</li>
<li>通过<code>module.exports</code>(不推荐exports)导出模块对象，通过require(模块路径)加载模块</li>
<li>当一个模块同时存在exports和module.exports时后者覆盖前者</li>
<li>规范中<code>__dirname</code>代表当前模块文件所在的文件夹路径，<code>__filename</code>代表当前模块文件夹路径+文件名</li>
<li>CommonJS通过同步的方式加载模块，其输出的模块是一个拷贝对象，所以修改原的模块不会对被引入的模块内部产生影响，且模块在代码运行的时候加载</li>
</ul>
<h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><ul>
<li>es6引入的export与import用于解决js自身不具备模块功能的缺陷</li>
<li>通过export或者export default导出模块接口，通过import xxx from ‘路径’，导入模块</li>
<li>对于export导出的接口可以使用import {接口} from ‘路径’，通过解构的方式按需导入</li>
<li>对于export default默认导出的，可以使用import xxx from ‘路径’，来导入默认导出的接口，xxx可以是自定义名称，且一个模块只能有一个默认导出，可以有多个export</li>
<li>还可以通过别名的方式设置导出和导入的接口名，如export {a as foo}，把foo作为a的别名导出，import foo as b from 路径，把b当作foo的别名导入</li>
<li>es6模块是在代码编译时输出接口即编译时加载，es6是通过命令来指定导出和加载，且导出的是模块中的只读引用，如果原始模块中的值被改变了，那么加载的值也会随之改变，所以是动态引用</li>
</ul>
<h2 id="十一、script标签之async与defer"><a href="#十一、script标签之async与defer" class="headerlink" title="十一、script标签之async与defer"></a>十一、script标签之async与defer</h2><h3 id="使用async属性"><a href="#使用async属性" class="headerlink" title="使用async属性"></a>使用async属性</h3><ul>
<li>如果script标签设置了这个值，则说明引入的js需要异步加载和执行，注意此属性只适用于外部引入的js</li>
<li>在有async的情况下脚本异步加载和执行，并且不会阻塞页面加载，但是也并不会保证其加载的顺序，如果多个async优先执行，则先加载好的js文件，所以使用此方式加载的js文件最好不要包含其他依赖</li>
</ul>
<h3 id="使用defer属性"><a href="#使用defer属性" class="headerlink" title="使用defer属性"></a>使用defer属性</h3><ul>
<li>如果使用此属性，也将会使js异步加载执行，且会在文档被解析完成后执行，这样就不会阻塞页面加载，但是它将会按照原来的执行顺序执行，对于有依赖关系的也可使用</li>
<li>html4.0中定义了defer，html5.0中定义了async</li>
</ul>
<h3 id="不同情况"><a href="#不同情况" class="headerlink" title="不同情况"></a>不同情况</h3><ul>
<li>如果只有async，那么脚本在下载完成后异步执行。</li>
<li>如果只有defer，那么脚本会在页面解析完毕之后执行。</li>
<li>如果都没有，那么脚本会在页面中马上解执行，停止文档解析阻塞页面加载</li>
<li>如果都有那么同async，当然此情况一般用于html的版本兼容下，如果没有async则defer生效</li>
<li>不过还是推荐直接把script标签放在body底部</li>
</ul>
<h2 id="十二、改变数组本身的api"><a href="#十二、改变数组本身的api" class="headerlink" title="十二、改变数组本身的api"></a>十二、改变数组本身的api</h2><ol>
<li><code>pop()</code>  尾部弹出一个元素</li>
<li><code>push()</code> 尾部插入一个元素</li>
<li><code>shift()</code>  头部弹出一个元素</li>
<li><code>unshift()</code>  头部插入一个元素</li>
<li><code>sort([func])</code> 对数组进行排序,func有2各参数，其返回值小于0，那么参数1被排列到参数2之前，反之参数2排在参数1之前</li>
<li>reverse() 原位反转数组中的元素</li>
<li><code>splice(pos,deleteCount,...item)</code>  返回修改后的数组，从pos开始删除deleteCount个元素，并在当前位置插入items</li>
<li><code>copyWithin(pos[, start[, end]])</code> 复制从start到end(不包括end)的元素，到pos开始的索引，返回改变后的数组，浅拷贝</li>
<li><code>arr.fill(value[, start[, end]])</code> 从start到end默认到数组最后一个位置，不包括end，填充val，返回填充后的数组</li>
</ol>
<p>其他数组api不改变原数组</p>
<h2 id="十三、window之location、navigator"><a href="#十三、window之location、navigator" class="headerlink" title="十三、window之location、navigator"></a>十三、window之location、navigator</h2><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><ul>
<li>location为全局对象window的一个属性，且<code>window.location===document.location</code>，其中的属性都是可读写的，但是只有修改<strong>href</strong>和<strong>hash</strong>才有意义，href会重新定位到一个URL，hash会跳到当前页面中的anchor名字的标记(如果有)，而且页面不会被重新加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这行代码将会使当前页面重定向到http://www.baidu.com</span></span><br><span class="line"><span class="built_in">window</span>.location.href = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 如果使用hash并且配合input输入框，那么当页面刷新之后，鼠标将会自动聚焦到对应id的input输入框，</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"target"</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">window</span>.location.hash = <span class="string">'#target'</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>先看下其拥有的属性</p>
<img src="https://user-gold-cdn.xitu.io/2020/4/21/1719d5465e6deae5?imageslim" alt="img" style="zoom:200%;" />

<p>这里补充一个<strong>origin</strong>属性，<code>返回URL协议+服务器名称+端口号 (location.origin == location.protocol + &#39;//&#39; + location.host)</code></p>
<ul>
<li>可以通过上述属性来获取URL中的指定部分，或者修改href于hash达到重新定位与跳转</li>
<li>添加hash改变监听器，来控制hash改变时执行的代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>, funcRef);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = funcRef;</span><br></pre></td></tr></table></figure>

<p>location方法</p>
<p><img src="../images/1719d54a9be043de.png" alt="img"></p>
<ul>
<li><code>assign(url)</code>,通过调用<code>window.location.assign</code>方法来打开指定url的新页面<code>window.location.assign(&#39;http://www.baidu.com&#39;)</code>在当前页面打开百度，可回退</li>
<li><code>replace(url)</code>,在当前页面打开指定url，不可回退</li>
<li><code>reload([Boolean])</code>,调用此方法将会重新加载当前页面，如果参数为false或者不填，则会以最优的方式重新加载页面，可能从缓存中取资源，如果参数为true则会从服务器重新请求加载资源</li>
</ul>
<h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><ul>
<li><code>window.navigator</code>对象包含<strong>有关浏览器的信息</strong>，可以用它来查询一些关于运行当前脚本的应用程序的相关信息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器的代码名:"</span> + navigator.appCodeName + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器的名称:"</span> + navigator.appName + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"当前浏览器的语言:"</span> + navigator.browserLanguage + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器的平台和版本信息:"</span> + navigator.appVersion + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器中是否启用 cookie :"</span> + navigator.cookieEnabled + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"运行浏览器的操作系统平台 :"</span> + navigator.platform + <span class="string">"&lt;br&gt;"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>navigator.appCodeName</code> 只读,任何浏览器中，总是返回 ‘Gecko’。该属性仅仅是为了保持兼容性。</li>
<li><code>navigator.appName</code> 只读,返回浏览器的官方名称。不要指望该属性返回正确的值。</li>
<li><code>navigator.appVersion</code> 只读,返回一个字符串，表示浏览器的版本。不要指望该属性返回正确的值。</li>
<li><code>navigator.platform</code> 只读,返回一个字符串，表示浏览器的所在系统平台。</li>
<li><code>navigator.product</code> 只读,返回当前浏览器的产品名称（如，”Gecko”）。</li>
<li><code>navigator.userAgent</code> 只读,返回当前浏览器的用户代理字符串（user agent string）</li>
</ul>
<p>如下在不同浏览器打印的信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">chrome:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Macintosh; Intel Mac OS X 10_12_6)</span></span><br><span class="line"><span class="comment">    AppleWebKit/537.36 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Chrome/61.0.3163.91 Safari/537.36</span></span><br><span class="line"><span class="comment">safari:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Macintosh; Intel Mac OS X 10_12_6)</span></span><br><span class="line"><span class="comment">    AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0</span></span><br><span class="line"><span class="comment">    Safari/604.1.38</span></span><br><span class="line"><span class="comment">ios11刘海X:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (iPhone; CPU iPhone OS 11_0 like Mac OS X)</span></span><br><span class="line"><span class="comment">    AppleWebKit/604.1.38 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Version/11.0 Mobile/15A372 Safari/604.1</span></span><br><span class="line"><span class="comment">ipad：</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (iPad; CPU OS 9_1 like Mac OS X)</span></span><br><span class="line"><span class="comment">    AppleWebKit/601.1.46 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Version/9.0 Mobile/13B143 Safari/601.1</span></span><br><span class="line"><span class="comment">galxy sansum:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Linux; Android 5.0; SM-G900P Build/LRX21T)</span></span><br><span class="line"><span class="comment">    AppleWebKit/537.36 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Chrome/61.0.3163.91 Mobile Safari/537.36</span></span><br><span class="line"><span class="comment">安装uc浏览器：</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Linux; U; Android 6.0.1; zh-CN; Mi Note 2 Build/MXB48T)</span></span><br><span class="line"><span class="comment">    AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0</span></span><br><span class="line"><span class="comment">    Chrome/40.0.2214.89 UCBrowser/11.4.9.941 Mobile Safari/537.36</span></span><br><span class="line"><span class="comment">winphone:</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (Linux; Android 5.1.1; Nexus 6 Build/LYZ28E)</span></span><br><span class="line"><span class="comment">    AppleWebKit/537.36 (KHTML, like Gecko) </span></span><br><span class="line"><span class="comment">    Chrome/61.0.3163.91 Mobile Safari/537.36</span></span><br><span class="line"><span class="comment">hybrid方法的可能：</span></span><br><span class="line"><span class="comment">    Mozilla/5.0</span></span><br><span class="line"><span class="comment">    (iPhone; CPU iPhone OS 11_0 like Mac OS X)</span></span><br><span class="line"><span class="comment">    AppleWebKit/604.1.38 (KHTML, like Gecko)</span></span><br><span class="line"><span class="comment">    Mobile/15A372 weibo/80011134</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="十四、ajax与fetch"><a href="#十四、ajax与fetch" class="headerlink" title="十四、ajax与fetch"></a>十四、ajax与fetch</h2><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><ul>
<li>ajax全称Asynchronous JavaScript And XML也就是异步js与xml，它可以让页面在不刷新的情况下发起请求获取数据</li>
<li>使用<code>window.XMLHttpRequest</code>构造器实例化一个网络请求对象<code>const XHR = new XMLHttpRequest()</code></li>
<li><code>XHR.open(method, url, [ async, [ user, [ password]]])</code>此方法用来发送一个请求，method为请求方法，url为请求地址，async为boolean值默认为true即使用异步请求，user和password在请求需要用户和密码的时候使用</li>
<li><code>XHR.send(body)</code>参数为发生请求主体内容，其格式可以为FormData、ArrayBuffer、Document、序列化字符串，在收到响应后，响应的数据会自动填充XHR对象的属性</li>
<li>当需要设置请求头时可以调用<code>XHR.setRequestHeader(header,value)</code>设置请求头的类型与值，当以post方式发起请求就用设置<code>XHR.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)</code>此请求头，值可更改</li>
<li>通过监听实例的onreadystatechange属性方法，当readyState的值改变的时候会触发onreadystatechange对应的回调函数<code>XHR.onreadystatechange = function () { }</code></li>
<li>请求状态readyState有5个值，对应5个请求状态，只读<ul>
<li>0 表示 请求还未初始化，尚未调用 open() 方法。</li>
<li>1 表示 已建立服务器链接，open() 方法已经被调用。</li>
<li>2 表示 请求已接受，send() 方法已经被调用，并且头部和状态已经可获得。</li>
<li>3 表示 正在处理请求，下载中； responseText 属性已经包含部分数据。</li>
<li>4 表示 完成，下载操作已完成。</li>
</ul>
</li>
<li>还有status属性，它是这次请求中的响应数字状态码，即为我们平时看到的1xx、2xx、3xx、4xx、5xx表示此次请求的状态结果，在还未发起请求和出错时都为0，只读</li>
<li><code>XHR.responseText</code>属性为此次响应的数据，为字符串，可能是JSON格式需要JSON.parse解析</li>
<li><code>XHR.responseXML</code>属性为xml形式的数据，可以通过<code>XHR.responseType = &#39;document&#39;</code>和<code>XHR.overrideMimeType(&#39;text/xml&#39;)</code>来解析为XML</li>
<li><code>XHR.withCredentials</code>属性设置为boolean值，通过此属性来设置是否使用cookies、authorization等凭证字段</li>
<li><code>XHR.timeout</code>通过此属性来设置请求超时时间</li>
<li><code>XHR.ontimeout</code>通过此属性来设置请求超时的回调函数,函数的参数为事件对象</li>
<li><code>XHR.abort()</code>此方法用来终止网络请求</li>
<li><code>XHR.getAllResponseHeaders()</code>此方法用来获取所有的响应头</li>
<li><code>XHR.getResponseHeader(name)</code>此方法用来获取指定的响应头</li>
<li>还有6个关于进度的事件<ul>
<li>loadstart 在收到响应的第一个字节触发</li>
<li>progress 在接收期间不断触发</li>
<li>error 发生错误</li>
<li>abort 调用abort方法而终止</li>
<li>load 接收到完整数据，可代替readystatechange与readyState判断</li>
<li>loadend 在通信完成或abort error load事件后触发</li>
</ul>
</li>
<li>通过<code>XHR.addEventListener(eventname,callback)</code>方法添加对应的事件监听，其回调函数接收一个事件对象参数</li>
<li>progress事件对象有3个属性用于查看当前进度相关信息，lengthComputable为boolean值，表示进度是否可用，position表示已经接收的字节数，totalSize表示总需要传输的内容长度即Content-Length字节数，通常在分片传输内容的时候用到</li>
</ul>
<p>简单的发起一次请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的发起一个请求</span></span><br><span class="line"><span class="keyword">const</span> XHR = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">XHR.open(<span class="string">'get'</span>,<span class="string">'http://127.0.0.1:3000/test?key=value'</span>)</span><br><span class="line">XHR.send()</span><br><span class="line">XHR.addEventListener(<span class="string">'load'</span>,(e)=&gt;&#123;</span><br><span class="line">  <span class="comment">// 服务端返回的是查询参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(XHR.response) <span class="comment">// &#123;"key":"value"&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于XMLHttpRequest封装一个请求方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送的数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  type: <span class="string">"post"</span>,</span><br><span class="line">  url: <span class="string">"http://127.0.0.1:3000/test"</span>,</span><br><span class="line">  data: data,</span><br><span class="line">  dataType: <span class="string">'application/json'</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求构造器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params">conf</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = conf.type || <span class="string">'get'</span></span><br><span class="line">  <span class="keyword">this</span>.url = conf.url || <span class="string">''</span></span><br><span class="line">  <span class="keyword">this</span>.data = conf.data || &#123;&#125;</span><br><span class="line">  <span class="keyword">this</span>.dataType = conf.dataType || <span class="string">''</span></span><br><span class="line">  <span class="keyword">this</span>.success = conf.success || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.error = conf.error || <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// send方法</span></span><br><span class="line">Ajax.prototype.send = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.url === <span class="string">''</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> XHR = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  XHR.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (XHR.status &gt;= <span class="number">200</span> &amp;&amp; XHR.status &lt; <span class="number">300</span> || XHR.status == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="keyword">this</span>.success === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.success(XHR.response)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  XHR.addEventListener(<span class="string">'error'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="keyword">this</span>.error === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.error(e)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.type.toLowerCase() === <span class="string">'get'</span>) &#123;</span><br><span class="line">    XHR.open(<span class="string">'get'</span>, <span class="keyword">this</span>.url)</span><br><span class="line">    XHR.send(<span class="literal">null</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    XHR.open(<span class="keyword">this</span>.type, <span class="keyword">this</span>.url)</span><br><span class="line">    XHR.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="keyword">this</span>.dataType || <span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">this</span>.data</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataType === <span class="string">'application/json'</span>) &#123;</span><br><span class="line">      data = <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">    XHR.send(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line"><span class="keyword">const</span> ajax = <span class="keyword">new</span> Ajax(config).send()</span><br></pre></td></tr></table></figure>

<p>由于网络请求模块封装较繁琐，这里就简单封装了一下，仅供参考（。＾▽＾）</p>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><ul>
<li>fetch API提供了js接口，用于替代XMLHttpRequest方式的网络请求，fetch()全局方法使用起来比XHR更加方便</li>
<li>fetch方法接受2个参数，参数1为请求url或 Request 对象，参数2为可选配置对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch方法返回一个Promise对象，可用then方法接收结果，用catch方法捕获异常，同Promise使用</span></span><br><span class="line"><span class="comment">// 配置对象具体配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  method: <span class="string">'GET'</span>,      <span class="comment">// 请求方法</span></span><br><span class="line">  headers: &#123;          <span class="comment">// 头信息</span></span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">'Mozilla/4.0 MDN Example'</span>,</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;  <span class="comment">// 请求的 body 信息，Blob, FormData 等</span></span><br><span class="line">    data: <span class="number">1</span></span><br><span class="line">  &#125;),</span><br><span class="line">  mode: <span class="string">'cors'</span>,             <span class="comment">// 请求的模式，cors、 no-cors 或 same-origin</span></span><br><span class="line">  credentials: <span class="string">'include'</span>,   <span class="comment">// omit、same-origin 或 include。为了在当前域名内自动发送 cookie, 必须提供这个选项</span></span><br><span class="line">  cache: <span class="string">'no-cache'</span>,        <span class="comment">// default 、 no-store 、 reload 、 no-cache 、 force-cache 或者 only-if-cached</span></span><br><span class="line">  redirect: <span class="string">'follow'</span>,       <span class="comment">// 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误), 或者 manual (手动处理重定向).</span></span><br><span class="line">  referrer: <span class="string">'no-referrer'</span>,  <span class="comment">// no-referrer、client或一个 URL。默认是 client。</span></span><br><span class="line">  referrerPolicy: <span class="string">'no-referrer'</span>, <span class="comment">// 指定 referer HTTP头</span></span><br><span class="line">  integrity: <span class="string">'sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE='</span>, <span class="comment">// 包括请求的  subresource integrity 值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发起请求</span></span><br><span class="line">fetch(<span class="string">'http://biadu.com'</span> [, config])</span><br></pre></td></tr></table></figure>

<ul>
<li>hen的回调函数接受一个Response对象参数，其对象拥有9个属性，8个方法</li>
<li>9个属性<ul>
<li>type 只读 包含Response的类型 (例如, basic, cors)</li>
<li>url 只读 包含Response的URL</li>
<li>useFinalURL 包含了一个布尔值来标示这是否是该Response的最终URL</li>
<li>status 只读 包含Response的状态码</li>
<li>ok 只读 包含了一个布尔值来标示该Response成功(状态码200-299)</li>
<li>redirected 只读 表示该Response是否来自一个重定向，如果是的话，它的URL列表将会有多个</li>
<li>statusText 只读 包含了与该Response状态码一致的状态信息</li>
<li>headers 只读 包含此Response所关联的Headers 对象</li>
<li>bodyUsed Body 只读 包含了一个布尔值来标示该Response是否读取过Body</li>
</ul>
</li>
<li>8个方法<ul>
<li>clone 创建一个Response对象的克隆</li>
<li>error 返回一个绑定了网络错误的新的Response对象</li>
<li>redirect(url, status) 用另一个URL创建一个新的 response</li>
<li>arrayBuffer 接受一个 Response 流, 并等待其读取完成. 并 resolve 一个 ArrayBuffer 对象</li>
<li>blob  blob()方法使用一个 Response 流，并将其读取完成</li>
<li>formData 将 Response 对象中的所承载的数据流读取并封装成为一个对象</li>
<li>json 使用一个 Response 流，并将其读取完成。解析结果是将文本体解析为 JSON</li>
<li>text 提供了一个可供读取的”返回流”, 它返回一个包含USVString对象，编码为UTF-8</li>
</ul>
</li>
</ul>
<h2 id="十五、WebSocket"><a href="#十五、WebSocket" class="headerlink" title="十五、WebSocket"></a>十五、WebSocket</h2><ul>
<li>WebSocket是一种在单个TCP连接上进行全双工通信的协议，即连接双方可以同时实时收发数据，它可以在用户的浏览器和服务器之间打开双工、双向通讯会话。</li>
<li>WebSocket API提供全局方法<code>WebSocket(url[, protocols])</code>创建实例,参数1 对方绝对url其url以<code>ws://</code>或者<code>wss://(加密)</code>开头，参数2 protocols是单协议或者包含协议的字符串数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须传入绝对URL，可以是任何网站</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.baidu.com'</span>) </span><br><span class="line">s.readyState    <span class="comment">// 0 建立连接 1 已经建立 2 正在关闭 3 连接已关闭或者没有链接成功</span></span><br><span class="line">s.send(<span class="string">'hello'</span>) <span class="comment">// 发送的数据必须是纯文本</span></span><br><span class="line">s.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">s.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">s.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当接收到消息时</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.data) <span class="comment">// 数据是纯字符</span></span><br><span class="line">&#125;</span><br><span class="line">s.close()   <span class="comment">// 关闭连接</span></span><br><span class="line">s.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * event.wasClean 是否明确的关闭 </span></span><br><span class="line"><span class="comment">    * event.code 服务器返回的数值状态码</span></span><br><span class="line"><span class="comment">    * event.reason 字符串，服务器返回的消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>10个属性<ul>
<li>binaryType 返回websocket连接所传输二进制数据的类型（blob, arraybuffer）</li>
<li>bufferedAmount 只读 返回已经被send()方法放入队列中但还没有被发送到网络中的数据的字节数。一旦队列中的所有数据被发送至网络，则该属性值将被重置为0。但是，若在发送过程中连接被关闭，则属性值不会重置为0。</li>
<li>extensions 只读 返回服务器选择的扩展名。这当前只是空字符串或连接协商的扩展列表</li>
<li>onclose 用于指定连接失败后的回调函数</li>
<li>onmessage 用于指定当从服务器接受到信息时的回调函数</li>
<li>onopen 用于指定连接成功后的回调函数</li>
<li>protocol 只读 服务器选择的下属协议</li>
<li>readyState 只读 当前的链接状态，共4个<ul>
<li>0 建立连接</li>
<li>1 已经连接</li>
<li>2 正在关闭</li>
<li>3 连接已经关闭或者没有连接成功</li>
</ul>
</li>
<li>url 只读 WebSocket 的绝对路径</li>
</ul>
</li>
<li>2个方法<ul>
<li>close(code, reason) 数字状态码 可选 默认 1005和一个可选的类可读的字符串，它解释了连接关闭的原因。</li>
<li>send(data) 向服务器发送数据（ArrayBuffer，Blob等）</li>
</ul>
</li>
</ul>
<h2 id="十六、短轮询、长轮询与WebSocket"><a href="#十六、短轮询、长轮询与WebSocket" class="headerlink" title="十六、短轮询、长轮询与WebSocket"></a>十六、短轮询、长轮询与WebSocket</h2><h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><ul>
<li>http 短轮询是server收到请求不管是否有数据到达都直接响应http请求，服务端响应完成，就会关闭这个TCP连接；如果浏览器收到的数据为空，则隔一段时间，浏览器又会发送相同的http请求到server以获取数据响应</li>
<li>缺点：消息交互的实时性较低（server端到浏览器端的数据反馈效率低）</li>
</ul>
<p>简单演示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 每秒发送一次短轮询</span></span><br><span class="line"><span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>, <span class="string">'http://127.0.0.1:3000/test?key=value'</span>)</span><br><span class="line">  xhr.addEventListener(<span class="string">'load'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="comment">// 如果不需要可以关闭</span></span><br><span class="line">      clearInterval(id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  xhr.send()</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><ul>
<li>http 长轮询是server收到请求后如果有数据，立刻响应请求；如果没有数据就会停留一段时间，这段时间内，如果server请求的数据到达（如查询数据库或数据的逻辑处理完成），就会立刻响应；如果这段时间过后，还没有数据到达，则以空数据的形式响应http请求；若浏览器收到的数据为空，会再次发送同样的http请求到server</li>
<li>缺点：server 没有数据到达时，http连接会停留一段时间，这会造成服务器资源浪费</li>
</ul>
<p>简单演示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>, <span class="string">'http://127.0.0.1:3000/test?key=value'</span>);</span><br><span class="line">  xhr.addEventListener(<span class="string">'load'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="comment">// 如果不需要可以关闭</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.response != <span class="string">''</span>) <span class="keyword">return</span></span><br><span class="line">      ajax()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>当server的数据不可达时，基于http长轮询和短轮询的http请求，都会停留一段时间</li>
<li>都是用于实时从服务器获取数据更新</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>http长轮询是在服务器端的停留，而http短轮询是在浏览器端的停留</li>
<li>短轮询隔一段时间向服务器发起请求，不管服务器数据有没有变化都直接返回结果，长轮询则在服务器数据有发生变化的时候才返回结果，如果在一定时间没有变化那么将会超时自动关闭连接</li>
</ul>
<p><img src="../images/1719d557898dae06.png" alt="img"></p>
<h3 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h3><ul>
<li>为了解决http无状态，被动性，以及轮询问题，html5新推出了websocket协议，浏览器和服务器只需完成一次握手，两者即可建立持久性连接，并进行双向通信</li>
<li>基于http进行握手，发生加密数据，保持连接不断开</li>
<li>优点：<ul>
<li>较少的控制开销，在进行客户端与服务器的数据交换时，用于协议控制的数据包头较小</li>
<li>更强的实时性，全双工通信，不必局限于一方发起的请求，服务器与客户端可以随时发送数据，延迟更少</li>
<li>有状态的连接，websocket在通信之前需要双方建立连接，才能进行通信，而http协议在每次请求都要携带状态信息</li>
<li>基于二进制数据传输，websocket定义了二进制帧，可以处理二进制内容，相比于文本传输，提高了效率</li>
<li>支持自定义子协议，可以自行扩展协议，如部分浏览器支持压缩等</li>
<li>更好的压缩效果，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>
</ul>
</li>
</ul>
<h2 id="十七、长连接与短连接"><a href="#十七、长连接与短连接" class="headerlink" title="十七、长连接与短连接"></a>十七、长连接与短连接</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><ul>
<li>HTTP/1.0中默认使用短连接，也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接</li>
<li>当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话</li>
<li>短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</li>
<li>像WEB网站的http服务一般都用短连接，并发量大，但每个用户无需频繁操作情况下需用短连接</li>
</ul>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><ul>
<li>从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码<code>Connection:keep-alive</code></li>
<li>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接</li>
<li>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接</li>
<li>长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接</li>
<li>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况</li>
</ul>
<h3 id="长短轮询和长短连接区别"><a href="#长短轮询和长短连接区别" class="headerlink" title="长短轮询和长短连接区别"></a>长短轮询和长短连接区别</h3><ul>
<li>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接</li>
<li>长短连接通过双方请求响应头是否设置<code>Connection:keep-alive</code>来决定使用，而是否轮询，是根据服务端的处理方式来决定的，与客户端没有关系</li>
<li>实现方式不同，长短连接通过协议来实现，而长短轮询通过服务器编程手动实现</li>
</ul>
<h2 id="十八、存储"><a href="#十八、存储" class="headerlink" title="十八、存储"></a>十八、存储</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul>
<li>cookie是由服务器发送给客户端用于存储少量信息，以键值对形式存储{key：value}</li>
</ul>
<p><img src="../images/1719d55c683250a9.png" alt="img"></p>
<ul>
<li>客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态</li>
<li>cookie是不可跨域，但是只在域名不同的情况下不支持跨域，忽略协议与端口，<code>https://localhost:80/</code>和<code>http://localhost:8080/</code>的Cookie是共享的，可以通过domain设置域，path设置域下的共享路径</li>
<li>cookie属性<ul>
<li>name 表示设置的cookie名也就是key，不能重复，不可更改</li>
<li>value 表示设置cookie的值</li>
<li>domain 表示cookie绑定的域名，默认绑定当前域，多级域名不可交换cookie，如果设置以点开头的域名，则所有子域名可以访问，如设置<code>.baidu.com</code>，则<code>a.baidu.com</code>可访问其上级域名的cookie</li>
<li>path 表示cookie所能使用的路径，默认’/‘路径，只要满足当前匹配路径以及子路径都可以共享cookie</li>
<li>maxAge 表示cookie失效时间，单位秒，正数为失效时间，负数表示当前cookie在浏览器关闭时失效，0表示删除cookie</li>
<li>secure 表示cookie是否使用安全协议传输如HTTPS、SSL，默认不使用，只在HTTPS等安全协议下有效，这个属性并不能对客户端的cookie进行加密，不能保证绝对的安全性</li>
<li>version 当前cookie使用的版本号，0 表示遵循Netscape的Cookie规范(多数)，1表示遵循W3C的RFC2109规范(较严格)，默认为0</li>
<li>same-site 规定浏览器不能在跨域请求中携带 Cookie，减少CSRF攻击</li>
<li>HttpOnly 如果这个属性设置为true，就不能通过js脚本来获取cookie的值，用来限制非HTTP协议程序接口对客户端Cookie进行访问，可以有效防止XSS攻击(跨站脚本攻击，代码注入攻击)</li>
</ul>
</li>
<li>前端通过document.cookie对cookie进行读写操作</li>
<li>创建cookie就是后端的事情了</li>
</ul>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul>
<li>session 表示服务器与客户端的一次会话过程，session对象存储特定用户的属性及配置信息</li>
<li>当用户在应用程序的 Web 页之间跳转时，存储在session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 session 超时失效时会话结束</li>
</ul>
<p><img src="../images/1719d5619add7922.png" alt="img"></p>
<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 session ，请求返回时将此 session 的唯一标识信息 sessionID 返回给浏览器，浏览器接收到服务器返回的 sessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 sessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 sessionID，再根据 sessionID 查找对应的 session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 session 证明用户已经登录可执行后面操作</li>
<li>session 的运行依赖 session id，而 session id 是存在 Cookie中的</li>
</ul>
<h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><ul>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。用户验证这种场合一般会用 session</li>
<li>session保存在服务器，客户端不知道其中的信息；反之，cookie保存在客户端，服务器能够知道其中的信息</li>
<li>session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</li>
<li>session中保存的是对象，cookie中保存的是字符串</li>
<li>session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的</li>
<li>session: 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</li>
<li>cookie: 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现session的一种方式</li>
</ul>
<h3 id="本地存储localStorage与sessionStorage"><a href="#本地存储localStorage与sessionStorage" class="headerlink" title="本地存储localStorage与sessionStorage"></a>本地存储localStorage与sessionStorage</h3><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><ul>
<li>localStorage浏览器api，用于存储本地数据，可持久化，永不过期，除非主动删除</li>
</ul>
<p>基本使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">"b"</span>, <span class="string">"isaac"</span>);  <span class="comment">//设置b为"isaac"</span></span><br><span class="line">localStorage.getItem(<span class="string">"b"</span>);           <span class="comment">//获取b的值,为"isaac"</span></span><br><span class="line">localStorage.key(<span class="number">0</span>);                 <span class="comment">//获取第0个数据项的键名，此处即为“b”</span></span><br><span class="line">localStorage.removeItem(<span class="string">"b"</span>);        <span class="comment">//清除c的值</span></span><br><span class="line">localStorage.clear();                <span class="comment">//清除当前域名下的所有localStorage数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据，一般用于跨页面共享数据</li>
<li>可通过<code>window.addEventListener(&quot;storage&quot;, function(e){}</code>设置localStorage事件监听，当存储区域的内容发生改变时，将会调用回调</li>
</ul>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><ul>
<li>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(name, num);    <span class="comment">//存储数据</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'value2'</span>, <span class="number">119</span>);</span><br><span class="line">sessionStorage.valueOf();             <span class="comment">//获取全部数据</span></span><br><span class="line">sessionStorage.getItem(name);         <span class="comment">//获取指定键名数据</span></span><br><span class="line">sessionStorage.sessionData;           <span class="comment">//sessionStorage是js对象，也可以使用key的方式来获取值</span></span><br><span class="line">sessionStorage.removeItem(name);      <span class="comment">//删除指定键名数据</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用方式与localStorage类似</li>
<li>仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</li>
<li>主要用于存储当前页面独有的数据，不与浏览器其他页面共享</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>数据存储方面<ul>
<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</li>
<li>sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。</li>
</ul>
</li>
<li>存储数据大小<ul>
<li>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。</li>
<li>sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
</ul>
</li>
<li>数据存储有效期<ul>
<li>sessionStorage：仅在当前浏览器窗口关闭之前有效； localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；</li>
<li>cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</li>
</ul>
</li>
<li>作用域不同<ul>
<li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li>
<li>localStorage在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</li>
<li>cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在</li>
</ul>
</li>
</ul>
<p><img src="../images/1719d566c4dee532.png" alt="img"></p>
<h2 id="十九、跨域"><a href="#十九、跨域" class="headerlink" title="十九、跨域"></a>十九、跨域</h2><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><ul>
<li>jsonp是一种跨域通信手段，通过script标签的src属性实现跨域，由于浏览器同源策略，并不会截断script的跨域响应</li>
<li>通过将前端方法名作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信</li>
<li>由于使用script标签的src属性，因此只支持get方法</li>
</ul>
<p>来实现一下吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端准备</span></span><br><span class="line"><span class="comment">// 定义回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// arg为服务端传来的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`客户端获取的数据：<span class="subst">$&#123;arg&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建script标签</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"><span class="comment">// 给script标签的src属性赋值，值为请求url，查询参数callback，需与后端对应</span></span><br><span class="line"><span class="comment">// fn为前端回调函数名</span></span><br><span class="line">s.src = <span class="string">`http://127.0.0.1:3000/test?callback=fn`</span></span><br><span class="line"><span class="comment">// 向html添加此标签，添加完成之后浏览器自动请求script的src对应的网址</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(s);</span><br><span class="line"><span class="comment">// 等待浏览器收到响应之后，将会自动执行响应内容的代码</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">// 后端准备</span></span><br><span class="line"><span class="comment">// nestjs(ts)处理</span></span><br><span class="line">@Controller(<span class="string">'test'</span>) <span class="comment">//api</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">  @Get() <span class="comment">//get方式请求</span></span><br><span class="line">  <span class="comment">//取url中的查询参数，即?之后的键值对，键与值对应query对象参数的键与值</span></span><br><span class="line">  callback(@Query() query) &#123;  </span><br><span class="line">    <span class="comment">// 返回的数据</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="string">'我是服务端返回的数据'</span>;</span><br><span class="line">    <span class="comment">// 取查询参数，这里的callback要与前端?之后的键名一致，fn即fn函数名</span></span><br><span class="line">    <span class="keyword">const</span> fn = query.callback;</span><br><span class="line">    <span class="comment">// 返回结果，格式：函数名(服务器的数据)，注意这里需要序列化成字符串，如果参数本身是字符串那么要加引号，前端并不知道data是字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;fn&#125;</span>('<span class="subst">$&#123;data&#125;</span>')`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// express(js)处理，同上</span></span><br><span class="line">router.get(<span class="string">'/test'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="string">'我是服务器返回的数据'</span></span><br><span class="line">  <span class="comment">// req.query为查询参数列表</span></span><br><span class="line">  <span class="keyword">const</span> fn = req.query.callback</span><br><span class="line">  <span class="comment">// 返回数据</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;fn&#125;</span>('<span class="subst">$&#123;data&#125;</span>')`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>响应内容</p>
<p><img src="../images/1719d571d31cb770.png" alt="img"></p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ul>
<li>跨域资源共享cors，它使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源</li>
<li>需要服务端与客户端同时支持cors跨域方式才能进行跨域请求，服务端通过设置<code>Access-Control-Allow-Origin:*</code>即可开启cors允许跨域请求，使用通配符*表示允许所有不同域的源访问资源，也可单独设置指定允许的源域名</li>
<li>使用cors跨域时，将会在发起请求时出现2种情况：</li>
<li>简单请求，需满足以下条件<ul>
<li>使用get、head、post方式发起的请求</li>
<li>Content-Type 的值仅限于下列三者之一：<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
</li>
<li>不满足这些条件即为预检请求</li>
</ul>
</li>
<li>预检请求<ul>
<li>需预检的请求要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求</li>
<li>预检请求的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响</li>
<li>当满足以下条件之一，将会发送预检请求<ul>
<li>使用了下面任一 HTTP 方法：</li>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ul>
</li>
<li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type (需要注意额外的限制)</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li>Content-Type 的值不属于下列之一:<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
<li>满足以上条件之一将会发起预检请求，总共会发起2次请求，第一次为OPTIONS方式的请求，用来确定服务器是否支持跨域，如果支持，再发起第二次实际请求，否则不发送第二次请求</li>
</ul>
</li>
</ul>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><ul>
<li>postMessage可用于不同页面之间的跨域传递数据</li>
<li><code>postMessage(data,origin[, source])</code>data为发送的数据只能发送字符串信息，origin发送目标源，指定哪些窗口能接收到消息事件，如果origin设置为*则表示无限制，source为发送消息窗口的window对象引用.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.html --&gt;</span><br><span class="line">&lt;iframe src=<span class="string">"http://127.0.0.1:5501/postMessage.html"</span></span><br><span class="line">name=<span class="string">"postIframe"</span> onload=<span class="string">"messageLoad()"</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 定义加载之后执行的函数，给postMessage.html发送数据</span></span><br><span class="line"><span class="regexp">function messageLoad() &#123;</span></span><br><span class="line"><span class="regexp">  const url = 'http:/</span><span class="regexp">/127.0.0.1:5501/</span>postMessage.html<span class="string">'</span></span><br><span class="line"><span class="string">  window.postIframe.postMessage('</span>给postMessage的数据<span class="string">', url)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 用于监听postMessage.html的回馈，执行回调</span></span><br><span class="line"><span class="string">window.addEventListener('</span>message<span class="string">', (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">  console.log(event.data);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">----------------------------------------------</span></span><br><span class="line"><span class="string">&lt;!-- postMessage.html --&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  // 监听test.html发来的数据，延迟1秒返回数据</span></span><br><span class="line"><span class="string">  window.addEventListener('</span>message<span class="string">', (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="string">      event.source.postMessage('</span>给test的数据<span class="string">', event.origin)</span></span><br><span class="line"><span class="string">    &#125;,1000)</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>event对象的几个重要属性<ul>
<li>data 指的是从其他窗口发送过来的消息对象</li>
<li>type 指的是发送消息的类型</li>
<li>source 指的是发送消息的窗口对象</li>
<li>origin 指的是发送消息的窗口的源</li>
</ul>
</li>
</ul>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><ul>
<li>由于<code>window.name</code>属于全局属性，在html中的iframe加载新页面(可以是跨域)，通过iframe设置的src指向的源中更改name的值，同时主页面中的name也随之更改，但是需要给iframe中的window设置为<code>about:blank</code>或者同源页面即可</li>
<li>iframe使用之后应该删除，name的值只能为string类型，且数据量最大支持2MB</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.html --&gt;</span><br><span class="line"><span class="comment">// 封装应该用于获取数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">url, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isFirst = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">  loadFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">      <span class="comment">// 设置为同源</span></span><br><span class="line">      ifr.contentWindow.location = <span class="string">'about:blank'</span></span><br><span class="line">      isFirst = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      func(ifr.contentWindow.name)</span><br><span class="line">      ifr.contentWindow.close()</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(ifr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ifr.src = url</span><br><span class="line">  ifr.style.display = <span class="string">'none'</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(ifr)</span><br><span class="line">  <span class="comment">// 加载之后的回调</span></span><br><span class="line">  ifr.onload = loadFunc</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">`http://127.0.0.1:5501/name.html`</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">//</span></span><br><span class="line">&#125;)</span><br><span class="line">----------------------------------------------</span><br><span class="line">&lt;!-- name.html --&gt;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">"iframe"</span> &#125;</span><br><span class="line"><span class="comment">// 修改name的值，必须为string类型</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="built_in">JSON</span>.stringify(obj);</span><br></pre></td></tr></table></figure>

<h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><ul>
<li><code>document.domain</code>的值对应当前页面的域名</li>
<li>通过对domain设置当前域名来实现跨域，不过仅限于域名不同，但是又要属于同一个基础域名下，如<code>http://a.baidu.com</code>与<code>http://b.baidu.com</code>这2个子域名之间才能使用domain跨域，一般用于子域名之间的跨域访问</li>
<li>domain只能赋值为当前域名或者其基础域名，即上级域名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.html --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'baidu.com'</span>;</span><br><span class="line"><span class="keyword">const</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">ifr.src = <span class="string">'a.baidu.com/test.html'</span>;</span><br><span class="line">ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line">ifr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> doc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">  <span class="comment">// 此处即可操作domain.html的document</span></span><br><span class="line">  ifr.onload = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">----------------------------------------------</span></span><br><span class="line"><span class="regexp">&lt;!-- domain.html --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ domain.html下设置为与test.html中的domain一致</span></span><br><span class="line"><span class="regexp">  document.domain = 'baidu.com';</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要就是通过设置为同源域名(只能为其基础域名)，通过iframe操作另一个页面的内容</li>
</ul>
<h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><ul>
<li>nginx反向代理，代理从客户端来的请求，转发到其代理源</li>
<li>通过配置nginx的配置文件实现代理到不同源</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// nginx.conf配置</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  listen 80;  // 监听端口</span><br><span class="line">  server_name  www.baidu.com; // 匹配来源</span><br><span class="line">  location / &#123;  //匹配路径</span><br><span class="line">    // 反向代理到http://127.0.0.1:3000</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class="line">    // 默认入口文件</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm index.jsp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>nginx反向代理还能实现负载均衡</li>
</ul>
<h2 id="二十、setTimeout与setInterval"><a href="#二十、setTimeout与setInterval" class="headerlink" title="二十、setTimeout与setInterval"></a>二十、setTimeout与setInterval</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><ul>
<li>setTimeout属于webApi的一部分，可以实现延时调用，属于异步宏任务，一次性使用</li>
<li><code>setTimeout(func|code, [delay], [arg1], [arg2], ...)</code> 参数1为想要执行的函数或代码字符串，参数2为延迟执行时间，单位毫秒默认0，参数3及之后的参数为参数1为函数时传入的参数，调用之后会返回一个定时器id</li>
<li>此方法只执行一次，可以使用<code>clearTimeout(id)</code>清除定时器来取消回调</li>
<li>看一下setTimeout的延迟执行机制</li>
</ul>
<p><img src="../images/1719d57a515531c0.png" alt="img"></p>
<ul>
<li>以上使用嵌套setTimeout来实现循环调用，可以从中看出setTimeout计时是从上一个setTimeout回调执行之后开始的，看看代码效果</li>
</ul>
<p><img src="../images/1719d57d50d46306.png" alt="img"></p>
<ul>
<li>上图计算的是2次调用回调之间的间隔，不包括回调执行时间，可以看出在开启定时器之后到执行回调的时间确实是参数2所设置的值，延迟时间与回调函数执行时间无关；</li>
<li>简单来讲setTimeout的延迟时间不包括自身回调所占用的时间</li>
</ul>
<p>也就是说setTimeout是在上一次回调执行之后才开启的定时</p>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><ul>
<li>setInterval同样也是webApi的一部分，主要用来定时循环执行代码</li>
<li>不同于setTimeout，此定时器的延迟执行机制有所不同</li>
<li><code>setInterval(func|code, [delay], [arg1], [arg2], ...)</code>，参数列表同setTimeout，参数2为每次循环时间</li>
</ul>
<p><img src="../images/1719d5823cbd8652.png" alt="img"></p>
<p>从上图可以先得出结论，setInterval的延迟执行时间包含自身回调执行所占用的时间，看看代码效果</p>
<p><img src="../images/1719d586296026d8.png" alt="img"></p>
<ul>
<li>上图计算的是2次调用回调之间的间隔，不包括回调执行时间，可以看出setInterval在2次执行之间的延迟受到了回调的影响，再验证一下</li>
</ul>
<p><img src="../images/1719d58a248e5cd3.png" alt="img"></p>
<ul>
<li>此次我把回调执行时间也算在计时之内，现在看来setInterval的定时时间确实包含了自身回调所占用的时间</li>
</ul>
<p>由于这2个api都属于异步宏任务，在执行的时候都会进入任务队列，如果队列前的任务执行时间较长，那么也会影响到定时器的执行时机</p>
<p>在浏览器中alert、confirm、prompt都会阻塞js主线程执行，直到弹窗消失，但是定时器还会继续执行；定时器并不能达到0延迟，最小延迟限制在4ms</p>
<h2 id="二十一、requestAnimationFrame"><a href="#二十一、requestAnimationFrame" class="headerlink" title="二十一、requestAnimationFrame"></a>二十一、requestAnimationFrame</h2><ul>
<li>在requestAnimationFrame还未出来之前，大多数使用定时器完成js动画，但是由于定时器不准确，而且每次更新动画的时候不能保证与浏览器渲染同步，这样将会导致画面的不流畅</li>
<li>由于目前主流屏幕的固定刷新频率一般为60HZ即一秒60帧，每次刷新间隔为1000/60ms，为了使浏览器得到最好的渲染效果，浏览器每次渲染应该与屏幕刷新率保持一致，那么对于js动画而言，最好的更新时机应该与浏览器尽量保持一致</li>
<li>当每次浏览器将要重绘之前，把要执行更新的动画更新完成，那么当浏览器渲染的时候将会保持最新的动画，这就是requestAnimationFrame所做的事情</li>
<li><code>requestAnimationFrame(callback)</code> 的参数就是每次渲染前需要执行的动画更新函数，当浏览器将要重绘画面时就会执行这个回调函数，这个回调函数接受一个参数，即从当前页面加载之后到现在所经过的毫秒数</li>
<li>此api将会与浏览器渲染同步，即浏览器渲染几次这个api将会执行几次，那么就达到了不掉帧的效果，画面效果就更加流程</li>
<li>requestAnimationFrame执行时机在事件循环机制中处于微任务队列之后，浏览器渲染之前，浏览器渲染之后就会进入下一次的事件循环(宏任务开始，浏览器渲染结束)</li>
<li>如果使用定时器进行js动画操作，那么首先将会导致动画更新与浏览器每次重绘时机不匹配，造成卡顿，其次过于频繁的更新动画还会导致不必要的性能开销，且并非能够达到更好的效果</li>
<li>简单说使用requestAnimationFrame更新的动画与浏览器保持同步，不会掉帧，除非浏览器掉帧或者，js主线程阻塞导致浏览器无法正常渲染，使用定时器更新动画，如果频率高了会影响性能，且达不到更好的效果，如果频率低了将会有不连贯的感觉</li>
</ul>
<p><img src="../images/1719d58f7ddf9656.png" alt="img"></p>
<ul>
<li>从上图可以看出确实是每帧执行一次，不过要注意，调用一次requestAnimationFrame只会执行一次，如果需要持续执行需要在回调函数内继续调用</li>
</ul>
<h2 id="二十二、事件"><a href="#二十二、事件" class="headerlink" title="二十二、事件"></a>二十二、事件</h2><h3 id="DOM0事件"><a href="#DOM0事件" class="headerlink" title="DOM0事件"></a>DOM0事件</h3><ul>
<li>DOM0事件并非w3c标准，在DOM标准形成之前的事件模型就是我们所说的0级DOM</li>
<li>添加DOM0事件，都是把一个函数赋值给文档元素，在事件监听函数被调用时，将会做为产生事件的元素方法调用，所以this指向目标元素，简单说就是直接把回调函数作为文档元素的一个方法调用</li>
<li>删除DOM0事件只需把事件赋值为null即可</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line">&lt;input type=<span class="string">"button"</span> onclick=<span class="string">"alert('hi!');"</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果回调方法返回一个false则会阻止浏览器事件的默认行为</li>
<li>DOM0事件在事件捕获阶段，无法接收事件，即没无法触发事件捕获，但是能够正常触发冒泡</li>
<li>由于DOM0事件的回调属于文档元素的方法，导致无法添加多个同名事件，不过看来兼容性最好</li>
</ul>
<h3 id="DOM2事件"><a href="#DOM2事件" class="headerlink" title="DOM2事件"></a>DOM2事件</h3><ul>
<li>由于w3c推出的1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型</li>
<li>在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型</li>
<li>2级DOM定义了事件传播，在事件传播过程中将会经历3个阶段：<ol>
<li>capturing阶段，即事件捕获阶段，在某个DOM上触发事件时，事件会先从Document对象 沿着dom数向下传递直到触发节点，此过程就是事件捕获阶段，在此过程中可以捕获传播的事件</li>
<li>目标元素的事件处理阶段，此阶段事件到达触发目标，调用回调处理事件</li>
<li>bubbling阶段，即事件冒泡阶段，在目标元素处理完成之后，此事件还会向上冒泡，回传到Document，此阶段与捕获阶段相反</li>
</ol>
</li>
<li>以上就是事件在触发之后的传播过程，可以配合下图理解</li>
</ul>
<p><img src="../images/1719d595e0ad539a.png" alt="img"></p>
<ul>
<li>DOM2 注册事件，可以通过<code>addEventListener(eventName,callback,isCapturing)</code>方法为元素设置事件监听器，参数1为注册事件名不带on开头的string类型，参数2为触发事件的回调函数，接受一个事件对象参数，参数3为是否在捕获阶段触发，默认为false</li>
<li>通过<code>removeEventListener(eventName,callback,isCapturing)</code>方法移除指定事件名、回调、是否捕获的事件，匿名回调无法删除</li>
<li>可给一个元素添加多个相同的事件，通过不同的回调实现不同效果</li>
<li>DOM2中的回调函数中的this指向，由浏览器决定，w3c标准中并未规定其指向，一般情况this指向window</li>
<li>回调函数event对象参数</li>
<li>属性<ul>
<li>type 发生事件的类型</li>
<li>target 发生事件的阶段，为触发事件的对象，可以与currentTarget不同</li>
<li>currentTarget 正在处理事件的节点，即注册此回调函数的元素</li>
<li>clientX，clientY鼠标相对浏览器的x坐标与y坐标</li>
<li>screenX，screenY鼠标相对于显示器左上角x，y坐标</li>
</ul>
</li>
<li>方法<ul>
<li>stopPropagation() 阻止当前事件的进一步传播</li>
<li>preventDefault() 阻止浏览器执行与世界相关的默认动作，与DOM0返回false相同</li>
</ul>
</li>
<li>触发时机<ul>
<li>document 往 target节点传播，捕获前进，遇到注册的捕获事件立即触发执行</li>
<li>到达target节点，触发事件（对于target节点上，是先捕获还是先冒泡则捕获事件和冒泡事件的注册顺序，先注册先执行）</li>
<li>target节点 往 document 方向传播，冒泡前进，遇到注册的冒泡事件立即触发</li>
</ul>
</li>
</ul>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><ul>
<li>事件代理又或是事件委托，通过事件冒泡机制，使用单一父节点来操作多个子节点的响应，简单讲就是把所有子节点的事件去除，只给父节点注册事件，那么就可以通过事件冒泡机制来处理子节点的响应</li>
<li>基于事件委托可以减少事件注册，节省内存，简化dom节点于事件的更新</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"f"</span>&gt;</span><br><span class="line">  &lt;li&gt;a&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;b&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;c&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#f'</span>)</span><br><span class="line">  <span class="comment">// 点击li时触发事件委托</span></span><br><span class="line">  ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 处理元素为父元素</span></span><br><span class="line">    <span class="built_in">console</span>.dir(event.currentTarget)  <span class="comment">// ul#f</span></span><br><span class="line">    <span class="comment">// 触发元素为子元素，event.target为具体触发对象</span></span><br><span class="line">    <span class="built_in">console</span>.dir(event.target)         <span class="comment">// li</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line">  <span class="comment">// 通过点击添加子元素</span></span><br><span class="line">  ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> child = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">    child.innerText = <span class="string">'我是新增的子元素'</span></span><br><span class="line">    event.currentTarget.appendChild(child)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line">  <span class="comment">// 通过点击删除子元素</span></span><br><span class="line">  ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.currentTarget.removeChild(event.target)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">----------------------------------------------</span></span><br><span class="line"><span class="regexp">&lt;!-- 如果点击span 想知道是哪个li下面的元素 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul id="f"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;a&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;b&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;c&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  const ul = document.querySelector('#f')</span></span><br><span class="line"><span class="regexp">  ul.addEventListener('click', function foo(event) &#123;</span></span><br><span class="line"><span class="regexp">    let target = event.target</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 一级级向上寻找直到找到满足条件的元素</span></span><br><span class="line"><span class="regexp">    while (target.nodeName.toLowerCase() !== 'li') &#123;</span></span><br><span class="line"><span class="regexp">      target.target.parentNode</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    console.dir(target) /</span><span class="regexp">/ li</span></span><br><span class="line"><span class="regexp">    console.dir(target.parentNode === event.currentTarget) /</span><span class="regexp">/true</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>以上就是几个简单的事件代理的例子，事件代理能够在我们平时开发中减少很多不必要的代码，优化事件系统，但是在使用的过程也要注意相应的问题</p>
<p>事件代理基于冒泡机制，如果代理层级过多，且在冒泡阶段如果被某层阻止冒泡那么父级将不会收到事件</p>
<p>理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理，所以建议就近委托</p>
<p>如果事件代理了许多情况那么要做好完善逻辑分析，避免一些误判的情况</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1436668936&auto=0&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">165</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
