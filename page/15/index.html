<!DOCTYPE html>


<html lang="en">
	

		<head>
			<meta charset="utf-8" />
			 
			<meta name="keywords" content="life,think,work,blog,code" />
			 
			<meta name="description" content="a place holder" />
			
			<meta
				name="viewport"
				content="width=device-width, initial-scale=1, maximum-scale=1"
			/>
			<meta
				name="google-site-verification"
				content="Xe5wkkWgdmMwA81kCWOHLlJSlYSRE47NKPlVzl8ynK8"
			/>
			<title> Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
			
			<link rel="shortcut icon" href="/favicon.ico" />
			 
<link rel="stylesheet" href="/dist/main.css">

			<link
				rel="stylesheet"
				href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
			/>
			
<link rel="stylesheet" href="/css/custom.css">
 
			<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
			 
 

		<link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>
	</html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
	<div class="cover-frame">
		<div class="bg-box">
			<img src="/images/cover3.jpg" alt="image frame" />
		</div>
		<div class="cover-inner text-center text-white">
			<h1><a href="/">Blog</a></h1>
			<div id="subtitle-box">
				
				<span id="subtitle"></span>
				
			</div>
			<div>
				
			</div>
		</div>
	</div>
	<div class="cover-learn-more">
		<a href="javascript:void(0)" class="anchor"
			><i class="ri-arrow-down-line"></i
		></a>
	</div>
</section>
 
<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

<script>
	try {
	  var typed = new Typed("#subtitle", {
	    strings: ['It doesn&#39;t work...... why?', 'It works...... why?', 'I used to have a life... But Now I&#39;m a programmer.'],
	    startDelay: 100,
	    typeSpeed: 50,
	    loop: false,
	    backSpeed: 20,
	    showCursor: true
	  });
	} catch (err) {
	  console.log(err)
	}
</script>


<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-如何应对经济危机"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/23/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%BB%8F%E6%B5%8E%E5%8D%B1%E6%9C%BA/"
    >如何应对经济危机</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/23/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%BB%8F%E6%B5%8E%E5%8D%B1%E6%9C%BA/" class="article-date">
  <time datetime="2020-03-24T00:03:23.000Z" itemprop="datePublished">2020-03-23</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="历史的见证者不重要，历史的受益者才重要。"><a href="#历史的见证者不重要，历史的受益者才重要。" class="headerlink" title="历史的见证者不重要，历史的受益者才重要。"></a><strong>历史的见证者不重要，历史的受益者才重要。</strong></h1><p>很多人都应该经历过中国房地产神话，但对于没有买房的历史见证人却算不上是好的记忆。</p>
<p>接下来这段时间会是我们这代人千载难逢的机遇，错过了房产的阶层跃迁，希望别放过这次机会。</p>
<p>虽然我知识有限，但我愿意让每个人都能了解世界，让普通人都能接触到未来的机遇。</p>
<p>本文长达万字，将会分为不同板块去介绍这一问题，相信看完所有内容的人会对现在的形势有一个更基本的了解和认知。</p>
<h2 id="本文分为五个部分："><a href="#本文分为五个部分：" class="headerlink" title="本文分为五个部分："></a>本文分为五个部分：</h2><p>一、世界背景</p>
<p>二、危机到来</p>
<p>三、世界机遇</p>
<p>四、中国的未来与机遇</p>
<p>五、机遇时间点与具体操作</p>
<p>需要的人也可以直接翻到自己喜欢的部分。</p>
<h3 id="第一部分：世界背景"><a href="#第一部分：世界背景" class="headerlink" title="第一部分：世界背景"></a><strong>第一部分：世界背景</strong></h3><p><strong>疫情前的世界已经处于一个经济下行的周期了，原因就在于科学技术的停滞创造不出新的生产力，从而导致了企业利润率低下。</strong></p>
<p>目前所有的国家都在延续里根的方法，开始贷款发展，这样就使经济发展加上了助推器。比如说你要开办企业，借钱开就可以，最后用赚的钱来还利息，这样市场上大家都满意，借出钱的人不用付出劳动就可以收获利息，借入钱的人可以有钱开始发展事业。</p>
<p>但所有的借款利息最终是要让实体企业去承担的，在科学技术发展的年代，企业可以用更少资源消耗生产出更多产品（能看懂就好），创造出更多的利润。因此，实际中的产品是越来越多的，每个个体也可以享受到更好的生活质量，整体社会的蛋糕也就做大了。</p>
<p>这个时候，生产力发展产出了更多的产品，也就是蛋糕做大了，这意味着所有人都可以享受其中的红利，只不过那些大资本多一些，个体少一些，但是还是大家都能接受的，这也就是所谓的日子越来越好了。</p>
<p><strong>然而生产力是不会一直前进的，资本的要求却是无止境的。</strong>即使在现在，资本依然要求有10%的利润，但现在企业因为竞争激烈根本就没有那么多利润，可他们依然要去还这个息，那就要开始借钱去还，然后那些收到钱的人再借出去，看上去这个游戏可以一直玩下去，但实际上却不是的。</p>
<p>因为总会有劣质企业借无可借，选择跑路，那么这个链条就开始断了，而且随着时间的推移，资本永远要求更高的收益率，那么越来越多的企业撑不住倒台，然后一些人开始资金链断裂，最后社会这个链条断裂，那就全部完蛋了。</p>
<p>在此过程中，大家要明白资本的复利是恐怖的，富人是会越来越富的，大资本的扩张率要比绝大多数的企业利润率高，个人的积累速度远远赶不上企业。</p>
<p><strong>这就会不可避免导致贫富差距，但不同人消费的比例是不同的。</strong>而对于我这种穷苦人来讲，活着就用尽全力了，赚多少花多少。而富人往往是花很小一部分钱，其他部分投资。</p>
<p>但这样的话会慢慢把钱集中到某些人手里，而这个时候呢，社会消费（下面人钱少）就必然降低，上层人的投资也必然得不到回报，然后这时候大资本还会继续剥削底层人，但如果把底层那些人逼急了，那就推到重来吧（古代土地兼并与朝代更替）。</p>
<p><strong>而其实大部分的时候，通过注入流动性总是可以缓解压力的（美国降息）</strong>，毕竟这是逼着市场的钱不放在银行，而是去流通，这样借钱这个游戏又可以继续玩下去了，如果运气好科技进步了啥事都解决了（空间换时间）。</p>
<p>市场流动性最重要，你拿5块钱买了肉，屠夫拿5块钱给了孩子，孩子去消费这5块，你再靠卖东西换5块，如此循环，完美的事情。</p>
<p>其实如果没有疫情，世界应该大概率还是处于慢慢走向玩不下去的状况。</p>
<h3 id="第二部分：危机到来"><a href="#第二部分：危机到来" class="headerlink" title="第二部分：危机到来"></a><strong>第二部分：危机到来</strong></h3><p>这个疫情，二十一世纪目前最大的黑天鹅，让这个游戏玩不下去了。</p>
<p><strong>1.疫情的来临</strong></p>
<p>所有人都不敢出门，那就没人消费了，企业赚不到钱，就要开始缩减成本，不管裁员还是不干，由此这些员工收入也没了，也就没办法消费了。</p>
<p>这是异常糟糕的恶性循环。</p>
<p>这时候企业一边支付着房租、人工的费用，一边还没有收入。那很多企业干脆就不干了，原本正常的时期，这些企业不干，会有其他企业会占据他离开空出去的市场，但疫情下，不好意思，全都不能干。</p>
<p><strong>正常市场上是供大于求、产能过剩。而现在暂时变成了部分市场供不应求，缺乏产能，部分市场供大于求，缺乏市场的尴尬状况，很麻烦。</strong></p>
<p>但如果人的收入受到了影响或者看到了其他人受到收入减低影响，从而因为保守不敢消费，所以一些非必需品（手表、奢侈品、旅游）就不买了，那么这些企业收入就低，不敢产出所以产出少，这些行业的人收入就会受影响，从而消费继续遇冷。</p>
<p>但是所有人，包括那些受影响行业的人，还得买必需品（肉、蔬菜），所以生活必需品涨价，其他东西全面下跌。<strong>基础物价涨价，钱变值钱。</strong></p>
<p>至于大家都关心的房价，醒醒，全球所有资产都在跌，你觉得房子还涨吗？</p>
<p><img src="../images/v2-aafa384587e259b55282e216d79900cd_1440w.jpg" alt="img"></p>
<p>目前就处于这个情况了，前一段咱国内一片嗷嚎遍野也是这个问题，但是当时美国“有利于制造业回流”。现在，咱结束了，世界却开始了。</p>
<p>对于目前这个形势，全世界目前陷入了比差的阶段。咱现在看外国热闹，其实不是咱现在崛起了，而更多是咱现在没他们差（比烂的世界大家都过不好）。</p>
<p><strong>2.危险的应对</strong></p>
<p><strong>不要让国民熬过了疫情，却扛不住失业。</strong></p>
<p><strong>仔细看咱国内：</strong></p>
<p>出口方面：外国疫情，抑制出口（标注：咱出口可不是只是出口口罩，还有许多其他东西的）；<br>消费方面：出口受挫影响外贸制造业企业收入，进而影响员工收入，影响消费；<br>投资方面：现在传统基建已经被放弃，新基建目前也只是个概念，市场也在观望着炒，收益更是薛定谔的猫存在。</p>
<p>总结一句话：虽然有咱政府的强力管控物价整体可控，但是因为国际形势预期不好，危机必然来临。</p>
<p><strong>应对措施：</strong></p>
<p>虽然我在鼓励大家疫情后多消费，但真的希望大家有多大锅下多大米。<br>第一步，先看看自己存款以及贷款情况；<br>第二步，然后看看自己收入以及预期；<br>第三步，检查自己直系亲属身体与潜在未来花费（投资重要，人更重要，不要迷）；<br>最后一步，看自己的能接受的投资额度（这决定了接下来的机遇你能吃到多少）。</p>
<p>还有那句话：这时候加杠杆抄底是高风险的。</p>
<p><strong>几点意见：</strong></p>
<p>第一，不管任何行业，都最好不要裸辞；<br>第二，这个时期，不要加杠杆（贷款），很容易被波动弄没；<br>第三，本身风险很大的尽量不要再加杠杆上风险了，未来大概率不好过；<br>第四，要适度投资孩子的教育。家长很容易陷入孩子误区：要给孩子最好的，不能让他比别人差，但其实父母才是孩子的门面，先让自己比其他家长强，再根据孩子的天资去发展。</p>
<p>如果学生党，仿照这四步问问父母，了解一下家里财务状况，不要自己在网上重拳出击，让父母现实中节衣缩食。这时候懂点事，如果家里有困难，多多考虑考虑家里，很多不必要的东西可以不买，花呗消费能不消费就不消费，不要让父母承担你讨好朋友或者炫耀的代价，甚至可以在不影响学习的前提下想办法兼职赚点钱。</p>
<p>记住一句话：虽然我鼓励大家消费去帮助国家经济迅速回复，但是找好定位，不要被消费主义影响，不要当着韭菜却想着为国护盘光荣，富则达济天下，穷则独善其身，国家远远不需要你“舍身取义”。</p>
<p>如果上述风险很高，先别想着机遇了，先活下去。</p>
<p><strong>忠告：</strong></p>
<p>没有很多投资经验知识的人，建议只去碰最稳妥的投资。尤其像我以前这样不知道天高地厚的年轻人。觉得自己看懂了一个K线、涨跌指数，然后在网上看了看股票常识就开始操作了，凭借着偶然的运气在市场上赚了点小钱，于是觉得自己会了、行了。然后感觉自己就是下一个巴菲特……</p>
<p>打开天窗说亮话：小年轻懂个锤子投资啊。</p>
<p>投资看得更多是天赋、心性、策略、经验跟执行力，人至少要经历一波牛市一波熊市才能说自己毕业了，而且不经历实盘的磨砺以及那种时时刻刻想止损止盈的复杂心理是很难成长为好的投资者。</p>
<p>投资是一种人性、信息获取的博弈。</p>
<p>牛顿也陷入过庞氏骗局，很多高学历金融专业人自己也会陷入投资困境，投资既要学会大胆，也要学会忍受长期可能存在的高波动，要能有随机应变能力以及要有甘愿做冷板凳的心，甚至要忍受各种人的不理解，坚持自己的理念。</p>
<p><strong>对市场常怀敬畏之心是每个投资者必须具备的前提。</strong></p>
<h3 id="第三部分：世界机遇"><a href="#第三部分：世界机遇" class="headerlink" title="第三部分：世界机遇"></a><strong>第三部分：世界机遇</strong></h3><p>再说机遇吧，美股以及全世界股市的下跌确实是市场千载难逢的机遇，最起码这波过去的话，未来二十年不会有这样的机会了。</p>
<p>而这次机会，不再是像当年中国无脑买房就能跟上了，需要知识的积累。</p>
<p>我先讲讲这次机会是啥吧，省的大家成天跟着大佬们高喊机遇机遇，其实自己啥也不知道。但说实话，往往机会是给有准备的人的，比如巴菲特（1280亿现金）。</p>
<p><strong>顺便感叹一下，以老爷子这个年龄，钱对于他的意义已经不大了，他所追求的就是人生最后阶段在这个市场上再证明自己一次，这种对市场的兴奋，交易的渴望以及事后证明自己的感觉是每个投资人的梦想。</strong></p>
<p>这个机会来自于流动性缺失，世界资产会疯了一样往下掉，这几天如果观察过世界各项资产的都知道，全世界资产都在下跌。而这个时候，现金为王。</p>
<p>现在世界在疫情的影响下出现了一个很奇怪的现象，市场上无论如何降息（让市场钱便宜起来，逼大家拿钱去消费），无论如何放水（印钞票进去）。市场的流动性都起不来，这也因为受疫情影响，大家现在都觉得现金最靠谱，世界资产近期都在跌，相对应的现金就值钱了。</p>
<p>基本这个时代有时候买入资产升值快（过去买房），有时候持有现金好（现在等资产跌），而能把握这一点的才是真的人中龙凤。</p>
<p><strong>1.普及印钱概念</strong><br>顺便说说国家印钱这件事吧，在经济发展劳动生产率提高的时候，适当往市场内印钱能让更多人享受到经济发展的益处，而且投放正确能减少点贫富差距。</p>
<p>但无休止的印钱就坑爹了，在社会社会整体产品没有大增长的前提下，政府每一次印钱，都是在稀薄所有人手里钱的购买力，这样举例子让大家理解一下。</p>
<p>大家手里有50块，市面上50块肉，一块钱对应一块肉。</p>
<p>官方印10块，市场上共有60块，生产力上涨了，市面上有60块肉，还是一块钱对应一块肉（大家还能接受，官方就吃了本来每人0.2的肉）。</p>
<p>假设官方印50块，市场50块肉，那么等于每个人手里的钱只能买0.5块肉了。</p>
<p>这就是剥削了，本来如果是金本位还不明显，毕竟黄金印不了嘛，但是各国政府发现印不了钱这政府运营太难了。行吧，大家都统一点，淡化黄金，发行纸币，国家信用背书（担保），醒醒兄弟，看看这一段美联储有个毛线信用（而各国还是疯狂屯黄金，毕竟人类几千年的用脚投票…..）。</p>
<p>所以说美国为啥牛X呢，印钱总比赚钱容易啊，基本可以解释为中国辛辛苦苦赚钱，美国辛辛苦苦印钱。</p>
<p><strong>2.普及收割概念</strong><br>然后再说收割的问题，最近看着收割这个词频率极高，但我发现好多人都不懂这是什么意思。</p>
<p>疫情是会过去的，这一点毋容置疑。</p>
<p>而疫情给每个国家带来的影响是不同的，大家不要看着美国股市这一点花式下跌，外围市场更是跌的惨不忍睹，更过分的人家美国这次印完钱放完水美元还是升值了。</p>
<p><strong>这是因为国际市场相信美元资产抗跌，而且美元流动性强，虽然人民币在这次疫情中可能表现得更好。</strong></p>
<p><strong>当然关于美元汇率波动的原因众说纷纷，有人说基金爆仓需要回美国，有人说各国美元荒原因，还有人说美国保护汇率，我个人还是倾向这点，但这不影响大家决策。</strong></p>
<p><strong>现在美元这汇率谁能保证自己百分百确定才有问题行吧，这时川普都不一定能决定，处于多方角力过程，我只是个人倾向。</strong></p>
<p><strong>但是还有一点吧。</strong></p>
<p><strong>市场上，错误的共识也是共识。</strong></p>
<p>但是由于我们保护我们经济安全的原因，人民币的流动和国际化一直是个问题。</p>
<p>这个政策在过去几十年保护了我们弱小的时候不被人收割，却也限制了我们变成世界货币，但是今年4月份可能会有新的变化。</p>
<p><strong>而抗跌看什么</strong>？<strong>看优质资产价值。</strong></p>
<p>例如，苹果再跌也不会比小米差</p>
<p><img src="../images/v2-4006ccb665d23a50a8c8d54e7eadb067_1440w.jpg" alt="img"></p>
<p><img src="../images/v2-4a883053d1c5a4722c8f070cae191d82_1440w.jpg" alt="img"></p>
<p>除去不合理的估值，这些资产有本身的价值，比欧洲以及其他股市要抗跌的多，而且就算跌的时候美国也可以印钱直接买股票托住股价（我印钱去买我自己）。</p>
<p>或者说，当美国股价跌的比其他国家多的时候，我就开始打一仗，让你强行跌的比我多，没办法，拳头大就是这么为所欲为（强大的军事实力是一切的保障）。</p>
<p>甚至美国可以在世界各国资产（股市、房市）暴跌之时，直接买下这些资产。</p>
<p>最骚的是，由于人家是国际货币，甚至直接可以印钱去买（当然无限地印钱会加剧世界对他的不信任，但没办法，美元霸主就是有这么个天然优势）。</p>
<p>而且等经济复苏了，美国作为全球经济的老大，一般来说会率先复苏，这时候其他国家发现他们的股市、楼市低价的时候都被美元买了，甚至有的核心公司还被控制了，一波收割就这么完成了。</p>
<p>看到这里，那些鼓吹美国不再强大的人好好想想，那是美国，在近百年历史中只要这个危机蔓延到全世界，美国最终会把危机转移到其他国家的。</p>
<p>当美元还是世界货币，美国还有那么多军事基地，还占据了那么多科研优势的时候，你给我说美国不行了………醒醒。</p>
<p><strong>尊重对手是打败对手的前提。</strong></p>
<p><strong>3.中国的窗口期</strong><br>虽说近期世界及中国经济遭受重创，但这确实是中国难得一遇的窗口期，因为随着美国的发展，美国已经看不上这些中低端制造业了，而且以往经验是美国把所有中低端制造业分给不同的国家，然后美国可以压价。</p>
<p><strong>但事实上，中国把几乎所有的中低端制造业给价格垄断了，走的依然是农村包围城市那一套。</strong></p>
<p>因为民众绝大多数还是使用普通产品居多的，想想为什么优衣库能席卷全球，为什么拼多多能异军突起，那些何不食肉糜的知乎用户是理解不了底层人民的，这些沉默的大多数才是这个社会真实的写照。</p>
<p>所以疫情来了，咱发现咱几乎啥都能生产，所以能打这一仗。</p>
<p>而全球化下的美国制造业已经不可能回流了，印钱就能解决事情，资本为啥要舍弃高利润？但是人家还是有办法，我去抢，中国我惹不起，意大利我还是能搞定的（大国小民出来下，我当你面把你人民救命药给你拿走了？你敢拦截我）。</p>
<p>所以美国发现基础产品会在关键时候（疫情或者说可能的战争）让我们卡了，这一点不要高潮，美国不是制造不出这些东西，而是他们制造出来成本太高了，资本主义美国不能接受这一切。</p>
<p>所以在现在各国都纷纷陷入抗疫这个泥潭里。这里说一下啊，本来这些国家不打算管疫情，要保护经济，但是各国的人民群众用脚投票了，你不管疫情，股票就崩，你管疫情，股票就稳住，各国政要们兜兜转转发现，保经济就得管疫情，也算是民意挟持着资本去打了这一仗吧。</p>
<p>无疑，我们的复工暂时处于一个卖方市场，这时候可以拿很多东西来交换。</p>
<p>而且欧洲各国也不傻，老被美国收割也不是事啊，我们得看看有新大腿可以依靠没有，好，目前这个人就是中国。</p>
<p>这时候的站队就是投资，所以中国对站队的意大利才如此慷慨解囊。</p>
<p>但其实他们也在犹豫，他们跟美国很久了，美国能给他们利益，但川普这一任的做法抛弃盟友其实深得我心（支持川普连任）。而中国目前军事能力保障不了欧洲的核心利益，甚至中国自己目前军事能力也保障不了自己绝对的能源安全。</p>
<p>我们在近些年疯狂补我们军事能力短板也在这里，没有实打实的拳头，你跟人家谈啥，人家不信啊（强军之路不能停）。</p>
<h3 id="第四部分：中国的未来，机遇所在"><a href="#第四部分：中国的未来，机遇所在" class="headerlink" title="第四部分：中国的未来，机遇所在"></a><strong>第四部分：中国的未来，机遇所在</strong></h3><p>说完了这些个背景故事，来说说本次的机遇。</p>
<p><strong>1.以美国为首的降息、印钱已经把流动性跟钱扔在市场上了，这些钱疫情过去是很难收回来的，现在是现金为王，这波过去立刻就是一场全球大通胀。</strong></p>
<p>这个时候很多股票、资产都将处于他未来几十年的低位，所以在这个时候购入这些资产，在通胀时就能最大程度增长个人的财富。</p>
<p><strong>2.我们也可以顺势收割收割其他国家，顺便在这个时候用人民币打开局面。</strong></p>
<p>在美元这么疯狂注水的情况下，其他国家必然会找到新的货币作为对冲，而人民币对应就是中低端产品，是实打实能买回来的东西，在这个过程中，会有更多国家会考虑跟我们签订货币互换协定的，这让国际逐渐通过这次疫情看到中国市场的潜力与稳定性。</p>
<p><strong>3.而之后中国这头沉默的雄狮没有机会再装小白兔了，我们必然会走出一个新的道路，必然会迎来一个全新的发展阶段。</strong></p>
<p>目前关于中国未来发展的各种分析五花八门，什么大中华东亚圈，什么亚元之类的，这些分析，我承认确实有道理，但我选择给大家说一个不管怎么发展都绕不开的路，而且与个人发展息息相关的。</p>
<p>如果国家即将往上走，那么我们必然会效仿美国那条路，走消费主义，所以分期消费在未来必然会普及，我们国家必然会走向高消费低储蓄的道路。</p>
<p>从那一刻起，家庭配置资产问题在未来一定成为一个潮流，那个无脑买房的时代已经过去了，而在未来，家庭资源的配置将会跟个人选择的综合性投资方式挂钩，只要国运仍在，我们仍会一定会走到这一步的。</p>
<p>我们现在是生产国，美国是消费国。</p>
<p>等我们什么时候变成生产国又变成了消费国了那就厉害了（虽然他有点矛盾）。</p>
<p>每代人有每代人的机会，过去几十年的机会在房市。</p>
<p>未来的机会在资产配置，大概率在金融资产。</p>
<h3 id="第五部分：机遇时间点与具体操作"><a href="#第五部分：机遇时间点与具体操作" class="headerlink" title="第五部分：机遇时间点与具体操作"></a><strong>第五部分：机遇时间点与具体操作</strong></h3><p>战略之后我再说说战术，这波机会目前大概率会分为两步。</p>
<p><strong>第一个机会就是未来这段时间到今年下半年或者明年这波行情，大概率会与疫情发展阶段挂钩。</strong></p>
<p>疫情下各国都如同不要命一样撒币，就像咱红色，看上去与世无争，这段时间也陆陆续续放了几万亿到市场上了。</p>
<p>咱就不说大统领了，一顿降息猛如虎，再加上不要命地印钱进市场。</p>
<p>欧洲市场大家不关心，但也都是一个套路，我降息，我印钱，玩命地印。</p>
<p>说实话，现在各国印钱就是在保命，但这些印出的钱没有提高生产力，没有匹配增长的产品，到最后总归是要反噬它们的。</p>
<p>疫情的时候，市场的流动性还低一些，这些钱还好，疫情过后，这些印出的钱以及降下来的息会在极快时间来一波世界级别的超级大通胀。</p>
<p>通胀之下无负债，全球普通民众会再一次被收割。</p>
<p><strong>但是这个机会就在于，如果在这个时候能用现金吸收一点资产，那么到时候资产会快速攀升，这就是市场所说的机遇了。</strong></p>
<p>以下提出几点措施。</p>
<p><strong>策略一,买入股票或者基金。</strong></p>
<p>这几个月谁有现金谁是老大，过几个月谁拿现金谁是弟弟。</p>
<p>市场就是这么魔幻，但是也不是说你买啥都能涨。</p>
<p><strong>投资这个东西，不谈标的和入场时间，就是耍流氓。</strong></p>
<p><strong>对于基金来说：</strong><br>目前大家都再说大盘大盘，还是那句话吧，大盘决定了市场的信心与恐慌，但现在的市场个股才是王道，当然普通人买行业基金ETF也可以。（这个百度下吧）</p>
<p>买基金的话重点看他的方向以及他的成分股，以及这个操盘人的水平。</p>
<p>但是行业ETF就不说了，就提几个未来几年的吧。</p>
<p>编个顺口溜：</p>
<p>短期看消费，长期看体育；</p>
<p>科技半导将领涨，银行券商看周期。</p>
<p><strong>对于个股来说：</strong></p>
<p>熊市不言底是正确的，在市场上没有人能告诉你啥时候是底部。</p>
<p>但你要好好研究了之后，你会发现个股是有底部的，当他跌到一定程度是不会再跌了的，在市场上没有任何人能吃到整条鱼。</p>
<p>在你研究了这支股票之后，你感觉他满足了三点：</p>
<p>1.稳定的现金流以及盈利能力（产品护城河）。</p>
<p>2.历史估值属于低位，且股息还不错。</p>
<p>3.市净率比较低。</p>
<p>这一块说说啊，银行股虽然市净率低，但对应的抵押物都是房子（也反应了市场对房产的信心），不要碰。</p>
<p>就算是前一段90块价投平安保险的，长期看也有希望的。</p>
<p><strong>策略二：如果对这些一无所知，那就无脑黄金白银。</strong></p>
<p>买白银黄金吧，更建议白银。</p>
<p>依据逻辑如下：</p>
<p>1.黄金白银比历史稳定在1：50到1：100之间，目前白银已经跌破这个点位了。</p>
<p>2.白银目前计价售价已接近成本。（成本美元计价11块多）</p>
<p>我写这篇文章的时候，白银11.8美元。</p>
<p><img src="../images/v2-f8b577dc46206617cbf73a3419c8c9e1_1440w.jpg" alt="img"></p>
<p>这张图不是我让买的时候的价格，是我文章写后涨了的价格，别误会。</p>
<p>把他当成比特币，买了别看就行，真卖的时候要看自己倒时候学会与否。，如果到那个时候还是听着别人买与卖，那就放弃投资吧。</p>
<p><strong>策略三：买房，虽然不建议。</strong></p>
<p>投资是一个很复杂的东西，没有人可以告诉你什么时候入手，什么时候卖出。</p>
<p>投资这个事情不要在知乎上，不要在别的问答上听推荐。去买些好书，了解这个市场。</p>
<p>更不要被那些机构蒙骗，最终走上了私盘大宗商品期货的道路。</p>
<p>对于普通人来说，牢记几点。</p>
<p>1、不轻易加杠杆。</p>
<p>2、不做短线，不频繁交易。</p>
<p>3、形成逻辑，纪律比一切都重要。</p>
<h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a><strong>结语：</strong></h2><p>我们见证了历史，我们即将成为历史的受益者。</p>
<p>这次的机会，很多人等了很久，本来预计的美股出现问题会在未来几年，但最近一年内，市面上很多年化率百分之十几的信托（可以返点的），没有选择入手，而选择放到货币基金吃着可能4%左右的利益，少着很多的收益。</p>
<p>等的也就是这次机会，如果不是这次疫情，可能会继续忍受美股在高位上涨而错过机会。</p>
<p>对很多人来说，这是历史，但对一些人来说，这可能是又一次改变命运的机会，在市场寻找标的，衡量风险，每天看盘掌握新的市场动向，不曾一次对投资逻辑进行考量，忍受着一天剧烈波动。</p>
<p>终于，等到了这一段时间。</p>
<p>但如果你没有预见到这次机会，没有为此付出努力去积累知识，你依然可以通过我这篇文章在这次机遇中抓住机会的，成为历史的受益者而不是见证人。</p>
<p>但无论你是否错过了这次机会或者开始尝试接触，都最好开始学习理财的知识，在未来十年抓住这些机会，抓住国家发展的这十年的机会。</p>
<p>耕种的季节即将到来，有些人费劲心血才终于在疫情来等到了这个机会。这个时候对于这些人是收获的季节，而机会总是给有准备的人。</p>
<p>而如果你手里恰好也有现金。</p>
<p>那你也可以是这次疫情的受益人，但要有知识为储备。</p>
<p>如果不是，为下一次做准备。</p>
<p>但其实就算你侥幸从市场里赚到了钱，只要你在吃足了这次甜头后好好补补知识你也能守住自己的财富，或者你吃完一波就再也不接触也可以。</p>
<p>但你如果贪心，继续交易，那你凭运气和冲动赚的钱总是会被市场用其他办法给震荡掉的，这个市场不缺聪明人。</p>
<p>只有最聪明的人以及有大智慧的人才能在这个市场能赚到钱。</p>
<p>人生也是一样，与君共勉。</p>
<p>我没有用什么复杂的句子，我也不想说些高大上的分析。</p>
<p>投资一样，花里胡哨的投资策略都不如实实在在沉下去。</p>
<p>最简单的，就是最好的。</p>
<p><strong>在市场里，没有一夜暴富的神话，只有厚积薄发的收获。</strong></p>
<p><strong>补个几句：</strong></p>
<p><strong>1、别光看见机遇，危险也存在。</strong></p>
<p><strong>2、高杠杆知道但不讲，快钱不碰。</strong></p>
<p><strong>3、我只是给个思路，具体操作自己要看，我没有给任何个股推荐，没有提及任何基金，只是给你们了一个我的逻辑和一个相对稳妥的看法，不要觉得现在就是底部，我甚至不给你们放好物推荐的链接说看那些书（事实上违规太多放不了…..）就算是建议白银你们也是在银行啊….我也没有说在我这买，没有私心，只有分享，希望大家都能理性对待。</strong></p>
<p><strong>4、介于这两天问我白银的人太多了，其实是建议分阶段分仓买的，而且黄金也是不错的标的，不过从我感受到市场狂热的情绪，我打消了我心里A股长期慢牛的想法。但是说实话，如果你看了我这篇文章，没有自己好好去了解黄金、白银的逻辑就打开银行购买的话，其实是很不适合的，多研究再下手最好，永远不要在自己不懂的领域贸然进入。而且这个时候市场很不稳定，你可以先下场，但不要把子弹打光搜哈进去，然后再骂我。至少有一点我是确认的，黄金百年收益率6%，相对跌了你们也能稳住。</strong></p>
<p><strong>5、还有很多人说如果看到我写这篇文章就买就是抄底，抄到了2.7块人民币的兄弟，这两天就涨了，说我眼光多毒。那我要说一些，恭喜你们第一笔投资取得收益。但这种想法不好，我认可白银只是他符合我的逻辑，而不是想着他是就是所谓的底了，不要看这些短期的震荡，过于在意短期的涨跌对普通人来说毫无意义的。</strong></p>
<p><strong>还有不要听银行人买黄金、白银T＋D，只买纸黄金、纸白银。</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-世界是否过度依赖中国制造"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/22/%E4%B8%96%E7%95%8C%E6%98%AF%E5%90%A6%E8%BF%87%E5%BA%A6%E4%BE%9D%E8%B5%96%E4%B8%AD%E5%9B%BD%E5%88%B6%E9%80%A0/"
    >世界是否过度依赖中国制造</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/22/%E4%B8%96%E7%95%8C%E6%98%AF%E5%90%A6%E8%BF%87%E5%BA%A6%E4%BE%9D%E8%B5%96%E4%B8%AD%E5%9B%BD%E5%88%B6%E9%80%A0/" class="article-date">
  <time datetime="2020-03-23T00:30:24.000Z" itemprop="datePublished">2020-03-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>是。更是好事。</p>
<p>年初因为春节与疫情的双重空档，我们在全球化工产品上的供应出现了一个大断档，这导致美帝的制药业在生产上出现停摆，一些病人因为无药可买陷入困境。</p>
<p>可想而知，一系列美帝政客立马打了个旗号：“夺回供应链”，并要求政府支持。这个口号在3月初进入高潮，配合疫情的全球蔓延，很是抓了一把眼球。</p>
<p>当然，这就是来诳国会的定向补贴的，和美军整天向国会老爷嚷嚷解放军天顶星战斗力是一个套路。</p>
<p>共和党一边拿供应链问题向国会要钱，一边唱川皇的赞歌，证明川皇贸易战搞脱钩的英明神武。如果不是疫情在美帝那炸了，那么这个故事才是三月份美帝的原定剧本。</p>
<p>但我个人认为：让全球都深度依赖中国供应链，最符合我们的核心利益。</p>
<p>有些观点不管私信里多少人骂，我还是没变：</p>
<p>要孝子送终式的图穷匕见，而不是一放就软一抓就泄。急吼吼的那是雏，没经验，只会过早交货；老手要的是适应节奏均匀呼吸，陪跑到最后。</p>
<p>天天以自己是政治点数加满的古国自豪，一到键政口嗨就掉头昭和去了？</p>
<p>我相信从局座到政委到温老爷子他们反复强调的“战略定力”，不相信公众号们的大标题。情绪大家都有，但是情绪不能形成有效的战略。</p>
<p>当前局面，和过去的游牧农耕对抗没有根本变化，依然是各自生产方式所决定的结构性矛盾。</p>
<p>我们作为工业时代的制造国，本质就是这个时代里的农耕文明。我们采买、生产、销售，依靠的是成本效率优化与科技改良，并不掌握资源的定价权与市场准入许可。</p>
<p>而美帝作为工业时代的金融国，通过武力与科技确保了全球货币与资源定价权。这导致美帝能在我们每个环节上收取铸币税，减少我们整体的收益积累，并通过收益落差来吸纳我们艰难攒下的资金与人才，极大减缓我们自身科技研发与社会福利的增长速度。</p>
<p>所幸我们的体量与农村的牺牲，保证了基础积累的成功；教员留下来的遗产，保证了基本的独立性与自卫能力。所以我们虽然一直被收割，甚至还要送钱给外国人去消费本国产品，但好歹攒下来的那点，大头还是在自己手里。</p>
<p>亚洲很多制造国没有这些，就要承受一三五搬砖赚点存点，二四六匈奴南下抢一把再烧一遍，周日找只替罪羊宰了，下周再来一遍的历史周期循环。</p>
<p>这个从白登之围到封狼居胥的过程，最考验战略定力，因为你既要忍耐，又要发展。</p>
<p>八爷打航母，难道不是天子不能具钧驷将相或乘牛车？60分钟上的咄咄逼问，难道不是冒顿单于问娶吕后？换做当时，精汉（不对我是实汉）可以天天震怒，但怒就可以勒石燕然了？</p>
<p>不是没有人瞎怒过，仓皇北顾在史书里多了去了。</p>
<p>结构性矛盾就要用结构来解决。</p>
<p>匈奴是游牧民族的联盟，是一个概念，里面成分繁杂，白匈奴了解一下。这个概念能团结草原上的诸多民族，是因为这概念能让他们集体南下打草谷，抢来多多的财粮女人回家分。</p>
<p>所以只要一边让他们不能打，一边让他们分不够，这个联盟就会自然瓦解，强大的力量在内斗中耗尽，给农耕文明一波定局的机会。</p>
<p>身为制造国，供应链就是我们的结构优势，是我们在工业时代延续农耕防反专精的底牌：</p>
<p>全球越依赖我们的供应链，他们自身的产业空心化就会越严重。失业的蓝领会加大国家的福利成本，并且使得整个政府政策越发倾向保守；</p>
<p>本国年轻人在教育上也会更追求高收益的金融与文化产业，基础科研的脑力将越来越依赖外部；</p>
<p>虚拟经济会高度繁荣，在收益率上与实体经济拉开强烈落差，进一步削弱本国发展实体的欲望；</p>
<p>缺乏实体应用的高端技术最终会流失向有需要的他国实体，抑或因缺乏应用闲置太久，先发优势被他国的投入所追平甚至赶超；</p>
<p>虚弱的实体相关者——多数为普通民众与拥有强势行业的地方——与被虚拟收益所捆绑的精英及中央政府，会在认知上产生巨大鸿沟；</p>
<p>一旦中央政府无法继续维持虚拟的高收益，结构性矛盾爆发，匈奴这个联盟就会开始瓦解。</p>
<p>拥有强势工业的地方能够继续输出有竞争力的工业产品，会谋求与外部的和平，保证正常贸易；</p>
<p>捆绑虚拟收益的中央政府和金融精英会用一切手段维系高收益率，当往高抬抬不动时，就会去把别人的收益率砸低，这往往意味着对外冲突甚至战争；</p>
<p>被国家视为负担、徘徊在虚拟经济和强势工业之外的普通人，会陷入巨大的认知混乱，并被宗教、种族、传统等感性概念收割吸纳。</p>
<p>有的南附，有的西迁，剩下的力量不够打不了草谷，就要开始忍受白毛风。</p>
<p>陈平教授的很多观点在经济学上有巨大争议，不予置评。但是他认为美帝空心化再继续下去，united states可能会变成divided states，我赞成。</p>
<p>什么叫阳谋？这种结构性对抗就是阳谋。</p>
<p>所以这个过程极为难受，因为对方不傻，对方知道你要这么搞。</p>
<p>对美帝来说，就算明知制造业不能回流，那么能把中国的制造业打碎流到可控的第三国，也是胜利，因为第三国都可打草谷收割，保证能一直分到足够的钱粮女人。</p>
<p>中国的产业不是把成本效率优化得很好吗？那高端封锁，打击中国制造2025，降速；低端扶植东南亚，劳动密集性做来多low多不环保，转移出去吧，我有一堆金融机构手把手教你；中端上贸易战，全面拉高你的成本，让你大量工业门类要么自己关门，要么求助国家，增加你总体成本。</p>
<p>这就是为什么印度的污染不被骂、泰国的血汗工厂是发展象征、孟加拉的山寨不叫抄袭。多数，都是打击你成本效率优化的借口。</p>
<p>万一我们没顶住陷了，印度起来了，这些帽子会原封不动给印度再戴一遍。</p>
<p>其次，一手是全力打压实体，一手是大力鼓励你金融开放。来呀，靠产线做工来赚钱多累，房租贷要不要玩？二次衍生投资产品赚得多不多？你不会玩不要紧，打开门，我教你玩。</p>
<p>将美帝那套成熟的虚拟经济玩法引进给我们。我们在虚拟经济里赚了钱？没事，你人民币还是看着我美元发行的，你在虚拟经济中滚出来的数字越大，你对我美元的需求就越高，我全球货币的地位更加尊崇。</p>
<p>另外，你实体失血就好。你也成虚拟经济了，那么一旦你波动，资本还不是回到全球货币的大本营——美元这。</p>
<p>某种意义上，对方也是阳谋。</p>
<p>两边都是摆在台面上，美帝明说不许中国制造2025，我们也明说稳定全球供应链，这是正式进入拉锯的信号。</p>
<p>我们希望耗，耗到美帝决策理智又消减，虚拟收益又迷了眼，转头回去吸大烟，继续空心化。</p>
<p>美帝希望我们急，制造一个不是核战争但是能足以公开切断我们供应链对外流动的局面。</p>
<p>一般来说，东南小岛。</p>
<p>我们的回应是：别的骂阵我可以忍，这事我们当核战争来看。</p>
<p>美帝再回：那我可以表演一番让你拿走，但你全球供应链的地位我一定要趁机搞掉。</p>
<p>这是当下焦点。</p>
<p>东南小岛不是我们想不想的问题，就算我们不想现在动手，美帝也会怂恿小岛，逼着我们动手，因为美帝要这个机会切断我们与世界的联系。</p>
<p>所以干脆顺水推舟：既然你要拿小岛做借口，小岛又是我的合法性，干脆我先说，等你出牌。</p>
<p>问题是之后我们的全球供应链怎么办？</p>
<p>丧失外部市场和投资，巨大的过剩产能和资金断链会严重反噬我们自身，这是最最经典不过的经济危机。一旦发生，那就是真正的中国版中等收入陷阱。</p>
<p>所以要打通一条通往欧洲的路。</p>
<p>一带一路，海上多是以全球为目的，陆上基本是欧洲。和平时期海上的收益高于陆上，但万一海上通路被封锁了呢？</p>
<p>我们离芬兰就隔着一个俄罗斯。</p>
<p>全球供应链是我们的命门，这里故事太多，说不完。就当下而论，不厚道地讲：</p>
<p>欧洲疫情是机会。</p>
<p>是的，宏大叙事就是这么让人丧失人性。因为国际社会没有法则，也就没有多少善良的空间。</p>
<p>疫情加重了欧洲对我们供应链的依赖，为我们在特殊时期的产能输出再加一码。我们在特殊时期过剩产能的压力越小，美帝借东南小岛搞掉我们全球供应链的效果就越差。</p>
<p>最后在一个投入产出比的节点上，美帝退出拉锯，继续吸大烟。直到德克萨斯孤星国和加利福尼亚共和国不再是一个笑话的那一天，真正的机会才算到了。</p>
<p>在那一天之前，本质都是乖乖上贡的孝子。继续补贴海外消费者，继续开放金融管制，继续忍受美元的铸币税。</p>
<p>觉得难听？那就想办法上贡得少一点，引导美帝去多抢别人，然后多给他送点大烟。</p>
<p>那是肉食者谋了，某不敢多言。</p>
<p>当然，键政侠意淫一把国师，口嗨的画面往往很美好，往往不可能。</p>
<p>因为就算上面可忍，庞大的民意恐怕也过了愿意忍的阶段。日本当年又是和解苏联又是疯狂用贸易稳住美帝，不就是眼馋英法的亚洲势力范围么？</p>
<p>没忍住。</p>
<p>孝子没忍住怎么办？</p>
<p>只能入关了。</p>
<p>父慈子孝，不也恰如大明建州么？</p>
<p>没想到写着写着，又能为嵩学增加一点素材。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-监守自盗影评"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/22/%E7%9B%91%E5%AE%88%E8%87%AA%E7%9B%97%E5%BD%B1%E8%AF%84/"
    >监守自盗影评</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/22/%E7%9B%91%E5%AE%88%E8%87%AA%E7%9B%97%E5%BD%B1%E8%AF%84/" class="article-date">
  <time datetime="2020-03-22T04:16:05.000Z" itemprop="datePublished">2020-03-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>这部电影很牛X。牛X的地方第一点是思路很清晰，虽然各位编导明显是选定了边站定了位，只是“论述自己的观点”的干活，但是人物采访数据分析，从华尔街，到政府，到经济学家，时不时地用胳膊肘捅观众一下，不太明显不是很故意，但效果毕竟是达到了。牛X的第二点是出场人物都很大牌，涉及美国高级行政人员，顶级银行家，金融分析师，大学教授，甚至新加坡，中国，法国的政府官员等等。从记录片，甚至可以说从discovery的角度，这都是一部很好的电影。对于有意研究金融的同学，有意研究危机的同学，有意研究金融危机的同学，甚至只是有意想要投资股市投资房产以抵抗通膨的同学，这都是一部深入浅出，信息丰富，分析明晰，概念清楚的资料/教学片。</p>
<p>说起美国这个国家，是个很神奇的国度，被很多人向往着，我则从来觉得“还好”，大约在经济发展之类的问题上我是个很保守又不思进取的人吧。但是常常有同学在我一番保守又不思进取的发言后面评论说“你看看人家美国”，言下之意美国是个绝好的榜样，只要我们在各方面照足美国那样做，十年之后不说赶英超美吧，把美国学到八九成像还是不成问题的。当然在这些同学的美好想像中，一旦我们变成美国的完整山寨版，他们必然不会是那些在底层社区挣扎温饱的 losers，统统都是在高级住宅区里牵着名贵小狗听着ipod享受阳光绿萌新鲜空气的成功人士。</p>
<p>暂且不去讨论谁在这些同学当中的脑海中扮演着那些loser的角色，但是这些同学美好的野望活生生的解释了一句话——greedy is good！当年《华尔街》当中的名台词鼓励无数美国的，中国的，法国的，日本的，天知道还有哪些国家的既不保守又很思进取的青年们学习金融经济最后投身于 “投资”行业，朝着“美国梦”或者“美国那样的梦”一步步迈进着。</p>
<p>我第一次见Luc的时候，他指着我的cv问“你有管理学的文凭为什么最后没有选择经管方面的工作”——这是多么的显而易见啊！我们做it业的民工而已，每天靠着点脑力赚血汗钱，怎么比得上经管行业，左手钱来右手钱去，转眼间兴许就发达了，你看看华尔街那些泡名模开名车住豪宅的。况且我是女生，编程神马的，跟一群穿老头衫夹脚拖鞋的宅男关在一个办公室里，连穿个名牌化个时髦妆容卖弄青春资本的机会都没有，划不来啊很划不来。因为太显而易见了，我都不晓得怎么回答这个问题。</p>
<p>once upon a time，我只身去远方旅行，家长拜托当地的友人照顾一下。友人很负责地百忙之中抽空领我四下游玩。当然生意人么，时间就是金钱，所以游玩间隙得到机会还是要百忙一下。于是在经过市中心的时候我们顺便进入当地最大的医院，直接找到该医院最牛X科系的主任。友人与主任一旁切切私语。我虽未成年，却不 innocent，诸如什么美国还没有通过临床检验期的抗xx病特效药，成本价多少，进价多少，开方价多少，给医生的回扣多少，等等等等，即使不是故意偷听也知道一二，自然晓得他们在聊什么。待友人谈毕了事情，主任送我们出来，拍着我的肩说“好好念书，只要你能进医学院，毕业了进xx医院肯定没问题”云云。只见候诊室里坐着千里迢迢不知从哪个乡下赶来看病的黑瘦农民，主楼门外停着医生们闪闪发亮的bmw。</p>
<p>后来我没进医学院，却报名了经管的双学位。我想知道，为什么有些人劳碌一生背朝天脚踏地提供人类最基本最需要的东西，末了搭上一生的积蓄却连一盒药都买不起，而有些人仗着好运或者好命就能在几个小时一桌饭上挥霍掉别人一年的生活费。虽然毕业之后我选择当民工——大部分时间跟代码纠缠是很痛苦的但在某些时候还会觉得“至少我是个创造者，一个小小的程序至少能改变一些人的生活”，不过这段过程还是挺有用的——至少想起来了自己还会记个账，也不至于被什么投资顾问坑骗。知识这个时候不仅是力量，也是金钱，我总觉得金融学之类的课程，在一个真正有道德的国家是应该免费的开放给所有国民，上山下乡，像大选宣传候选人那样硬塞也要塞给每个公民人的。</p>
<p>但是现实世界的国家，全都分成既得利益者和未得利益者。既得利益者制定掌握控制了游戏规则，以防止自己的利益被未得利益者窃取，未得利益者削尖了脑袋钻营这些游戏规则以求谋取别人的利益，而一旦他们得到了利益，他们就变成新的规则守护者。变的只是玩游戏双方的关系，游戏的规则从来未曾改变过。 greedy是人类的天性，人人都以为“只要我这样这样，那样那样，我也就可以变得和xxx一样一样”。于是掌握了规则的人，都不希望别人窥探到规则当中的奥秘，更不希望有人来打破这个规则。直到这个游戏崩坏为止，所以金融学校永远是最贵的学校。</p>
<p>问题是，永远没机会成为得利者的人问——什么会时候崩坏？既得利或者有可能得利者问——如果我们不想它崩坏，想继续这样玩下去，有没有阻止的办法？</p>
<p>进入二十一世纪后，几次金融危机好像大震前警告，预示着一场以美国这个掌握了全球最多资源的金融帝国为核心的大灾难的到来，于是所有处在这个金融圈里，利益间有瓜葛的都开始自危，都开始思考。这部电影应该跟Cleveland vs. Wall Street一起看，看两种文化两种经济制度两种社会体系——自我设定角色为“有可能得利者”和“永远没机会得利者”——的思考后结果。</p>
<p>本片以社会主义式的经济制度被破坏的结果入手，片中采访的几位国外官员，其中有象征着第三方崛起力量的中国，亚洲四小龙的新加坡，而充当欧洲发言人的并非好朋友英国，而是其历任（不包括现任）总统都被美国指为“对美国不友好，喜欢共产党”的法国的财政部长。这三个国家的发展路线，社会制度，司法体系各有不同，透露出本片编导对于国家干预经济，结束美国人向来标榜的“绝对自由市场”，这个路线的倾向性。</p>
<p>而另一厢边，在面对美国的钱力时，法国人恰恰也在想着改变自七八十年代开始搞起来的国家社会主义形式。</p>
<p>在这场追逐钱的游戏中，根据能量守恒，永远只能是一部分人压榨另一部分人的结果，每个个体所在乎的只是自己究竟处在被压榨一方还是压榨者一方。美国的社会结构以中产阶级为中坚力量，银行家和政客们也都不傻，不会太伸手去压榨这个主流社会，而主流社会想的也不过就是老婆孩子热炕头，这些都有保障之余，现行的社会体制还能给他们个“一朝致富爬入上流”的美国梦发发，那些低收入户是死是活有何相干。只要这一部分人的利益没有受到威胁，只要这一部分人还乐于盯着眼前的胡萝卜前进。那么这场游戏必将以现行的规则玩下去，直到崩盘的那一天。温水煮青蛙，向来如此。</p>
<p>电影这个载体，当不是以娱乐的姿态，而是以这种“我要摇醒你们”的形态出现在大众面前时，其威力究竟是否能达到艺术家们所期望的力量，也只能拭目以待了。毕竟greedy is good，如果眼前就有一块肥肉，谁能禁得住诱惑不立刻咬上去呢？我们真心所希望的，也只是——这块肥肉千万不要是从自己身上割出去的才好</p>
<p>PS：通货膨胀，房价飞涨，两极分化，教育昂贵，政经一体，权钱交融……大家觉得此情此景此等描述熟悉吗？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-香港怎么救"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/20/%E9%A6%99%E6%B8%AF%E6%80%8E%E4%B9%88%E6%95%91/"
    >香港怎么救</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/20/%E9%A6%99%E6%B8%AF%E6%80%8E%E4%B9%88%E6%95%91/" class="article-date">
  <time datetime="2020-03-21T02:40:42.000Z" itemprop="datePublished">2020-03-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>今天我们跟风，讲一讲香港的问题。首先一句话概括一下香港问题的实质，那就是，香港内部的阶级矛盾，被恶意引导为陆港矛盾。</p>
<p>过去，我讲过一个“伊里奇陷阱”。也就是说，要学会换位思考。我们讲政治稳定理论，实际上就是把列宁主义的革命理论倒转过来，换个角度看问题。列宁讲革命的前提，讲的是“两个不能照旧”：一个是统治阶级不能照旧统治下去；另一个是被统治阶级不能照旧生活下去。</p>
<p>现在我们的分析更多侧重于第二个，也就是从民生角度，从经济角度去看问题。这是对的。比如说，我们讲香港，人均住房面积大概只有16平方米左右，相当于大陆的40%左右。在大陆的住房问题已经成为年轻人痛点的情况下，香港年轻人究竟有多不愿意照旧生活下去，是显而易见的。现有的分析也有很多，这里不班门弄斧。</p>
<p>但是，光分析民生问题是不够的。毕竟，香港无论如何，都是高度发达地区，香港的贫民，无论是从账面上还是从实质上看，也都属于相对贫穷。所以，香港这种相对贫穷，光是从民生角度看，并不必然导致政治和社会问题。还是要去找第一个原因，也就是为什么不能照旧统治下去。</p>
<p>对于正规的资本主义而言，私有制下的市场经济制造出的贫富差距，是依靠西方式的大众民主去平衡的。也就是说，贫民虽然在经济上没有钱，但在政治上，和富翁有着平等的一票。至少形式上如此。即使在许多不那么正规的资本主义国家和地区，尤其是在发展中国家或转型社会中，形式上的平等被实质上的贿选所操纵，但人家好歹还得花钱来买这个票。</p>
<p>对于正规的社会主义而言，具有比较完善的人民民主制度。很多人对东方式民主有误解。但事实上，东方式民主政治中，开会的过程和谐，是因为将很多工夫做在了会前，通过充分酝酿、科学分析、广泛征求意见，再将一个各方都能接受的议案付诸表决，从而使多数决议能够较好的体现各方面意志。</p>
<p>问题是，在香港，这两种形式上的民主都是不具备的。香港特区的行政长官由一个选举委员会选出。这个委员会包括了4个界别，共38组。第一组是工商业，包括17组资本家。第二组是专业人士，包括会计、建筑、教育等10组高知分子。第三组是渔农、劳工、宗教、社会福利、艺体出版等5组社会贤达。第四组是全国人大代表、政协委员，以及各级议员。从这个构成不难看出，香港政治并不是去设法弥补劳动群众由于私有制与市场经济所造成的被剥削地位，相反，更倾向于强化精英阶层，即剥削阶级在香港社会中的统治地位。这样一来，被剥削的大多数人的利益诉求势必在既有政治框架下很难有合法的实现途径。在这种情况下，单纯说什么法治与理性，实际上是十分空洞的。</p>
<p>当然，不民主的社会并非不能维持稳定。对于一个方圆近千余平方公里的小地区而言，极权政治没有存在的土壤，威权政治倒是可行的。然而，自古以来，要搞威权政治，首先要有威。而要有威，那么就必须有一个强大的统治集团。然而，这样一个集团在香港是不具备的。</p>
<p>如上所述，香港的政治体制塑造出一个人数占绝对少数的精英集团。在“港人治港”的大框架下，形成了与被治的港人相对立的、横亘在中央政府与香港人民之间的一个“治港港人”集团。他们代表人物，正如本号其他文章所说，当然是李先生们。从“一国两制”的初衷看，我们当然是希望这个“治港港人”集团能够切实担负起治港责任，维护好香港的繁荣稳定。如果做不到，至少维持稳定。</p>
<p>这里讲到了两个字：责任。问题是，这种责任感在“治港港人”集团中是不存在的。但凡实行威权政治，那就是以少数去治理多数，若是少数人无组织、不团结、没有决心，又如何治理得了呢？要说好的威权，新加坡就是典型，维持了繁荣稳定，但那是别人家的李先生们。差一点的威权，统治集团从齐奥塞斯库、卡扎菲等人血淋淋的教训中也不难看出，丢失政权就是死路一条，拼了命至少能维持个稳定，即使最后不一定做得到，出发点总是这样子的。</p>
<p>前几天我们讲，一个政府，可以腐败，但不能无能。今天要补充一句，无能就算了，好歹得负点责任。但事实上呢？这个“治港港人”集团所做的，是把香港的利益据为己有，10个最大的家族资产就占到香港GDP的35%，这种财富集中程度世所罕见。但与此同时，一是将资产逐步转移出香港，转移到大陆和西方，这样一来，就不再同香港的命运联系在一起，随时可以跳船。二就是把统治责任推给中央政府。</p>
<p>要使北京去背这口锅，很显然，就是要将“治港港人”与“被治港人”的港人内部矛盾，转化成了港人与大陆的矛盾。要让在香港几无立锥之地的穷屌觉得自己和李先生是一种人，却与深圳河对岸的大陆同胞不是一种人，很明显，就要强化“港人”的身份认同，而弱化“被治”的阶级认同。</p>
<p>于是，经济上的民生问题与政治上的民权问题就必然由建构“香港人”这样一个想象的共同体，而转变为民族问题。你要问“港独”是怎么来的，就是从回避不平等经济体制与不民主政治体制那里来的。有文章讲香港的年轻人“蠢”，这是不对的，从整体受教育程度看，香港年轻人比大陆还是要高的。当然，从政治上看，他们的政治表达方式与具体政治诉求确实相当不成熟，但是，我们要知道，这种不成熟并非先天愚钝，而是由不平等不民主的政治经济体制所塑造出来的，是由于他们没有生在红旗下、长在新时代。</p>
<p>只要我们知道，香港问题的症结一不是出在中央政府身上，二不是出在香港人民身上，而是出在横亘于这两者的“治港港人”集团身上，就应该知道，香港并不是没有救。</p>
<p>对维持香港繁荣稳定的共同愿望构成了中央政府与香港人民同呼吸共命运的基础。维持香港繁荣稳定，对于中央政府来说是必须的，因为无论风云如何变幻，香港就在那里，谁也带不走。对于香港人民来说也是必须的，因为无论风云如何变幻，他们就在那里，贫贱是不能移的。对于“治港港人”来说，不是必须的，他们在世界各地都有资产。</p>
<p>通过“治港港人”实现港人治港的这种间接统治的政治安排，本意是希望一个在香港既有既得利益，又有统治经验的集团去维持香港的繁荣稳定。因此，我们可以让渡给他们一定的经济利益。问题是，既然他们不仅做不到这一点，反而将他们获利所带来的社会矛盾转移到中央政府那里，我们就不禁要问，凭什么要许给这些麻烦制造者香港GDP的35%那么大的利益？</p>
<p>对于香港人民，尤其是香港年轻人来说，关键是必须看清自己诉求的实现路径。必须要让他们认识到，让他们买不起房子的，绝不是远在天边的中央政府。大陆的执政党及其领导的人民政府，是香港人民最可依赖的核心力量。除了大陆的党和政府，没有其他任何一个国家、任何一个组织能够帮助到他们。要看清楚，香港的繁荣稳定，符合双方的共同利益。</p>
<p>这样一来，路径就很清晰。站在“被治港人”的立场上，很显然，就是要把中央政府当做是对抗“治港港人”的依靠，要把意志统一到爱国爱港上面。他们应该认清，西方列强是靠不住的。无论谁给了何种承诺（更何况连公开的口头承诺都不敢给），都应该认清，同中央政府对抗没有出路，与中央政府合作前途远大。</p>
<p>这就意味着，给西方列强和本港大亨当枪使，将矛头对准大陆，不仅实现不了自身经济利益与政治诉求，反而会遂了“治港港人”的意——假如“被治港人”靠不住，那不就只能依靠“治港港人”了？相反，和中央政府、大陆人民站在一起，“治港港人”就成了可有可无、有不如无的群体，那么，为什么还要留着他们呢？</p>
<p>如果香港人民觉得这样好，那就这样办。如果觉得这样不好，那就算了。问题总归是要解决的。</p>
<p>最后是学习强国时间：</p>
<p>从1997年7月1日回归祖国那一刻起，香港的前途就已牢牢掌握在香港同胞手中，香港的命运就更加紧密地同祖国的命运联系在一起。有伟大祖国作坚强后盾，依靠香港特别行政区政府和社会各界人士共同团结奋斗，香港就一定能克服前进道路上的任何风险、困难和挑战，香港的明天必定会更加美好，香港市民生活必定会更加幸福，祖国的东方之珠必定会更加璀璨！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Java工程师还是算法工程师"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/20/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%98%E6%98%AF%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/"
    >Java工程师还是算法工程师</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/20/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%98%E6%98%AF%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/" class="article-date">
  <time datetime="2020-03-20T04:53:25.000Z" itemprop="datePublished">2020-03-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>年轻人想太多了，以大部分人的技术水平，都谈不上选择技术方向，出去都是被社会艹的。</p>
<p>大部分人，能够选择一个价值观和你 match，给你机会发展的公司，已经是人生高光时刻了，做啥技术真的不重要。</p>
<p>打个蹭热点的比方，你要是憧憬生物学，去了武汉病毒所，除非你心黑，喜欢靠院士升职器当所长，这我无话可说，年轻人心不够脏的，你选择生物学方向，却屁颠颠去了这种机构，方向还重要吗？</p>
<p>像我们一些垃圾群里面</p>
<p>有人喜欢算法，刚进行业时候，觉得自己数学好所以放大算法的价值，恨不得未来都是算法，然后干两年，发现破烂公司觉得算法没用，做算法创新涨一点点，还不如写 ppt 做架构做产品的牛逼，技术又上不去，管理也做不好，团队都被削了，跳槽没人要，整天骂骂咧咧。</p>
<p>有人喜欢做开发，觉得自己特立独行，恨不得都劝退算法，过来搞开发，结果发现开发特别吃年龄，活也重的喘不过气，30 岁升不上管理或者架构师，就要退休了，自己爬不上，最终也是整天骂骂咧咧。</p>
<p>有人喜欢钱，拼命刷题，一开始 offer 多， 纠结个半天哪个岗位钱多，结果找一个号称技术积累深厚，天天沸腾，搞“牢疫结合”的公司，进去发现领导结果就是坨屎，2 年下来技术啥都没学，白闷一肚子火气。</p>
<p>结果，现在全都成了一堆骂骂咧咧的人。</p>
<p>然后其他人咋理解我们呢？一群针对互联网的黑公关狂欢！只有我们深知，绝对没有人能够跟上社会科技和商业的改变速度的，你奋斗还是躺平，都是一个人和 N 平方的群体博弈，保不济还有黑天鹅事件，你说统计上谁赢？</p>
<p><strong>大部分普通人与其纠结选择啥，还不如想着社会未来会是啥，增量是啥，你思考对了，躺在这个潮流里面都能笑傲江湖了。</strong></p>
<p>想靠 alpha 策略成为人赢，当你知道这个因子的时候，因子已经开始 decay 了。</p>
<p>你真的倔的不肯承认，活该被全球 quant 顺着网线过来打你。</p>
<p><strong>支撑一个人走下去的，从来不是你手头那点杂耍，而是你内心相信未来是啥，是信仰让你坚强，不是高空走钢丝赢来的廉价掌声。</strong></p>
<p>少年，你从现在开始，应该努力思考，我该如何做，才能更加接近未来互联网的新形态和新的渗透模式。</p>
<p>职业危机的本质是什么？本质是不需要那么多有经验的工程师，如何拿五个人的饭喂饱十个人？答案是，怎么分配都有人吃不饱。所以，这不是个人选择问题，而是市场问题、需求问题。比如一个老兵，会用迫击炮，会叫空中支援，懂无线电通讯，会火力压制，但是在岛主手下当兵，发一杆中正式，50发子弹，10个手榴弹，就这点东西，吃不饱饭还用绳子牵着防止逃跑去上战场跟穷凶极恶的鬼子拼命，那未必比得过战友那些文盲出身的士兵。因为，岛主的需求和市场和成本，不足以支撑美式老兵。难道，30多岁软工多年的老工程师，真的不如20多岁的新人？我30多岁写代码的能力比20多岁时不知道强了多少。关键在于就业市场和公司强调的，是什么竞争力。国内码工市场显然强调的是工作时间和耐劳易使。35岁的人其实技艺更精湛，但耐不住精力衰退，家庭分心，所以工作时间下降了不少；加上老油条好多时候想得多见得多，更不容易被情怀忽悠，滑得很。以前我觉得，这种跟西方的差别，是效率和技术水平导致的；现在又觉得，这也许是文化导致的，是思路不一样导致的。东方的思路本身就是强调人本身的能力，把“人”的潜力发挥到最大，是主观性的；西方的思路是强调“流程”，尽可能地消除“人”之间的差异，是客观性的。这是两种不同的思潮和习惯。测试职位回到正题，测试本身就是软件开发下的一个分支，既然软件开发都有市场带来的35岁危机，那么转测试并不能从根本上解决问题。当然，单分析测试和开发这两个方向的话，可以说测试更不乐观了。提到测试历史，必须说“陆奇改革”事件。长话短说，就是陆奇在微软时将自己部门SDET全部改为SDE，最后推广到全公司。这种带阵痛的改革非常成功，使得微软大大提高了开发效率。我先前听说一个SDET的Manager，在微软17年，从SDET1一路升上来，一行code没写过，是不是舒服得有些过分了？陆奇改革后，这人后来转成了SDE2，当然，人早就不差钱了。测试分为两种：手动测试的严格来说不算测试，跟Engineering不搭边，在如今的环境下，大公司基本上都是外包这种手动测试（中国和印度）；一般软工说的“测试”应该指的是“测试工程师”，是知道如何写code的人，写测试用例和框架。然而，测试工程师最大的问题就在于，他们的工作内容只是软件工程师的一个子集。这些code，完全可以交给软工来写，并且软工还更了解一个系统的弱点和细节。这就导致，测试工程师的职位，也被逐渐削减或是外包到更便宜的公司和国家去。我不是说测试框架在软工中不重要，而是说那种传统的微软式的开发、测试成双成对的做法，逐渐转变为全开发职位，部分人或是部分精力维护测试框架，偶尔一个部门下有一两个专精测试框架的专家（亚马逊这样做）即可。所以， 我个人认为，跟十几年前流行的工作方式比，其实对软工的要求更高了，活更重了，整个环节也更简单了。这就带来，软工职位不断增加，而测试、DBA等职位不断被削减，公司的效率和收益更高。从前，软工只是被认为是软件开发的一个环节，虽然也是最重要的；如今，软工的职责范围其实是扩大了。甚至，在很多快节奏，更现代化的大公司，软工还管项目进度和人员协调，以及项目报告等很多活，部分替代了PM/TPM/Manager的职责。有时候manager跑了、被开了，甚至还有“码工自治联盟”状态出现，没人管，几个码工自己商量做什么，也见过。这也部分解释了，软工需求大而且工资在过去10年间慢慢上涨的原因。很多公司之所以难面，不光是算法题的问题，还有承压、交流和设计等很多指标。要求高了，自然难招人，公司也不在乎钱多给点，因为巴不得进来的都是多面手。行业兴衰个人的努力虽然能够减缓、但是还是很难摆脱行业兴衰的。一个行业，享受它的福利，就必然承受它的规律和残酷。软工，无论国内外，最大的特征还是高强度的智力输出。而人的思维活跃和精力，无疑是一直随着时间而衰退的，有些衰退是因为要考虑的事情更多（比如身体状况，家庭等），哪怕30多岁更聪明了更努力了，也不行。此外，软工的行业跟总经济形式特别相关。你可以看出，各国的软工待遇，跟其GDP是非常相关的。中美IT之所以厉害，你当然可以吹说中美两国人聪明、能吃苦、自主研发，但说穿了还是因为两国GDP世界第一第二，有的是钱和市场，随便给点投资就雇得起码工去造东西，然后在本来已经非常巨大的市场上获得更多回报，良性循环。比如某些垃圾国家，饭都吃不饱，肉都不敢大口吃，穷得叮当乱响，你做外卖软件给谁用？在这种情况下，我倒是觉得，应该心平气和： 自己赚钱，是因为踏上行业的快车；自己失业，是因为行业或是经济下行。个人的能力和选择，倒没必要那么焦虑。</p>
<p>如果是技术类型管理的话，说几点：</p>
<p><strong>最重要的，明确组里在公司的地位，聪明地接活，合理的安排活</strong></p>
<p>业务过于琐碎和繁重会压垮组里成员，接着压垮你，要懂得抢做重要的活，为组里的整体绩效做精细化打算。</p>
<p>抢活能力是管理层自身修为的重要体现，无非两个方面，你的技术和人品都要好，技术好不必多说，技术不好连人家要做啥都不懂，谈何抢活。</p>
<p>这里强调人品不好的，就是对人特别狂的那种，这种人不适合当管理，很容易引起组和组之间的矛盾，这对整个组的影响力都是灾难性的打击。商业社会是利益的捆绑体，一个人再厉害，被人厌恶，也抵挡不住一堆人对你抵制。</p>
<p>当然，待人接物温文尔雅，这事情没这么理想，如果公司金字塔结构都被削成纺锤形了，中层管理哪怕学富五车，也一样极度内卷，谁也看不惯谁，互相倾轧抢活打架，这也是非常有可能的。</p>
<p>一般感受到这种纺锤形结构诞生以后，我觉得，中层管理赶紧跑路为好。</p>
<p><strong>保持打磨自己的技术，不求深，但一定要广</strong></p>
<p>管理以后技术是不可能变深的，管理如同挖战壕，你挖地过深会导致和其他人挖的连不到一块，反而还会形成一个巨坑，谁都爬不出来。此外，组里有人挖的深，有人挖的浅，管理要做的的是保证深浅不一的都能够串接起来。</p>
<p>所以，技术管理层技术广度必须够广，这里的广，不仅说你懂的知识多，而且，你还要知道各种 low 的解决方案，和各种高级的解决方案，雅俗共赏。不然各种乱七八糟的技术做出来，你半天整合不到一起，同事做的你不懂没法帮人家说话， low 的你看不惯打击人家，感情这饭你没法吃了。</p>
<p>但是，管理也有弊端，因为技术不深，导致跳槽经常性吃亏，一般国外的技术狂人都很不喜欢 manage people。只是国内风气不知为何，上年纪必须要考核你管理能力，实在是烦人。</p>
<p><strong>听组里同事吐槽和抱怨，并想办法制造条件给他们排忧解难，学会给组里同事挡子弹</strong></p>
<p>强调的是，管理不是奶妈或者坦克职业，管理也不是花掉你全部生命去做全职心理顾问，接受吐槽和挡子弹，只是一种最大化激励团队的措施，听取抱怨是防止有本事的同事频繁离职，增加你的招人成本，同时防止造成人才的死海效应。挡子弹是激发同事发挥更多自己主观能动性的措施，同时让他们觉得和你共事是有安全感的。</p>
<p>一般公司的管理层和干活的绩效是分开打的，所以同事干活开心产出高，管理层也有好的绩效，两者不是你死我活的关系，而是同生共辱的关系。</p>
<p>此外，国内对管理的理解还是掌握人事权这一点有点分歧，认为管理是统治阶级，抱有敌对态度。其实将心比心来说，互联网管理类岗位是很危险的职业，技术精进放慢，琐事增多，拿的工资未必比技术人员高(沸腾厂除外？？？)，离职跳槽非常困难，公司一个内斗或者业务不确定，人生被毁掉还不如一个写前端的小弟出去好找工作。</p>
<p>至于如何听取抱怨和吐槽，这和你听你家人唠叨和抱怨一个道理，很多抱怨都是你个人理性层面没法理解的，但是你也要听下去，所以，可以从家人入手，解决他们的唠叨，学会让他们宽心，这个训练如果做下去，往往非常见效。</p>
<p><strong>正确对待组里怠惰的同事</strong></p>
<p>有些同事可能对业务和前途没啥盼头，觉得业务做来做去都是一坨屎，陷入迷茫状态，这对管理人性话来说，很考验心性的。可能国内管理第一想法就是干掉人家，常见于脉脉里面骂街的针对对象，这是一种懒政思维，也是恶化团队关系，增加各种谣言的罪魁祸首。</p>
<p>对方不想做就候着，让他做自己喜欢做的，刷题考证都别理他，也别灌鸡汤忽悠人家或者苦口婆心劝对方，正确的方法是，组里潜意识灌输你不来给我们解决琐碎问题，我们组就要挂了的一种危机感，潜移默化让他觉得他是来救你的，不是来给你打工的，激发他的主人公意识。</p>
<p>至于如何让对方觉得做琐碎事还是救火呢，很简单也有点欺骗性质的，就是每周开周会的时候，让组里其它同时疯狂吐槽这东西不做，就没法干下去了，需要人来拯救，接着管理者适当抽象这种吐槽，变成目标明确的活，说谁能解决请谁吃饭，总之多来几轮这种形式的会议，怠惰的同事久了也不好意思一个人啥都不干，愣在那里摸鱼。</p>
<p>所以，有时候，可以巧妙地把一件事情拖到大家都觉得重要了才开始做，大家的战斗力都会巨大提升，deadline 是生产力，不是吗？</p>
<p>最后一点，不是最重要，但是却是一种神奇的力量，就是谈吐能力</p>
<p>谈吐能力无非几点，让人感到通情达理，幽默风趣，格局宏大，句句金句，都是好的谈吐。有空多多看看奇葩说一类的，看几本语言震撼的文学作品，多和脑洞大的有趣的人聊天，懂生活懂得玩，有共同话题。不求道理对不对，但求你的表达能力让人觉得耳目一新，听起来就是有趣的人。无论做啥事情，风趣的沟通能力都是好的印象分，如果实在受不了社会的虚假，你可以到网络匿名吐槽怼人也成(虽然我不是太赞同，不过有一些宣泄渠道很重要的)，总是，人前一定要学会高级别的谈吐，让人觉得你谈吐能力一流的人。</p>
<h2 id="中台和微服务有什么区别？"><a href="#中台和微服务有什么区别？" class="headerlink" title="中台和微服务有什么区别？"></a>中台和微服务有什么区别？</h2><p>你到高校去，导师承包一个项目，分给学生做，学生根据甲方需求，没日没夜做好一个项目，做完毕业，然后师弟过来接手，一看傻眼了，完全看不懂，推倒重做，接着毕业，接着让小小师弟接手，小小师弟接着崩溃，接着推倒重做。</p>
<p>组里唯一日益增长的，是导师的荷包，手下无数的横向项目ppt，还有组里某个学生才能看得懂的项目成果。这些拆分无比稀碎，功能又交叠极大的微型工程，只有做这个业务的学生看得懂，其它学生想用，费劲，没门。</p>
<p>导师一看，不成呀，每次招一个苦力过来，都要高年纪的学生带，越带越吃力，还重复造轮子，出活越来越慢，成本越来越高。</p>
<p>咋办呢，导师心里一横，把几个技术好的高年级博士叫过来，画了一个大饼，说你们前途无亮，让他们把整个组的项目都整和梳理一遍，把里面共同，且通用的东西都抽离出来，做了沉淀，让以后新来的师弟能够快速完成横向项目。</p>
<p>这几位博士不负众望，高质量地完成了导师的任务，让新来师弟调包溜得飞起，小小小师弟很快地解决了导师的横向项目，迅速毕业，走向人生巅峰。</p>
<p>而这几位博士，却因为没有直接完成导师的横向项目，被导师延期了。。。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何看待所谓中国病毒"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/18/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E7%97%85%E6%AF%92/"
    >如何看待所谓中国病毒</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/18/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E7%97%85%E6%AF%92/" class="article-date">
  <time datetime="2020-03-18T18:07:58.000Z" itemprop="datePublished">2020-03-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>川皇这不是不合适，是不要脸。</p>
<p>美股三次熔断，按他老人家当年的言论，他是要装进大炮发射到月球上的。三次，地月之间三个来回都够了，人肉阿波罗。</p>
<p><strong>别人说得一点都没错，你莫乱发表言论好吗？多看的专业知识，把工作做好争取早点考个中高级职称，莫管闲事好吗</strong></p>
<p><strong>没上进心，整天混日子迟早会被淘汰的</strong></p>
<p>现在问题来了：人家不要脸，你咋办？</p>
<p>CGTN？</p>
<p>某性感主编在线叼盘？</p>
<p>观察者网国内整几个视频批判一下来波流量？</p>
<p>真特么内卷。</p>
<p>出门干啊！现在一通操作管下来，费拉不堪。忘了我们帝吧当年多么武德充沛么？</p>
<p>推特转发个几万条就全球热搜了，帝吧老哥分分钟能让你被骂上全球热搜，也能分分钟让你主动关闭评论区。</p>
<p>从当年红客留下来的口嗨传统，愣是给自我阉割了。现在川皇一口水洗脸，想起义和团了？</p>
<p>无事关闸，有事开闸？当人狗呢？连央行降准的闸都没整明白，指望你会在舆论的闸上开关自如？</p>
<p>疫情的舆论战争到底算不算人民战争？</p>
<p>川皇今日说中国病毒，明日就是中国造成的损失，后天欧洲一帮右翼党派喜滋滋点赞。</p>
<p>你之前的一切努力，近乎乌有。</p>
<p>b站一堆营销号可以艰难地在油管评论区找几句好听的，然后剪下来糊弄b站小孩，自欺欺人营造一种“我们好受欢迎鸭”的幻觉。</p>
<p>你不能这么干吧？</p>
<p>凭啥代表我们唾面自干？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-危机下的四种人"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/17/%E5%8D%B1%E6%9C%BA%E4%B8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%BA/"
    >危机下的四种人</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/17/%E5%8D%B1%E6%9C%BA%E4%B8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%BA/" class="article-date">
  <time datetime="2020-03-17T21:34:18.000Z" itemprop="datePublished">2020-03-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>今天讲一点点政治经济学。原理是重要的，特别是当你被市场经济搞的生活不能自理的时候。</p>
<p>第一个案例是小黄车。小黄车是什么问题呢？现象上的小黄车是一个遍地垃圾的问题，质量上的小黄车是一个刚好满足成本最低又不会骑着骑着就散架的二次函<br>数最大值的初中数学问题，政治经济学的小黄车是一个你在1929年就学会的资本<br>主义的生产过剩问题。</p>
<p>创业不是一个政治经济学概念，创业是一个文学概念，创业用政治经济学的说法叫资本主义再生产。是资本家的钱躺在账户里就相当于亏本，必须拿出来钱滚钱，小黄车只是钱滚钱的工具，而依附于这个工具上的一切美名其曰创业的活动都是对这个原理的修辞。</p>
<p>第二个案例叫做瑞幸咖啡。这个案例的修辞是据说要改变中国人的生活习惯。修辞背后的原理是一样的，我们决定讲一讲这个原理，即资本主义再生产的必然性是什么，即为什么资本家的钱不能躺在账户里。</p>
<p>因为资本主义从诞生开始就是冲着毁灭封建生产关系去的。封建生产关系是一种怎样的生产关系呢？是你知道你的土地是有限的，你知道人口涨到一定程度就必须战争，你知道君子之泽五世而斩，在有了这种稳定的预期之下诞生了一系列以宗教或者礼教为工具的社会生产约束。</p>
<p>然后资本主义来了，资本主义用创新和效率证明过去的约束条件统统不存在，我只要比你更快地生产，消费，投资，再生产，封建关系就会瓦解，你就要找我借钱。在这个游戏里，非但地主阶级抵抗不了这一套，小资产阶级和法西斯同样抵抗不了这一套，我只要比你快就好，冒险只要成功一次，就能覆盖之前的所有损失，这是资本主义出现后，西方资本家发现世界无限大后的本能反应。</p>
<p>当世界不再无限大的时候，就会发生帝国主义和帝国主义战争，如果核武器让帝国主义战争打不起来，帝国主义内部就会发生革命，资本家就会绞死自己，然后新一轮的科技创新，新一轮的速度游戏，历史周而复始。如果核武器让帝国主义战争打不起来，帝国主义内部就会发生革命，最后，革命未必会让你变得更好，说不定会让你变成俄罗斯和乌克兰。</p>
<p>明白了这一点，你才能理解为什么在中国的全要素生产率提升速度突然慢下来的时候，会出现小黄车和瑞幸咖啡这种东西。小黄车和瑞幸咖啡的投资者非但不是愚蠢的，反而是理性的。主要的创投扔出去的并不是自己的钱，但是没有项目投是不行的。自由市场发展到后期不但不会提升社会的生产率，反而会导致社会资源的浪费，因为浪费资本家的钱对职业经理人反而是有好处的，而资本家也必须允许这种浪费，你亲眼目睹了政治书里发生的一切。</p>
<p>那么怎么办呢？</p>
<p>接下来我们开始阅读新闻。</p>
<p>社科院蓝皮书：制造业就业需求萎缩，结构性失业和招工难并存。</p>
<p>这个新闻是什么意思呢？这个新闻是直接指向去年10月各个大企业内部开始压缩就业名额的措施的。具体讲，战略新兴产业人才不够，传统的就业大户现在不需要这么多人。</p>
<p>什么是传统的就业大户所不需要的人呢？我们再看下一个新闻。</p>
<p>京东坚决淘汰三类人。</p>
<p>某茶卸任重庆嫩绿茶艺董事。</p>
<p>显然，当然是互联网引发的服务业扩张所新容纳的就业人口。</p>
<p>这些人为什么要被挤出呢？因为你越要压低成本，你就越要996，你越996，你就越没有时间消费，你越没时间消费，就导致就必须进一步压低成本才能吸引你消费。循环几次你就可以自闭了。</p>
<p>这个现象和主题有什么关系呢？让我们回到政治经济学。</p>
<p>政治经济学明确了，生产过剩就是泡沫，泡沫就是生产危机（达里奥这种反复从经济周期中获益的大佬也直言不讳这一套对百分之八十的美国人毫无用处，因为他发现美国小孩的社会平均福利在不断下降，同样，我们讲过，09年信贷扩张之后中国小孩所享受到福利的质量问题），就在互联网服务业引发了巨大的创业泡沫的时候，工人阶级的先锋队当然是洞察了这一切，那么不好意思，只能以抬高上游企业生产成本的方式直接刺破泡沫，走好不送。</p>
<p>为了进一步巩固这件事的效果，下一步的思路自然是扫黑除恶，打掉高利贷分子的社会基础。至于你问我为什么先锋队为什么要这个时候刺破泡沫，我只能说这是历史的进程。</p>
<p>接下来会怎么样呢？我们回到社科院的报告提到的随着经济结构的调整所必然出<br>现的结构性失业问题。过度扩张的互联网服务业收缩时，最终挤出的人口要怎么<br>办呢？</p>
<p>以美国为例，苏联解体后，美国进一步将制造业转移到海外，国内傻的可爱高呼苏联解体万岁的白人工人阶级被这一套瓦解（搞垮苏东就是为了东欧世界的廉价劳动力啊哥哥，最后你不但当不了工人阶级，你连权贵的仆从都当不好，众所周知，美国人没有东欧人长得细腻），在不存在中产阶级这个阶级之后，他们应该怎么办呢？</p>
<p>最普遍的方式就不提了。有一句话说得好，no country for white men.</p>
<p>稍微好一点的方式是嗑药，滥交，环游世界，散步阴谋论，成立自己的右派网站，并且鼓动自己的粉丝给特朗普投票，宣称美国已经被犹太人篡夺。</p>
<p>进阶一点的方式是参军，改掉坏毛病，一边打工一边考上耶鲁大学法学院，却发现自己完全不知道怎么在有三把叉子和七个瓶瓶罐罐的餐馆吃饭，毕业后看着自己的同学飞黄腾达，一腔悲愤写出一本《乡下人的悲歌》。</p>
<p>高阶一点的方式是完全把自己与同样阶层的人隔绝开来，去图书馆猛看曾国藩传<br>和列宁全集，参加海军，去高盛搞清楚资本主义那一套，然后辞职，创办布莱巴<br>特网站，送特朗普进入白宫，再次辞职去欧洲发动群众，发誓干死索罗斯，深藏<br>功与名。</p>
<p>最后让我们阅读一份文件。</p>
<p>超大特大城市要立足城市功能定位、防止无序蔓延，合理疏解中心城区非核心功能，推动产业和人口向一小时交通圈地区扩散。大城市要提高精细化管理水平，增强要素集聚、高端服务和科技创新能力，发挥规模效应和辐射带动作用。中小城市发展要分类施策，都市圈内和潜力型中小城市要提高产业支撑能力、公共服务品质，促进人口就地就近城镇化；收缩型中小城市要瘦身强体，转变惯性的增量规划思维，严控增量、盘活存量，引导人口和公共资源向城区集中。</p>
<p>什么意思呢？很简单，结束了，回去吧。指望用市场经济去冲破一切，最终无非是一场梦呓。我还是那句话，关心你自己，关心你的过去，关心你身边的人。</p>
<p>我们将在下一期谈一谈如何预防黄马甲的问题。今天的任务就到这里。</p>
<p>现在是吐槽时间。</p>
<p>当生产过剩的时候，企业主采取裁员和关闭工厂的方式来躲避危机，把工厂看作是自己的一己之私，而不是社会大生产中不可或缺的一部分，自大革命开始，企业主就把这种残忍的生活方式当做了面对历史之神露出笑容时的唯一办法，他们总是有一种错觉，觉得自己已经是世界的主人了。这种错觉逼迫着他们种植一些因为假故事而昂贵起来的橙子，再卖给那些连一个工人都雇不起却非要感同身受的好孩子们。</p>
<p>比起这些，我还是更愿意听一听杜金同志的故事，起码他在意识到苏联续不上的时候没有选择背叛灵魂，而只是留起了胡须。但是更多的人毕竟是背叛了灵魂，并且宣称自己这样的背叛是有好处的，是为了国家，自己和父辈们好，希望他们的这种不正确的自我感觉良好能够在海南岛的医疗条件下逐渐康复。</p>
<p>第三个问题，就个人而言，围绕创新我们可以做些什么？我想借此机会对在座每一位毕业生同学谈谈对你们的希望，权当对你们的临行嘱托。</p>
<p>这里，我主要谈六个方面。</p>
<p>第一，养成并保持学习的能力。我在每一次开学典礼上都要谈一个话题：上大学是为了什么？我认为两件事情最为重要：一是掌握学习的能力，二是养成合作的习惯。掌握了学习的能力和拥有合作的习惯，才能事业顺利，缺一不成。</p>
<p>在我看来，学习的能力不是指掌握知识和技能，而是指认知世界、理解世界的能力。我们已经知道“知识越多越反动”这句话是错误的，我还要说培根的“知识就力量”这句话也是有时代局限的。在今天信息爆炸的时代，信息和技能永远在过时的道路上。人的一生只有不断掌握并增强自身的学习能力才能不落后于时代。这也是真正的大学教育的宗旨。</p>
<p>耶鲁大学的前校长理查德.莱文曾经说过一句话：如果一个学生从耶鲁大学毕业之后居然掌握了某种很专业的知识和技能，那是耶鲁教育的失败。学习的能力不仅仅来自阅读，更多的还有走出去看世界、观察世界、思考世界、品味世界，只有这样才能够拥有开阔的视野，体会、了解人类的诸多不同，这会使人更加宽容。宽容是人类最高的智慧之一，它会使人类增进幸福。</p>
<p>第二，独立思考的能力。没有独立思考的个人，不会产生创新性社会。我们都看过电影《阿凡达》，导演卡梅隆70多岁时拍了这部电影，我看后曾说过一句话：这是基于人类的想象达到了人类想象的边界。为什么他可以拍出这部片子？是由于他幼年时代的幻想、对世界的好奇心到了70多岁依然如故，没有被泯灭。</p>
<p>好奇心、想象力在今天的中国，在座各位还剩下多少？我真的不敢恭维。大家从幼儿园走到今天，基本上是做着标准答案走过来的。在毕业典礼上，本应对大家说些鼓励的话，但是我还是想严肃地跟大家说，在各位今后的生活当中，如果没有好奇心和想象力的话，将是人生的悲剧。好奇心和想象力塑造着一个人的偏好和喜好，没有自身喜好的人生或者说有自己的喜好却被父母和其他人强行改变的人生是非常恐怖的。这样的人多了，这样的人组成的社会也一定是恐怖的。所以，学习能力加上独立思考，是形成创新性社会的基本条件。</p>
<p>第三，自主选择的能力。经济学是一门研究资源稀缺条件下行为主体如何选择的学问。在计划经济条件下，我们基本上是不需要选择的。我上小学、中学的时候，感到自己没有什么选择，因为组织上已经替我选好了，不是上山下乡，就是到工厂接班。其实那时也没有什么痛苦，想起来很快乐。</p>
<p>今天，同学们的选择非常多。早晨起来你会选择是到A食堂还是B食堂或C食堂吃早餐，要选择上李老师的课、赵老师的课还是张老师的课。选择是有成本的，起码有机会成本，但不论怎样，市场经济条件下自主选择的成本再多也是必要的，市场经济就是由无数的选择组成的。</p>
<p>今天，在应试教育体制下大家还有多少自主选择能力？近几年经常遇到大学同学、朋友打来电话，说我孩子或者亲属今年要高考了，请你跟我说说哪个专业更好？我问他们孩子自己喜欢什么？经常的回答是“不知道”。在座的各位家长，你们可能更清楚是不是这样。这是很悲哀的一件事情。在我上课提问时，很多同学不敢正视我的眼睛，目光所到之处他们基本上都是放下眼帘，好像他不看我我就看不到他一样。没有问题意识，提不出问题，也自然缺乏自主选择能力，这是个恶性循环。具有学习能力的人，能够独立思考的人，也一定是拥有自主选择能力的人，自然是创新能力很强的人。</p>
<p>谈及自主选择能力，我想谈一点个人体会。现在大家都已基本上选择好了职业，未来还可能有许多新的选择，今天谈这些体会还不晚，也许对你们有参考。经济学强调发挥比较优势，但在做出人生选择的时候，应该注重自己的比较劣势。就是说，你要知道自己的缺点和不足。什么是理性？理性就是知道自己是无知的，或者说知道自己的不足。当你深入了解这些之后，比如在选择职业的时候，就要尽力回避因自身缺陷或不足难以胜任的领域。</p>
<p>这样做，不仅避开了自己的不足，实际上也是选择了你的比较优势，而且会使自己更加快乐、宽容。你不会见到某同学去金融机构做的很好，便产生凭啥我不能去金融机构、大学时我金融学成绩比他好之类的不正常心态。冷静地了解自己的比较劣势会让你有一个健康心态，你会认为那个同学成功是因为他确实很优秀，而在他很优秀的那个方面，我却是不足的。所以，了解自己的不足却不回避，一味地同他人比较，盲目跟风，无异于人生的铤而走险。</p>
<p>第四，审美能力。如果展开一幅世界经济地图，你会发现每个国家都有自己的比较优势，如美国出口的是金融服务，日本出口的是制造业技术，中国人出口的是劳动力，欧洲人出口的是古老的贵族文明积淀下来的审美，几乎所有的奢侈品都来自欧洲。</p>
<p>审美是一种历史积淀，前提是一个国家历史、文化的连续性。这个话题其实是很沉重的，在此我只想谈谈自己的体会。对个人而言，审美是一种品质和修养。一个审美能力低下的民族不仅素养、品格不高，道德水准也会有问题。迄今为止，大家的审美能力基本上都是从父母那里熏陶出来的，问题是在座的各位父母都是“文革”后的一代，这在很大程度上是问题所在。</p>
<p>我非常高兴地看到，在今天的毕业典礼上，大家都穿着皮鞋，穿着带领子的正装，我跟赵勇书记提出过毕业典礼上同学们的着装要求。为什么？看看我们的校园里，许多男同学穿着一条大短裤，露着带毛的双腿，穿一双拖鞋，身披庄严的毕业礼服满校园逛。你们觉得美吗？</p>
<p>今天，走在世界上任何地方，判断一个人是否是中国人的标准，基本上就是服饰与行为。针对个体，主要看服饰，相对于其他亚洲人，中国人的服装搭配比如衣裤、鞋帽、鞋袜等的搭配基本是不合体的，远远一看便知道是中国人，在亚洲人里韩国人喜欢穿着鲜艳，穿的素雅且搭配合理的多半是日本人。如果是团体，看到一个人在说，几乎所有人在听是日本人；一个人在讲，一半人在听，一半人乱乱哄哄的是韩国人；一个人在说，少数人在听，多数人各干各的，大多是中国人。</p>
<p>审美是一种尊严意识，是一种自我尊重也是对别人的尊重。在庄重的场合，一个没有仪式感的人、着装随意的人既是对自己的贬低，也是对他人的极大不敬。在更大意义上讲，审美可以让人知晓世界上的美好与丑恶，它告诉每一个人，人类的行为应当是有底线的，知道有些事情是绝对不可以去碰的、不可以去做的，而不是为达目的不择手段。这样，我们社会的道德水准才会有所提升。</p>
<p>第五，战胜困难的能力。人生中困难是常态，幸福是短暂的，海明威说“勇气就是优雅地面对压力”，人的一生中能成为优雅的人太难了，这也是我自己经常苦恼的问题。有时候，我跟同事说话时会忘乎所以，事后会反思自己的不优雅。但是优雅地面对压力真的是很难的一件事情，一个人在压力面前如果能做到优雅的话，这本身就说明你真的能够把困境作为常态。这一点对大家未来的人生、工作非常重要，会增进你的幸福感。</p>
<p>最后一点，要做一个具有使命感的人。我不想在这里空谈使命感，不要把它看作离我们很遥远的神圣之物。一个人做好自己每一个人生阶段中应该做好的事情，把自己喜欢做的事情尽可能地做到极致甚至像清教徒那样对待自己喜欢的职业并愿意为此努力一生，你就是一个具有使命感的人。所谓工匠精神，本质上与这种对职业的敬畏和使命感的理解与坚守密不可分。工匠精神与功利主义无缘。</p>
<p>在此我还想强调的是，今天的中国已经不是国土沦丧、家破人亡的民族危亡状态，而是处在快速崛起的进程当中，过去的“为中华崛起而读书”不应当是现在大家读书、学习的目标。</p>
<p>今天的中国面对着前所未有的经济全球化的大环境、面对着如何成为创新性国家的重任，只有我们每一个人、在座的每一位毕业生同学成为真正的人，即成为具有学习能力、独立思考能力、自主选择能力、审美能力、战胜困难能力和有使命感的人，你自己的一生才会幸福，我们这个社会才能不断进步，中华民族才真的有希望。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何看待英国的疫情操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/17/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%8B%B1%E5%9B%BD%E7%9A%84%E7%96%AB%E6%83%85%E6%93%8D%E4%BD%9C/"
    >如何看待英国的疫情操作</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/17/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%8B%B1%E5%9B%BD%E7%9A%84%E7%96%AB%E6%83%85%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2020-03-17T04:09:58.000Z" itemprop="datePublished">2020-03-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>今天也在油管上看了Channel 4的这档新闻，印象最深的就是那哥们在强调herd immunity时，另外一个主张强力介入的嘉宾的表情。</p>
<p>当时我狂笑了快一分钟。</p>
<p>不过，我对腹黑的英国人充满不信任。美国和英国在阴谋诡计上对比，美国就是个弟弟。所以我有个不成熟的猜想：</p>
<p>英国同样想实施强力介入的措施，快一千例了，意大利啥样子都看到了。</p>
<p>打了两次世界大战又不是不懂什么叫战时体制，加上NHS又是英国特色社会主义的经典体现，有经验有工具干嘛不搞？</p>
<p>一是钱算谁的，二是要做的好看。</p>
<p>小特朗普鲍里斯为了上位，除了脱欧之外，还大力支持增加NHS的预算。所以他胜选后宣布的第一优先都不是脱欧，而是搞定NHS的预算。</p>
<p>这6600万人真是能花，我国基本医保总支出18年也就18000亿人民币。</p>
<p>强力介入必然要花大钱，这是当务之急。</p>
<p>所以怎么把花钱的事做的好听？</p>
<p>你传染一发生就大张旗鼓严格介入，直接的防疫费用不用说；伦敦以金融业旅游业交通业地产业为主，哪个行业不是严重依赖人的流动？这因防疫所导致的经济停转成本就吓死人。</p>
<p>老老实实按照WHO那套去隔离去封锁，控制不住鲍里斯死定了；就算控制住了，经济停转的亏空也足以让万年陪跑科尔宾在议院里轰上一年。</p>
<p>加上今年经济形势明显下滑，已经进入准危机状态，怕是防疫成功经济也没救。鲍里斯一直主张脱欧有助于经济，稍有不慎，疫情+经济下滑，普通民众和留欧派肯定会让科尔宾刷新战绩。</p>
<p>不行，肯定不行。</p>
<p>其次，英国一直暗搓搓地阻挠欧洲和中国的联手。英国自明确脱欧后，一直的战略思路是反对欧洲与中国直接走近，并引导中国选择英国，作为中国在欧洲整个大洲的利益支点。</p>
<p>这样，脱欧后的英国就能在传统英美关系下又获得与中国的特殊关系，反向加强自身在五眼联盟中的地位，平衡美帝独大的压力。</p>
<p>所以说老阴比嘛。</p>
<p>因此英国在对中国宣传上一直在夹私货，尝试用自己的影响力来缓阻欧洲的转向速度。这次疫情我们有好的一面，但烂的那面也不少，自然成为英国宣传战略里的绝佳素材。</p>
<p>现在开嘲讽开了快两个月，中国之前的一切被喷的手段突然要用到自己身上，不找个好点的借口，不仅英国民众要闹，欧洲回头也要炸锅。</p>
<p>所以要换过来，让民众觉得是他们自己要花钱。</p>
<p>怎么让民众心甘情愿掏钱？恐吓他们。</p>
<p>“中国那套玩法我们是搞不了的，体制不同，我们无法支付那样的成本，民众也不会同意”；</p>
<p>“出行自由我们是尊重的，税金的使用我们要严格根据法律规定来办，这是我国的价值观”；</p>
<p>“因此我们根据国民和国情，总结出一套资源内可行的方案，你们资辞不资辞呀”。</p>
<p>民众一看昏古去，醒过来骂声震天。</p>
<p>然后下周下议院一上班，科尔宾必然要开火：</p>
<p>听说你们要herd immunity，你们是不是打算置普通英国民众，特别是the old and the weak的生死于不顾！</p>
<p>表情一定要义正言辞。</p>
<p>鲍里斯一捋金发，怒目圆睁：</p>
<p>谁说的？没看到NHS和政府正在全力为英国人民对抗疫情吗？政府何时说要放弃民众？你你你你们工党不要听风是雨，天真简单！</p>
<p>然后抽一出一个本本：</p>
<p>我们现在正在竭尽全力，但是困难时刻需要我们英国人民的支持，这是临时增加的预算大家康康。</p>
<p>估计还会念几句丘吉尔。</p>
<p>科尔宾和鲍里斯几个来回互表对英国人民的忠心，夹杂在对英国人民坚韧性格的回顾和赞美声中，要多花钱这句话就过去了。然后是大英上下一心，共抗疫情，医护辛苦，巴拉巴拉。</p>
<p>这样就很漂亮。</p>
<p>第一，不是我们主动花钱抗疫、亏钱防疫，是应民众之呼唤，朝野之悲声，是救水火解倒悬的大义。</p>
<p>第二，万一钱花了效果还不行，你们骂中国去，丫的过度防疫引起恐慌欺骗他国混乱WHO，BBC出来干活啦。</p>
<p>你看，这样虽然英国本质上和美帝一样漠视疫情滞后反应，但是鲍里斯哪要像特朗普一样承担CNN7x24小时的反攻倒算？</p>
<p>疫情成为特朗普本来毫无悬念胜选的最大黑马事件，但操作得当，却会成为我鲍里斯继脱欧后的又一大功。脱欧与NHS，押宝全中，鲍中堂可列大英名相之位咯。</p>
<p>所以说美国人啊，真的是最年轻的帝国主义，太实诚。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-为什么出现危机都要启动大基建"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%E5%8D%B1%E6%9C%BA%E9%83%BD%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%A7%E5%9F%BA%E5%BB%BA/"
    >为什么出现危机都要启动大基建</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%E5%8D%B1%E6%9C%BA%E9%83%BD%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%A7%E5%9F%BA%E5%BB%BA/" class="article-date">
  <time datetime="2020-03-15T17:54:48.000Z" itemprop="datePublished">2020-03-15</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>1.本质上来说，凯恩斯主义的核心，就是通过财政扩张来解决经济周期问题，搞基建只是最常见的一种。但这里要提醒一下，旧凯恩斯主义已经失败被淘汰了（这里不展开了，有兴趣的人去看看当年的滞涨时期出现后，旧凯恩斯主义是如何因为无法解释这一原因导致整个学派崩溃的，至于几个高票答案，显然不知道这段历史）。</p>
<p>2.中国现在搞基建，边际收益还勉强是正的。对于其他发达国家来说，因为基建已经较为完备，再搞基建边际收益可能就是负数了。过一段时间以后中国也会是如此。这一轮之所以强调新基建，因为公路铁路这些旧基建的边际收益很可能已经是负数了。旧基建从业人员前景堪忧，以后可能只能去非洲中亚找饭吃（曹学上线）。</p>
<p>1，2是宏观经济学里最基本的常识。</p>
<p>说不好听一点，满嘴基建狂魔的人，见识档次欠佳。基建狂魔其实是发达国家上世纪和上上世纪玩剩下的。现在发达国家要是继续搞下去，只能和日本政府一样债台高筑了。</p>
<p>现在搞基建＝扶贫，以工代赈，顺便洗钱。这事你我知道就好，说出来很多人接受不了。</p>
<p>老板吃肉，下面才有汤</p>
<p>从《美国货币史》来看，新政的效果其实没有那么好。当时经济危机发生的原因也和中学教材说的完全不一样。彼时没有存款保险法，银行倒闭储户存款也会完蛋。所以危机出现后很快出现了遍及全美的银行挤兑。银行体系处于半瘫痪状态，这个过程里基础货币从银行体系搬家到了家庭床底下。引发了严重的通缩和危机。</p>
<p>本币债务能通过通胀消化，魏玛德国、德三帝国时期主要有大量的外币债务（一战失败的战争赔款），货币政策受到掣肘（蒙代尔不可能三角）。最终大概率铤而走险对外扩张，吞并法国直接消灭了对法外债。</p>
<p>我看网上有一个大佬写的。为什么相同的方法，瘸子被后世吹捧，元首被人唾骂。因为元首先憋不住了，决定改卖货为抢货。为什么呢？第一市场销售环境不同，美国在美洲基本没有竞争对手，产品销路稳定，在东亚，日本在上升期，消费胃口大，肯烧钱搞海军陆军，美国钢铁的销售行情一路看涨，德国不一样，它主要做中欧和巴尔干市场，这里都是小国，消费能力本就有限，而且面临法国的竞争，例如德国卖一批军火给保加利亚，小协约国，捷罗南之类马上会像巴黎下单。第二农业危机，纳粹本质是小农小业主的代表，既不像苏俄一样可以搞集体农奴制，也不像美国一样幅员辽阔，有搞农庄的基础，小农的底子不能触动，又要供应大工业城镇的市场需求，怎么办？于是西进是为了工商业者和英法争夺欧洲大陆的市场，东进是为了小农们的土地需求。</p>
<p>我的观点从来就没有变化：一切力量都可以为国家利益服务，从金融到军事。</p>
<p>这不是说有些人天生就爱杀人爱流血爱尸骸成堆，这是在阐述一个系统，一种万有引力：它的目的不受个人的意志而转移。</p>
<p>金融对美帝的重要性不用说了吧？外号就叫金融帝国主义，高度发达的虚拟经济，使得国民和政府的大量利益——从养老金到五角大楼——都由华尔街来交易、变现、流通。</p>
<p>不夸张地说，美帝这个国家已经证券化了。</p>
<p>所以千万不要用国内看A股洗脚婢的心态来看美股。A股从属于我朝，美帝从属于华尔街。不是华尔街的人真的吊到天天对总统耳提面命（其实是有的，例如高盛提携里根的那位），而是华尔街象征着一种系统，系统的意志高于它的零部件。</p>
<p>所以，当美帝的虚拟经济遭到承重压力，政府、国民、资本方的利益都被捆绑时，他们必然会寻找解决方案。不需要什么阴谋，不用像电影里奏起诡谲的BGM，他们会自发诞生答案，如同蜂群。</p>
<p>因此，思考的重点不在于美帝想做什么，而是他还能做什么。</p>
<p>虚拟经济收益畸高，必然会在一个拐点上开始回归实体经济。这个回归多数就是泡沫要炸了。</p>
<p>泡沫要炸了无外乎三种：</p>
<p>一是任你炸，躺平任艹。日本广场协议那波非常类似，但更经典的就是2933大危机。</p>
<p>任你炸的后果现在大家都知道了。恐慌无限放大人的非理性部分，市场严重震荡，资产价格跳崖，全行业现金流奔崩裂，国家直接动乱。</p>
<p>现在不是非洲那种捞一把就去迪拜巴黎养老的军阀，没有政府会在还有的选的时候来这个。</p>
<p>二是冻住不许走，时停系列。典型的就是我朝在几次房价要飙时的操作。</p>
<p>冻住不许走需要你有一套备用系统，可以在冻结泡沫的同时保证国家系统的基础运营。我们从来都是双轨制，所以但凡某个领域泡沫要炸，就用文件把泡沫冻住：</p>
<p>北上广深泡沫要炸，冻住之后成都武汉开始抢人了；成都武汉房价要炸，冻住之后还有高铁经济带；万一高铁经济带的房价也过了，还有鹤岗呢。</p>
<p>鹤岗的房子是谁建的？城投城建；城投城建是谁？是国开行。这就是两套系统。</p>
<p>冻住不许走除了我们，还有一个国家也很溜，就是大家平日口嗨的印度。（想不到吧.jpg）</p>
<p>印度还有一大批半封建半现代的小农自治体，这是印度每次在貌似要总崩盘的时候都能奇妙苟过来的重要底牌。不愧是把社会主义写入宪法的国家。</p>
<p>三是改变气压。</p>
<p>是不是突然以为在上物理课？</p>
<p>泡沫为什么炸？因为你吹了太多气在泡沫里，内部压力高于外部，就炸了。</p>
<p>那我要是把外部压力搞得比我内部压力还大，那泡沫不就不炸了嘛！</p>
<p>恭喜你，格林斯潘今晚请你吃饭！</p>
<p>美国所掌握的实体经济基本上只有军工复合体、能源、农业和航天芯片高尖精工业。而这些加一块都不足以满足虚拟经济的收益要求，美帝的虚拟收益和实体收益之间存在巨大落差。</p>
<p>资本一旦发现虚拟经济无法兑现许诺的畸高收益，就会重回有较稳定收益的实体；本国没有实体来承载，资本就必然外逃。</p>
<p>这个回归的过程犹如自由落体（巧了，今天推特上最多的词就是free fall）。那怎么阻止free fall？</p>
<p>美帝已经掌握了全球的铸币权，全球资源的总定价权在他手里，他牢牢占据虚拟经济的高地。</p>
<p>那剩下来要做的，就是确保全球范围内，没有比他更优的实体经济，没有只进不出的貔貅。</p>
<p>因为历史上就有一只貔貅，给他造成大麻烦。</p>
<p>大萧条时，美帝这边资产跳水、工人和技术人员失业，那边苏联咬着牙用集体农庄饿死乌克兰人的外汇疯狂买美帝的设备和人，实现工业化猪突猛进。</p>
<p>这导致了美帝当时居然出现了一定程度的去工业化，而苏联留下了一票美国人移民后裔。</p>
<p>这就是貔貅。苏联的体制决定了美帝在低价位时出售的东西，没法做个更低价让苏联吐出来。而技术、工业设备、研发人才的流失，是真正的失血，特别是当你没有掌握铸币权的时候。</p>
<p>万幸的是二战把欧洲打烂了，最后苏联解体时也把当年得到的加了百倍利息吐回来。从此，美帝就再也没有真正纠结过金融危机。</p>
<p>99年欧元正式发行，我就去揍一顿南联盟，给你出生庆礼；没想到你还整挺好，03年再打一顿伊拉克。</p>
<p>不是法德俄欧洲三大国一致反对吗？不是说中东是你们的利益范围吗？照打。资本需要暴力来保证交易的顺利执行，美帝能展现暴力的可靠，资本就会稳定在美帝一方。</p>
<p>“哎哎哎王蜀黍，为什么美帝不能让自己的实体经济变得更好，用竞争超过其他人呢？”</p>
<p>傻孩子，有美军在手，打就完事了。老老实实开工厂做研发做优化多累啊。没事，等你将来大学读自动化，出来就业就理解了。</p>
<p>我朝现在最尴尬的地方，就是我们是貔貅。</p>
<p>我们的实体收益高吗？</p>
<p>不算高，但比美帝高。而且本身的内需市场和产品所覆盖的全球市场加总，还是挺高的；</p>
<p>我们的资本可以随意流动吗？</p>
<p>不能，一般进来了就出不去，换个美元要凑几十个人的身份证，反洗钱中心都快把留学生逼疯了；</p>
<p>我们的暴力可靠吗？</p>
<p>跟美帝打遍全球不能比，但是家门口这一圈，还是能保证有来无回的。</p>
<p>那你不就是貔貅嘛。</p>
<p>一个有独立经济权力和武力保证的制造国，就是天然貔貅。</p>
<p>制造国、金融国、资源国三者里，制造国最容易维系工业体系的运转，因为金融国和资源国都需要制造国的产品；</p>
<p>制造国也能较好保证科技的迭代，因为制造会产生大量现实的市场需求，并为科研提供基础的成本；</p>
<p>一个制造国一旦拥有独立的经济权力，可以把握自己的货币政策和金融监管。那在工业社会里，他就是一个半闭环。</p>
<p>弱的如越南，强的如德国，都是这种半闭环，能成为区域内的稳态社会，并逐步吸纳区域内的资源。引进原材料，加工制造，同时形成基础研发乃至高端研发能力，保留利润，卖出去。</p>
<p>如果这种技术能力最后出现代差，资源国和金融国看制造国就跟看黑盒子一样。</p>
<p>所以占据优位的金融国，必须时不时打破这种半闭环，夺走利润，保证制造国长期处于技术下游。</p>
<p>金融收割是常态，必要时武力打击也可以。而且不需要直接打击，太难看了。破坏制造国的市场，让他资金无法回来就行，例如老欧洲的中东，例如俄罗斯最后的境外工业品市场乌克兰。</p>
<p>把多数国家锁在资源国身份，少数锁在低端制造业，金融和高端制造牢牢握在自己手里，进而形成科技与军事的代差优势，这是金融国最美的梦。</p>
<p>但是有只貔貅出现了。</p>
<p>按照美帝正常的剧本，我们在改开之初，就应该一直老老实实做玩具衣服；等到美帝做了新能源汽车，我们再去做小摩托；等到美帝做了火星飞船，我们再去做飞机。</p>
<p>但是庞大的人口、完备的工业门类、高素质廉价劳动力、公费高等教育（对，就是公费）、政府产业规划、独立主权，等等等等因素汇总，使得我们没有按照既定剧本走下去。</p>
<p>一边是低端产业逐渐爬升中端，玩具变机电；一边是科研投入与留学形成的中高端雏形；再加上严格的资本政策。</p>
<p>你慢慢变得更好，收益率逐步提高，同时能突然打断你收益率的手段在快速减少。</p>
<p>一个稳定的不可控的高收益地区对美帝，这个金融帝国主义，意味着什么？</p>
<p>血在外流，经脉逆行。</p>
<p>人有意识形态，资本没有。斯大林管理的卢布和胡佛管理的美元，虽然限定在不同的意识形态里，但是卢布和美元一样，需要实际价值做支撑，需要交换，需要收益和增殖。</p>
<p>如果美元没有收益而人民币有，那美元也会变成人民币。</p>
<p>这是美帝绝不允许的。</p>
<p>所以从崩溃论、威胁论、共治论、敌国论，各路帽子如大雪纷飞，应接不暇。手段也从常规的贸易战上升到科技战，并且开始在尝试进一步越界。</p>
<p>然后突然，美帝的金融，好像有点崩。</p>
<p>预示着什么？</p>
<p>不知道。</p>
<p>我只知道虚拟收益总是要向实体收益回归，小冰河期总是要来，等降水线总是要南移。</p>
<p>要么进了长城种田，要么长城内变成草原。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chinese/" rel="tag">Chinese</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-React总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/14/React%E6%80%BB%E7%BB%93/"
    >React总结</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/14/React%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-03-14T19:38:17.000Z" itemprop="datePublished">2020-03-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1、什么是react"><a href="#1、什么是react" class="headerlink" title="1、什么是react"></a>1、什么是react</h2><p>React.js 是一个帮助你构建页面 UI 的库。<br> React.js 将帮助我们将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，就成了我们的页面。<br> <strong>React.js 中一切皆组件，用 React.js 写的其实就是 React.js 组件。</strong><br> React.js 不是一个框架，它只是一个库。它只提供 UI （view）层面的解决方案。在实际的项目当中，它并不能解决我们所有的问题，需要结合其它的库，例如 Redux、React-router 等来协助提供完整的解决方法。</p>
<h2 id="2、理解JSX"><a href="#2、理解JSX" class="headerlink" title="2、理解JSX"></a>2、理解JSX</h2><p>React.js 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构。<br> <strong>所谓的 JSX 其实就是 JavaScript 对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     React.createElement(</span><br><span class="line">        <span class="string">&quot;div&quot;</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        React.createElement(</span><br><span class="line">          <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">          &#123; <span class="attr">className</span>: <span class="string">&#x27;title&#x27;</span> &#125;,</span><br><span class="line">          <span class="string">&quot;React 小书&quot;</span></span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="../images/image-20200314143949254.png" alt="image-20200314143949254" style="zoom:200%;" />

<p>有些同学可能会问，为什么不直接从 JSX 直接渲染构造 DOM 结构，而是要经过中间这么一层呢？</p>
<p>第一个原因是，当我们拿到一个表示 UI 的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能把这个结构渲染到 canvas 上，或者是手机 App 上。所以这也是为什么会要把 react-dom 单独抽离出来的原因，可以想象有一个叫 react-canvas 可以帮我们把 UI 渲染到 canvas 上，或者是有一个叫 react-app 可以帮我们把它转换成原生的 App（实际上这玩意叫 ReactNative）。</p>
<p>第二个原因是，有了这样一个对象。当数据变化，需要更新组件的时候，就可以用比较快的算法操作这个 JavaScript 对象，而不用直接操作页面上的 DOM，这样可以尽量少的减少浏览器重排，极大地优化性能。这个在以后的章节中我们会提到。</p>
<p><strong>总结</strong></p>
<p>要记住几个点：</p>
<ul>
<li>JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML。</li>
<li>React.js 可以用 JSX 来描述你的组件长什么样的。</li>
<li>JSX 在编译的时候会变成相应的 JavaScript 对象描述。</li>
<li>react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上。</li>
</ul>
<h2 id="3、组件的组合、嵌套和组件树"><a href="#3、组件的组合、嵌套和组件树" class="headerlink" title="3、组件的组合、嵌套和组件树"></a>3、组件的组合、嵌套和组件树</h2><p>组件可以和组件组合在一起，组件内部可以使用别的组件。就像普通的 HTML 标签一样使用就可以。这样的组合嵌套，最后构成一个所谓的组件树，就正如上面的例子那样，Index 用了 Header、Main、Footer，Header 又使用了 Title 。这样用这样的树状结构表示它们之间的关系：</p>
<p><img src="../images/image-20200314144040294.png" alt="image-20200314144040294"></p>
<p>当页面结构复杂起来，有许多不同的组件嵌套组合的话，组件树会相当的复杂和庞大。<strong>理解组件树的概念对后面理解数据是如何在组件树内自上往下流动过程很重要。</strong></p>
<h2 id="4、事件监听"><a href="#4、事件监听" class="headerlink" title="4、事件监听"></a>4、事件监听</h2><p><strong>关于事件中的 this</strong><br> 一般在某个类的实例方法里面的 this 指的是这个实例本身。<br> 但是 React.js 调用你所传给它的方法的时候，并不是通过对象方法的方式调用（this.handleClickOnTitle），而是直接通过函数调用 （handleClickOnTitle），<strong>所以事件监听函数内并不能通过 this 获取到实例。</strong><br> 如果你想在事件函数当中使用当前的实例，你需要手动地将实例方法 bind 到当前实例上再传入给 React.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClickOnTitle (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1 onClick=&#123;<span class="built_in">this</span>.handleClickOnTitle.bind(<span class="built_in">this</span>)&#125;&gt;React 小书&lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>为 React 的组件添加事件监听是很简单的事情，你只需要使用 React.js 提供了一系列的 on* 方法即可。</li>
<li>React.js 会给每个事件监听传入一个 event 对象，这个对象提供的功能和浏览器提供的功能一致，而且它是兼容所有浏览器的。</li>
<li>React.js 的事件监听方法需要手动 bind 到当前实例，这种模式在 React.js 中非常常用。</li>
</ul>
<h2 id="5、组件的-state-和-setState"><a href="#5、组件的-state-和-setState" class="headerlink" title="5、组件的 state 和 setState"></a>5、组件的 state 和 setState</h2><p>setState 接受函数参数:<br> 这里还有要注意的是，当你调用 setState 的时候，<strong>React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。</strong>这一点要好好注意。可以体会一下下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.isLiked)</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    isLiked: !<span class="built_in">this</span>.state.isLiked</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.isLiked)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现两次打印的都是 false，即使我们中间已经 setState 过一次了。这并不是什么 bug，只是 React.js 的 setState 把你的传进来的状态缓存起来，稍后才会帮你更新到 state 上，所以你获取到的还是原来的 isLiked。</p>
<p>所以如果你想在 setState 之后使用新的 state 来做后续运算就做不到了，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) <span class="comment">// =&gt; this.state.count 还是 undefined</span></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span>&#125;) <span class="comment">// =&gt; undefined + 1 = NaN</span></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">2</span>&#125;) <span class="comment">// =&gt; NaN + 2 = NaN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码的运行结果并不能达到我们的预期，我们希望 count 运行结果是 3 ，可是最后得到的是 NaN。但是这种后续操作依赖前一个 setState 的结果的情况并不罕见。</p>
<p>这里就自然地引出了<strong>setState 的第二种使用方式:可以接受一个函数作为参数</strong>，。React.js 会把上一个 setState 的结果传入这个函数，你就可以使用该结果进行运算、操作，然后返回一个对象作为更新 state 的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: prevState.count + <span class="number">1</span> &#125; <span class="comment">// 上一个 setState 的返回是 count 为 0，当前返回 1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: prevState.count + <span class="number">2</span> &#125; <span class="comment">// 上一个 setState 的返回是 count 为 1，当前返回 3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后的结果是 this.state.count 为 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以达到上述的利用上一次 setState 结果进行运算的效果。</p>
<hr>
<p><strong>setState 合并</strong><br> 上面我们进行了三次 setState，但是实际上组件只会重新渲染一次，而不是三次；这是因为在 React.js 内部会把 JavaScript 事件循环中的消息队列的同一个消息中的 setState 都进行合并以后再重新渲染组件。</p>
<p>深层的原理并不需要过多纠结，你只需要记住的是：在使用 React.js 的时候，并不需要担心多次进行 setState 会带来性能问题。</p>
<h2 id="6、配置组件的-props"><a href="#6、配置组件的-props" class="headerlink" title="6、配置组件的 props"></a>6、配置组件的 props</h2><p>在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为 props 对象的键值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClickOnLikeButton () &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> wordings = <span class="built_in">this</span>.props.wordings || &#123; <span class="comment">//获取props</span></span><br><span class="line">      likedText: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">      unlikedText: <span class="string">&#x27;点赞&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClickOnLikeButton.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isLiked ? wordings.likedText : wordings.unlikedText&#125; 👍</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;LikeButton likedText=<span class="string">&#x27;已赞&#x27;</span> unlikedText=<span class="string">&#x27;赞&#x27;</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>props 不可变</strong><br>props 一旦传入进来就不能改变。修改上面的例子中的 handleClickOnLikeButton:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">  <span class="built_in">this</span>.props.likedText = <span class="string">&#x27;取消&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    isLiked: !<span class="built_in">this</span>.state.isLiked</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们尝试在用户点击按钮的时候改变 <code>this.props.likedText</code> ，然后你会看到控制台报错了。<br> <strong>你不能改变一个组件被渲染的时候传进来的 props</strong>。React.js 希望一个组件在输入确定的 props 的时候，能够输出确定的 UI 显示形态。<strong>如果 props 渲染过程中可以被修改，那么就会导致这个组件显示形态和行为变得不可预测，这样会可能会给组件使用者带来困惑。</strong></p>
<p>但这并不意味着由 props 决定的显示形态不能被修改。<strong>组件的使用者可以主动地通过重新渲染的方式把新的 props 传入组件当中</strong>，这样这个组件中由 props 决定的显示形态也会得到相应的改变。</p>
<hr>
<p><strong>总结</strong></p>
<ul>
<li>为了使得组件的可定制性更强，在使用组件的时候，可以在标签上加属性来传入配置参数。</li>
<li>组件可以在内部通过 this.props 获取到配置参数，组件可以根据 props 的不同来确定自己的显示形态，达到可配置的效果。</li>
<li>可以通过给组件添加类属性 defaultProps 来配置默认参数。<br> props 一旦传入，你就不可以在组件内部对它进行修改。但是你可以通过父组件主动重新渲染的方式来传入新的 props，从而达到更新的效果。</li>
</ul>
<h2 id="7、state-vs-props"><a href="#7、state-vs-props" class="headerlink" title="7、state vs props"></a>7、state vs props</h2><p>我们来一个关于 state 和 props 的总结。</p>
<p><strong>state</strong>:主要作用是用于组件保存、控制、修改<strong>自己</strong>的可变状态。state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。state 中状态可以通过 this.setState 方法进行更新，setState 会导致组件的重新渲染。</p>
<p><strong>props</strong>: 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props，否则组件的 props 永远保持不变。</p>
<p>state 和 props 有着千丝万缕的关系。它们都可以决定组件的行为和显示形态。一个组件的 state 中的数据可以通过 props 传给子组件，一个组件可以使用外部传入的 props 来初始化自己的 state。但是它们的职责其实非常明晰分明：<strong>state 是让组件控制自己的状态，props 是让外部对组件自己进行配置。</strong></p>
<p><strong>如果你觉得还是搞不清 state 和 props 的使用场景，那么请记住一个简单的规则：尽量少地用 state，尽量多地用 props。</strong></p>
<p><strong>没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）</strong>。</p>
<blockquote>
<p>因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。前端应用状态管理是一个复杂的问题，我们后续会继续讨论。</p>
</blockquote>
<p>React.js 非常鼓励无状态组件，在 0.14 版本引入了函数式组件——一种定义不能使用 state 组件，例如一个原来这样写的组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi () &#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="built_in">this</span>.sayHi.bind(<span class="built_in">this</span>)&#125;&gt;Hello World&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用函数式组件的编写方式就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HelloWorld = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sayHi = <span class="function">(<span class="params">event</span>) =&gt;</span> alert(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onClick=&#123;sayHi&#125;&gt;Hello World&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以前一个组件是通过继承 Component 来构建，一个子类就是一个组件。而用函数式的组件编写方式是一个函数就是一个组件，你可以和以前一样通过 <HellWorld /> 使用该组件。不同的是，函数式组件只能接受 props 而无法像跟类组件一样可以在 constructor 里面初始化 state。你可以理解函数式组件就是一种只能接受 props 和提供 render 方法的类组件。</p>
<h2 id="8、渲染列表数据"><a href="#8、渲染列表数据" class="headerlink" title="8、渲染列表数据"></a>8、渲染列表数据</h2><p>列表数据在前端非常常见，我们经常要处理这种类型的数据，例如文章列表、评论列表、用户列表…一个前端工程师几乎每天都需要跟列表数据打交道。</p>
<p>React.js 当然也允许我们处理列表数据，但在使用 React.js 处理列表数据的时候，需要掌握一些规则。我们这一节会专门讨论这方面的知识。</p>
<h3 id="渲染存放-JSX-元素的数组"><a href="#渲染存放-JSX-元素的数组" class="headerlink" title="渲染存放 JSX 元素的数组"></a>渲染存放 JSX 元素的数组</h3><p>假设现在我们有这么一个用户列表数据，存放在一个数组当中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Tomy&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Lily&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Lucy&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果现在要把这个数组里面的数据渲染页面上要怎么做？开始之前要补充一个知识。之前说过 JSX 的表达式插入 <code>&#123;&#125;</code> 里面可以放任何数据，如果我们往 <code>&#123;&#125;</code> 里面放一个存放 JSX 元素的数组会怎么样？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;[</span><br><span class="line">          &lt;span&gt;React.js &lt;/span&gt;,</span><br><span class="line">          &lt;span&gt;is &lt;/span&gt;,</span><br><span class="line">          &lt;span&gt;good&lt;/span&gt;</span><br><span class="line">        ]&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们往 JSX 里面塞了一个数组，这个数组里面放了一些 JSX 元素（其实就是 JavaScript 对象）。</p>
<p>React.js 把插入表达式数组里面的每一个 JSX 元素一个个罗列下来，渲染到页面上。所以这里有个关键点：<em>如果你往 <code>&#123;&#125;</code> 放一个数组，React.js 会帮你把数组里面一个个元素罗列并且渲染出来</em>。</p>
<h3 id="使用-map-渲染列表数据"><a href="#使用-map-渲染列表数据" class="headerlink" title="使用 map 渲染列表数据"></a>使用 map 渲染列表数据</h3><p>知道这一点以后你就可以知道怎么用循环把元素渲染到页面上：循环上面用户数组里面的每一个用户，为每个用户数据构建一个 JSX，然后把 JSX 放到一个新的数组里面，再把新的数组插入 <code>render</code> 方法的 JSX 里面。看看代码怎么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Tomy&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Lily&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Lucy&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> usersElements = [] <span class="comment">// 保存每个用户渲染以后 JSX 的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) &#123;</span><br><span class="line">      usersElements.push( <span class="comment">// 循环每个用户，构建 JSX，push 到数组中</span></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div&gt;姓名：&#123;user.username&#125;&lt;/div&gt;</span><br><span class="line">          &lt;div&gt;年龄：&#123;user.age&#125;&lt;/div&gt;</span><br><span class="line">          &lt;div&gt;性别：&#123;user.gender&#125;&lt;/div&gt;</span><br><span class="line">          &lt;hr /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;usersElements&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里用了一个新的数组 <code>usersElements</code>，然后循环 <code>users</code> 数组，为每个 <code>user</code> 构建一个 JSX 结构，然后 push 到 <code>usersElements</code> 中。然后直接用表达式插入，把这个 <code>userElements</code> 插到 return 的 JSX 当中。因为 React.js 会自动化帮我们把数组当中的 JSX 罗列渲染出来，所以可以看到页面上显示：</p>
<img src="../images/image-20200314144503017.png" alt="image-20200314144503017" style="zoom:200%;" />

<p>但我们一般不会手动写循环来构建列表的 JSX 结构，可以直接用 ES6 自带的 <code>map</code>（不了解 <code>map</code> 函数的同学可以先了解相关的知识再来回顾这里），代码可以简化成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;div&gt;姓名：&#123;user.username&#125;&lt;/div&gt;</span><br><span class="line">              &lt;div&gt;年龄：&#123;user.age&#125;&lt;/div&gt;</span><br><span class="line">              &lt;div&gt;性别：&#123;user.gender&#125;&lt;/div&gt;</span><br><span class="line">              &lt;hr /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的模式在 JavaScript 中非常常见，一般来说，在 React.js 处理列表就是用 <code>map</code> 来处理、渲染的。现在进一步把渲染单独一个用户的结构抽离出来作为一个组件，继续优化代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Tomy&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Lily&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">&#x27;Lucy&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; user &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;姓名：&#123;user.username&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;年龄：&#123;user.age&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;性别：&#123;user.gender&#125;&lt;/div&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map(<span class="function">(<span class="params">user</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">User</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span></span>)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里把负责展示用户数据的 JSX 结构抽离成一个组件 <code>User</code> ，并且通过 <code>props</code> 把 <code>user</code> 数据作为组件的配置参数传进去；这样改写 <code>Index</code> 就非常清晰了，看一眼就知道负责渲染 <code>users</code> 列表，而用的组件是 <code>User</code>。</p>
<h3 id="key-key-key"><a href="#key-key-key" class="headerlink" title="key! key! key!"></a>key! key! key!</h3><p>现在代码运作正常，好像没什么问题。打开控制台看看：</p>
<img src="../images/image-20200314144605558.png" alt="image-20200314144605558" style="zoom:200%;" />

<p>React.js 报错了。如果需要详细解释这里报错的原因，估计要单独写半本书。但可以简单解释一下。</p>
<p>React.js 的是非常高效的，它高效依赖于所谓的 Virtual-DOM 策略。简单来说，能复用的话 React.js 就会尽量复用，没有必要的话绝对不碰 DOM。对于列表元素来说也是这样，但是处理列表元素的复用性会有一个问题：元素可能会在一个列表中改变位置。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;a&lt;/div&gt;</span><br><span class="line">&lt;div&gt;b&lt;/div&gt;</span><br><span class="line">&lt;div&gt;c&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>假设页面上有这么3个列表元素，现在改变一下位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;a&lt;/div&gt;</span><br><span class="line">&lt;div&gt;c&lt;/div&gt;</span><br><span class="line">&lt;div&gt;b&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><code>c</code> 和 <code>b</code> 的位置互换了。但其实 React.js 只需要交换一下 DOM 位置就行了，但是它并不知道其实我们只是改变了元素的位置，所以它会重新渲染后面两个元素（再执行 Virtual-DOM 策略），这样会大大增加 DOM 操作。但如果给每个元素加上唯一的标识，React.js 就可以知道这两个元素只是交换了位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div key=<span class="string">&#x27;a&#x27;</span>&gt;a&lt;/div&gt;</span><br><span class="line">&lt;div key=<span class="string">&#x27;b&#x27;</span>&gt;b&lt;/div&gt;</span><br><span class="line">&lt;div key=<span class="string">&#x27;c&#x27;</span>&gt;c&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这样 React.js 就简单的通过 <code>key</code> 来判断出来，这两个列表元素只是交换了位置，可以尽量复用元素内部的结构。</p>
<p>这里没听懂没有关系，后面有机会会继续讲解这部分内容。现在只需要记住一个简单的规则：<em>对于用表达式套数组罗列到页面上的元素，都要为每个元素加上 <code>key</code> 属性，这个 <code>key</code> 必须是每个元素唯一的标识</em>。一般来说，<code>key</code> 的值可以直接后台数据返回的 <code>id</code>，因为后台的 <code>id</code> 都是唯一的。</p>
<p>在上面的例子当中，每个 <code>user</code> 没有 <code>id</code> 可以用，可以直接用循环计数器 <code>i</code> 作为 <code>key</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map(<span class="function">(<span class="params">user, i</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">User</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span></span>)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>再看看，控制台已经没有错误信息了。但这是不好的做法，这只是掩耳盗铃（具体原因大家可以自己思考一下）。记住一点：在实际项目当中，如果你的数据顺序可能发生变化，标准做法是最好是后台数据返回的 <code>id</code> 作为列表元素的 <code>key</code>。</p>
<h2 id="9、前端应用状态管理-——-状态提升"><a href="#9、前端应用状态管理-——-状态提升" class="headerlink" title="9、前端应用状态管理 —— 状态提升"></a>9、前端应用状态管理 —— 状态提升</h2><p>我们在讲解 JSX 的章节中提到，下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line"> &lt;Header /&gt;, </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>会编译成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Header, <span class="literal">null</span>), </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其实我们把 <code>Header</code> 组件传给了 <code>React.createElement</code> 函数，又把函数返回结果传给了 <code>ReactDOM.render</code>。我们可以简单猜想一下它们会干什么事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.createElement 中实例化一个 Header</span></span><br><span class="line"><span class="keyword">const</span> header = <span class="keyword">new</span> Header(props, children)</span><br><span class="line"><span class="comment">// React.createElement 中调用 header.render 方法渲染组件的内容</span></span><br><span class="line"><span class="keyword">const</span> headerJsxObject = header.render()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM 用渲染后的 JavaScript 对象来来构建真正的 DOM 元素</span></span><br><span class="line"><span class="keyword">const</span> headerDOM = createDOMFromObject(headerJsxObject)</span><br><span class="line"><span class="comment">// ReactDOM 把 DOM 元素塞到页面上</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>).appendChild(headerDOM)</span><br></pre></td></tr></table></figure>

<p>上面过程其实很简单，看代码就能理解。</p>
<p>我们把 <em>React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载</em>（这个定义请好好记住）。其实 React.js 内部对待每个组件都有这么一个过程，也就是初始化组件 -&gt; 挂载到页面上的过程。所以你可以理解一个组件的方法调用是这么一个过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line">-&gt; <span class="title">render</span>(<span class="params"></span>)</span><br><span class="line">// 然后构造 <span class="title">DOM</span> 元素插入页面</span><br></pre></td></tr></table></figure>

<p>这当然是很好理解的。React.js 为了让我们能够更好的掌控组件的挂载过程，往上面插入了两个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line">-&gt; <span class="title">componentWillMount</span>(<span class="params"></span>)</span><br><span class="line">-&gt; <span class="title">render</span>(<span class="params"></span>)</span><br><span class="line">// 然后构造 <span class="title">DOM</span> 元素插入页面</span><br><span class="line">-&gt; <span class="title">componentDidMount</span>(<span class="params"></span>)</span><br></pre></td></tr></table></figure>

<p><code>componentWillMount</code> 和 <code>componentDidMount</code> 都是可以像 <code>render</code> 方法一样自定义在组件的内部。挂载的时候，React.js 会在组件的 <code>render</code> 之前调用 <code>componentWillMount</code>，在 DOM 元素塞入页面以后调用 <code>componentDidMount</code>。</p>
<p>我们给 <code>Header</code> 组件加上这两个方法，并且打一些 Log：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;construct&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;component will mount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;component did mount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1 className=<span class="string">&#x27;title&#x27;</span>&gt;React 小书&lt;/h1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台你可以看到依次输出：</p>
<img src="../images/image-20200314145149375.png" alt="image-20200314145149375" style="zoom:200%;" />

<p>可以看到，React.js 确实按照我们上面所说的那样调用了定义的两个方法 <code>componentWillMount</code> 和 <code>componentDidMount</code>。</p>
<p>机灵的同学可以想到，一个组件可以插入页面，当然也可以从页面中删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line">-&gt; <span class="title">componentWillMount</span>(<span class="params"></span>)</span><br><span class="line">-&gt; <span class="title">render</span>(<span class="params"></span>)</span><br><span class="line">// 然后构造 <span class="title">DOM</span> 元素插入页面</span><br><span class="line">-&gt; <span class="title">componentDidMount</span>(<span class="params"></span>)</span><br><span class="line">// ...</span><br><span class="line">// 从页面中删除</span><br></pre></td></tr></table></figure>

<p>React.js 也控制了这个组件的删除过程。在组件删除之前 React.js 会调用组件定义的 <code>componentWillUnmount</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; <span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line">-&gt; <span class="title">componentWillMount</span>(<span class="params"></span>)</span><br><span class="line">-&gt; <span class="title">render</span>(<span class="params"></span>)</span><br><span class="line">// 然后构造 <span class="title">DOM</span> 元素插入页面</span><br><span class="line">-&gt; <span class="title">componentDidMount</span>(<span class="params"></span>)</span><br><span class="line">// ...</span><br><span class="line">// 即将从页面中删除</span><br><span class="line">-&gt; <span class="title">componentWillUnmount</span>(<span class="params"></span>)</span><br><span class="line">// 从页面中删除</span><br></pre></td></tr></table></figure>

<p>看看什么情况下会把组件从页面中删除，继续使用上面例子的代码，我们再定义一个 <code>Index</code> 组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      isShowHeader: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleShowOrHide () &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      isShowHeader: !<span class="built_in">this</span>.state.isShowHeader</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isShowHeader ? <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleShowOrHide.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line">          显示或者隐藏标题</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>Index</code> 组件使用了 <code>Header</code> 组件，并且有一个按钮，可以控制 <code>Header</code> 的显示或者隐藏。下面这行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...a</span><br><span class="line">&#123;<span class="built_in">this</span>.state.isShowHeader ? <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>相当于 <code>state.isShowHeader</code> 为 <code>true</code> 的时候把 <code>Header</code> 插入页面，<code>false</code> 的时候把 <code>Header</code> 从页面上删除。这时候我们给 <code>Header</code> 添加 <code>componentWillUnmount</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;component will unmount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时候点击页面上的按钮，你会看到页面的标题隐藏了，并且控制台打印出来下图的最后一行，说明 <code>componentWillUnmount</code> 确实被 React.js 所调用了：</p>
<img src="../images/image-20200314145348052.png" alt="image-20200314145348052" style="zoom:200%;" />

<p>你可以多次点击按钮，随着按钮的显示和隐藏，上面的内容会按顺序重复地打印出来，可以体会一下这几个方法的调用过程和顺序。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载。这一节我们学习了 React.js 控制组件在页面上挂载和删除过程里面几个方法：</p>
<ul>
<li><code>componentWillMount</code>：组件挂载开始之前，也就是在组件调用 <code>render</code> 方法之前调用。</li>
<li><code>componentDidMount</code>：组件挂载完成以后，也就是 DOM 元素已经插入页面后调用。</li>
<li><code>componentWillUnmount</code>：组件对应的 DOM 元素从页面中删除之前调用。</li>
</ul>
<p>但这一节并没有讲这几个方法到底在实际项目当中有什么作用，下一节我们通过例子来讲解一下这几个方法的用途。</p>
<h2 id="10、挂载阶段的组件生命周期"><a href="#10、挂载阶段的组件生命周期" class="headerlink" title="10、挂载阶段的组件生命周期"></a>10、挂载阶段的组件生命周期</h2><p>这一节我们来讨论一下对于一个组件来说，<code>constructor</code> 、<code>componentWillMount</code>、<code>componentDidMount</code>、<code>componentWillUnmount</code> 这几个方法在一个组件的出生到死亡的过程里面起了什么样的作用。</p>
<p>一般来说，所有关于组件自身的状态的初始化工作都会放在 <code>constructor</code> 里面去做。你会发现本书所有组件的 <code>state</code> 的初始化工作都是放在 <code>constructor</code> 里面的。假设我们现在在做一个时钟应用：</p>
<img src="../images/image-20200314145413595.png" alt="image-20200314145413595" style="zoom:200%;" />

<p>我们会在 <code>constructor</code> 里面初始化 <code>state.date</code>，当然现在页面还是静态的，等下一会让时间动起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">          &lt;p&gt;现在的时间是&lt;/p&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些组件启动的动作，包括像 Ajax 数据的拉取操作、一些定时器的启动等，就可以放在 <code>componentWillMount</code> 里面进行，例如 Ajax：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    ajax.get(<span class="string">&#x27;http://json-api.com/user&#x27;</span>, <span class="function">(<span class="params">userData</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; userData &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然在我们这个例子里面是定时器的启动，我们给 <code>Clock</code> 启动定时器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>componentWillMount</code> 中用 <code>setInterval</code> 启动了一个定时器：每隔 1 秒更新中的 <code>state.date</code>，这样页面就可以动起来了。我们用一个 <code>Index</code> 把它用起来，并且插入页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Clock /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>像上一节那样，我们修改这个 <code>Index</code> 让这个时钟可以隐藏或者显示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">isShowClock</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleShowOrHide () &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      isShowClock: !<span class="built_in">this</span>.state.isShowClock</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isShowClock ? <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span> : <span class="literal">null</span> &#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleShowOrHide.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line">          显示或隐藏时钟</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在页面上有个按钮可以显示或者隐藏时钟。你试一下显示或者隐藏时钟，虽然页面上看起来功能都正常，在控制台你会发现报错了：</p>
<img src="../images/image-20200314145616845.png" alt="image-20200314145616845" style="zoom:200%;" />

<p>这是因为，<em>当时钟隐藏的时候，我们并没有清除定时器</em>。时钟隐藏的时候，定时器的回调函数还在不停地尝试 <code>setState</code>，由于 <code>setState</code> 只能在已经挂载或者正在挂载的组件上调用，所以 React.js 开始疯狂报错。</p>
<p>多次的隐藏和显示会让 React.js 重新构造和销毁 <code>Clock</code> 组件，每次构造都会重新构建一个定时器。而销毁组件的时候没有清除定时器，所以你看到报错会越来越多。而且因为 JavaScript 的闭包特性，这样会导致严重的内存泄漏。</p>
<p>这时候<code>componentWillUnmount</code> 就可以派上用场了，它的作用就是在组件销毁的时候，做这种清场的工作。例如清除该组件的定时器和其他的数据清理工作。我们给 <code>Clock</code>添加 <code>componentWillUnmount</code>，在组件销毁的时候清除该组件的定时器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时候就没有错误了。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>我们一般会把组件的 <code>state</code> 的初始化工作放在 <code>constructor</code> 里面去做；在 <code>componentWillMount</code> 进行组件的启动工作，例如 Ajax 数据拉取、定时器的启动；组件从页面上销毁的时候，有时候需要一些数据的清理，例如定时器的清理，就会放在 <code>componentWillUnmount</code> 里面去做。</p>
<p>说一下本节没有提到的 <code>componentDidMount</code> 。一般来说，有些组件的启动工作是依赖 DOM 的，例如动画的启动，而 <code>componentWillMount</code> 的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在 <code>componentDidMount</code> 当中。<code>componentDidMount</code> 的具体使用我们会在接下来的章节当中结合 DOM 来讲。</p>
<h2 id="11、更新阶段的组件生命周期"><a href="#11、更新阶段的组件生命周期" class="headerlink" title="11、更新阶段的组件生命周期"></a>11、更新阶段的组件生命周期</h2><p>从之前的章节我们了解到，组件的挂载指的是将组件渲染并且构造 DOM 元素然后插入页面的过程。<em>这是一个从无到有的过程</em>，React.js 提供一些生命周期函数可以给我们在这个过程中做一些操作。</p>
<p>除了挂载阶段，还有一种“更新阶段”。说白了就是 <code>setState</code> 导致 React.js 重新渲染组件并且把组件的变化应用到 DOM 元素上的过程，<em>这是一个组件的变化过程</em>。而 React.js 也提供了一系列的生命周期函数可以让我们在这个组件更新的过程执行一些操作。</p>
<p>这些生命周期在深入项目开发阶段是非常重要的。而要完全理解更新阶段的组件生命周期是一个需要经验和知识积累的过程，你需要对 Virtual-DOM 策略有比较深入理解才能完全掌握，但这超出了本书的目的。<em>本书的目的是为了让大家快速掌握 React.js 核心的概念，快速上手项目进行实战</em>。所以对于组件更新阶段的组件生命周期，我们简单提及并且提供一些资料给大家。</p>
<p>这里为了知识的完整，补充关于更新阶段的组件生命周期：</p>
<ol>
<li><code>shouldComponentUpdate(nextProps, nextState)</code>：你可以通过这个方法控制组件是否重新渲染。如果返回 <code>false</code> 组件就不会重新渲染。这个生命周期在 React.js 性能优化上非常有用。</li>
<li><code>componentWillReceiveProps(nextProps)</code>：组件从父组件接收到新的 <code>props</code> 之前调用。</li>
<li><code>componentWillUpdate()</code>：组件开始重新渲染之前调用。</li>
<li><code>componentDidUpdate()</code>：组件重新渲染并且把更改变更到真实的 DOM 以后调用。</li>
</ol>
<p>大家对这更新阶段的生命周期比较感兴趣的话可以查看<a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/react-component.html">官网文档</a>。</p>
<p><em>但这里建议大家可以先简单了解 React.js 组件是有更新阶段的，并且有这么几个更新阶段的生命周期即可</em>。然后在深入项目实战的时候逐渐地掌握理解他们，现在并不需要对他们放过多的精力。</p>
<h2 id="12、ref-和-React-js-中的-DOM-操作"><a href="#12、ref-和-React-js-中的-DOM-操作" class="headerlink" title="12、ref 和 React.js 中的 DOM 操作"></a>12、ref 和 React.js 中的 DOM 操作</h2><p>在 React.js 当中你基本不需要和 DOM 直接打交道。React.js 提供了一系列的 on* 方法帮助我们进行事件监听，所以 React.js 当中不需要直接调用 addEventListener 的 DOM API；以前我们通过手动 DOM 操作进行页面更新（例如借助 jQuery），而在 React.js 当中可以直接通过 setState 的方式重新渲染组件，渲染的时候可以把新的 props 传递给子组件，从而达到页面更新的效果。</p>
<p>React.js 这种重新渲染的机制帮助我们免除了绝大部分的 DOM 更新操作，也让类似于 jQuery 这种以封装 DOM 操作为主的第三方的库从我们的开发工具链中删除。</p>
<p>但是 React.js 并不能完全满足所有 DOM 操作需求，有些时候我们还是需要和 DOM 打交道。比如说你想进入页面以后自动 focus 到某个输入框，你需要调用 input.focus() 的 DOM API，比如说你想动态获取某个 DOM 元素的尺寸来做后续的动画，等等。</p>
<p>React.js 当中提供了 ref 属性来帮助我们获取已经挂载的元素的 DOM 节点，你可以给某个 JSX 元素加上 ref属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">this</span>.input.focus()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input ref=&#123;<span class="function">(<span class="params">input</span>) =&gt;</span> <span class="built_in">this</span>.input = input&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;AutoFocusInput /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以看到我们给 input 元素加了一个 ref 属性，这个属性值是一个函数。当 input 元素在页面上挂载完成以后，React.js 就会调用这个函数，并且把这个挂载以后的 DOM 节点传给这个函数。在函数中我们把这个 DOM 元素设置为组件实例的一个属性，这样以后我们就可以通过 this.input 获取到这个 DOM 元素。</p>
<p>然后我们就可以在 componentDidMount 中使用这个 DOM 元素，并且调用 this.input.focus() 的 DOM API。整体就达到了页面加载完成就自动 focus 到输入框的功能（大家可以注意到我们用上了 componentDidMount 这个组件生命周期）。</p>
<p>我们可以给任意代表 HTML 元素标签加上 ref 从而获取到它 DOM 元素然后调用 DOM API。但是记住一个原则：能不用 ref 就不用。特别是要避免用 ref 来做 React.js 本来就可以帮助你做到的页面自动更新的操作和事件监听。多余的 DOM 操作其实是代码里面的“噪音”，不利于我们理解和维护。</p>
<p>顺带一提的是，其实可以给组件标签也加上 ref ，例如：</p>
<p>&lt;Clock ref={(clock) =&gt; this.clock = clock} /&gt;<br> 这样你获取到的是这个 Clock 组件在 React.js 内部初始化的实例。但这并不是什么常用的做法，而且也并不建议这么做，所以这里就简单提及，有兴趣的朋友可以自己学习探索。</p>
<h2 id="13、props-children-和容器类组件"><a href="#13、props-children-和容器类组件" class="headerlink" title="13、props.children 和容器类组件"></a>13、props.children 和容器类组件</h2><p>有一类组件，充当了容器的作用，它定义了一种外层结构形式，然后你可以往里面塞任意的内容。这种结构在实际当中非常常见，例如这种带卡片组件：</p>
<p>组件本身是一个不带任何内容的方形的容器，我可以在用这个组件的时候给它传入任意内容：</p>
<p>基于我们目前的知识储备，可以迅速写出这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&#x27;card&#x27;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;card-content&#x27;</span>&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.props.content&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Card content=&#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;React.js 小书&lt;/h2&gt;</span><br><span class="line">       &lt;div&gt;开源、免费、专业、简单&lt;/div&gt;</span><br><span class="line">      订阅：&lt;input /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们通过给 <code>Card</code> 组件传入一个 <code>content</code> 属性，这个属性可以传入任意的 JSX 结构。然后在 <code>Card</code> 内部会通过 <code>&#123;this.props.content&#125;</code> 把内容渲染到页面上。</p>
<p>这样明显太丑了，如果 <code>Card</code> 除了 <code>content</code> 以外还能传入其他属性的话，那么这些 JSX 和其他属性就会混在一起。很不好维护，如果能像下面的代码那样使用 <code>Card</code> 那想必也是极好的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Card&gt;</span><br><span class="line">    &lt;h2&gt;React.js 小书&lt;/h2&gt;</span><br><span class="line">    &lt;div&gt;开源、免费、专业、简单&lt;/div&gt;</span><br><span class="line">    订阅：&lt;input /&gt;</span><br><span class="line">  &lt;/Card&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果组件标签也能像普通的 HTML 标签那样编写内嵌的结构，那么就方便很多了。实际上，React.js 默认就支持这种写法，所有嵌套在组件中的 JSX 结构都可以在组件内部通过 <code>props.children</code> 获取到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&#x27;card&#x27;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;card-content&#x27;</span>&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>props.children</code> 打印出来，你可以看到它其实是个数组：</p>
<img src="../images/image-20200314145828931.png" alt="image-20200314145828931" style="zoom:200%;" />

<p>React.js 就是把我们嵌套的 JSX 元素一个个都放到数组当中，然后通过 <code>props.children</code> 传给了 <code>Card</code>。</p>
<p>由于 JSX 会把插入表达式里面数组中的 JSX 一个个罗列下来显示。所以其实就相当于在 <code>Card</code> 中嵌套了什么 JSX 结构，都会显示在 <code>Card</code> 的类名为 <code>card-content</code> 的 <code>div</code> 元素当中。</p>
<p>这种嵌套的内容成为了 <code>props.children</code> 数组的机制使得我们编写组件变得非常的灵活，我们甚至可以在组件内部把数组中的 JSX 元素安置在不同的地方：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&#x27;two-cols-layout&#x27;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;sidebar&#x27;</span>&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.props.children[<span class="number">0</span>]&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;main&#x27;</span>&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.props.children[<span class="number">1</span>]&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个两列布局组件，嵌套的 JSX 的第一个结构会成为侧边栏，第二个结构会成为内容栏，其余的结构都会被忽略。这样通过这个布局组件，就可以在各个地方高度复用我们的布局。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>使用自定义组件的时候，可以在其中嵌套 JSX 结构。嵌套的结构在组件内部都可以通过 <code>props.children</code> 获取到，这种组件编写方式在编写容器类型的组件当中非常有用。而在实际的 React.js 项目当中，我们几乎每天都需要用这种方式来编写组件。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">prev page</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/16/">next page</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Aaron
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">🏡</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">🏛</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">📚</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">🏷</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>