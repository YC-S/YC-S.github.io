<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1前端黎明HTML是一种标记语言，属于声明式编程范式，然而，声明式的缺点——复用性差，往往会制约着开发者对应用进行扩展。 早期的网页应用往往体量较小，加之用户体验不强，很多服务器直接将HTML作为数据处理，形成MVC的中介模式（脱藕）实现，model和view是两种不同的数据系统，中介controller则负责将不同的model输入映射到响应的view输出。   中介模式使用一个中介对象来封装两个">
<meta property="og:type" content="article">
<meta property="og:title" content="Angular发展">
<meta property="og:url" content="http://yoursite.com/2020/04/21/Angular%E5%8F%91%E5%B1%95/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:description" content="1前端黎明HTML是一种标记语言，属于声明式编程范式，然而，声明式的缺点——复用性差，往往会制约着开发者对应用进行扩展。 早期的网页应用往往体量较小，加之用户体验不强，很多服务器直接将HTML作为数据处理，形成MVC的中介模式（脱藕）实现，model和view是两种不同的数据系统，中介controller则负责将不同的model输入映射到响应的view输出。   中介模式使用一个中介对象来封装两个">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-33c6b0d61468c9c47096d927ba63a7f4_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-c69ae47c13a33ae29258aaa4e5a746c1_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-5c939ce85d3493b84228c4e9c42ddcfb_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-0b18db551fb28f22ec2b2a6144e314fa_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-1c6fb3d444a24b9d47da59aa59cf0e28_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-9dc80c05224c32a8229415e5c5c7d24f_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-344b3bf052c0670d0961388783ca35e7_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-71e10093612ce44a2ec73dd802369055_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-0aae540aa681bf0b1f65ed3048d549fd_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-bbd1c263d0558f50140f00b10fb0afe8_b-20200421122638731.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-4df3c92e9e36f88ff2b1469e3b39d2d1_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-9b71342a3832a85b2bb4d5215cbf6552_r.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-815e8fe27815962eaf4b9e19e70af166_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-cc7b18b07476255ecd2edf30f42ddc19_b.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-45789737110cc75ba130a034da041d93_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/21/images/v2-bf04a0b5908d27db992f7c591bba4ad7_b.jpg">
<meta property="article:published_time" content="2020-04-21T16:21:36.000Z">
<meta property="article:modified_time" content="2020-04-21T16:29:56.408Z">
<meta property="article:author" content="Yuanchen">
<meta property="article:tag" content="Angular">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/04/21/images/v2-33c6b0d61468c9c47096d927ba63a7f4_b.jpg">

<link rel="canonical" href="http://yoursite.com/2020/04/21/Angular%E5%8F%91%E5%B1%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Angular发展 | Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/Angular%E5%8F%91%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Angular发展
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-21 12:21:36 / Modified: 12:29:56" itemprop="dateCreated datePublished" datetime="2020-04-21T12:21:36-04:00">2020-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="前端黎明"><a href="#前端黎明" class="headerlink" title="前端黎明"></a><strong>前端黎明</strong></h2><p>HTML是一种标记语言，属于声明式编程范式，然而，声明式的缺点——复用性差，往往会制约着开发者对应用进行扩展。</p>
<p>早期的网页应用往往体量较小，加之用户体验不强，很多服务器直接将HTML作为数据处理，形成MVC的中介模式（脱藕）实现，model和view是两种不同的数据系统，中介controller则负责将不同的model输入映射到响应的view输出。</p>
<p><img src="../images/v2-33c6b0d61468c9c47096d927ba63a7f4_b.jpg" alt="img"></p>
<blockquote>
<p>中介模式<br>使用一个中介对象来封装两个系统之间的交互，使得各对象不用显示地相互引用</p>
</blockquote>
<p>但是随着前端交互越来越多，静态的HTML服务端处理根本不能满足交互需求，因此有实现将数据与视图的映射（MVC）迁移到前端，例如AngularJS，Backbone等。</p>
<h2 id="混乱大时代"><a href="#混乱大时代" class="headerlink" title="混乱大时代"></a><strong>混乱大时代</strong></h2><p>但是随着应用体量的不断变大，前端交互逻辑的不断复杂化，这类框架的Controller越来越复杂难以管理，加上浏览器的事件驱动模型（事件循环），使得前端开发步入了困境。</p>
<p>首先解决这一困境的是React，采用函数式编程语言中广泛使用的单向数据流，控制耦合数据的产生和事件的作用范围。</p>
<p><img src="../images/v2-c69ae47c13a33ae29258aaa4e5a746c1_b.jpg" alt="img"></p>
<blockquote>
<p>单向数据流<br>函数式编程（λ演算），例如LISP，采用的是不可变数据+态射变换的方式进行计算，最早由<em>阿隆索·丘奇</em>(Alonzo Church)提出，想象一个函数（函子）的参数是函数，返回值也是函数。（不可变数据本身也是函数，总是返回自身参数，即单位元，单位态射）<br>参考：<br><a href="http://link.zhihu.com/?target=https%3A//github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn">https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn</a><br><a href="http://link.zhihu.com/?target=https%3A//plato.stanford.edu/entries/category-theory/">https://plato.stanford.edu/entries/category-theory/</a><br>维持态射连续性，即形成unidirectional network（单向网络），输入单位元总使从计算系统的输入流向输出（想象一个工业生产线）<br>这样的做法的目的，也是函数式编程的优点之一（参考傻瓜函数式）：<br>因为FP中的每个符号都是final的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。<br>当然函数式的这一优势不仅仅用在前端领域，包括密集计算（模型能够运行则要求运行不出错，例如Haskell），军用（导弹巡航控制），核电站中控（安全要求高），气象等等领域。</p>
</blockquote>
<p><strong>但是React夹杂的私货，却也被混入了前端开发中，这便是MVVM</strong>。</p>
<p><img src="../images/v2-5c939ce85d3493b84228c4e9c42ddcfb_1440w.jpg" alt="img"></p>
<p>每一个设计模式，都有他的应用领域，MVVM是马丁·富勒的Presentation Modal（表示模型）的变体，由约翰·高斯曼提出，优点是<strong>不依赖于特定用户界面平台</strong>。</p>
<p>缺点呢？创造者约翰·高斯曼自己就提出：</p>
<blockquote>
<p>实现MVVM的开销对于简单的UI操作是“过度的”，对于更大的应用来说，推广ViewModel变得更加困难。而且，非常大的应用程序中的数据绑定会导致相当大的内存消耗。</p>
</blockquote>
<p>不仅如此，浏览器在实现视图绑定的阶段，往往伴随着性能开销，而采用VM到V的映射，<strong>往往伴随着大量的视图绑定和解绑过程</strong>，会造成相当的性能瓶颈。</p>
<p>React可以通过很多优化控制重绘的数量（diff）和时间（requestAnimationFrame，setTimeout），但是当应用体量越来越庞大的时候，它所提到的<strong>“Web UI中跨层级移动操作特别少”这个前置条件慢慢失效，而维护一个庞大的数据池带来的内存消耗和数据持久化问题也越来越突出</strong>。</p>
<p>但是React为什么还要采用MVVM而放弃掉MVC呢？</p>
<p>Facebook成立于2004年，而2005年WWDC大会上，苹果不仅发布了iPod nano这一音乐领域的飓风，还联合各家浏览器厂商，联合发布了围堵IE的<strong>WebKit</strong>，浏览器领域迎来了新的一波风暴。</p>
<p><img src="../images/v2-0b18db551fb28f22ec2b2a6144e314fa_b.jpg" alt="img"></p>
<p>当然，刚刚成立的facebook直到当年九月份才将高中版Facebook向大众开放，自然错过了浏览器之争的关键时机。但是作为以互联网产品为盈利主力的facebook，肯定不希望自己的产品被浏览器钳制，不可能因为浏览器的更新迭代甚至是恶意竞争而妨碍到自己的利益。并且在当时浏览器兼容问题严重的情况下，MVVM的平台无关也更加符合Facebook甚至是用户的切身利益。</p>
<p>另外，由于没有考虑到前端的复杂度会到达今天这样的地步，网景在设计JavaScript的时候，考虑利用函数式编程中“直观”的优势，以及异步带来的交互友好，将JS设计成了协程异步系统，这毫无疑问将编程要求提高到一个较高的层次，使得一线开发人员叫苦不迭。<strong>而MVVM又能有效地将异步的问题同步化（针对数据操作）</strong>，因此，选择MVVM这一模式几乎是必然的。</p>
<p>因此React在2011年开始用于facebook的newsfeed，而这一年正是浏览器竞争最为激烈的一年，不管是从开发效率还是从运行稳定性上来看，React都是最好并且最符合Facebook利益的选择，于是快马加鞭，于2013年正式向公众开放。</p>
<p><img src="../images/v2-1c6fb3d444a24b9d47da59aa59cf0e28_b.jpg" alt="img"></p>
<p>React的单向数据流思想，让组件化，工程化的进程不再受到阻碍，整个前端领域也迎来了大的发展期。</p>
<p>本来故事到这里就应该结束了的，不过，谁也没有想到会有另外一个公司出手，将前端领域带入了另外一个世界。</p>
<hr>
<h2 id="移动端大时代"><a href="#移动端大时代" class="headerlink" title="移动端大时代"></a><strong>移动端大时代</strong></h2><p>08年大家都印象深刻，乔布斯将手中的iphone4举向空中的那一刻，相信每一个人都心潮澎湃。而此时iOS的竞争对手Android加入了Google，开始了与iOS长达多年的拉锯战。面对发布会上乔布斯自豪的网页浏览功能，Android团队建议放弃KHTML，加入WebKit开发项目。</p>
<p>但是不知是不是早有预谋还是其他原因（毕竟08年Google已经有了v8），08年加入WebKit的Google从09年开始就成为了WebKit最大的代码提供者，而提交贡献相对较少的苹果却拥有最终决断权。</p>
<p>于是当2013年blink爆炸性发布时，苹果WebKit团队领头人Maciej Stachowiak说：</p>
<blockquote>
<p>我们在写任何WebKit2代码前就问了Google的人，他们愿不愿意将多进程架构的支持整合到WebKit中，他们的答案是否定的。在这种情况下，我们面临的选择是做一个怀有敌意的Chromium分支，或者写我们自己的多进程架构，或者继续使用单进程架构。我们选择了写自己的多进程架构。</p>
</blockquote>
<p>而凭借着多进程，v8，沙箱的三板斧，Chrome迅速侵占浏览器市场，终于在15年底，完成了对浏览器领域的垄断。</p>
<p><img src="../images/v2-9dc80c05224c32a8229415e5c5c7d24f_b.jpg" alt="img"></p>
<p>这时浏览器巨人再回过头看，<strong>看到的是“平台无关”的Happy Hacking代码肆意运行在它的浏览器上</strong>。</p>
<p>Don’t be evil?事实应该是Don‘t let anybody say I’m evil。涉及到利益之争，不可能不重视。早在2012年，当市场上风闻Facebook新项目时，Google就将其假象竞争对手AngularJS收入囊中，几乎是与blink同时布局。</p>
<p>开源世界的主导权竞争就是人才的竞争，谷歌早就深谙这一套玩法，为了更广大的互联网市场，Google开始了新一轮的降维打击，而这一布局的关键一环，就是——Angular。</p>
<hr>
<h2 id="只用一个平台的野心"><a href="#只用一个平台的野心" class="headerlink" title="只用一个平台的野心"></a><strong>只用一个平台的野心</strong></h2><p>Hack的思想，是如何在系统框架内部，实现对自己有利的功能，Facebook是一家富有极客精神的公司，因此，React的实现也颇有些无耐，没有浏览器，即便再Hack，都只是别人既定框架下的小聪明。</p>
<p>而这时，Angular在紧锣密鼓地计划中：</p>
<p>stage中的代码阻塞如何处理？工程界早有成熟的方式，可以采用多线程的方式，主线程处理不了的任务转化成事件，转交给从线程运行，保障高IO的进行——chrome 17支持了web worker。</p>
<p>前端开发调试，离线浏览，消息推送？没问题，chrome service worker为你提供保障。</p>
<p>提供了完整的性能监视，每个区域的重绘，fps，layer边界，都给你直观地展示，堪称世界上最完善的浏览器调试工具。</p>
<p>甚至是微软，经历了IE的失败，比其他人都更加意识到开源社区的重要，作为事件驱动windows系统中的长期经验总结，Rx的js版本Rxjs，顺理成章地被运用到同样处于事件驱动环境的浏览器中。</p>
<p>接下来，就是等待能够彻底压榨浏览器性能，用户友好，集成化的前端开发框架了。</p>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><blockquote>
<p>上回说到Google需要一款前端技术栈将它的浏览器性能完全发挥，并于其他浏览器拉开身位，阻击平台无关（MVVM）的各类框架。<br>如何能够让Google在浏览器制霸之后，将魔抓伸向应用层？<br>如何在渲染中发挥出浏览器最大性能呢？</p>
</blockquote>
<p>最近房价波动比较厉害，作为一个高薪程序员，新房大多地段不好，而购入一套离公司近的二手房，自然需要一个好的房地产中介。</p>
<blockquote>
<p>需要他联系买卖双方</p>
</blockquote>
<p>但是这时却有两种中介商：</p>
<ol>
<li><strong>所有买方跟我联系，我同意把你们愿意出的价格和需求报给卖方，最后把结果给你们双份分开展示</strong>（MVVM）</li>
<li><strong>你要买房？我单独联系卖方和你，你说啥，我就原封不动地传达给卖方，反之亦然</strong>（MVC）</li>
</ol>
<p>大家别急着选 2，想象一个场景，如果卖方那群人天天在变，一会儿这个看不上，一会儿那个瞧不起，房子也不停在变，早上 50 平晚上 100 平的，你会不会觉得第一种房地产中介要好一点呢？</p>
<blockquote>
<p>大哥我跟你说，这个卖家真的有毒，上次那房看的时候在 3 环，卖的时候带我们去 5 环，您看看这个，这个靠谱，他家房子是真的大。</p>
</blockquote>
<p>你也别急着调过头选 1，就算卖家不靠谱，1 中的中介每天下午 5 点才能将所有卖家信息汇总给你看，你婚礼在上午 8 点，未婚妻说：</p>
<blockquote>
<p>不干！什么时候买房，什么时候结婚！</p>
</blockquote>
<p>这个时候你又怎么办？另外即便未婚妻能等到下午 6 点，中介从 5 点开始翻记录就翻到了 6 点半，你又怎么办？</p>
<p>对的，浏览器也遇到这个问题，js 中的 dom 操作是买方，而页面渲染则是卖方。</p>
<hr>
<p>React 作为一个出色的前端框架，通过 MVVM 做到了平台无关，facebook 相关产品在任何浏览器上打开都能有不错的性能，甚至能够进军原生终端应用开发，这都是 MVVM 架构的功劳。</p>
<p>但是 vm 这一全局的 view 副本，始终在消耗着浏览器资源，项目小的时候看不出来，当项目无限膨胀的时候，弊病开始显现。</p>
<p>书接上回，Google 需要一个前端框架，这个技术栈<strong>不一定需要 Google 产品在其他浏览器上的体验与 Chrome 一样，但一定要在 Chrome 上有极致的性能</strong>。用纯数据的方式保留一个 view 副本？不可能也不需要这么做。</p>
<p>Angular 框架采用 TypeScript 开发（工程化会另有文章讨论），其中一个优点便是代码易读，打开源码<code>angular/packages/core/src/linker</code>,里面有许多抽象类，方便了解大致的 Angular 渲染机制。</p>
<ol>
<li>templateRef: 用户声明模板</li>
<li>viewRef: 自定义视图</li>
<li>elementRef: 原生 Dom 元素</li>
<li>viewContainerRef:自定义挂载点</li>
<li>componentFactory: 组件工厂函数</li>
<li>moduleFactory: 模块工厂函数</li>
</ol>
<p>举例说明两个重要类：ComponentRef 和 viewContainerRef。</p>
<p>ComponentRef 需要确定和视图的关系，以及相关的变更检测，依赖注入等（变更检测在 M 中进行而非 vm 中）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;https:&#x2F;&#x2F;github.com&#x2F;angular&#x2F;angular&#x2F;blob&#x2F;master&#x2F;packages&#x2F;core&#x2F;src&#x2F;linker&#x2F;component_factory.ts</span><br><span class="line">&#x2F;&#x2F; 组件引用</span><br><span class="line">export abstract class ComponentRef&lt;C&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 宿主元素</span><br><span class="line">  abstract get location(): ElementRef;</span><br><span class="line">  &#x2F;&#x2F; 依赖</span><br><span class="line">  abstract get injector(): Injector;</span><br><span class="line">  &#x2F;&#x2F; 组件实例</span><br><span class="line">  abstract get instance(): C;</span><br><span class="line">  &#x2F;&#x2F; 宿主视图</span><br><span class="line">  abstract get hostView(): ViewRef;</span><br><span class="line">  &#x2F;&#x2F; 检测树</span><br><span class="line">  abstract get changeDetectorRef(): ChangeDetectorRef;</span><br><span class="line">  &#x2F;&#x2F; 获取组件类型</span><br><span class="line">  abstract get componentType(): Type&lt;any&gt;;</span><br><span class="line">  &#x2F;&#x2F; 组件销毁</span><br><span class="line">  abstract destroy(): void;</span><br><span class="line">  &#x2F;&#x2F; 组件销毁回调</span><br><span class="line">  abstract onDestroy(callback: Function): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>viewContanerRef 需要实现对 viewRef 的挂载和删除，因此他的抽象类声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; angular&#x2F;packages&#x2F;core&#x2F;src&#x2F;linker&#x2F;view_container_ref.ts</span><br><span class="line">export abstract class ViewContainerRef &#123;</span><br><span class="line">  &#x2F;&#x2F; 针对每一个container 的锚点 element</span><br><span class="line">  abstract get element(): ElementRef;</span><br><span class="line">  &#x2F;&#x2F; 清除内容</span><br><span class="line">  abstract clear(): void;</span><br><span class="line">  &#x2F;&#x2F; 获取view</span><br><span class="line">  abstract get(index: number): ViewRef | null;</span><br><span class="line">  &#x2F;&#x2F; 获取view 长度</span><br><span class="line">  abstract get length(): number;</span><br><span class="line">  &#x2F;&#x2F; 创建嵌入式view（偷懒专用）</span><br><span class="line">  abstract createEmbeddedView&lt;C&gt;(</span><br><span class="line">    templateRef: TemplateRef&lt;C&gt;,</span><br><span class="line">    context?: C,</span><br><span class="line">    index?: number</span><br><span class="line">  ): EmbeddedViewRef&lt;C&gt;;</span><br><span class="line">  &#x2F;&#x2F; 插入view</span><br><span class="line">  abstract insert(viewRef: ViewRef, index?: number): ViewRef;</span><br><span class="line">  &#x2F;&#x2F; 移动view</span><br><span class="line">  abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;</span><br><span class="line">  &#x2F;&#x2F; 获取view 的 index</span><br><span class="line">  abstract indexOf(viewRef: ViewRef): number;</span><br><span class="line">  &#x2F;&#x2F; 删除view</span><br><span class="line">  abstract remove(index?: number): void;</span><br><span class="line">  &#x2F;&#x2F; 解绑但是不删除view</span><br><span class="line">  abstract detach(index?: number): ViewRef | null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意那个 move 移动方法，稍后会有讨论许多其他框架中“跨层级移动不会发生”的前置条件是否存在。</p>
<p>注：变更检测的简单声明在 angular/packages/core/src/change_detection/change_detector_ref.ts</p>
<p>如果<strong>组件绑定的 ChangeDetectionRef 发现了变更，标记为脏，则重新运行 Component 到 View 的渲染，官方称作渲染引擎</strong>。</p>
<p>这便是Angular的MVC架构：</p>
<p><img src="../images/v2-344b3bf052c0670d0961388783ca35e7_b.jpg" alt="img"></p>
<p>直接操作DOM，极大地减少了中间数据操作，提升了性能。</p>
<hr>
<p>Angular 4.0 更新了渲染引擎 Renderer2，将渲染操作封装成函数，方便大家进行渲染（直接使用有违背组件化的开发方式）。 而现在，官方已经放出了 Renderer3，也就是<a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/92e80af8751993879a1d0b4a5a029ededb973e4d/packages/core/src/render3/STATUS.md">ivy 渲染引擎</a>，将摇树优化，依赖，国际化等等操作融入到渲染层级，并且以“<strong>装饰器即编译</strong>”的理念作为中心思想。</p>
<p><img src="../images/v2-71e10093612ce44a2ec73dd802369055_1440w.jpg" alt="img"></p>
<p>更加恐怖的是，能够在 <strong>6.2kb</strong> 的大小下实现一个渲染的最小功能集。</p>
<hr>
<p>DOM 中有一个幽灵——</p>
<blockquote>
<p>良好用户体验的保证是 60 帧的刷新率，最好是120帧！</p>
</blockquote>
<p>然而在这 8ms 左右的帧时间中，一次 <strong>DOM 结构变更（appendChild,removeChild）会占用平均 4ms 左右的时间</strong>，因此——</p>
<h2 id="你得代码必须在-4ms-内执行完毕"><a href="#你得代码必须在-4ms-内执行完毕" class="headerlink" title="你得代码必须在 4ms 内执行完毕!"></a><strong>你得代码必须在 4ms 内执行完毕!</strong></h2><p>而且 DOM 结构变更是浏览器过程，浏览器会保证你单纯的 dom 变更操作绝对会有稳定的用户界面变更，但<strong>这个过程在 js 代码中不可优化！</strong></p>
<p>React 的解决办法，是利用浏览器 RquestAnimationFrame 或者自己统计时间（RequestAnimationFrameWithSetTimeout）,<strong>将需要执行的reconsiliation代码和提交的DOM变更依次安排在浏览器渲染结束的空隙里</strong>。</p>
<p>但这有没有真正解决问题，大家都有自己的判断。</p>
<p>Angular 采用了另外的方式：</p>
<p><strong>（一）MVC 的变更是响应式的，并且脏检查只针对数据（onPush）。</strong></p>
<p>渲染引擎在处理数据变更时，采用单向绑定（数据变更即更新）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; angular&#x2F;packages&#x2F;core&#x2F;src&#x2F;view&#x2F;util.ts</span><br><span class="line">&#x2F;&#x2F; 检测view是否变更</span><br><span class="line">export function checkAndUpdateBinding(</span><br><span class="line">    view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean &#123;</span><br><span class="line">  if (checkBinding(view, def, bindingIdx, value)) &#123;</span><br><span class="line">    view.oldValues[def.bindingIndex + bindingIdx] &#x3D; value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; angular&#x2F;packages&#x2F;core&#x2F;src&#x2F;view&#x2F;text.ts</span><br><span class="line">&#x2F;&#x2F; 以textNode为例，还有内联性能优化</span><br><span class="line">export function checkAndUpdateTextInline(</span><br><span class="line">    view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any,</span><br><span class="line">    v7: any, v8: any, v9: any): boolean &#123;</span><br><span class="line">    let changed &#x3D; false;</span><br><span class="line">      const bindings &#x3D; def.bindings;</span><br><span class="line">      const bindLen &#x3D; bindings.length;</span><br><span class="line">      if (bindLen &gt; 0 &amp;&amp; checkAndUpdateBinding(view, def, 0, v0)) changed &#x3D; true;</span><br><span class="line">      &#x2F;&#x2F; ...10个内联</span><br><span class="line">      if (changed) &#123;</span><br><span class="line">    let value &#x3D; def.text !.prefix;</span><br><span class="line">    if (bindLen &gt; 0) value +&#x3D; _addInterpolationPart(v0, bindings[0]);</span><br><span class="line">    &#x2F;&#x2F; ... 10个内联</span><br><span class="line">    const renderNode &#x3D; asTextData(view, def.nodeIndex).renderText;</span><br><span class="line">    view.renderer.setValue(renderNode, value);</span><br><span class="line">  &#125;</span><br><span class="line">  return changed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，单纯的数据的改变无法引起DOM的结构变更。</p>
<p>并且，<strong>DOM操作是会发生节点间的移动的！</strong>拖拽，弹框等等，如果设计大量复杂组建节点，一次DOM的移动操作伴随大量重绘。</p>
<p>这些问题，在Angular中也只是调用一个move方法，名正言顺地replaceChild。</p>
<p>但是当NgIf等发生时，还是会有结构变更怎么办，如果这个时候大量代码逻辑导致4ms内代码运行超时，卡顿还是会发生。</p>
<p><strong>（二）我不与你在这 4ms 中争抢性能，使用 webWorker 在另一个线程处理逻辑，最后通过指令告诉浏览器视图更新，在这 8ms 中尽情地完成你那平均 4ms 的渲染~</strong></p>
<p>这方法就是Angular在渲染性能领域的杀手锏，也是充分利用浏览器做到的极致性能，官网描述，源代码在<code>angular/packages/platform-webworker-dynamic/</code>，官网描述为：</p>
<blockquote>
<p>Achieve the maximum speed possible on the Web Platform today</p>
</blockquote>
<p>汪老师在翻译时，加了一个‘以及未来’:</p>
<blockquote>
<p>通过Web Worker和服务端渲染，达到在如今(以及未来）的Web平台上所能达到的最高速度</p>
</blockquote>
<p>为什么有个括号里的以及未来？因为webworker与浏览器强关联，<strong>技术平台只有在浏览器垄断的庇护下才能肆无忌惮地使用web worker，其技术架构甚至比绝大部分客户端程序的io性能还要高（因为webWorker是系统线程，不是用户态）</strong>。</p>
<p>这一点是如何实现的呢？</p>
<p><img src="../images/v2-0aae540aa681bf0b1f65ed3048d549fd_b.jpg" alt="img"></p>
<p><strong>组件逻辑代码完全与主线程相分离，在另一个线程处理数据，而在UI中只进行渲染有关操作。</strong>（不然你得Angular师傅叫你把代码写在service里面只是为了好看么？）</p>
<p><img src="../images/v2-bbd1c263d0558f50140f00b10fb0afe8_b-20200421122638731.jpg" alt="img"></p>
<p><strong>通过ServiceMessageBroker提交变更，渲染引擎在客户端获取变更数据，进行视图渲染。</strong></p>
<p>正如<a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DKz_zKXiNGSE%26t%3D4s">ason Teplitz演讲</a>所言，所有如下的操作：</p>
<p><img src="../images/v2-4df3c92e9e36f88ff2b1469e3b39d2d1_1440w.jpg" alt="img"></p>
<p>都不会对你的视图渲染造成任何影响，<strong>V与M在前端实现了真正的分离</strong>！</p>
<hr>
<p>是的，Angular实现的（设计目标更严谨），是浏览器中的最强渲染性能，强大的浏览器后盾允许他这么做。</p>
<p>但是采用了MVC的方式，会不会导致AngularJS一代那样的异步错乱和数据意外耦合变更的问题呢？</p>
<h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p><img src="../images/v2-9b71342a3832a85b2bb4d5215cbf6552_r.jpg" alt="Angular物语（三）ReactiveX（1）"></p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a><strong>动机</strong></h2><blockquote>
<p>如果你觉得你没有必要用Rxjs，那你就不要用</p>
</blockquote>
<p>这个说法很万金油，可以避免很多不必要的争论，但是并没有什么建设意义——什么时候会觉得有必要用呢？</p>
<p>先给一个结论，大家可以参考参考：</p>
<blockquote>
<p>在一个<strong>事件驱动系统</strong>中处理<strong>复杂异步</strong>，<strong>必须</strong>使用ReactiveX或者类似工具</p>
</blockquote>
<p>必须？是的，必须！</p>
<p>就是这么绝对，毕竟先抛出一个绝对的概念，大家讨论特殊情况的时候才能言之有物不是？</p>
<p>这个武断中有一下几点需要特殊说明——</p>
<ol>
<li><strong>事件驱动</strong></li>
<li><strong>复杂异步</strong></li>
<li><strong>必要性</strong></li>
</ol>
<p>我们一个个说明吧~</p>
<hr>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a><strong>事件驱动</strong></h2><p>XXX驱动，一般指的是你代码逻辑运行的原因。</p>
<p>如果你代码运行是因为某种事件或者消息——事件驱动。</p>
<p>如果是因为数据的改变——数据驱动。</p>
<p>首先声明这不是一个编程概念，因为你很容易在非编程领域看到这些概念——比如市场分析可以采用事件驱动和数据驱动的方法——但是他却是在编程概念之上更高层级的思想方法，<strong>很多种模式的不同实现就是来源于这两种不同的思想</strong>（例如MVC，MVVM）。</p>
<p>举例说明一个随时间变化的数据系统：</p>
<p><img src="../images/v2-815e8fe27815962eaf4b9e19e70af166_b.jpg" alt="img"></p>
<p>你如果注重数据，注重代码实现（代码的目的就是将事件消息翻译成数据变更）而不在意时间方向上的变化——数据驱动：</p>
<p><img src="../images/v2-cc7b18b07476255ecd2edf30f42ddc19_b.jpg" alt="img"></p>
<p>你如果注重事件，注重服务而不在意单一时刻的数据变化——事件驱动：<img src="../images/v2-45789737110cc75ba130a034da041d93_1440w.jpg" alt="img"></p>
<p>有什么区别呢？</p>
<p>我们先来看数据驱动：</p>
<ol>
<li>每一时刻只需要考虑数据的变更，而不需要考虑数据为什么变更，又会引起怎样的变更——<strong>耦合性低，不可回溯</strong></li>
<li>状态的迁移需要由编程人员或是系统发出的消息驱动——<strong>即时性差</strong></li>
<li>总是由一个状态迁移到另一个状态，方便时间旅行——<strong>可回退</strong></li>
</ol>
<p>惊喜的是，事件驱动就像它的另一面一样，优缺点完全互补：</p>
<ol>
<li>需要考虑特定事件会引起怎样的变更，多个事件极容易出现耦合，但是容易定位数据变更的原因——<strong>耦合性大，可回溯</strong></li>
<li>状态的迁移是由事件决定的，事件逻辑不受阻挡——<strong>即时性强</strong></li>
<li>单一时刻数据不确定，很难进行时间旅行——<strong>不可回退</strong></li>
</ol>
<p>因此两种思想方法的口号也就容易理解了——</p>
<blockquote>
<p><strong>数据驱动——人类不善于处理逻辑，但善于处理数据</strong><br><strong>事件驱动——一切以最大化服务为优先</strong></p>
</blockquote>
<p>数据库事务，浏览器DOM，游戏帧画面渲染都是数据驱动，他们之间有一定的共性——</p>
<ol>
<li>对数据准确定有要求</li>
<li>状态迁移没有额外开销或者开销很小（文件存储读写，或者直接渲染一帧即释放）</li>
</ol>
<p>服务器IO，浏览器接口，游戏逻辑都是事件驱动，他们之间也有一定的共性——</p>
<ol>
<li>需要对用户操作或者请求及时响应</li>
<li>全部状态迁移几乎不可能或者开销极大，只能通过消息进行</li>
</ol>
<p><strong>所谓的前端层面有名的伪概念之一——数据驱动适合前端开发——完完全全就是错误的！</strong></p>
<p>并且，浏览器为了快速响应用户操作可是采用的事件驱动模型，为此还在单线程中实现了协程，这一方向在可见的未来不会改变。</p>
<p>那怎么处理这个复杂的，即时性要求如此之高的系统呢？如何优化其耦合性大，不可回退的缺点？实现高可用呢？</p>
<p>数据驱动模式一般如何解决不可回溯的缺点？</p>
<p><strong>将事件作为数据存储——flux，redux模式</strong></p>
<p>点到为止，应该很多前端都很熟悉这样的概念，其实这样的概念和redis缓存，sql语句操作数据库没有什么本质区别，都是消息——事务——数据变更的模式。</p>
<p>同理可得，如何处理事件驱动中的耦合性问题呢？</p>
<p><strong>将数据也作为事件发出——stream模式</strong></p>
<p>对的，这就是ReactiveX定义中的“<strong>数据流</strong>”。</p>
<hr>
<h2 id="复杂异步"><a href="#复杂异步" class="headerlink" title="复杂异步"></a><strong>复杂异步</strong></h2><p>浏览器给了你异步的代码能力，但是怎样实现异步，怎样处理异步，却没有告诉你行之有效的方法。</p>
<blockquote>
<p>异步怎么可能复杂，不就是async await么？</p>
</blockquote>
<p>好吧，那你坐好了，我给你看看异步到底有多复杂：</p>
<p><strong>性能问题</strong></p>
<p>大部分所谓的异步代码比同步代码还慢（需要调度时间）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">await A; await B; awaitC;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">await Promise.all([A,B,C])</span><br></pre></td></tr></table></figure>

<p><strong>竞态问题</strong></p>
<p>发出多个请求，以最先返回的数据为准？（别急着打产品经理）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await Promise.race([A,B])</span><br></pre></td></tr></table></figure>

<p>嗯，这些好像Promise也能做，不急，还有其他问题呢。</p>
<p><strong>组合问题</strong></p>
<p>需要一次异步紧跟上一次异步，即时处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const result_1 &#x3D; await Promise.All([A,B,C])</span><br><span class="line">const result_2 &#x3D; await D(result_1[0])</span><br><span class="line">&#x2F;&#x2F; 异步耦合，也是耦合</span><br></pre></td></tr></table></figure>

<p><strong>并发问题</strong></p>
<p>需要进行节流和去抖。</p>
<p><strong>撤销问题</strong></p>
<p>需要必要的时候撤销回调，防止空置错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await A;</span><br><span class="line">if(componentDestroied)&#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异常问题</strong></p>
<p>需要统一处理异步异常，捕获异步异常以便让异步顺利进行，处处try catch？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    await A;</span><br><span class="line">    await B;</span><br><span class="line">&#125;catch(err)&#123;</span><br><span class="line">    &#x2F;&#x2F; error handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调度问题</strong></p>
<p>这个promise只有micro一种调度模式，你如果需要用其他调度方式，恭喜你扑街：</p>
<p><img src="../images/v2-bf04a0b5908d27db992f7c591bba4ad7_b.jpg" alt="img"></p>
<p>micro和macro都有可能导致页面渲染阻塞（前者推迟，后者导致逻辑帧挤压物理帧），想要更加流畅的效果？试试animationFrame？</p>
<p>更或者，你是希望用到webworker多线程渲染（主线程只提交patch），那就得自己实现调度器了~</p>
<p>这些还只是冰山一角，还有循环变更，事件过滤，事件侦听，多播等等问题，信息交换会遇到什么问题，异步能把他们都走一遭~</p>
<p>别紧张，这些问题有没有简单的可以解决的办法呢？哈哈，你算是找对人了！</p>
<hr>
<h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a><strong>必要性</strong></h2><p>不过很多有后端经验的朋友肯定会反驳我——<strong>解决异步耦合问题不是可以用面向对象么？</strong></p>
<p>是的，类和对象的思想就是<strong>封装数据和事件（行为）</strong>，理论上数据驱动的问题和事件驱动的短板都可以用面向对象来弥补。</p>
<p>但是，面向对象需要复杂的结构信息来声明依赖，当异步过于复杂的时候，你需要维持一个异常庞大的结构，这样就回到了该用库还是该自己实现的问题上——不过以事件驱动系统中遇到的异步问题复杂度，自己用面向对象实现很不可靠。</p>
<p>不信问问用NodeJs的小朋友，最多做做可读可写流的连接，用人处理过race，combine，mergeAll？</p>
<p>当然，如果你觉得完全没有使用Rxjs的必要，那么可能存在以下几种情况——</p>
<ol>
<li>处于一个完全数据驱动系统下（React），状态迁移是由固定消息驱动的。如setState，将所有数据流订阅之后再打平成数据，然后setState？这有意义？那自动订阅然后setState呢？那就请小心处理并发问题（diff可是个性能无底洞）。</li>
<li>不需要处理复杂的异步问题。比如博客，官网等产品，数据来源确定，前端往往只有展示的需求。</li>
</ol>
<hr>
<h2 id="Rxjs和Angular"><a href="#Rxjs和Angular" class="headerlink" title="Rxjs和Angular"></a><strong>Rxjs和Angular</strong></h2><h2 id="Angular是数据驱动么？"><a href="#Angular是数据驱动么？" class="headerlink" title="Angular是数据驱动么？"></a>Angular是数据驱动么？</h2><p>这么说某种程度也对，毕竟class的变量和elementRef的绑定是数据驱动的（数据改变会引发响应逻辑），但是也仅仅停留在一个Component声明内部，并且是响应式实现（getter，setter），本质不是变量改变，而是触发了新的事件。</p>
<p>另外提一句，vue也是如此的原理，但是getter，setter没有暴露给你，用watch和computed配合Rxjs说不定是个很好的思路（但是它是diff实现，同样也要考虑性能问题，虽然diff只是局限于component内部）。</p>
<p><strong>全局来看，Angular触发视图变更的原因，有且只有zone拦截的事件！，并且是响应式变更至template，是一个不折不扣，200%的事件驱动系统，和浏览器实现高度吻合！</strong></p>
<p>数据驱动有什么问题？毕竟都流行那么多年了？</p>
<p>因为前端的大环境改变了，我也希望大家能清楚地明白这一趋势。</p>
<p>数年前前端的主题是跨平台，因此数据驱动的MVVM大行其道可以理解，但是<strong>DOM diff消耗性能阻塞协程，状态手动迁移导致异步性能极差</strong>，是无论如何无法被忽视的。</p>
<p>而浏览器平均patch时间是4ms左右，现代浏览器普遍60-120hz的刷新能每个事件循环你有10ms左右的时间处理逻辑。</p>
<p>好像时间挺宽裕的，别忘了，历史的洪流在不断向前——</p>
<p>5g时代如果VR大行其道，低于240hz产生的栅栏效应将严重影响用户体验，这种情况下——<strong>你已经完全没有了在渲染线程处理业务逻辑的时间</strong>。<br>再加上万物互联和1ms延迟导致的呈几何倍数增长的异步问题，届时如何为用户提供服务？</p>
<p>platform-webworker提供了多线程渲染的新的解决办法，服务将渐渐凌驾于实现之上，面对着新的产业升级，<strong>这波车，你上不上？</strong></p>
<hr>
<p>明白为什么要使用Rxjs了么？</p>
<p><strong>更快（快速无阻塞响应服务），更稳定（数据流约束耦合），更方便（函数式避免复杂结构）</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Angular/" rel="tag"># Angular</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/20/%E7%BE%8E%E5%9B%BD%E4%BA%BA%E6%80%A7%E6%A0%BC%E7%89%B9%E7%82%B9%E8%A7%82%E5%AF%9F/" rel="prev" title="美国人性格特点观察">
      <i class="fa fa-chevron-left"></i> 美国人性格特点观察
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/22/AugularJS%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" rel="next" title="AugularJS思维导图">
      AugularJS思维导图 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1"><span class="nav-number">1.</span> <span class="nav-text">1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前端黎明"><span class="nav-number">1.1.</span> <span class="nav-text">前端黎明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#混乱大时代"><span class="nav-number">1.2.</span> <span class="nav-text">混乱大时代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移动端大时代"><span class="nav-number">1.3.</span> <span class="nav-text">移动端大时代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只用一个平台的野心"><span class="nav-number">1.4.</span> <span class="nav-text">只用一个平台的野心</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2"><span class="nav-number">2.</span> <span class="nav-text">2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#你得代码必须在-4ms-内执行完毕"><span class="nav-number">2.1.</span> <span class="nav-text">你得代码必须在 4ms 内执行完毕!</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3"><span class="nav-number">3.</span> <span class="nav-text">3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动机"><span class="nav-number">3.1.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件驱动"><span class="nav-number">3.2.</span> <span class="nav-text">事件驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂异步"><span class="nav-number">3.3.</span> <span class="nav-text">复杂异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#必要性"><span class="nav-number">3.4.</span> <span class="nav-text">必要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rxjs和Angular"><span class="nav-number">3.5.</span> <span class="nav-text">Rxjs和Angular</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Angular是数据驱动么？"><span class="nav-number">3.6.</span> <span class="nav-text">Angular是数据驱动么？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1436668936&auto=0&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
