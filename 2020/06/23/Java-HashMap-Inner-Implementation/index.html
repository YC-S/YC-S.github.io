<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1. OverviewBefore we get started with the implementation, it’s important to point out that the primary List and Set collection interfaces extend Collection but Map does not. Simply put, the HashMap st">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_HashMap_Inner_Implementation">
<meta property="og:url" content="http://yoursite.com/2020/06/23/Java-HashMap-Inner-Implementation/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:description" content="1. OverviewBefore we get started with the implementation, it’s important to point out that the primary List and Set collection interfaces extend Collection but Map does not. Simply put, the HashMap st">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-24T00:15:00.000Z">
<meta property="article:modified_time" content="2020-06-24T00:21:32.220Z">
<meta property="article:author" content="Yuanchen">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/06/23/Java-HashMap-Inner-Implementation/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Java_HashMap_Inner_Implementation | Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/23/Java-HashMap-Inner-Implementation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java_HashMap_Inner_Implementation
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-23 20:15:00 / Modified: 20:21:32" itemprop="dateCreated datePublished" datetime="2020-06-23T20:15:00-04:00">2020-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a><strong>1. Overview</strong></h2><p>Before we get started with the implementation, it’s important to point out that the primary <em>List</em> and <em>Set</em> collection interfaces extend <em>Collection</em> but <em>Map</em> does not.</p>
<p>Simply put, the <em>HashMap</em> stores values by key and provides APIs for adding, retrieving and manipulating stored data in various ways. The implementation is <strong>based on the the principles of a hashtable</strong>, which sounds a little complex at first but is actually very easy to understand.</p>
<p>Key-value pairs are stored in what is known as buckets which together make up what is called a table, which is actually an internal array.</p>
<p>Once we know the key under which an object is stored or is to be stored, <strong>storage and retrieval operations occur in constant time</strong>, <em>O(1)</em> in a well-dimensioned hash map.</p>
<p>To understand how hash maps work under the hood, one needs to understand the storage and retrieval mechanism employed by the <em>HashMap.</em> We’ll focus a lot on these.</p>
<p>Finally, <strong><em>HashMap\</em> related questions are quite common in interviews</strong>, so this is a solid way to either prepare an interview or prepare for it.</p>
<h2 id="2-The-put-API"><a href="#2-The-put-API" class="headerlink" title="2. The put() API"></a><strong>2. The put() API</strong></h2><p>To store a value in a hash map, we call the <em>put</em> API which takes two parameters; a key and the corresponding value:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>When a value is added to the map under a key, the <em>hashCode()</em> API of the key object is called to retrieve what is known as the initial hash value.</p>
<p>To see this in action, let us create an object that will act as a key. We will only create a single attribute to use as a hash code to simulate the first phase of hashing:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calling hashCode()"</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructor, setters and getters </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can now use this object to map a value in the hash map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHashCodeIsCalledOnPut_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyKey key = <span class="keyword">new</span> MyKey(<span class="number">1</span>);</span><br><span class="line">    Map&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(key, <span class="string">"val"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nothing much happening in the above code, but pay attention to the console output. Indeed the <em>hashCode</em> method gets invoked:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Calling <span class="title">hashCode</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>Next, the <em>hash()</em> API of the hash map is called internally to compute the final hash value using the initial hash value.</p>
<p>This final hash value ultimately boils down to an index in the internal array or what we call a bucket location.</p>
<p>The <em>hash</em> function of <em>HashMap</em> looks like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What we should note here is only the use of the hash code from the key object to compute a final hash value.</p>
<p>While inside the <em>put</em> function, the final hash value is used like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that an internal <em>putVal</em> function is called and given the final hash value as the first parameter.</p>
<p>One may wonder why the key is again used inside this function since we have already used it to compute the hash value.</p>
<p>The reason is that <strong>hash maps store both key and value in the bucket location as a *Map.Entry* object</strong>.</p>
<p>As discussed before, all Java collections framework interfaces extend <em>Collection</em> interface but <em>Map</em> does not. Compare the declaration of Map interface we saw earlier to that of <em>Set</em> interface:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>The reason is that <strong>maps do not exactly store single elements as do other collections but rather a collection of key-value pairs.</strong></p>
<p>So the generic methods of <em>Collection</em> interface such as <em>add</em>, <em>toArray</em> do not make sense when it comes to <em>Map</em>.</p>
<p>The concept we have covered in the last three paragraphs makes for one of the <strong>most popular Java Collections Framework interview questions</strong>. So, it’s worth understanding.</p>
<p>One special attribute with the hash map is that it accepts <em>null</em> values and null keys:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNullKeyAndVal_whenAccepts_thenCorrect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>When a null key is encountered during a *put* operation, it is automatically assigned a final hash value of *0*</strong>, which means it becomes the first element of the underlying array.</p>
<p>This also means that when the key is null, there is no hashing operation and therefore, the <em>hashCode</em> API of the key is not invoked, ultimately avoiding a null pointer exception.</p>
<p>During a <em>put</em> operation, when we use a key that was already used previously to store a value, it returns the previous value associated with the key:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenExistingKey_whenPutReturnsPrevValue_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"key1"</span>, <span class="string">"val1"</span>);</span><br><span class="line"> </span><br><span class="line">    String rtnVal = map.put(<span class="string">"key1"</span>, <span class="string">"val2"</span>);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="string">"val1"</span>, rtnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>otherwise, it returns <em>null:</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNewKey_whenPutReturnsNull_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    String rtnVal = map.put(<span class="string">"key1"</span>, <span class="string">"val1"</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(rtnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When <em>put</em> returns null, it could also mean that the previous value associated with the key is null, not necessarily that it’s a new key-value mapping:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNullVal_whenPutReturnsNull_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    String rtnVal = map.put(<span class="string">"key1"</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(rtnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <em>containsKey</em> API can be used to distinguish between such scenarios as we will see in the next subsection.</p>
<h2 id="3-The-get-API"><a href="#3-The-get-API" class="headerlink" title="3. The get API"></a><strong>3. The get API</strong></h2><p>To retrieve an object already stored in the hash map, we must know the key under which it was stored. We call the <em>get</em> API and pass to it the key object:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenGetWorks_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"key"</span>, <span class="string">"val"</span>);</span><br><span class="line"> </span><br><span class="line">    String val = map.get(<span class="string">"key"</span>);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="string">"val"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Internally, the same hashing principle is used. <em>The hashCode()</em> API of the key object is called to obtain the initial hash value:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHashCodeIsCalledOnGet_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyKey key = <span class="keyword">new</span> MyKey(<span class="number">1</span>);</span><br><span class="line">    Map&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(key, <span class="string">"val"</span>);</span><br><span class="line">    map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This time, the <em>hashCode</em> API of <em>MyKey</em> is called twice; once for <em>put</em> and once for <em>get</em>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Calling <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Calling <span class="title">hashCode</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>This value is then rehashed by calling the internal <em>hash()</em> API to obtain the final hash value.</p>
<p>As we saw in the previous section, this final hash value ultimately boils down to a bucket location or an index of the internal array.</p>
<p>The value object stored in that location is then retrieved and returned to the calling function.</p>
<p>When the returned value is null, it could mean that the key object is not associated with any value in the hash map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenUnmappedKey_whenGetReturnsNull_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    String rtnVal = map.get(<span class="string">"key1"</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(rtnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Or it could simply mean that the key was explicitly mapped to a null instance:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNullVal_whenRetrieves_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"key"</span>, <span class="keyword">null</span>);</span><br><span class="line">         </span><br><span class="line">    String val=map.get(<span class="string">"key"</span>);</span><br><span class="line">         </span><br><span class="line">    assertNull(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To distinguish between the two scenarios, we can use the <em>containsKey</em> API, to which we pass the key and it returns true if and only if a mapping was created for the specified key in the hash map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenContainsDistinguishesNullValues_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    String val1 = map.get(<span class="string">"key"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> valPresent = map.containsKey(<span class="string">"key"</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(val1);</span><br><span class="line">    assertFalse(valPresent);</span><br><span class="line"> </span><br><span class="line">    map.put(<span class="string">"key"</span>, <span class="keyword">null</span>);</span><br><span class="line">    String val = map.get(<span class="string">"key"</span>);</span><br><span class="line">    valPresent = map.containsKey(<span class="string">"key"</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(val);</span><br><span class="line">    assertTrue(valPresent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For both cases in the above test, the return value of the <em>get</em> API call is null but we are able to distinguish which one is which.</p>
<h2 id="4-Collection-Views-in-HashMap"><a href="#4-Collection-Views-in-HashMap" class="headerlink" title="4. Collection Views in HashMap"></a><strong>4. Collection Views in HashMap</strong></h2><p><em>HashMap</em> offers three views that enable us to treat its keys and values as another collection. We can get a set of all <strong>keys of the map</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenHashMap_whenRetrievesKeyset_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"yc"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, <span class="string">"blog"</span>);</span><br><span class="line"> </span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">2</span>, keys.size());</span><br><span class="line">    assertTrue(keys.contains(<span class="string">"name"</span>));</span><br><span class="line">    assertTrue(keys.contains(<span class="string">"type"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The set is backed by the map itself. So <strong>any change made to the set is reflected in the map</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenKeySet_whenChangeReflectsInMap_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"yc"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, <span class="string">"blog"</span>);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">2</span>, map.size());</span><br><span class="line"> </span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">    keys.remove(<span class="string">"name"</span>);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">1</span>, map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can also obtain a <strong>collection view of the values</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenHashMap_whenRetrievesValues_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"baeldung"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, <span class="string">"blog"</span>);</span><br><span class="line"> </span><br><span class="line">    Collection&lt;String&gt; values = map.values();</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">2</span>, values.size());</span><br><span class="line">    assertTrue(values.contains(<span class="string">"yc"</span>));</span><br><span class="line">    assertTrue(values.contains(<span class="string">"blog"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Just like the key set, any <strong>changes made in this collection will be reflected in the underlying map</strong>.</p>
<p>Finally, we can obtain a <strong>set view of all entries</strong> in the map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenHashMap_whenRetrievesEntries_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"yc"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, <span class="string">"blog"</span>);</span><br><span class="line"> </span><br><span class="line">    Set&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">2</span>, entries.size());</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, String&gt; e : entries) &#123;</span><br><span class="line">        String key = e.getKey();</span><br><span class="line">        String val = e.getValue();</span><br><span class="line">        assertTrue(key.equals(<span class="string">"name"</span>) || key.equals(<span class="string">"type"</span>));</span><br><span class="line">        assertTrue(val.equals(<span class="string">"yc"</span>) || val.equals(<span class="string">"blog"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember that a hash map specifically contains unordered elements, therefore we assume any order when testing the keys and values of entries in the <em>for each</em> loop.</p>
<p>Many times, you will use the collection views in a loop as in the last example, and more specifically using their iterators.</p>
<p>Just remember that the <strong>iterators for all the above views are *fail-fast*</strong>.</p>
<p>If any structural modification is made on the map, after the iterator has been created, a concurrent modification exception will be thrown:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = ConcurrentModificationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">givenIterator_whenFailsFastOnModification_thenCorrect</span>() </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"yc"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, <span class="string">"blog"</span>);</span><br><span class="line"> </span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">    Iterator&lt;String&gt; it = keys.iterator();</span><br><span class="line">    map.remove(<span class="string">"type"</span>);</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        String key = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The only <strong>allowed structural modification is a *remove*</strong> operation performed through the iterator itself:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenIterator_whenRemoveWorks_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"yc"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, <span class="string">"blog"</span>);</span><br><span class="line"> </span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">    Iterator&lt;String&gt; it = keys.iterator();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">0</span>, map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The final thing to remember about these collection views is the performance of iterations. This is where a hash map performs quite poorly compared with its counterparts linked hash map and tree map.</p>
<p>Iteration over a hash map happens in worst case <em>O(n)</em> where n is the sum of its capacity and the number of entries.</p>
<h2 id="5-HashMap-Performance"><a href="#5-HashMap-Performance" class="headerlink" title="5. HashMap Performance"></a><strong><em>5. HashMap Performance</em></strong></h2><p>The performance of a hash map is affected by two parameters: <em>Initial Capacity</em> and <em>Load Factor</em>. The capacity is the number of buckets or the underlying array length and the initial capacity is simply the capacity during creation.</p>
<p>The load factor or LF, in short, is a measure of how full the hash map should be after adding some values before it is resized.</p>
<p>The default initial capacity is <em>16</em> and default load factor is <em>0.75</em>. We can create a hash map with custom values for initial capacity and LF:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; hashMapWithCapacity=<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">Map&lt;String,String&gt; hashMapWithCapacityAndLF=<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">32</span>, <span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure>

<p>The default values set by the Java team are well optimized for most cases. However, if you need to use your own values, which is very okay, you need to understand the performance implications so that you know what you are doing.</p>
<p>When the number of hash map entries exceeds the product of LF and capacity, then <strong>rehashing</strong> occurs i.e. <strong>another internal array is created with twice the size of the initial one and all entries are moved over to new bucket locations in the new array</strong>.</p>
<p>A <strong>low initial capacity</strong> reduces space cost but <strong>increases the frequency of rehashing</strong>. Rehashing is obviously a very expensive process. So as a rule, if you anticipate many entries, you should set a considerably high initial capacity.</p>
<p>On the flip side, if you set the initial capacity too high, you will pay the cost in iteration time. As we saw in the previous section.</p>
<p>So <strong>a high initial capacity is good for a large number of entries coupled with little to no iteration</strong>.</p>
<p>A <strong>low initial capacity is good for few entries with a lot of iteration</strong>.</p>
<h2 id="6-Collisions-in-the-HashMap"><a href="#6-Collisions-in-the-HashMap" class="headerlink" title="*6. Collisions in the HashMap"></a><em>*6. Collisions in the HashMap</em></h2><p>A collision, or more specifically, a hash code collision in a <em>HashMap</em>, is a situation where <strong>two or more key objects produce the same final hash value</strong> and hence point to the same bucket location or array index.</p>
<p>This scenario can occur because according to the <em>equals</em> and <em>hashCode</em> contract, <strong>two unequal objects in Java can have the same hash code</strong>.</p>
<p>It can also happen because of the finite size of the underlying array, that is, before resizing. The smaller this array, the higher the chances of collision.</p>
<p>That said, it’s worth mentioning that Java implements a hash code collision resolution technique which we will see using an example.</p>
<p><strong>Keep in mind that it’s the hash value of the key that determines the bucket the object will be stored in. And so, if the hash codes of any two keys collide, their entries will still be stored in the same bucket.</strong></p>
<p>And by default, the implementation uses a linked list as the bucket implementation.</p>
<p>The initially constant time <em>O(1)</em> <em>put</em> and <em>get</em> operations will occur in linear time <em>O(n)</em> in the case of a collision. This is because after finding the bucket location with the final hash value, each of the keys at this location will be compared with the provided key object using the <em>equals</em> API.</p>
<p>To simulate this collision resolution technique, let’s modify our earlier key object a little:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyKey</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calling hashCode()"</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// toString override for pretty logging</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calling equals() for key: "</span> + obj);</span><br><span class="line">        <span class="comment">// generated implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice how we’re simply returning the <em>id</em> attribute as the hash code – and thus force a collision to occur.</p>
<p>Also, note that we’ve added log statements in our <em>equals</em> and <em>hashCode</em> implementations – so that we know exactly when the logic is called.</p>
<p>Let’s now go ahead to store and retrieve some objects that collide at some point:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenCallsEqualsOnCollision_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    MyKey k1 = <span class="keyword">new</span> MyKey(<span class="number">1</span>, <span class="string">"firstKey"</span>);</span><br><span class="line">    MyKey k2 = <span class="keyword">new</span> MyKey(<span class="number">2</span>, <span class="string">"secondKey"</span>);</span><br><span class="line">    MyKey k3 = <span class="keyword">new</span> MyKey(<span class="number">2</span>, <span class="string">"thirdKey"</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"storing value for k1"</span>);</span><br><span class="line">    map.put(k1, <span class="string">"firstValue"</span>);</span><br><span class="line">    System.out.println(<span class="string">"storing value for k2"</span>);</span><br><span class="line">    map.put(k2, <span class="string">"secondValue"</span>);</span><br><span class="line">    System.out.println(<span class="string">"storing value for k3"</span>);</span><br><span class="line">    map.put(k3, <span class="string">"thirdValue"</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"retrieving value for k1"</span>);</span><br><span class="line">    String v1 = map.get(k1);</span><br><span class="line">    System.out.println(<span class="string">"retrieving value for k2"</span>);</span><br><span class="line">    String v2 = map.get(k2);</span><br><span class="line">    System.out.println(<span class="string">"retrieving value for k3"</span>);</span><br><span class="line">    String v3 = map.get(k3);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="string">"firstValue"</span>, v1);</span><br><span class="line">    assertEquals(<span class="string">"secondValue"</span>, v2);</span><br><span class="line">    assertEquals(<span class="string">"thirdValue"</span>, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above test, we create three different keys – one has a unique <em>id</em> and the other two have the same <em>id</em>. Since we use <em>id</em> as the initial hash value, <strong>there will definitely be a collision</strong> during both storage and retrieval of data with these keys.</p>
<p>In addition to that, thanks to the collision resolution technique we saw earlier, we expect each of our stored values to be retrieved correctly, hence the assertions in the last three lines.</p>
<p>When we run the test, it should pass, indicating that collisions were resolved and we will use the logging produced to confirm that the collisions indeed occurred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">storing value for k1</span><br><span class="line">Calling hashCode()</span><br><span class="line">storing value for k2</span><br><span class="line">Calling hashCode()</span><br><span class="line">storing value for k3</span><br><span class="line">Calling hashCode()</span><br><span class="line">Calling equals() for key: MyKey [name&#x3D;secondKey, id&#x3D;2]</span><br><span class="line">retrieving value for k1</span><br><span class="line">Calling hashCode()</span><br><span class="line">retrieving value for k2</span><br><span class="line">Calling hashCode()</span><br><span class="line">retrieving value for k3</span><br><span class="line">Calling hashCode()</span><br><span class="line">Calling equals() for key: MyKey [name&#x3D;secondKey, id&#x3D;2]</span><br></pre></td></tr></table></figure>

<p>Notice that during storage operations, <em>k1</em> and <em>k2</em> were successfully mapped to their values using only the hash code.</p>
<p>However, storage of <em>k3</em> was not so simple, the system detected that its bucket location already contained a mapping for <em>k2</em>. Therefore, <em>equals</em> comparison was used to distinguish them and a linked list was created to contain both mappings.</p>
<p>Any other subsequent mapping whose key hashes to the same bucket location will follow the same route and end up replacing one of the nodes in the linked list or be added to the head of the list if <em>equals</em> comparison returns false for all existing nodes.</p>
<p>Likewise, during retrieval, <em>k3</em> and <em>k2</em> were <em>equals</em>-compared to identify the correct key whose value should be retrieved.</p>
<p>On a final note, from Java 8, the linked lists are dynamically replaced with balanced binary search trees in collision resolution after the number of collisions in a given bucket location exceed a certain threshold.</p>
<p>This change offers a performance boost, since, in the case of a collision, storage and retrieval happen in <em>O(log n).</em></p>
<p>This section is <strong>very common in technical interviews,</strong> especially after the basic storage and retrieval questions.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/22/67-Spring-Interview-Questions/" rel="prev" title="67_Spring_Interview_Questions">
      <i class="fa fa-chevron-left"></i> 67_Spring_Interview_Questions
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/24/Python-Interview-Questions/" rel="next" title="Python_Interview_Questions">
      Python_Interview_Questions <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Overview"><span class="nav-number">1.</span> <span class="nav-text">1. Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-The-put-API"><span class="nav-number">2.</span> <span class="nav-text">2. The put() API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-The-get-API"><span class="nav-number">3.</span> <span class="nav-text">3. The get API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Collection-Views-in-HashMap"><span class="nav-number">4.</span> <span class="nav-text">4. Collection Views in HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-HashMap-Performance"><span class="nav-number">5.</span> <span class="nav-text">5. HashMap Performance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Collisions-in-the-HashMap"><span class="nav-number">6.</span> <span class="nav-text">*6. Collisions in the HashMap</span></a></li></ol></div>
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1436668936&auto=0&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">203</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">74</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
