<!DOCTYPE html>


<html lang="en">
	

		<head>
			<meta charset="utf-8" />
			 
			<meta name="keywords" content="life,think,work,blog,code" />
			 
			<meta name="description" content="a place holder" />
			
			<meta
				name="viewport"
				content="width=device-width, initial-scale=1, maximum-scale=1"
			/>
			<meta
				name="google-site-verification"
				content="Xe5wkkWgdmMwA81kCWOHLlJSlYSRE47NKPlVzl8ynK8"
			/>
			<title>Java_HashMap_Inner_Implementation |  Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
			
			<link rel="shortcut icon" href="/favicon.ico" />
			 
<link rel="stylesheet" href="/dist/main.css">

			<link
				rel="stylesheet"
				href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
			/>
			
<link rel="stylesheet" href="/css/custom.css">
 
			<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
			 
 

		<link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>
	</html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Java-HashMap-Inner-Implementation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Java_HashMap_Inner_Implementation
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/23/Java-HashMap-Inner-Implementation/" class="article-date">
  <time datetime="2020-06-24T01:15:00.000Z" itemprop="datePublished">2020-06-23</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">3.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">19 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a><strong>1. Overview</strong></h2><p>Before we get started with the implementation, it’s important to point out that the primary <em>List</em> and <em>Set</em> collection interfaces extend <em>Collection</em> but <em>Map</em> does not.</p>
<p>Simply put, the <em>HashMap</em> stores values by key and provides APIs for adding, retrieving and manipulating stored data in various ways. The implementation is <strong>based on the the principles of a hashtable</strong>, which sounds a little complex at first but is actually very easy to understand.</p>
<p>Key-value pairs are stored in what is known as buckets which together make up what is called a table, which is actually an internal array.</p>
<p>Once we know the key under which an object is stored or is to be stored, <strong>storage and retrieval operations occur in constant time</strong>, <em>O(1)</em> in a well-dimensioned hash map.</p>
<p>To understand how hash maps work under the hood, one needs to understand the storage and retrieval mechanism employed by the <em>HashMap.</em> We’ll focus a lot on these.</p>
<p>Finally, <strong><em>HashMap\</em> related questions are quite common in interviews</strong>, so this is a solid way to either prepare an interview or prepare for it.</p>
<h2 id="2-The-put-API"><a href="#2-The-put-API" class="headerlink" title="2. The put() API"></a><strong>2. The put() API</strong></h2><p>To store a value in a hash map, we call the <em>put</em> API which takes two parameters; a key and the corresponding value:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>When a value is added to the map under a key, the <em>hashCode()</em> API of the key object is called to retrieve what is known as the initial hash value.</p>
<p>To see this in action, let us create an object that will act as a key. We will only create a single attribute to use as a hash code to simulate the first phase of hashing:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Calling hashCode()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructor, setters and getters </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can now use this object to map a value in the hash map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHashCodeIsCalledOnPut_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyKey key = <span class="keyword">new</span> MyKey(<span class="number">1</span>);</span><br><span class="line">    Map&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(key, <span class="string">&quot;val&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nothing much happening in the above code, but pay attention to the console output. Indeed the <em>hashCode</em> method gets invoked:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Calling <span class="title">hashCode</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>Next, the <em>hash()</em> API of the hash map is called internally to compute the final hash value using the initial hash value.</p>
<p>This final hash value ultimately boils down to an index in the internal array or what we call a bucket location.</p>
<p>The <em>hash</em> function of <em>HashMap</em> looks like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What we should note here is only the use of the hash code from the key object to compute a final hash value.</p>
<p>While inside the <em>put</em> function, the final hash value is used like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that an internal <em>putVal</em> function is called and given the final hash value as the first parameter.</p>
<p>One may wonder why the key is again used inside this function since we have already used it to compute the hash value.</p>
<p>The reason is that <strong>hash maps store both key and value in the bucket location as a *Map.Entry* object</strong>.</p>
<p>As discussed before, all Java collections framework interfaces extend <em>Collection</em> interface but <em>Map</em> does not. Compare the declaration of Map interface we saw earlier to that of <em>Set</em> interface:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>The reason is that <strong>maps do not exactly store single elements as do other collections but rather a collection of key-value pairs.</strong></p>
<p>So the generic methods of <em>Collection</em> interface such as <em>add</em>, <em>toArray</em> do not make sense when it comes to <em>Map</em>.</p>
<p>The concept we have covered in the last three paragraphs makes for one of the <strong>most popular Java Collections Framework interview questions</strong>. So, it’s worth understanding.</p>
<p>One special attribute with the hash map is that it accepts <em>null</em> values and null keys:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNullKeyAndVal_whenAccepts_thenCorrect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>When a null key is encountered during a *put* operation, it is automatically assigned a final hash value of *0*</strong>, which means it becomes the first element of the underlying array.</p>
<p>This also means that when the key is null, there is no hashing operation and therefore, the <em>hashCode</em> API of the key is not invoked, ultimately avoiding a null pointer exception.</p>
<p>During a <em>put</em> operation, when we use a key that was already used previously to store a value, it returns the previous value associated with the key:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenExistingKey_whenPutReturnsPrevValue_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    String rtnVal = map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="string">&quot;val1&quot;</span>, rtnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>otherwise, it returns <em>null:</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNewKey_whenPutReturnsNull_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    String rtnVal = map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(rtnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When <em>put</em> returns null, it could also mean that the previous value associated with the key is null, not necessarily that it’s a new key-value mapping:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNullVal_whenPutReturnsNull_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    String rtnVal = map.put(<span class="string">&quot;key1&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(rtnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <em>containsKey</em> API can be used to distinguish between such scenarios as we will see in the next subsection.</p>
<h2 id="3-The-get-API"><a href="#3-The-get-API" class="headerlink" title="3. The get API"></a><strong>3. The get API</strong></h2><p>To retrieve an object already stored in the hash map, we must know the key under which it was stored. We call the <em>get</em> API and pass to it the key object:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenGetWorks_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    String val = map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="string">&quot;val&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Internally, the same hashing principle is used. <em>The hashCode()</em> API of the key object is called to obtain the initial hash value:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHashCodeIsCalledOnGet_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyKey key = <span class="keyword">new</span> MyKey(<span class="number">1</span>);</span><br><span class="line">    Map&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(key, <span class="string">&quot;val&quot;</span>);</span><br><span class="line">    map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This time, the <em>hashCode</em> API of <em>MyKey</em> is called twice; once for <em>put</em> and once for <em>get</em>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Calling <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Calling <span class="title">hashCode</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>This value is then rehashed by calling the internal <em>hash()</em> API to obtain the final hash value.</p>
<p>As we saw in the previous section, this final hash value ultimately boils down to a bucket location or an index of the internal array.</p>
<p>The value object stored in that location is then retrieved and returned to the calling function.</p>
<p>When the returned value is null, it could mean that the key object is not associated with any value in the hash map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenUnmappedKey_whenGetReturnsNull_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    String rtnVal = map.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(rtnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Or it could simply mean that the key was explicitly mapped to a null instance:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNullVal_whenRetrieves_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">         </span><br><span class="line">    String val=map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">         </span><br><span class="line">    assertNull(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To distinguish between the two scenarios, we can use the <em>containsKey</em> API, to which we pass the key and it returns true if and only if a mapping was created for the specified key in the hash map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenContainsDistinguishesNullValues_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    String val1 = map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> valPresent = map.containsKey(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(val1);</span><br><span class="line">    assertFalse(valPresent);</span><br><span class="line"> </span><br><span class="line">    map.put(<span class="string">&quot;key&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    String val = map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    valPresent = map.containsKey(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    assertNull(val);</span><br><span class="line">    assertTrue(valPresent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For both cases in the above test, the return value of the <em>get</em> API call is null but we are able to distinguish which one is which.</p>
<h2 id="4-Collection-Views-in-HashMap"><a href="#4-Collection-Views-in-HashMap" class="headerlink" title="4. Collection Views in HashMap"></a><strong>4. Collection Views in HashMap</strong></h2><p><em>HashMap</em> offers three views that enable us to treat its keys and values as another collection. We can get a set of all <strong>keys of the map</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenHashMap_whenRetrievesKeyset_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yc&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;blog&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">2</span>, keys.size());</span><br><span class="line">    assertTrue(keys.contains(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    assertTrue(keys.contains(<span class="string">&quot;type&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The set is backed by the map itself. So <strong>any change made to the set is reflected in the map</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenKeySet_whenChangeReflectsInMap_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yc&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;blog&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">2</span>, map.size());</span><br><span class="line"> </span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">    keys.remove(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">1</span>, map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can also obtain a <strong>collection view of the values</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenHashMap_whenRetrievesValues_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;baeldung&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;blog&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    Collection&lt;String&gt; values = map.values();</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">2</span>, values.size());</span><br><span class="line">    assertTrue(values.contains(<span class="string">&quot;yc&quot;</span>));</span><br><span class="line">    assertTrue(values.contains(<span class="string">&quot;blog&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Just like the key set, any <strong>changes made in this collection will be reflected in the underlying map</strong>.</p>
<p>Finally, we can obtain a <strong>set view of all entries</strong> in the map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenHashMap_whenRetrievesEntries_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yc&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;blog&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    Set&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">2</span>, entries.size());</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, String&gt; e : entries) &#123;</span><br><span class="line">        String key = e.getKey();</span><br><span class="line">        String val = e.getValue();</span><br><span class="line">        assertTrue(key.equals(<span class="string">&quot;name&quot;</span>) || key.equals(<span class="string">&quot;type&quot;</span>));</span><br><span class="line">        assertTrue(val.equals(<span class="string">&quot;yc&quot;</span>) || val.equals(<span class="string">&quot;blog&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember that a hash map specifically contains unordered elements, therefore we assume any order when testing the keys and values of entries in the <em>for each</em> loop.</p>
<p>Many times, you will use the collection views in a loop as in the last example, and more specifically using their iterators.</p>
<p>Just remember that the <strong>iterators for all the above views are *fail-fast*</strong>.</p>
<p>If any structural modification is made on the map, after the iterator has been created, a concurrent modification exception will be thrown:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected = ConcurrentModificationException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenIterator_whenFailsFastOnModification_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yc&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;blog&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">    Iterator&lt;String&gt; it = keys.iterator();</span><br><span class="line">    map.remove(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        String key = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The only <strong>allowed structural modification is a *remove*</strong> operation performed through the iterator itself:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenIterator_whenRemoveWorks_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yc&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;blog&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">    Iterator&lt;String&gt; it = keys.iterator();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="number">0</span>, map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The final thing to remember about these collection views is the performance of iterations. This is where a hash map performs quite poorly compared with its counterparts linked hash map and tree map.</p>
<p>Iteration over a hash map happens in worst case <em>O(n)</em> where n is the sum of its capacity and the number of entries.</p>
<h2 id="5-HashMap-Performance"><a href="#5-HashMap-Performance" class="headerlink" title="5. HashMap Performance"></a><strong><em>5. HashMap Performance</em></strong></h2><p>The performance of a hash map is affected by two parameters: <em>Initial Capacity</em> and <em>Load Factor</em>. The capacity is the number of buckets or the underlying array length and the initial capacity is simply the capacity during creation.</p>
<p>The load factor or LF, in short, is a measure of how full the hash map should be after adding some values before it is resized.</p>
<p>The default initial capacity is <em>16</em> and default load factor is <em>0.75</em>. We can create a hash map with custom values for initial capacity and LF:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; hashMapWithCapacity=<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">Map&lt;String,String&gt; hashMapWithCapacityAndLF=<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">32</span>, <span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure>

<p>The default values set by the Java team are well optimized for most cases. However, if you need to use your own values, which is very okay, you need to understand the performance implications so that you know what you are doing.</p>
<p>When the number of hash map entries exceeds the product of LF and capacity, then <strong>rehashing</strong> occurs i.e. <strong>another internal array is created with twice the size of the initial one and all entries are moved over to new bucket locations in the new array</strong>.</p>
<p>A <strong>low initial capacity</strong> reduces space cost but <strong>increases the frequency of rehashing</strong>. Rehashing is obviously a very expensive process. So as a rule, if you anticipate many entries, you should set a considerably high initial capacity.</p>
<p>On the flip side, if you set the initial capacity too high, you will pay the cost in iteration time. As we saw in the previous section.</p>
<p>So <strong>a high initial capacity is good for a large number of entries coupled with little to no iteration</strong>.</p>
<p>A <strong>low initial capacity is good for few entries with a lot of iteration</strong>.</p>
<h2 id="6-Collisions-in-the-HashMap"><a href="#6-Collisions-in-the-HashMap" class="headerlink" title="*6. Collisions in the HashMap"></a><em>*6. Collisions in the HashMap</em></h2><p>A collision, or more specifically, a hash code collision in a <em>HashMap</em>, is a situation where <strong>two or more key objects produce the same final hash value</strong> and hence point to the same bucket location or array index.</p>
<p>This scenario can occur because according to the <em>equals</em> and <em>hashCode</em> contract, <strong>two unequal objects in Java can have the same hash code</strong>.</p>
<p>It can also happen because of the finite size of the underlying array, that is, before resizing. The smaller this array, the higher the chances of collision.</p>
<p>That said, it’s worth mentioning that Java implements a hash code collision resolution technique which we will see using an example.</p>
<p><strong>Keep in mind that it’s the hash value of the key that determines the bucket the object will be stored in. And so, if the hash codes of any two keys collide, their entries will still be stored in the same bucket.</strong></p>
<p>And by default, the implementation uses a linked list as the bucket implementation.</p>
<p>The initially constant time <em>O(1)</em> <em>put</em> and <em>get</em> operations will occur in linear time <em>O(n)</em> in the case of a collision. This is because after finding the bucket location with the final hash value, each of the keys at this location will be compared with the provided key object using the <em>equals</em> API.</p>
<p>To simulate this collision resolution technique, let’s modify our earlier key object a little:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyKey</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Calling hashCode()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// toString override for pretty logging</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Calling equals() for key: &quot;</span> + obj);</span><br><span class="line">        <span class="comment">// generated implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice how we’re simply returning the <em>id</em> attribute as the hash code – and thus force a collision to occur.</p>
<p>Also, note that we’ve added log statements in our <em>equals</em> and <em>hashCode</em> implementations – so that we know exactly when the logic is called.</p>
<p>Let’s now go ahead to store and retrieve some objects that collide at some point:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenCallsEqualsOnCollision_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    MyKey k1 = <span class="keyword">new</span> MyKey(<span class="number">1</span>, <span class="string">&quot;firstKey&quot;</span>);</span><br><span class="line">    MyKey k2 = <span class="keyword">new</span> MyKey(<span class="number">2</span>, <span class="string">&quot;secondKey&quot;</span>);</span><br><span class="line">    MyKey k3 = <span class="keyword">new</span> MyKey(<span class="number">2</span>, <span class="string">&quot;thirdKey&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;storing value for k1&quot;</span>);</span><br><span class="line">    map.put(k1, <span class="string">&quot;firstValue&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;storing value for k2&quot;</span>);</span><br><span class="line">    map.put(k2, <span class="string">&quot;secondValue&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;storing value for k3&quot;</span>);</span><br><span class="line">    map.put(k3, <span class="string">&quot;thirdValue&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;retrieving value for k1&quot;</span>);</span><br><span class="line">    String v1 = map.get(k1);</span><br><span class="line">    System.out.println(<span class="string">&quot;retrieving value for k2&quot;</span>);</span><br><span class="line">    String v2 = map.get(k2);</span><br><span class="line">    System.out.println(<span class="string">&quot;retrieving value for k3&quot;</span>);</span><br><span class="line">    String v3 = map.get(k3);</span><br><span class="line"> </span><br><span class="line">    assertEquals(<span class="string">&quot;firstValue&quot;</span>, v1);</span><br><span class="line">    assertEquals(<span class="string">&quot;secondValue&quot;</span>, v2);</span><br><span class="line">    assertEquals(<span class="string">&quot;thirdValue&quot;</span>, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above test, we create three different keys – one has a unique <em>id</em> and the other two have the same <em>id</em>. Since we use <em>id</em> as the initial hash value, <strong>there will definitely be a collision</strong> during both storage and retrieval of data with these keys.</p>
<p>In addition to that, thanks to the collision resolution technique we saw earlier, we expect each of our stored values to be retrieved correctly, hence the assertions in the last three lines.</p>
<p>When we run the test, it should pass, indicating that collisions were resolved and we will use the logging produced to confirm that the collisions indeed occurred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">storing value for k1</span><br><span class="line">Calling hashCode()</span><br><span class="line">storing value for k2</span><br><span class="line">Calling hashCode()</span><br><span class="line">storing value for k3</span><br><span class="line">Calling hashCode()</span><br><span class="line">Calling equals() for key: MyKey [name&#x3D;secondKey, id&#x3D;2]</span><br><span class="line">retrieving value for k1</span><br><span class="line">Calling hashCode()</span><br><span class="line">retrieving value for k2</span><br><span class="line">Calling hashCode()</span><br><span class="line">retrieving value for k3</span><br><span class="line">Calling hashCode()</span><br><span class="line">Calling equals() for key: MyKey [name&#x3D;secondKey, id&#x3D;2]</span><br></pre></td></tr></table></figure>

<p>Notice that during storage operations, <em>k1</em> and <em>k2</em> were successfully mapped to their values using only the hash code.</p>
<p>However, storage of <em>k3</em> was not so simple, the system detected that its bucket location already contained a mapping for <em>k2</em>. Therefore, <em>equals</em> comparison was used to distinguish them and a linked list was created to contain both mappings.</p>
<p>Any other subsequent mapping whose key hashes to the same bucket location will follow the same route and end up replacing one of the nodes in the linked list or be added to the head of the list if <em>equals</em> comparison returns false for all existing nodes.</p>
<p>Likewise, during retrieval, <em>k3</em> and <em>k2</em> were <em>equals</em>-compared to identify the correct key whose value should be retrieved.</p>
<p>On a final note, from Java 8, the linked lists are dynamically replaced with balanced binary search trees in collision resolution after the number of collisions in a given bucket location exceed a certain threshold.</p>
<p>This change offers a performance boost, since, in the case of a collision, storage and retrieval happen in <em>O(log n).</em></p>
<p>This section is <strong>very common in technical interviews,</strong> especially after the basic storage and retrieval questions.</p>
 
      <!-- reward -->
      
    </div>
    

    <!--comments -->
    
    <section id="comments">

    <div id="disqus_thread"></div>
    <script>

    var disqus_config = function () {
        this.page.url = 'https://yc-s.github.io/2020/06/23/Java-HashMap-Inner-Implementation/index.html';
        this.page.identifier = '2020/06/23/Java-HashMap-Inner-Implementation/index.html';
        this.page.title = 'Java_HashMap_Inner_Implementation';
    };

    (function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yc-s-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </section>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        Share
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://yc-s.github.io/2020/06/23/Java-HashMap-Inner-Implementation/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/06/24/Python-Interview-Questions/" class="article-nav-link">
        <strong class="article-nav-caption">prev post</strong>
        <div class="article-nav-title">
          
            Python_Interview_Questions
          
        </div>
      </a>
    
    
      <a href="/2020/06/22/67-Spring-Interview-Questions/" class="article-nav-link">
        <strong class="article-nav-caption">next post</strong>
        <div class="article-nav-title">67_Spring_Interview_Questions</div>
      </a>
    
  </nav>

  
   
     


</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Aaron
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
  
  <script>
    var disqus_shortname = 'yc-s-github-io';
    
    var disqus_url = 'https://yc-s.github.io/categories/index.html';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  
</footer>

      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">🏡</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">🏛</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">📚</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">🏷</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>