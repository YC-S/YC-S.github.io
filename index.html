<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yuanchen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yuanchen&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yuanchen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yuanchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuanchen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/01/%E4%B8%AD%E5%9B%BD%E6%80%8E%E6%A0%B7%E6%B6%88%E7%81%AD996/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/%E4%B8%AD%E5%9B%BD%E6%80%8E%E6%A0%B7%E6%B6%88%E7%81%AD996/" class="post-title-link" itemprop="url">中国怎样消灭996</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-01 21:32:48 / Modified: 21:38:22" itemprop="dateCreated datePublished" datetime="2020-03-01T21:32:48-06:00">2020-03-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>但是，古尔丹，代价是什么呢？</p>
<p>获得一份收益，付出一份代价。我读萨米尔阿明时有时会感慨：原来钢炼的片头说的真是真理。</p>
<p>你不想上班，就要失去上班工资的收益；你要这份收益，你就要付出上班的代价。</p>
<p>你说隔壁老王不上班也很滋润呀，对，他失去的工资收益用别的收益补偿了呗，可能是房租，可能是私活，可能是讨厌的家族遗产…</p>
<p>这些看不到的收益，补偿了隔壁老王不上班的代价。</p>
<p>所以当你痛苦996789这些烂事时，特别是你开始思考为什么这种现象如此广泛时，你最好去看看那些没有这种现象的国家，他们为什么没有？</p>
<p>他们为什么不需要996的收益？</p>
<p>他们在用什么补偿失去这些收益的代价？知乎作为工业党人的重要据点，已经有大量资料论证了那些不需要996还能过上好日子的国家，是凭什么：</p>
<p>美帝有美元、美金、美军、好莱坞的多重全球霸权，是现行的国际秩序制定者、科技第一国、金融主导国。这些全球霸权就是全球收益，在这些收益里切下一小块，就能给吸毒者发毒品，给三千万人发粮票；</p>
<p>英国依旧在国际外交中有重要影响力，依然是英联邦的名义领袖、国际金融的重要避风港、航空工业的核心技术掌握者，而且还是美帝的紧密伙伴；</p>
<p>法国则凭借自己较完整的工业体系，和对非洲铁血般地控制，经济、文化乃至军事，还是布鲁塞尔重要的大哥；</p>
<p>德国通过堪称俾斯麦复生的纵横捭阖，用欧元渗透了整个欧洲，并且还是欧盟体系内唯一能打的工业国，多项核心工业的主导者；</p>
<p>就连日本，社畜一词发源地的日本，都有着庞大的海外经济殖民地，海外日企资产高于国内。我们现在的对外援助套路就来自于日本。所以日本的社畜更多是对普通人的管制，企业之间的竞争比我朝要和缓多了。</p>
<p>说真的，日本工作留学的中国人那么多了，普通日本人真有我们这么“畜”？</p>
<p>所以，古尔丹，代价是什么呢？</p>
<p>代价就是，能不能够把代价转移到别人身上。</p>
<p>如果美帝不能把量化宽松的代价转移出去，那美债就是屎，美股就是屎，美企就会死。但是四重结界摆在这，它转移把代价转移给你，你只能接着，于是代价的代价在你身上，不在领粮票的三千万美国人身上。</p>
<p>美帝能找别人买单，墨西哥在为它买单，我朝也在为美国人买单，美帝的单，全世界都要买，拉丁美洲已经买出了血泪史。</p>
<p>任何繁荣都是建立在奴隶身上的，问题是你能不能找到奴隶，找不到，你就只能自己做奴隶。</p>
<p>希腊的工业不就是德国人的奴隶吗？</p>
<p>中非西非的政变和旧法郎经济区，不就是法国人的奴隶吗？</p>
<p>就连韩国人，都在美帝的奴隶外做了半个日本人的奴隶。反日情绪再高涨，也改变不了韩国财阀里到处都是日本人的钱的事实；</p>
<p>你看一眼菲律宾巨头的账本，日本政府的援助贷款，美帝的世行授信，欧洲人披着新加坡皮的投资，然后换来了整个国家的矿、林、农、渔。</p>
<p>当然还有人，廉价的人，从工人到雇农，到走私黑枪和毒品的小弟，到女人，妓女，还有童妓，全球最大量的童妓。</p>
<p>整个国家，不就是奴隶么？</p>
<p>我朝这个体量，如果人人都要过上不错的日子，那在现行秩序里找不到位置。我们需要的代价太大，不是三百万人口那些小而美，干点代理的活拿点分成就能搞定的。</p>
<p>虽然很多人讲法治，法治也确实有改善的空间，但是这个空间不会太大。我个人坚信，法制也好法治也罢，都是结果，有了足够的蛋糕才能讲分配。</p>
<p>解决一两家公司可以，解决多数人的996，只能靠算账。</p>
<p>而这笔帐，你现在算不过来。第四次工业革命要不要赶上？前三次你都错过了，再错过这次又不知道几百年能翻身。要赶？钱，干活的人；</p>
<p>产能要不要输出？不输出产能过剩经济萧条失业爆发还被人割韭菜。输出？继续印钱撒钱，通胀不可避，民生就是四处灭火；</p>
<p>国防要不要建设？核心利益，海外利益，更不要说你现在已经被大哥盯着搞。要？钱，人；</p>
<p>你站在国家角度看账本，看三秒就能理解冒牌天神里弗里曼的表情。</p>
<p>为什么要反腐？就这么点钱，都少拿点，要干正事。</p>
<p>还有减税呐。</p>
<p>想翻身，甚至只是想这么走下去，代价太多。</p>
<p>我不想为什么意识形态呐喊，我只是认为，现代化有一套无法躲避的逻辑，这个过程需要巨大的代价才能得以实现，这个代价是不分意识形态的，斯大林体制，刚果被砍手的黑人，墨西哥的毒品，拉丁美洲的军阀，东南亚的家族体制，都是代价。</p>
<p>因此我对我朝在最近20年内能否消灭996，抱以相当悲观的态度。</p>
<p>个人看奋斗，简历好一点，专业有远见一点，公司找的谨慎一点，技能和人脉丰富一点，知乎人均大神，躲还是好躲的。</p>
<p>但你说到历史的进程嘛。</p>
<p>我想，大概只有三种可能，能够“消灭”996：</p>
<p>一，我朝放弃现代化和独立道路，选择依附。这样中产阶级会极大萎缩，下层数量会激增，但中产阶级能够消灭996，毕竟代理人生活得还是很好的；</p>
<p>二，我朝show hand，滚滚红尘一波流，皇国兴废在此一战，还居然灭了美帝。就此重新划分世界后，产能、货币、文化输出，享受全球收益，就能为多数人消灭996；</p>
<p>三，我朝死磕第四次工业革命，勉力维系基本盘不崩，完成产业升级，并且实现多工业细项垄断，进而在现行国际秩序外建立“新秩序”，那也能实现多数人没有996。</p>
<p>所以，古尔丹，代价是什么呢？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/29/%E4%B8%80%E4%BA%A9%E4%B8%89%E5%88%86%E5%9C%B0%E9%A2%98%E5%BA%93-%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF%E7%AD%94%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%E4%B8%80%E4%BA%A9%E4%B8%89%E5%88%86%E5%9C%B0%E9%A2%98%E5%BA%93-%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF%E7%AD%94%E6%A1%88/" class="post-title-link" itemprop="url">一亩三分地题库+新手上路答案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-29 16:54:05 / Modified: 16:54:40" itemprop="dateCreated datePublished" datetime="2020-02-29T16:54:05-06:00">2020-02-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.一亩三分地 新手上路 网站规则 - 满分5大米(适用于所有用户)<br>2.一亩三分地 考试中心 满分95大米(只适用于2019年之后注册的新人)<br>3.一亩三分地 每日答题 题库</p>
<h3 id="网站规则-满分5大米"><a href="#网站规则-满分5大米" class="headerlink" title="网站规则 - 满分5大米"></a>网站规则 - 满分5大米</h3><ol>
<li>一亩三分地发帖可以选择内容用hide进行隐藏。隐藏方式：[hide=200]隐藏的内容[/hide] 下面哪个选项hi‍‌‌‌‌‌‌‌‍‍‍‌‌‌‍‌‌‌‌‌de正确。 (1.0 分)<br><strong>A. 两人第一次华山论剑，争的是荣名与[hide=188]《九阴真经》[/hide]；</strong><br>B. 第二次在桃花岛过招，是为了郭靖与[hide=188]欧阳克[\hide]争婚。<br>C. 第三次海上相斗，生死只隔一线，但(hide=188)洪七公(\ hide)手下尚自容让；<br>D. 现下第四次恶战，[hide188]才是各出全力[/hide]，再无半点留情。<br>E. 洪七公伸指疾点欧阳锋背心[hide=188]“凤尾穴”(/hide)，要迫他松手。</li>
<li>为什么一亩三分地除了租房广告找室友、学有飞友工友、本地版聚等少数版块之外，绝大多数板块都不允许拉群？ (1.0 分)<br>A. 地里信息是公开的，全部回复每个人都可以看到。而群里的信息，作为新入群的同学是无法看到历史消息的，并且无法查找<br>B. 公开自己的微信，将来可能会被人人肉或者骚扰<br>C. 地里的信息永远存在，有些群很可能不活跃甚至不存在了，里面的讨论也就消失了<br><strong>D. 以上全都理解并接受</strong></li>
<li>在下面哪些板块里留微信号等各种联系方式，事后可以要求版主删除？ (1.0 分)<br>A. 如果发在求职类板块里，可以删除，我的隐私你得尊重啊<br>B. 如果发在留学类板块里，可以删除，毕竟我年少不懂事嘛<br>C. 如果发在非正事、无聊帖子里，可以删除，毕竟没啥营养啊<br><strong>D. 绝大多数板块禁止留微信、拉群，如果你非要发出来，那就永远不删。另外，私下联系建议发站内信。</strong></li>
<li>为什么我们不鼓励用谐音或者各种拐弯抹角的说法来指代公司或者学校名称？比如：“湾区某元音开头和结尾公司” (1.0 分)<br>A. 也许有什么顾虑吧<br>B. 这样不好玩<br><strong>C. 写成这样子，别人看不懂，也搜不到。如果别人也这样写，你也看不懂、搜不到。信息没法分享和交流。</strong><br>D. 不知道</li>
<li>下面哪个说法是错误的？ (1.0 分)<br>A. 连续超过14天不登录，每天扣一个大米，直到大米数=100<br><strong>B. 抖包袱版看帖，不会消耗积分</strong><br>C. 可以消耗积分更改用户名（网站右上角设置-&gt;个人资料-&gt;更改用户名）<br>D. 看到干货帖子和回复，给作者加分，不会消耗我的积分<br>E. 每日签到、每日答题都可以拿到积分奖励<br>F. 手机app里也可以每日签到，好方便！<br>G. 给地里官方app五星好评，可以拿加分奖励: <a href="http://www.1point3acres.com/bbs/thread-446981-1-1.html" target="_blank" rel="noopener">www.1point3acres.com/bbs/thread-446981-1-1.html</a><br>H. 在手工加分的帖子里，多次回复骗取积分，会被系统检测到，积分扣除+额外扣分！<br>I. 网站上方导航栏 -&gt; 道具中心，可以兑换匿名卡，把自己的帖子匿名。</li>
</ol>
<h3 id="网站规则-满分95大米"><a href="#网站规则-满分95大米" class="headerlink" title="网站规则 - 满分95大米"></a>网站规则 - 满分95大米</h3><ol>
<li>一亩三分地里有哪些方面的信息？ (5.0 分)<br><strong>A. 美国大学各专业录取信息<br>B. 美国和中国公司面试题目<br>C. 买房买车租‍‌‌‌‌‌‌‌‍‍‍‌‌‌‍‌‌‌‌‌房等生活信息<br>D. 移民签证H1B等信息<br>E. 公开课、刷题、做项目<br>F. 八卦我司版：美国公司评价（各公司员工发帖）<br>G. 抖包袱版：各公司工资offer的详细数目<br>H. 缘来如此版可以发帖征友<br>I. 职场达人：中美职场和职业发展话题<br>J. TOEFL/GRE考试信息</strong></li>
<li>一亩三分地有积分限制，请戳这里阅读《攒积分和消耗积分完全指南》然后回答：下面哪些说法正确？ (10.0 分)<br><strong>A. 认真做考卷，很容易拿到满分<br>B. 每日签到（网站右上方），奖励1颗大米<br>C. 每日答题（网站右上方），答对了奖励1颗大米，答错了消耗1颗<br>D. 设置头像，奖励一颗大米（只能获得一次）<br>E. 验证邮箱，奖励一颗大米（只能获得一次）<br>F. 管理员每日选择2-3个干货帖子全站置顶，大家会奖励给你大米<br>G. 分享面经、录取信息、工资数目等干货，或者积极参与讨论<br>H. 积极参与论坛各种活动，比如给地里官方app五星好评<br>I. 《攒积分和消耗积分完全指南》里有更多获取积分方法的说明<br>J. 积分变更记录在网站右上角设置-&gt;积分里能找到（2019年3月2日之前的部分记录不显示，之后的全显示）</strong></li>
<li>一亩三分地发帖可以选择内容进行隐藏。举个例子：<br>黄蓉哭了一会，抽抽噎噎的道：“我听爹爹说过，洪老前辈有一套武功，当真是天下无双、古今独步，甚至全真教的王重阳也忌惮三分，叫做……叫做……咦，我怎么想不起来啦，明明刚才我还记得的，我想求他教你，这套拳法叫做……叫做……”其实她哪里知道，全是信口胡吹。洪七公在树顶上听她苦苦思索，实在忍不住了，喝道：“叫做‘[hide=200]降龙十八掌[/hide]’！”说着一跃而下。上述段落里，“降龙十八掌”五个字被隐藏，只有积分&gt;=200分的用户才能看到。<br>隐藏方式：[hide=200]隐藏的内容[/hide] 注意不要添加多余的空格！第二个hide前面的斜线别弄反方向！下面隐藏的内容哪个被188分正确隐藏？真相只有一个！ (10.0 分)<br>A. 柯南的名字是[hide=188]工藤新一[\hide]<br>B. 柯南的名字是[hide]工藤新一[/hide=188]<br><strong>C. 柯南的名字是[hide=188]工藤新一[/hide]</strong><br>D. 柯南的名字是[hide=188]工藤新一[\ hide]<br>E. 柯南的名字是[hide=188]工藤新一{\hide}<br>F. 柯南的名字是(hide=188)工藤新一(\hide)</li>
<li>在论坛发slack群、qq群、微信群等任何站外讨论方式，会如何？ (10.0 分)<br>A. 如果发在本地版聚、租房找室友、飞友学友工友版块，是允许的<br>B. 如果发在求职、面经、申请类板块里，都会被删帖扣分<br>C. 举报这些群，可能得到加分奖励<br><strong>D. 以上都正确</strong></li>
<li>下面哪种情况，管理员会按照你的要求，进行删帖？ (10.0 分)<br>A. 问了问题，得到了答案，然后我过河拆桥，删帖让其他人看不到<br>B. 尽管地里不允许，但是我到处留微信号，然后说隐私暴露要求删帖<br>C. 发帖赚到了积分，看到了有权限设置的内容，然后反悔<br><strong>D. 这些情况全都不删帖！</strong></li>
<li>你的一亩三分地账号很宝贵，在别的网站，考完托福你就离开了，申请完了你也不会再去。但是在一亩三分地，拿到录取以后，你找实习要回来，找全职工作要回来，申请OPT要回来，等H1b签证和绿卡要回来，甚至工作几年后要跳槽你也要回来看求职信息 - 随着地里的壮大，你会经常回来。<br>下面哪些方法可以保护你的账号？ (10.0 分)<br><strong>A. 给账号设置复杂密码，并且只在一亩三分地使用该密码。<br>B. 把地里的邮件放入白名单以免被判定为垃圾邮件而导致收不到密码重设等重要信息（地里从来不发广告）。<br>C. 绑定微信。如果账号有异常，会被系统要求扫码登录，而且扫码登录比输入密码方便。<br>D. 管理好用来注册账号的电子邮箱，如果连邮箱都没了，那就惨了。。。</strong><br>E. 别那么多有的没的，我爱咋地就咋地。</li>
<li>下面哪些发帖行为，值得鼓励和倡导？ (10.0 分)<br>A. 随便发就是了，反正有版主和管理员给调整<br><strong>B. 读一下各个版块的置顶信息，了解网站规则。<br>C. 发帖之前，先浏览有哪些版块，帖子要发在对应的板块里。</strong><br>D. 帖子设置回复可见，大家必须回复才能看到，然后一堆人发“顶”<br><strong>E. 帖子标题最好能用一句话概括主要内容，方便大家阅读<br>F. 地里很多帖子有分类设置，方便大家查找，发帖确保分类信息设置合理</strong><br>G. 很多帖子有权限设置，我积分不够，到处发“看不到啊”、“积分不够啊”，水掉论坛</li>
<li>新人积分不够。下面哪些做法正确？ (5.0 分)<br><strong>A. 分享干货、签到答题、参加活动等，争取早日攒够积分。</strong><br>B. 到处发帖抱怨积分不够、看不到，没准会有帮助呢。<br>C. 想各种办法绕开积分限制，比如要求楼主私下把信息发给我<br>D. 注册个小号，相互加分（嘿嘿，地里有后台系统检测哦）</li>
<li>下面哪些方式，可以获得积分奖励？ (5.0 分)<br><strong>A. 分享干货，无论是录取信息、面经题目、工资数据，还是各种生活经验。</strong><br>B. 在帖子里给别人加分，告诉对方给我加回来。<br><strong>C. 认真参与网站里的讨论，贡献我的看法和信息</strong><br>D. 没有分享干货，但是可以缠着别人要积分<br><strong>E. 干货帖子被全站置顶或者公众号推出，至少拿100分，很多帖子拿到200+</strong><br>F. 我有信息可以分享，但是大家来给我加分吧，谁加了分我私下里发给你</li>
<li>一亩三分地里可以购买VIP通行证，位于网站上方导航栏 -&gt; VIP。关于VIP，下面哪些说法正确？ (10.0 分)<br><strong>A. VIP可以瞬间解锁地里有权限的帖子，获得阅读权限<br>B. VIP下载附件不扣积分，不受权限限制<br>C. VIP用户可以自由搜索，不扣积分</strong><br>D. VIP是“免责金牌”，在地里不受规则约束，可以为所欲为<br><strong>E. VIP获得的只是阅读帖子权限，网站有的功能仍需积分（可以攒大米或者购买蓝莓）<br>F. VIP收入用来支付一亩三分地运营和发展的必要花费；我的打赏能支持一亩三分地做的更好</strong></li>
<li>下面哪种行为，在地里会被扣光积分，甚至封号？ (10.0 分)<br><strong>A. 戾气十足、人身攻击<br>B. 种种手段恶意刷分<br>C. 软硬广告或导流吸粉<br>D. 造谣或者发钓鱼贴<br>E. 多人共享账号<br>F. 违反版规，胡乱跨版发帖，到处留邮箱或微信号<br>G. 购买了VIP通行证，作为付费用户，违反网站规则。</strong></li>
</ol>
<h3 id="每日答题题库"><a href="#每日答题题库" class="headerlink" title="每日答题题库"></a>每日答题题库</h3><p>【题目】 公司之间级别对应，如下哪个是错误的？<br>Google T5 = Facebook E5/6<br>Uber Sr II = Lyft T6<br>Amazon L7 = Facebook E6<br>✓ Facebook L6 = Facebook E6</p>
<p>【题目】一亩三分地发帖可以选择内容用 hide 进行隐藏。隐藏方式：[hide=200]隐藏的内容[/hide] 下面哪个选项 hide 正确。<br>✓ A. 两人第一次华山论剑，争的是荣名与[hide=188]《九阴真经》[/hide]；<br>B. 第二次在桃花岛过招，是为了郭靖与[hide=188]欧阳克[\hide]争婚。<br>C. 第三次海上相斗，生死只隔一线，但(hide=188)洪七公(\ hide)手下尚自容让；<br>D. 现下第四次恶战，[hide188]才是各出全力[/hide]，再无半点留情。<br>E. 洪七公伸指疾点欧阳锋背心[hide=188]“凤尾穴”(/hide)，要迫他松手。</p>
<p>【题目】为什么一亩三分地除了租房广告找室友、学有飞友工友、本地版聚等少数版块之外，绝大多数板块都不允许拉群？<br>A. 地里信息是公开的，全部回复每个人都可以看到。而群里的信息，作为新入群的同学是无法看到历史消息的，并且无法查找<br>B. 公开自己的微信，将来可能会被人人肉或者骚扰<br>C. 地里的信息永远存在，有些群很可能不活跃甚至不存在了，里面的讨论也就消失了<br>✓ D. 以上全都理解并接受</p>
<p>【题目】在下面哪些板块里留微信号等各种联系方式，事后可以要求版主删除？<br>A. 如果发在求职类板块里，可以删除，我的隐私你得尊重啊<br>B. 如果发在留学类板块里，可以删除，毕竟我年少不懂事嘛<br>C. 如果发在非正事、无聊帖子里，可以删除，毕竟没啥营养啊<br>✓ D. 绝大多数板块禁止留微信、拉群，如果你非要发出来，那就永远不删。另外，私下联系建议发站内信。</p>
<p>【题目】为什么我们不鼓励用谐音或者各种拐弯抹角的说法来指代公司或者学校名称？ 比如：“湾区某元音开头和结尾公司”，你能猜到是哪家吗？<br>A. 也许有什么顾虑吧<br>B. 这样不好玩<br>✓ C. 写成这样子，别人看不懂，也搜不到。如果别人也这样写，你也看不懂、搜不到。信息没法分享和交流。<br>D. 不知道</p>
<p>【题目】下面哪个说法是错误的？<br>A. 连续超过 14 天不登录，每天扣一个大米，直到大米数=100<br>✓ B. 抖包袱版看帖，不会消耗积分<br>C. 可以消耗积分更改用户名（网站右上角设置-&gt;个人资料-&gt;更改用户名）<br>D. 看到干货帖子和回复，给作者加分，不会消耗我的积分 E. 每日签到、每日答题都可以拿到积分奖励<br>F. 手机 app 里也可以每日签到，好方便！<br>G. 给地里官方 app 五星好评，可以拿加分奖励: <a href="http://www.1point3acres.com/bbs/thread-446981-1-1.html" target="_blank" rel="noopener">www.1point3acres.com/bbs/thread-446981-1-1.html</a> H. 在手工加分的帖子里，多次回复骗取积分，会被系统检测到，积分扣除+额外扣分！<br>I. 网站上方导航栏 -&gt; 道具中心，可以兑换匿名卡，把自己的帖子匿名。</p>
<p>【题目】 下面哪个情况，不会消耗你的积分？<br>超过 14 天不登录<br>使用论坛搜索<br>下载附件<br>✓ 看到干货帖子和精华回复，给作者加分！</p>
<p>【题目】 下面哪个州，没有 income tax?<br>✓ Nevada<br>New York<br>Nebraska<br>Massachusetts</p>
<p>【题目】 下面哪个州，有 state income tax<br>Tennessee<br>Alaska<br>Washington<br>✓ Mississippi</p>
<p>【题目】 求内推如何作死？<br>一下子叫好多人给内推同一家公司<br>别人回复慢了就抱怨<br>简历上撒谎<br>✓ 这些都会作死</p>
<p>【题目】 下面哪种方法，可以妥妥拿到积分？<br>上传头像<br>每日签到（需绑定微信）<br>分享干货<br>✓ 这些全都可以</p>
<p>【题目】 回答别人的私信提问还需要消耗我 5 大米怎么办？<br>✓ 直接在版面回答，这样大家都能看见</p>
<p>【题目】 下面哪种行为，在地里会被扣光积分，甚至封号？<br>✓ 这些全都会</p>
<p>【题目】一亩三分地发帖可以用 hide 语法隐藏内容。下面哪个写法正确？<br>✓ 柯南的名字是[hide=200]工藤新一[/hide]<br>柯南的名字是[hide=200]工藤新一[\hide]<br>柯南的名字是[hide=200]工藤新一[hide]<br>柯南的名字是[hide=200]工藤新一[/hide=200]</p>
<p>【题目】 在 Linkedin 上求内推如何作死<br>看也不看对方情况，直接扔简历要求内推，国人必须帮助国人啊<br>写模板内容要求内推，不论男女都叫学姐<br>也不自我介绍，就要求对方介绍公司情况<br>✓ 这些都会作死</p>
<p>【题目】一亩三分地鼓励如何发面经？<br>遇到有人留邮箱，私下发面经的，点举报<br>积分隐藏[hide==188]内容[/hide]<br>✓ 以上都正确</p>
<p>【题目】 下面哪个大学在华盛顿州？<br>Washington University<br>✓ University of Washington<br>George Washington University<br>Washington College</p>
<p>【题目】下面哪个大学不在 Virginia/DC 附近<br>✓ Washington and Jefferson College<br>Trinity Washington University<br>George Washington University<br>Washington and Lee University</p>
<p>【题目】 下面哪个州，对公司友好，所以吸引了美国很多公司注册？<br>加利福尼亚<br>✓ 特拉华<br>佛罗里达<br>纽约</p>
<p>【题目】 下面哪个州，有 state income tax<br>South Dakota<br>Wyoming<br>✓ North Dakota<br>Tennessee</p>
<p>【题目】 下面哪个州，没有 state income tax<br>New York<br>New Jersey<br>✓ New Hampshire<br>New Mexico</p>
<p>【题目】 下面哪个州，没有 state income tax?<br>✓ Florida<br>Georgia<br>Hawaii<br>Idahoda</p>
<p>【题目】 下面哪个州，没有 state income tax?<br>Alabama<br>✓ Alaska<br>Arizona<br>Arkansas</p>
<p>【题目】下面哪个州冬天最暖和？<br>Minnesota<br>✓ Oklahoma<br>Michigan<br>Massachusetts</p>
<p>【题目】下面哪个大学实际上不存在？<br>University of California, San Francisco<br>University of Massachusetts, Dartmouth<br>✓ University of Michigan, Twin City<br>University of Nevada, Las Vegas</p>
<p>【题目】下面哪所大学所在城市不是波士顿？<br>✓ Boston College<br>Berklee College Of Music<br>Northeastern University<br>Boston University</p>
<p>【题目】下面哪个说法错误？<br>伊利诺伊大学在芝加哥有校区<br>✓ 芝加哥是美国著名的雨城<br>美国西北大学在芝加哥有校区<br>芝加哥 skydeck 上可以看到四个州</p>
<p>【题目】 Which company is the largest single✓site employer in the US?<br>Walmart<br>Ford<br>Costco<br>✓ Disney World</p>
<p>【题目】 下面哪种方法，可以妥妥拿到积分？<br>分享干货<br>上传头像<br>每日签到（需绑定微信）<br>✓ 这些全都可以</p>
<p>【题目】 下面哪家公司的总部不在西雅图<br>亚马逊<br>阿拉斯加航空公司<br>星巴克<br>✓ 波音</p>
<p>【题目】 给论坛 ios 或者安卓手机应用留评价如何获取 50 大米？<br>留 5 星评价<br>截屏作为证据<br>上传到第一个大区的”官方开发版“<br>✓ 以上步骤都需要</p>
<p>【题目】 地里发帖可以隐藏内容。假如要设置 200 积分以上才可以看到，下面哪个语法正确？<br>[hide]想要隐藏的内容[/hide]<br>[hide=200 ]想要隐藏的内容[/hide]<br>✓ [hide=200]想要隐藏的内容[/hide]<br>[hide=200]想要隐藏的内容[hide]</p>
<p>【题目】 地里面经数目最多的是哪家公司？<br>Facebook<br>Google<br>✓ Amazon<br>Uber</p>
<p>【题目】 Negotiate 工资的时候，哪种做法有利于得到更大的包裹？<br>拿地里抖包袱版的工资数字要对方 match<br>直接告诉对方自己目前薪酬，让对方看着良心办<br>开一个天价，谈不拢就散伙<br>✓ 精读地里谈工资宝典，知己知彼，百战不殆</p>
<p>【题目】 which state is University of Miami located?<br>California<br>Nevada<br>✓ Florida<br>Ohio</p>
<p>【题目】 下面哪个城市没有 SUNY（纽约州立大学）校区？<br>Albany<br>Buffalo<br>✓ Fulton<br>Stony Brook</p>
<p>【题目】 下面哪个州里有 Disney World？<br>✓ Florida<br>New York<br>North Carolina<br>Texas</p>
<p>【题目】 下面哪所大学所在城市不是波士顿？<br>✓ MIT<br>Boston University<br>Northeastern University<br>Emerson College</p>
<p>【题目】 关于旧金山市中心描述，下面哪个不正确？<br>走路得看着路，很多流浪汉，地上屎尿一不小心会踩上<br>车里一定不要放东西，但即使不放，也可能被砸车玻璃<br>Uber/Airbnb/Pinterest/Twitter 等著名科技公司都在 SOMA 区<br>✓ 旧金山创业公司很多，被称为“硅谷”</p>
<p>【题目】 一亩三分地是哪年创立的？<br>✓ 2009<br>2011<br>2013<br>2015</p>
<p>【题目】 下面哪个州在美国西海岸<br>VirginiaNorth<br>DakotaMaine<br>✓ Washington</p>
<p>【题目】 which state is University of Miami located?<br>Ohio<br>✓ Florida<br>Nevada<br>California</p>
<p>【题目】 加州大学有多个分校，下面哪个成立时间最短？<br>UC Davis<br>✓ UC Merced<br>UC Riverside<br>UC Santa Cruz</p>
<p>【题目】 下面哪个专业，不是 STEM，OPT 没法延期？<br>会计学以前不是，现在很多学校 stem 获批<br>数据科学<br>EECS<br>✓ 教育学</p>
<p>【题目】 哪种选校策略最合理？<br>按照排名高低选，谁高谁就好<br>交给中介选，反正不想操心<br>所有学校都申，蒙中哪个算哪个<br>✓ 根据自己下一步职业和学业目标，参考地里数据和成功率，认真斟酌</p>
<p>【题目】 一亩三分地是谁创立的？<br>✓ Warald<br>俞敏洪<br>李大辉<br>徐小平</p>
<p>【题目】 下面几个州，哪个离美国首都最远？<br>Maryland<br>Delaware<br>✓ North Carolina<br>Virginia</p>
<p>【题目】 地里数据科学类职位面经放在在什么版最合理？<br>数据科学版<br>美国面经版数据科学分类<br>✓ 数科面经版<br>找工求职版</p>
<p>【题目】 下面哪个公司总部在圣地亚哥？<br>✓ Qualcomm<br>AMD<br>Nvidia<br>Netflix</p>
<p>【题目】 下面哪种情况，管理员会按照你的要求，进行删帖？<br>问了问题，得到了答案，然后我过河拆桥，删帖让其他人看不到<br>发帖赚到了积分，看到了有权限设置的内容，然后反悔<br>尽管地里不允许，但是我到处留微信号，然后说隐私暴露要求删帖<br>✓ 这些情况全都不删帖！</p>
<p>【题目】 Miami University 在哪个城市<br>Miami, Florida<br>Las Vegas, Nevada<br>✓ Oxford, Ohio<br>Los Angeles, California</p>
<p>【题目】 想找室友或者当房东，帖子发在哪里？<br>✓ 租房广告|找室友版<br>房地产版<br>生活版<br>面经版</p>
<p>【题目】 在论坛发 slack 群，qq 群，微信群，任何站外讨论方式，会如何？<br>如果发在求职面经大区，申请大区，都会被删帖扣分<br>举报这些群，可能得到加分奖励<br>✓ 以上都正确<br>如果发在版聚，或者本地版块，是允许的</p>
<p>【题目】 下面哪类版块，可以拉群，而且不会被警告扣分？<br>录取结果汇报<br>求职、面经<br>内推<br>✓ 学友工友、找室友或者版聚本地</p>
<p>【题目】下面哪个说法错误？<br>雪城大学尽管在纽约州，但是离纽约城很远！<br>✓ 中国驻纽约领事馆位于法拉盛中国城，周围全是好吃的！<br>哥伦比亚大学离纽约中央公园很近<br>纽约州立大学石溪分校学费很便宜</p>
<p>【题目】 下面哪个学术会议不是机器学习领域的？<br>CVPR<br>ICML<br>SIGKDD<br>✓ ICSE</p>
<p>【题目】 下面哪个童话故事不是安徒生写的<br>✓ 尼尔斯骑鹅旅行记<br>冰雪女王<br>卖火柴的小女孩<br>国王的新装</p>
<p>【题目】 下面哪个作家是英国人？<br>✓Charles Dickens<br>Ernest Hemingway<br>Victor Hugo<br>Alexander Pushkin</p>
<p>【题目】 income tax on wages<br>✓North Dakota<br>South Dakota<br>Wyoming<br>Teness…</p>
<p>【题目】 下面哪个machine learning 的模型不是supervised<br>Logistic regression<br>✓Clustering<br>SVM<br>Decision Tree</p>
<p>【题目】 Apollo 11是哪一年登月的？<br>1969</p>
<p>【题目】 下面哪个公司的streaming service不是会员subscription付费模式运营的？<br>✓tubi</p>
<p>【题目】 著名篮球运动员姚明效力的NBA球队是休斯敦火箭队。取名“ 火箭队”是因为休斯敦是美国著名的?<br>钢城<br>汽车城<br>✓ 宇航工业城<br>电影城</p>
<p>【题目】 音乐家贝多芬出生于哪国？<br>✓ 德国<br>法国<br>意大利<br>英国</p>
<p>【题目】 下面哪个Ivy League，离东海岸最远？<br>Brown<br>Dartmouth<br>Princeton<br>✓ Cornell</p>
<p>【题目】 美国哪个州没有夏令时？<br>南达科他州<br>爱荷华州<br>✓亚利桑那州<br>阿肯色州</p>
<p>【题目】 下面哪部作品是喜剧？<br>麦克白<br>李尔王<br>✓仲夏夜之梦<br>哈姆雷特</p>
<p>【题目】 下面哪个公司总部不在湾区？<br>google<br>✓snapchat<br>facebook<br>Apple</p>
<p>【题目】 下面哪所纽约高校坐落于中央公园附近？<br>Fordham University<br>New York University<br>New York Institute of Technology<br>✓Columbia University</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向对象编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-29 14:05:42 / Modified: 14:06:46" itemprop="dateCreated datePublished" datetime="2020-02-29T14:05:42-06:00">2020-02-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于状态和数据的处理，我们有必要提一下“面向对象编程”（Object-oriented programming，缩写为 OOP）这个编程范式了。我们知道，<strong>面向对象的编程有三大特性：封装、继承和多态</strong>。</p>
<p>面向对象编程是种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。</p>
<p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。</p>
<p>目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。</p>
<p>现在，几乎所有的主流语言都支持面向对象，比如：Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP 等。</p>
<p>说起面向对象，就不得不提由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合作出版的《<a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">设计模式：可复用面向对象软件的基础</a>》（Design Patterns - Elements of Reusable Object-Oriented Software）一书，在此书中共收录了 23 种设计模式。</p>
<p>这本书的 23 个经典的设计模式，基本上就是说了两个面向对象的核心理念。</p>
<ul>
<li>“Program to an ‘interface’, not an ‘implementation’.”<ul>
<li>使用者不需要知道数据类型、结构、算法的细节。</li>
<li>使用者不需要知道实现细节，只需要知道提供的接口。</li>
<li>利于抽象、封装、动态绑定、多态。</li>
<li>符合面向对象的特质和理念。</li>
</ul>
</li>
<li>“Favor ‘object composition’ over ‘class inheritance’.”<ul>
<li>继承需要给子类暴露一些父类的设计和实现细节。</li>
<li>父类实现的改变会造成子类也需要改变。</li>
<li>我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。</li>
<li>继承更多的应该是为了多态。</li>
</ul>
</li>
</ul>
<h1 id="示例一：拼装对象"><a href="#示例一：拼装对象" class="headerlink" title="示例一：拼装对象"></a>示例一：拼装对象</h1><p>好，我们先来看一个示例，假设我们有如下的描述：</p>
<ul>
<li><strong>四个物体</strong>：木头桌子、木头椅子、塑料桌子、塑料椅子</li>
<li><strong>四个属性</strong>：燃点、密度、价格、重量</li>
</ul>
<p>那么，我们怎么用面向对象的方式来设计我们的类呢？</p>
<p>参看下图：</p>
<p><img src="../images/21f0377bc34b52e5c007a3f7c76054b7.png" alt="img"></p>
<ul>
<li>图的左边是“材质类” Material。其属性有燃点和密度。</li>
<li>图的右边是“家具类” Furniture。其属性有价格和体积。</li>
<li>在 Furniture 中耦合了 Material。而具体的 Material 是 Wood 还是 Plastic，这是在构造对象的时候注入到 Furniture 里就好了。</li>
<li>这样，在家具类中，通过材料的密度属性和家具的体积属性就可以计算出重量属性。</li>
</ul>
<p>这样设计的优点显而易见，它能和现实世界相对应起来。而且，材料类是可以重用的。这个模式也表现了面向对象的拼装数据的另一个精髓——喜欢组合，而不是继承。这个模式在设计模式里叫“桥接模式”。</p>
<p>和函数式编程来比较，函数式强调于动词，而面向对象强调于名词，面向对象更多的关注于接口间的关系，而通过多态来适配不同的具体实现。</p>
<h1 id="示例二：拼装功能"><a href="#示例二：拼装功能" class="headerlink" title="示例二：拼装功能"></a>示例二：拼装功能</h1><p>再来看一个示例。我们的需求是这样的——处理订单，处理订单有一个关键的动作就是计算订单的价格。有的订单需要打折，有的则不打折。</p>
<p>在进行面向对象编程时，假设我们用 Java 语言，我们需要先写一个接口—— <code>BillingStrategy</code>，其中就是一个方法：<code>GetActPrice(double rawPrice)</code>，输入一个原始的价格，输出一个根据相应的策略计算出来的价格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface BillingStrategy &#123;</span><br><span class="line">    public double GetActPrice(double rawPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口很简单，只是对接口的抽象，而与实现无关。现在我们需要对这个接口进行实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Normal billing strategy (unchanged price)</span><br><span class="line">class NormalStrategy implements BillingStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double GetActPrice(double rawPrice) &#123;</span><br><span class="line">        return rawPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Strategy for Happy hour (50% discount)</span><br><span class="line">class HappyHourStrategy implements BillingStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double GetActPrice(double rawPrice) &#123;</span><br><span class="line">        return rawPrice * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了两个策略，一个是不打折的：<code>NormalStrategy</code>，一个是打了 5 折的：<code>HappyHourStrategy</code>。</p>
<p>于是，我们先封装订单项 <code>OrderItem</code>，其包含了每个商品的原始价格和数量，以及计算价格的策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class OrderItem &#123;</span><br><span class="line">    public String Name;</span><br><span class="line">    public double Price;</span><br><span class="line">    public int Quantity;</span><br><span class="line">    public BillingStrategy Strategy;</span><br><span class="line">    public OrderItem(String name, double price, int quantity, BillingStrategy strategy) &#123;</span><br><span class="line">        this.Name &#x3D; name;</span><br><span class="line">        this.Price &#x3D; price;</span><br><span class="line">        this.Quantity &#x3D; quantity;</span><br><span class="line">        this.Strategy &#x3D; strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在我们的订单类—— <code>Order</code> 中封装了 <code>OrderItem</code> 的列表，即商品列表。并在操作订单添加购买商品时，加入一个计算价格的 <code>BillingStrategy</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Order &#123;</span><br><span class="line">    private List&lt;OrderItem&gt; orderItems &#x3D; new ArrayList&lt;OrderItem&gt;();</span><br><span class="line">    private BillingStrategy strategy &#x3D; new NormalStrategy();</span><br><span class="line"> </span><br><span class="line">    public void Add(String name, double price, int quantity, BillingStrategy strategy) &#123;</span><br><span class="line">        orderItems.add(new OrderItem(name, price, quantity, strategy));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Payment of bill</span><br><span class="line">    public void PayBill() &#123;</span><br><span class="line">        double sum &#x3D; 0;</span><br><span class="line">        for (OrderItem item : orderItems) &#123;</span><br><span class="line">            </span><br><span class="line">            actPrice &#x3D; item.Strategy.GetActPrice(item.price * item.quantity);</span><br><span class="line">            sum +&#x3D; actPrice;</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;%s -- %f(%d) - %f&quot;, </span><br><span class="line">            		item.name, item.price, item.quantity, actPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Total due: &quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，我们在 <code>PayBill()</code> 函数中，把整个订单的价格明细和总价打印出来。</p>
<p>在上面这个示例中，可以看到，我把订价策略和订单处理的流程分开了。这么做的好处是，我们可以随时给不同的商品注入不同的价格计算策略，这样一来就有很高的灵活度了。剩下的事就交给我们的运营人员来配置不同的商品使用什么样的价格计算的策略了。</p>
<p>注意，现实社会中，订单价格计算会比这个事复杂得多，比如：有会员价，有打折卡，还有商品的打包价等，而且还可以叠加不同的策略（叠加策略用前面说的函数式的 pipeline 或 decorator 就可以实现）。我们这里只是为了说明面向对象编程范式，所以故意简单化了。</p>
<p>其实，这个设计模式叫——策略模式。我认为，这是设计模式中最为经典的模式了，其充分体现了面向对象编程的方式。</p>
<h1 id="示例三：资源管理"><a href="#示例三：资源管理" class="headerlink" title="示例三：资源管理"></a>示例三：资源管理</h1><p>先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line"> </span><br><span class="line">void foo() &#123;</span><br><span class="line">    m.lock();</span><br><span class="line">    Func();</span><br><span class="line">    if ( ! everythingOk() ) return; </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    m.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，上面这段代码是有问题的，原因是，那个 <code>if</code> 语句返回时没有把锁给 unlock 掉，这会导致锁没有被释放。如果我们要把代码写对，需要在 return 前 unlock 一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line"> </span><br><span class="line">void foo() &#123;</span><br><span class="line">    m.lock();</span><br><span class="line">    Func();</span><br><span class="line">    if ( ! everythingOk() ) &#123;</span><br><span class="line">        m.unlock();</span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    m.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在所有的函数退出的地方都要加上 <code>m.unlock();</code> 语句，这会让我们很难维护代码。于是可以使用面向对象的编程模式，我们先设计一个代理类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class lock_guard &#123;</span><br><span class="line">	private: </span><br><span class="line">		mutex &amp;_m;</span><br><span class="line">	public:</span><br><span class="line">		lock_guard(mutex &amp;m):_m(m) &#123; _m.lock(); &#125;</span><br><span class="line">		~lock_guard() &#123; _m.unlock(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，我们的代码就可以这样写了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line"> </span><br><span class="line">void foo() &#123;</span><br><span class="line">	lock_guard guard(m);</span><br><span class="line">	Func();</span><br><span class="line">	if ( ! everythingOk() ) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个技术叫 RAII（Resource Acquisition Is Initialization）， 是 C++ 中的一个利用了面向对象的技术。这个设计模式叫“代理模式”。我们可以把一些控制资源分配和释放的逻辑交给这些代理类，然后，就只需要关注业务逻辑代码了。而且，在我们的业务逻辑代码中，减少了这些和业务逻辑不相关的程序控制的代码。</p>
<p>从上面的代码中，我们可以看到下面几个面向对象的事情。</p>
<ul>
<li>我们使用接口抽象了具体的实现类。</li>
<li>然后其它类耦合的是接口而不是实现类。这就是多态，其增加了程序的可扩展性。</li>
<li>因为这就是接口编程，所谓接口也就是一种“协议”，就像 HTTP 协议一样。浏览器和后端的程序都依赖于这一种协议，而不是具体实现（如果是依赖具体实现，那么浏览器就要依赖后端的编程语言或中间件了，这就太恶心了）。于是，浏览器和后端的程序就完全解开依赖关系，而去依赖于一个标准的协议。</li>
<li>这就是面向对象的编程范式的精髓！同样也是 IoC/DIP（控制反转 / 依赖倒置）的本质。</li>
</ul>
<h1 id="IoC-控制反转"><a href="#IoC-控制反转" class="headerlink" title="IoC 控制反转"></a>IoC 控制反转</h1><p>关于 IoC 的的概念提出来已经很多年了，其被用于一种面向对象的设计。我在这里再简单地回顾一下这个概念。我先谈技术，再说管理。</p>
<p>话说，我们有一个开关要控制一个灯的开和关这两个动作，最常见也是最没有技术含量的实现会是这个样子：</p>
<p><img src="../images/6095b6ad1e168cb3bd973bf41489b1ca.jpg" alt="img"></p>
<p>然后，有一天，我们发现需要对灯泡扩展一下，于是做了个抽象类：</p>
<p><img src="../images/9f8d0a147a15fe6c0273796bedce1dc3.jpg" alt="img"></p>
<p>但是，如果有一天，我们发现这个开关可能还要控制别的不单单是灯泡的东西，就会发现这个开关耦合了灯泡这种类别，非常不利于扩展，于是反转控制出现了。</p>
<p>就像现实世界一样，造开关的工厂根本不关心要控制的东西是什么，它只做一个开关应该做好的事，就是把电接通，把电断开（不管是手动的，还是声控的，还是光控，还是遥控的）。而我们造的各种各样的灯泡（不管是日光灯，白炽灯）的工厂也不关心你用什么样的开关，反正我只管把灯的电源接口给做出来。然后，开关厂和电灯厂依赖于一个标准的通电和断电的接口。于是产生了 IoC 控制反转，如下图。</p>
<p><img src="../images/4d1b95052b62dc82dc099302c8612613.jpg" alt="img"></p>
<p>所谓控制反转的意思是，开关从以前设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备。也就是说，开关从依赖设备这种情况，变成了，设备反过来依赖于开关所定义的接口。</p>
<p>这样的例子在生活中太多见了。比如说：</p>
<ul>
<li>钱就是一个很好的例子。以前大家都是“以物易物”，所以，在各种物品之前都需要相应的“交易策略”，比如：一头羊换 2 袋米，一袋米换一斤猪后腿肉……这种换算太复杂了。于是，“钱”就出来了，所谓“钱”，其实就是一种交易协议，所有的商品都依赖这个协议，而不用再互相依赖了。于是整个世界的运作就简单了很多。</li>
<li>在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。这就是反转控制。买卖双方把对对方的直接依赖和控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。</li>
<li>上面这个例子，可能还不明显，再举一个例子。海尔公司作为一个电器制商需要把自己的商品分销到全国各地，但是发现，不同的分销渠道有不同的玩法，于是派出了各种销售代表玩不同的玩法。随着渠道越来越多，发现，每增加一个渠道就要新增一批人和一个新的流程，严重耦合并依赖各渠道商的玩法。</li>
</ul>
<p>实在受不了了，于是制定业务标准，开发分销信息化系统，只有符合这个标准的渠道商才能成为海尔的分销商。让各个渠道商反过来依赖自己标准。反转了控制，倒置了依赖。</p>
<p>这个思维方式其实还深远地影响了很多东西，比如我们的系统架构。</p>
<ul>
<li>云计算平台中有很多的云产品线。一些底层服务的开发团队只管开发底层的技术，然后什么也不管了，就交给上层的开发人员。上层开发人员在底层团队开发出来的产品上面开发各种管理这个底层资源的东西，比如：生产底层资源的业务，底层资源的控制台，底层资源的监控系统。</li>
</ul>
<p>然而，随着接入的资源的越来越多，上层为各个云资源控制生产，开发控制台和监控的团队，完全干不过来了。这个时候依赖倒置和反转控制又可以解决问题了。为了有统一一致的云产品体验，各个云产品线需要遵从一定的协议或规范来开发。比如，每个云产品团队需要按照标准定义相关资源的生命周期管理，提供控制台，接入整体监控系统，通过标准的协议开发控制系统。</p>
<ul>
<li>集中式处理电子商务订单的流程。各个垂直业务线都需要通过这个平台来处理自己的交易业务，但是垂直业务线上的个性化需求太多。于是，这个技术平台开始发现，对来自各个业务方的需求应接不暇，各种变态需求严重干扰系统，各种技术决策越来越不好做，导致需求排期排不过来。</li>
</ul>
<p>这个时候，也可以使用依赖倒置和反转控制的思想来解决问题：开发一个插件模型、工作流引擎和 Pub/Sub 系统，让业务方的个性化需求可以以插件的方式插入订单流程中。业务方自己的数据存在自己的库中，业务逻辑也不要侵入系统，并可以使用工作流引擎或 Pub/Sub 的协议标准来自己定义工作流的各个步骤（甚至把工作流引擎的各个步骤的 decider 交给各个业务方自行处理）。</p>
<p>让各个业务方来依赖于标准插件和工作流接口，反转控制，让它们来控制系统，依赖倒置，让它们来依赖标准。</p>
<p>上面这些我想说什么？我想说的是：</p>
<ul>
<li>我们每天都在标准化和定制化中纠结。我们痛苦于哪些应该是平台要做的，哪些应该要甩出去的。</li>
<li>这里面会出现大量的与业务无关的软件或中间件，包括协议、数据、接口……</li>
<li>通过面向对象的这些方式，我们可以通过抽象来解耦，通过中间件来解耦，这样可以降低软件的复杂度。</li>
</ul>
<p>总而言之，我们就是想通过一种标准来让业务更为规范。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>不过，我们也需要知道面向对象的优缺点。</p>
<ul>
<li><strong>优点</strong><ul>
<li>能和真实的世界交相辉映，符合人的直觉。</li>
<li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。</li>
<li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。</li>
<li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。</li>
<li>拥有大量非常优秀的设计原则和设计模式。</li>
<li>S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。</li>
<li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li>
<li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。</li>
</ul>
</li>
</ul>
<p>还是好多人并不是喜欢面向对象，尤其是喜欢函数式和泛型那些人，似乎都是非常讨厌面向对象的。</p>
<p>通过对象来达到抽象结果，把代码分散在不同的类里面，然后，要让它们执行起来，就需要把这些类粘合起来。所以，它另外一方面鼓励相当厚重的代码黏合层（代码黏合层就是把代码黏合到这里面）。</p>
<p>在 Java 里有很多注入方式，像 Spring 那些注入，鼓励黏合，导致了大量的封装，完全不知道里面在干什么事情。而且封装屏蔽了细节，具体发生啥事你还不知道。这些都是面向对象不太好的地方。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/28/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/28/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">边缘计算</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-28 15:42:08 / Modified: 15:44:10" itemprop="dateCreated datePublished" datetime="2020-02-28T15:42:08-06:00">2020-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先，一说起边缘计算，网上大多数文章都会说这是和 IoT 相关的一个技术。其实，这个说法只说对了边缘计算的一部分，边缘计算可以做的事情还有很多很多。</p>
<p>所谓边缘计算，它是相对于数据中心而言。数据中心喜欢把所有的服务放在一个机房里集中处理用户的数据和请求，集中式部署一方面便于管理和运维，另一方面也便于服务间的通讯有一个比较好的网络保障。的确没错。不过，我们依然需要像 CDN 这样的边缘式的内容发布网络，把我们的静态内容推到离用户最近的地方，然后获得更好的性能。</p>
<p>如果我们让 CDN 的这些边缘结点拥有可定制的计算能力，那么就可以像秒杀那样，可以在边缘结点上处理很多事情，从而为我们的数据中心带来更好的性能，更好的扩展性，还有更好的稳定性。而我们的用户也会觉得响应飞快，从而有了更好的用户体验。</p>
<p>下面，让我们来看看为什么边缘计算会变成一个必然的产物。</p>
<h1 id="为什么要有边缘计算"><a href="#为什么要有边缘计算" class="headerlink" title="为什么要有边缘计算"></a>为什么要有边缘计算</h1><h2 id="从趋势上来说"><a href="#从趋势上来说" class="headerlink" title="从趋势上来说"></a>从趋势上来说</h2><p>首先，我们得看一下整个时代是怎么发展的。我们处在信息化革命时代，也有人叫数字化革命，总之就是电脑时代。这个时代，把各式各样的信息都给数字化掉，然后交给计算机来处理。所以，我们要清楚地知道，<strong>整个计算机发展的本质就是我们人类生活信息化建设的过程</strong>。</p>
<p>这个过程中，计算机硬件的发展也是非常迅猛的。CPU 的处理速度，硬盘的大小和速度，网络的带宽和速度都在拼命地升级和降价。我们用越来越低的成本，获得越来越快的速度、越来越大的带宽、越来越快的存储……</p>
<p>所有的这一切，其实都是和信息还有数据有关。我们的信息和数据越来越多，越来越大，所以，我们需要更好、更快、更便宜的硬件和基础设施。这个演化过程中，在我参加工作这 20 年来就没有停止过，而且，我也不认为未来会停下来，这个过程只会越来越加剧。</p>
<p>下面是一个时代的变更图（不用太纠结其中的时间点，我只是想表示信息演进的过程）</p>
<p><img src="../images/3257b6428ef87f7a663bd3677bb49ddb.png" alt="img"></p>
<p>从一开始，我们处在 MB 时代，那个时候，电脑也是几百兆的硬盘就够了。因为那个时候的信息量不够大，只有内容服务提供商在提供内容，他们主要以新闻资讯为主，所以数据还不多。</p>
<p>然后，开始进入 UGC 时代，用户开始产生数据，他们写博客，发贴子，拍照片，拍视频……于是，信息越来越多，于是我们的数据进入了 GB 时代，于是计算机的硬件，网络的基础设施都在升级。</p>
<p>再然后，我们进入了大数据时代，这个时代也是移动互联网的时代。以前你要打开电脑才能上网，现在你只要手机有电，你就是在线的，而且这个时代，大量的线下服务走到线上，比如外卖、叫车……于是，有各种各样的 App 在收集你的行为和数据。这个时候，是计算机在记录每个人的上网行为的时候，所以，数据量也不是一般的大。</p>
<p>然后，这个趋势只会越来越大，下一个时间，我们的数据和信息只会越来越大，因为计算机正在吞噬可以被数字化的一切事情。除了继续吞噬线上的业务，一定会开始吞噬线下的信息和数据。比如，通过摄像头识别线下的各种活动，如车牌；通过一些传感器来收集线下的各种数据，如农业、水利……于是，数据只会变得越来越大。</p>
<p>这个时候，我们想一想，如果把这么大量的数据都拿到数据中心来做分析和计算，一个数据中心顶得住吗？我现在已经接到好几个用户和我说，数据量太大了，不知道怎么架构数据中心了，各种慢，各种贵，各种痛苦……</p>
<p>而且，还有另外一个需求就是要实时，对于大数据处理的实时需求越来越成为刚需了，因为，如果不能实时处理、实时响应，那么怎么能跟得上这个快速的时代呢。这就好像一个人脸识别的功能。如果苹果手机的人脸识别需要到服务器上算，然后把结果返回，那么用户的体验就很糟糕了。这就是为什么苹果在手机里直接植入了神经网络的芯片。</p>
<p><strong>我们可以看到，数量越来越大，分析结果的速度需要越来越快，这两个需求，只会把我们逼到边缘计算上去。</strong>如果你还是在数据中心处理，你会发现你的成本只会越来越高，到一时候就完全玩不下去了。</p>
<h2 id="从成本上来说"><a href="#从成本上来说" class="headerlink" title="从成本上来说"></a>从成本上来说</h2><p>上面这个是第一个示例，我们再来看看数据中心的成本，当一个公司需要支持几十万用户时候，并没有什么感觉。当他们要支撑上千万乃至上亿的用户的时候，我们就会发现，一个几十万用户的系统架构和一个支撑上千万用户的架构，在成本上来说，完全不是一个数量级的。就像文本中的图所画的一样（只是一个草图，用于说明问题）。</p>
<p><img src="../images/f5337ffab2d65ae5fc114ba21da82de7.png" alt="img"></p>
<p>在这个图中，我们可以看到，当需要处理的数据或是用户请求的规模越来越大时，我们的成本是呈现快速上升的曲线，而不是一个线性上升的成本关系。</p>
<p>我们可以来算一下，根据我过去服务过的 40 多家公司的经验，可以看到如下的投入：</p>
<ul>
<li>几十万用户的公司，只需要处理百级 QPS 的量，只需要 10 台左右的服务器；</li>
<li>上百万用户的公司，只需要处理千级 QPS 的量，需要有 50 台左右的服务器；</li>
<li>上千万用户的公司，需要处理万级到十万级 QPS 的量，需要 700 台左右的服务器；</li>
<li>上亿用户的公司，其需要处理百万级 QPS 的量，需要上万台的服务器。</li>
</ul>
<p>可以看到，十万用户到上亿用户，也就多了 100 倍，为什么服务器需要 1000 倍？完全不是呈线性的关系。</p>
<p>这时因为，当架构变复杂了后，你就要做很多非功能的东西了，比如，缓存、队列、服务发现、网关、自动化运维、监控等。</p>
<p>那么，我们不妨开个脑洞。如果我们能够把那上亿的用户拆成 100 个百万级的用户，那么只需要 5000 多台机器（100 个 50 台服务器的数据中心）。</p>
<p>我们还是同样服务了这么多的用户，但我们的成本下降得很快。只不过，我们需要运维 100 个小数据中心。不过，运维 100 个 50 台服务器的小数据中心的难度应该远远低于运维一个 10000 台服务器的数据中心。</p>
<p>好了，问题来了，什么样的业务可以这么做？我觉得有地域性的业务是可以这么做的，比如：外卖、叫车、共享单车之类的。</p>
<p>然而，100 个 50 台服务器的小数据中心也会带来一些复杂的问题，因为当你的公司有 100 万用户的时候的业务形态和有 1 亿用户的业务形态是完全不一样的，1 亿用户的业务形态可能会复杂得多得多。也就是说，我们不可能在一个小数据中心只有 50 台服务器，因为那是百万用户的业务形态，只有几十个服务。当公司成长到上亿用户的规模时，可能会有上百个服务，50 台服务器是不够部署的。</p>
<p>所以，我上面那种多个数据中心的理想只存在于理论上，而实际上不会发生。</p>
<p>但是，我们依然可以沿着这条路思考下去。我们不难发现，我们完全可以用边缘结点处理高峰流量，这样，我们的数据中心就不需要花那么大的成本来建设了。</p>
<p>于是，还是到了边缘计算。</p>
<h1 id="边缘计算的业务场景"><a href="#边缘计算的业务场景" class="headerlink" title="边缘计算的业务场景"></a>边缘计算的业务场景</h1><p>通过上面的两个案例分析，我觉得边缘计算一定会成为一个必然产物，其会作为以数据中心为主的云计算的一个非常好的补充。这个补充在我看来，其主要是做下面一些事情。</p>
<ul>
<li>处理一些实时响应的业务。它和用户靠得很近，所以其可以实时响应用户的一些本地请求，比如，某公司的人脸门禁系统、共享单车的开锁。</li>
<li>处理一些简单的业务逻辑。比如像秒杀、抢红包这样的业务场景。</li>
<li>收集并结构化数据。比如，把视频中的车牌信息抠出来，转成文字，传回数据中心。</li>
<li>实时设备监控。主要是线下设备的数据采集和监控。</li>
<li>P2P 的一些去中心化的应用。比如：边缘结点作为一个服务发现的服务器，可以让本地设备之间进行 P2P 通讯。</li>
<li>云资源调度。边缘结点非常适合用来做云端服务的调度。比如，允许用户使用不同生产商的云存储服务，使用不同生产商但是功能相同的 API 服务（比如支付 API 相关）。因为是流量接入方，所以可以调度流量。</li>
<li>云资源聚合。比如，我们可以把语音转文字的 API 和语义识别的 API 相结合，聚合出来一个识别语音语义的 API，从而简化开发人员的开发成本。</li>
<li>……</li>
</ul>
<p>其实还有很多，我觉得边缘计算带来的想象力还是很令人激动的。</p>
<p>关于现实当中的一些案例，你可以看看 <a href="https://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146" target="_blank" rel="noopener">Netflix 的全球边缘架构的 PPT</a>。</p>
<h1 id="边缘计算的关键技术"><a href="#边缘计算的关键技术" class="headerlink" title="边缘计算的关键技术"></a>边缘计算的关键技术</h1><p>在我看来，边缘计算的关键技术如下。</p>
<ul>
<li>API Gateway。关于网关，这个就不说了，我们在管理设计篇中有一篇就是专门讨论这个东西的。</li>
<li>Serverless/FaaS。就是服务函数化，这个技术就像是 AWS Lambda 服务一样，你写好一个函数，然后不用关心这个函数运行在哪里，直接发布就好了。然后就可以用了。</li>
</ul>
<p>Serverless 这个词第一次被使用大约是 2012 年由 Ken Form 所写的一篇名为《Why The Future of Software and Apps is Serverless》的文章。这篇文章谈到的内容是关于持续集成及源代码控制等，并不是我们今天所特指的这一种架构模式。</p>
<p>但 Amazon 在 2014 年发布的 AWS Lambda 让 “Serverless” 这一范式提高到一个全新的层面，为云中运行的应用程序提供了一种全新的系统体系结构。至此再也不需要在服务器上持续运行进程以等待 HTTP 请求或 API 调用，而是可以通过某种事件机制触发代码的执行。</p>
<p>通常，这只需要在 AWS 的某台服务器上配置一个简单的功能。此后 Ant Stanley 在 2015 年 7 月的名为《Server are Dead…》的文章中更是围绕着 AWS Lambda 及刚刚发布的 AWS API Gateway 这两个服务解释了他心目中的 Serverless，“Server are dead…they just don’t know it yet”。</p>
<p>如果说微服务是以专注于单一责任与功能的小型功能块为基础，利用模块化的方式组合出复杂的大型应用程序，那么我们还可以进一步认为 Serverless 架构可以提供一种更加 “ 代码碎片化 “ 的软件架构范式，我们称之为 Function as a Services（FaaS）。所谓的 “ 函数 “（Function）提供的是相比微服务更加细小的程序单元。</p>
<p>目前比较流行的几个开源项目是：</p>
<ul>
<li><a href="https://github.com/serverless/serverless" target="_blank" rel="noopener">Serverless Framework</a></li>
<li><a href="https://github.com/fission/fission" target="_blank" rel="noopener">Fission: Serverless Functions for Kubernetes</a></li>
<li><a href="https://github.com/open-lambda/open-lambda" target="_blank" rel="noopener">Open Lambda</a></li>
<li><a href="https://github.com/openfaas/faas" target="_blank" rel="noopener">Open FaaS</a></li>
<li><a href="https://github.com/iron-io/functions" target="_blank" rel="noopener">IronFunction</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%B1%95/" class="post-title-link" itemprop="url">数据库扩展</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-27 20:23:17 / Modified: 20:24:10" itemprop="dateCreated datePublished" datetime="2020-02-27T20:23:17-06:00">2020-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="读写分离-CQRS"><a href="#读写分离-CQRS" class="headerlink" title="读写分离 CQRS"></a>读写分离 CQRS</h1><p>读写分离是数据库扩展最简单实用的玩法了，这种方法针对读多写少的业务场景还是很管用的，而且还可以有效地把业务做相应的隔离。</p>
<p>如下图所示，数据库只有一个写库，有两个读库，所有的服务都写一个数据库。对于读操作来说，服务 A 和服务 B 走从库 A，服务 D 和服务 E 走从库 B，服务 C 在从库 A 和从库 B 间做轮询。</p>
<p><img src="../images/77892f8385a4fa21e97ca41075780b71.png" alt="img"></p>
<p>这样的方法好处是：</p>
<ul>
<li>比较容易实现。数据库的 master-slave 的配置和服务框架里的读写分离都比较成熟，应用起来也很快。</li>
<li>可以很好地把各个业务隔离开来。不会因为一个业务把数据库拖死而导致所有的业务都死掉。</li>
<li>可以很好地分担数据库的读负载，毕竟读操作是最耗数据库 CPU 的操作。</li>
</ul>
<p>这样的方法不好的地方是：</p>
<ul>
<li>写库有单点故障问题。如果是写库出了性能问题，那么所有的业务一样不可用。对于交易型的业务，要得到高的写操作速度，这样的方式不行。</li>
<li>数据库同步不实时，需要强一致性的读写操作还是需要落在写库上。</li>
</ul>
<p>综上所述，一般来说，这样的玩法主要是为了减少读操作的压力。</p>
<p>当然，这样的读写分离看上去有点矬，那么，我们还是为之找一个更靠谱的设计——CQRS。关于 CQRS，我在这里只做一个简单的介绍，更多的细节你可以上网自行 Google。</p>
<p>CQRS 全称 Command and Query Responsibility Segregation，也就是命令与查询职责分离。其原理是，用户对于一个应用的操作可以分成两种，一种是 Command 也就是我们的写操作（增，删，改），另一种是 Query 操作（查），也就是读操作。Query 操作基本上是在做数据整合显现，而 Command 操作这边会有更重的业务逻辑。分离开这两种操作可以在语义上做好区分。</p>
<ul>
<li>命令 Command 不会返回结果数据，只会返回执行状态，但会改变数据。</li>
<li>查询 Query 会返回结果数据，但是不会改变数据，对系统没有副作用。</li>
</ul>
<p>这样一来，可以带来一些好处。</p>
<ul>
<li>分工明确，可以负责不同的部分。</li>
<li>将业务上的命令和查询的职责分离，能够提高系统的性能、可扩展性和安全性。并且在系统的演化中能够保持高度的灵活性，能够防止出现 CRUD 模式中，对查询或者修改中的某一方进行改动，导致另一方出现问题的情况。</li>
<li>逻辑清晰，能够看到系统中的哪些行为或者操作导致了系统的状态变化。</li>
<li>可以从数据驱动（Data-Driven）转到任务驱动（Task-Driven）以及事件驱动。</li>
</ul>
<p>如果把 Command 操作变成 Event Sourcing，那么只需要记录不可修改的事件，并通过回溯事件得到数据的状态。于是，我们可以把写操作给完全简化掉，也变成无状态的，这样可以大幅度降低整个系统的副作用，并可以得到更大的并发和性能。</p>
<p>文本中有 Event Sourcing 和 CQRS 的架构示意图。</p>
<p><img src="../images/ceeb536d0fa15afa4f5fde0b2cbe7787.png" alt="img"></p>
<p>图片来源 - <a href="https://www.slideshare.net/planetcassandra/codecentric-ag-cqrs-and-event-sourcing-applications-with-cassandra" target="_blank" rel="noopener">CQRS and Event Sourcing Application with Cassandra</a></p>
<h1 id="分库分表-Sharding"><a href="#分库分表-Sharding" class="headerlink" title="分库分表 Sharding"></a>分库分表 Sharding</h1><p>一般来说，影响数据库最大的性能问题有两个，一个是对数据库的操作，一个是数据库中数据的大小。</p>
<p>对于前者，我们需要从业务上来优化。一方面，简化业务，不要在数据库上做太多的关联查询，而对于一些更为复杂的用于做报表或是搜索的数据库操作，应该把其移到更适合的地方。比如，用 ElasticSearch 来做查询，用 Hadoop 或别的数据分析软件来做报表分析。</p>
<p>对于后者，如果数据库里的数据越来越多，那么也会影响我们的数据操作。而且，对于我们的分布式系统来说，后端服务都可以做成分布式的，而数据库最好也是可以拆开成分布式的。读写分离也因为数据库里的数据太多而变慢，于是，分库分表就成了我们必须用的手段。</p>
<p><img src="../images/8ab721d3d6512a7f607fe393f6550f64.png" alt="img"></p>
<p>上面的图片是一个分库的示例。其中有两个事，这里需要提一下，一个是关于分库的策略，一个是关于数据访问层的中间件。</p>
<p><strong>关于分库的策略</strong>。我们把数据库按某种规则分成了三个库。比如，或是按地理位置，或是按日期，或是按某个范围分，或是按一种哈希散列算法。总之，我们把数据分到了三个库中。</p>
<p><strong>关于数据访问层</strong>。为了不让我们前面的服务感知到数据库的变化，我们需要引入一个叫 “ 数据访问层 “ 的中间件，用来做数据路由。但是，老实说，这个数据访问层的中间件很不好写，其中要有解析 SQL 语句的能力，还要根据解析好的 SQL 语句来做路由。但即便是这样，也有很多麻烦事。</p>
<p>比如，我要做一个分页功能，需要读一组顺序的数据，或是需要做 Max/Min/Count 这样的操作。于是，你要到三个库中分别求值，然后在数据访问层这里再合计处理返回。但即使是这样，你也会遇到各种令人烦恼的事，比如一个跨库的事务，你需要走 XA 这样的两阶段提交的操作，这样会把数据库的性能降到最低的。</p>
<p>为了避免数据访问层的麻烦，分片策略一般如下。</p>
<ul>
<li>按多租户的方式。用租户 ID 来分，这样可以把租户隔离开来。比如：一个电商平台的商家中心可以按商家的 ID 来分。</li>
<li>按数据的种类来分。比如，一个电商平台的商品库可以按类目来分，或是商家按地域来分。</li>
<li>通过范围来分。这样分片，可以保证在同一分片中的数据是连续的，于是我们数据库操作，比如分页查询会更高效一些。一般来说，大多数情况是用时间来分片的，比如，一个电商平台的订单中心是按月份来分表的，这样可以快速检索和统计一段连续的数据。</li>
<li>通过哈希散列算法来分（比如：主键 id % 3 之类的算法。）此策略的目的是降低形成热点的可能性（接收不成比例的负载的分片）。但是，这会带来两个问题，一个就是前面所说的跨库跨表的查询和事务问题，另一个就是如果要扩容需要重新哈希部分或全部数据。</li>
</ul>
<p>上面是最常见的分片模式，但是你还应考虑应用程序的业务要求及其数据使用模式。这里请注意几个非常关键的事宜。</p>
<ol>
<li>数据库分片必须考虑业务，从业务的角度入手，而不是从技术的角度入手，如果你不清楚业务，那么无法做出好的分片策略。</li>
<li>请只考虑业务分片。请不要走哈希散列的分片方式，除非有个人拿着把刀把你逼到墙角，你马上就有生命危险，你才能走哈希散列的分片方式。</li>
</ol>
<h1 id="数据库扩展的设计重点"><a href="#数据库扩展的设计重点" class="headerlink" title="数据库扩展的设计重点"></a>数据库扩展的设计重点</h1><p>先说明一下，这里没有讲真正数据库引擎的水平扩展的方法，我们只是在业务层上谈了一下数据扩展的两种方法。关于数据库引擎的水平扩展，你可能看一下我之前发过的《分布式数据调度的相关论文》一文中的 AWS Aurora 和 Google Spanner 的相关论文中提到的那些方法。</p>
<p>接下来，我们说一下从业务层上把单体的数据库给拆解掉的相关重点。</p>
<p>首先，你需要把数据库和应用服务一同拆开。也就是说，一个服务一个库，这就是微服务的玩法，也是 Amazon 的服务化的玩法——服务之间只能通过服务接口通讯，不能通过访问对方的数据库。在 Amazon 内，每个服务都会有一个自己的数据库，比如地址库、银行卡库等。这样一来，你的数据库就会被 “ 天生地 “ 给拆成服务化的，而不是一个单体的库。</p>
<p>我们要知道，在一个单体的库上做读写分离或是做分片都是一件治标不治本的事，真正治本的方法就是要和服务一起拆解。</p>
<p>当数据库也服务化后，我们才会在这个小的服务数据库上进行读写分离或分片的方式来获得更多的性能和吞吐量。这是整个设计模式的原则——先做服务化拆分，再做分片。</p>
<p>对于分片来说，有两种分片模式，一种是水平分片，一种是垂直分片。水平分片就是我们之前说的那种分片。而垂直分片是把一张表中的一些字段放到一张表中，另一些字段放到另一张表中。垂直分片主要是把一些经常修改的数据和不经常修改的数据给分离开来，这样在修改某个字段的数据时，不会导致其它字段的数据被锁而影响性能。比如，对于电商系统来说，商品的描述信息不常改，但是商品的库存和价格经常改，所以，可以把描述信息和库存价格分成两张表，这样可以让商品的描述信息的查询更快。</p>
<p>我们所说的 sharding 更多的是说水平分片。水平分片需要有以下一些注意事项。</p>
<ul>
<li>随着数据库中数据的变化，我们有可能需要定期重新平衡分片，以保证均匀分布并降低形成热点的可能性。 但是，重新平衡是一项昂贵的操作。 若要减少重新平衡的频率，我们需要通过确保每个分片包含足够的可用空间来处理未来一段时间的变化。 另外，我们还需要开发用于快速重新平衡分片的工具和脚本。</li>
<li>分片是静态的，而数据的访问则是不可预期的，可能会需要经常性地调整我们的分片，这样一来成本太高。所以，我们最好使用一个索引表的方式来进行分片。也就是说，把我们数据的索引动态地记录在一个索引表中。这样一来，我们就可以非常灵活地调度我们的数据了。当数据调度到另一台结点上时，我们只需要去索引表里改一下这个数据的位置就好了。</li>
<li>如果程序必须要从多个分片检索数据的查询，则可以使用并行任务从各个分片上提取此数据，然后聚合到单个结果中。 但是，此方法不可避免地会在一定程度上增加解决方案数据访问逻辑的复杂性。</li>
<li>数据分片后，我们很难在分片之间保持引用完整性和一致性，也就是所谓的跨分片的事务，因此应尽量减少会影响多个分片中的数据的操作。如果应用程序必须跨分片修改数据，那么我们需要评估一致性以及评估是否采用两阶段提交的方式。</li>
<li>配置和管理大量分片可能是一个挑战。在做相应的变更时，一定要先从生产线上拉出数据，然后根据数据计划好新的分片方式，并做好相当的测试工作。否则，这个事出了问题会是一个灾难性的问题。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">异步处理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 12:40:10" itemprop="dateCreated datePublished" datetime="2020-02-26T12:40:10-06:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-27 12:41:21" itemprop="dateModified" datetime="2020-02-27T12:41:21-06:00">2020-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在弹力设计篇中我们讲过，异步通讯的设计模式有助于提高系统的稳定性和容错能力。其实，异步通讯在分布式系统中还可以增加整个系统的吞吐量，从而可以面对更高的并发，并可以更多地利用好现有的系统资源。为什么这么说呢？</p>
<p>我们试想一下，在你的工作中，有很多人会来找你，让你帮着做事。如果你是这种请求响应式的工作方式，那么本质上来说，你是在被动工作，也就是被别人驱动的工作方式。</p>
<p>当你在做一件事的时候，如果有别人来找你做其它事，你就会被打断而要去干别的事。另外，没办法把这些事统筹安排。如果可以统筹安排，本来五件事只需要 2 个小时，如果不能，你可能要做出 5 个小时来。异步处理任务可以让你更好地利用好时间和资源。利用好了时间和资源，性能自然就会提升上来。</p>
<p>这就好像邮递业务一样，你寄东西的时候，邮递公司会把大量的去往同一个方向的订单合并处理，并统一地调配物流交通工具，从而在整体上更为节省资源和时间。</p>
<p>在分布式架构中，我们的系统被拆成了很多的子系统。如果想把这堆系统合理地用好，并更快地处理大量的任务，我们就需要统一地规划和统筹整体，这样可以达到整体的最优。本质上，这和邮递公司处理邮件一样，是相同的道理。</p>
<p>在计算机的世界里，到处都是异步处理。比如：当程序读写文件时，我们的操作系统并不会真正同步地去操作硬盘，而是把硬盘读写请求先在内存中 hold 上一小会儿（几十毫秒），然后，对这些读写请求做 merge 和 sort。</p>
<p>也就是说，merge 是把相同的操作合并，相同的读操作只读一次，相同的写操作，只写最后一次，而 sort 是把不同的操作排个序，这样可以让硬盘向一个方向转一次就可以把所有的数据读出来，而不是来来回回地转。这样可以极大地提高硬盘的吞吐率。</p>
<p>再如，我们的 TCP 协议向网络发包的时候，会把我们要发的数据先在缓冲区中进行囤积，当囤积到一定尺寸时（MTU），才向网络发送，这样可以最大化利用我们的网络带宽。而传输速度和性能也会变得很快。</p>
<p><strong>这就是异步系统所带来的好处——让我们的系统可以统一调度。</strong></p>
<p>另外，我举上面这两个例子是想告诉你，我们可能会觉得异步通讯慢，其实并不然，我们同样也可以把异步做得比较实时。</p>
<p>多说一句，就算是有延时，异步处理在用户体验上也可以给用户带来一个不错的用户体验，那就是用户可以有机会反悔之前的操作。</p>
<h1 id="异步处理的设计"><a href="#异步处理的设计" class="headerlink" title="异步处理的设计"></a>异步处理的设计</h1><p>之前，我们在弹力设计中讲的是异步通讯，这里，我们想讲的是异步任务处理。当然，这里面没有什么冲突的，只不过是，异步通讯讲的是怎么把系统连接起来，而我们这里想讲的是怎么处理任务。</p>
<p>首先，我们需要一个前台系统，把用户发来的请求一一记录下来。这有点像请求日志。这样，我们的操作在数据库或是存储上只会有追加的操作，性能会很高。我们收到请求后，给客户端返回 “ 收到请求，正在处理中 “。</p>
<p>然后，我们有个任务处理系统来真正地处理收到的这些请求。为了解耦，我们需要一个任务派发器，这里就会出来两个事，一个是推模型 Push，一个是拉模型 Pull。</p>
<p>所谓 Push 推模型，就是把任务派发给相应的人去处理，有点像是一个工头的调度者的角色。而 Pull 拉模型，则是由处理的人来拉取任务处理。这两种模型各有各的好坏。一般来说，Push 模型可以做调度，但是它需要知道下游工作结点的情况。</p>
<p>除了要知道哪些是活着的，还要知道它们的忙闲程度。这样一来，当下游工作结点扩容缩容或是有故障需要维护等一些情况发生时，Push 结点都需要知道，这会增加一定的系统复杂度。而 Pull 的好处则是可以让上游结点不用关心下游结点的状态，只要自己忙得过来，就会来拿任务处理，这样可以减少一定的复杂度，但是少了整体任务调度。</p>
<p>一般来说，我们构建的都是推拉结合的系统，Push 端会做一定的任务调度，比如它可以像物流那样把相同商品的订单都合并起来，打成一个包，交给下游系统让其一次处理掉；也可以把同一个用户的订单中的不同商品给拆成多个订单。然后 Pull 端来订阅 Push 端发出来的异步消息，处理相应的任务。</p>
<h1 id="事件溯源"><a href="#事件溯源" class="headerlink" title="事件溯源"></a>事件溯源</h1><p>在这里，我们需要提一下 Event Sourcing（事件溯源）这个设计模式。</p>
<p>所谓 Event Sourcing，其主要想解决的问题是，我们可以看到数据库中的一个数据的值（状态），但我们完全不知道这个值是怎么得出来的。就像银行的存折一样，我们可以在银行的存折看到我们收支的所有记录，也能看得到每一笔记录后的余额。</p>
<p>当然，如果我们有了所有的收支流水账的记录，我们完全不需要保存余额，因为我们只需要回放一下所有的收支事件，就可以得到最终的数据状态。这样一来，我们的系统就会变得非常简单，只需要追加不可修改的数据操作事件，而不是保存最终状态。除了可以提高性能和响应时间之外，还可以提供事务数据一致性，并保留了可以启用补偿操作的完整记录和历史记录。</p>
<p>还有一个好处，就是如果我们的代码里有了 bug，在记录状态的系统里，我们修改 bug 后还需要做数据修正。然而，在 Event Sourcing 的系统里，我们只需要把所有事件重新播放一遍就好了，因为整个系统没有状态了。</p>
<p>事件不可变，并且可使用只追加操作进行存储。 用户界面、工作流或启动事件的进程可继续，处理事件的任务可在后台异步运行。 此外，处理事务期间不存在争用，这两点可极大提高应用程序的性能和可伸缩性。</p>
<p>事件是描述已发生操作的简单对象以及描述事件代表的操作所需的相关数据。 事件不会直接更新数据存储，只会对事件进行记录，以便在合适的时间进行处理。 这可简化实施和管理。</p>
<p>事件溯源不需要直接更新数据存储中的对象，因而有助于防止并发更新造成冲突。</p>
<p>最重要的是，异步处理 + 事件溯源的方式，可以很好地让我们的整个系统进行任务的统筹安排、批量处理，可以让整体处理过程达到性能和资源的最大化利用。</p>
<p>关于 Event Sourcing 一般会和 CQRS 一起提。另外，你可以去 GitHub 上看看<a href="https://github.com/cer/event-sourcing-examples" target="_blank" rel="noopener">这个项目的示例</a>以得到更多的信息。</p>
<h1 id="异步处理的分布式事务"><a href="#异步处理的分布式事务" class="headerlink" title="异步处理的分布式事务"></a>异步处理的分布式事务</h1><p>在前面的《分布式系统的本质》一文中，我们说过，对于分布式事务，在强一致性下，在业务层上只能做两阶段提交，而在数据层面上需要使用 Raft/Paxos 的算法。但是，我想说，在现实生活中，需要用到强一致性的场景实在不多，真是不是所有的场景都必须要强一致性的事务的。</p>
<p>我们仔细想想现实生活当中的很多例子。比如，我们去餐馆吃饭，先付钱，然后拿个小票去领吃的。这种情况下，把交钱和取货这两个动作分开，可以让我们的餐馆有更高的并发和接客能力。如果要做成两阶段提交，顾客锁定好钱，餐馆锁定好食材，最后一手交钱一手交饭，那么这是一件非常恐怖的事。</p>
<p>是的，你可以看到，我们的现实世界中有很多这样先付钱，拿小票去领货的场景，也有先消费，然后拿一个账单去付钱的场景。总之，完全不需要两阶段提交这种方式。我们完全可以使用异步的方式来达到一致性，当然，是最终一致性。</p>
<p>要达到最终一致性，我们需要有个交易凭证。也就是说，如果一个事务需要做 A 和 B 两件事，比如，把我的钱转给我的朋友，首先先做扣钱交易，然后，记录下扣钱的凭证，拿这个凭证去给我朋友的账号上加钱。</p>
<p>在达成这个事务的过程中，有几点需要注意。</p>
<ul>
<li>凭证需要非常好地保存起来，不然会导致事务做不下去。</li>
<li>凭证处理的幂等性问题，不然在重试时就会出现多次交易的情况。</li>
<li>如果事务完成不了，需要做补偿事务处理。</li>
</ul>
<h1 id="异步处理的设计要点"><a href="#异步处理的设计要点" class="headerlink" title="异步处理的设计要点"></a>异步处理的设计要点</h1><p>异步处理中的事件驱动和事件溯源是两个比较关键的技术。</p>
<p>异步处理可能会因为一些故障导致我们的一些任务没有被处理，比如消息丢失，没有通知到，或通知到了，没有处理。有这一系列的问题，异步通知的方式需要任务处理方处理完成后，给任务发起方回传状态，这样确保不会有漏掉的。</p>
<p>另外，发起方也需要有个定时任务，把一些超时没有回传状态的任务再重新做一遍，你可以认为这是异步系统中的 “ 对账 “ 功能。当然，如果要重做的话，就需要处理方支持幂等性处理。</p>
<p>异步处理的整体业务事务问题，也就是说，异步处理在处理任务的时候，并不知道能否处理成功，于是其会一步一步地处理，如果到最后一步不能成功，那么你就需要回滚。这个时候，需要走我们在弹力设计中说的补偿事务的流程。</p>
<p>并不是所有的业务都可以用异步的方式，比如一些需要强一致性的业务，使用异步的方式可能就不适合，这里需要我们小心地分析业务。我相信绝大多数的业务场景都用不到强一致性，包括银行业务。另外，在需要性能的时候，需要牺牲强一致性，变为最终一致性。</p>
<p>在运维时，我们要监控任务队列里的任务积压情况。如果有任务积压了，要能做到快速地扩容。如果不能扩容，而且任务积压太多，可能会导致整个系统挂掉，那么就要开始对前端流量进行限流。</p>
<p>最后，还想强调一下，异步处理系统的本质是把被动的任务处理变成主动的任务处理，其本质是在对任务进行调度和统筹管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">缓存</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-25 22:20:10 / Modified: 22:22:14" itemprop="dateCreated datePublished" datetime="2020-02-25T22:20:10-06:00">2020-02-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基本上来说，在分布式系统中最耗性能的地方就是最后端的数据库了。一般来说，只要小心维护好，数据库四种操作（select、update、insert 和 delete）中的三个写操作 insert、update 和 delete 不太会出现性能问题（insert 一般不会有性能问题，update 和 delete 一般会有主键，所以也不会太慢）。除非索引建得太多，而数据库里的数据又太多，这三个操作才会变慢。</p>
<p>绝大多数情况下，select 是出现性能问题最大的地方。一方面，select 会有很多像 join、group、order、like 等这样丰富的语义，而这些语义是非常耗性能的；另一方面，大多数应用都是读多写少，所以加剧了慢查询的问题。</p>
<p>分布式系统中远程调用也会耗很多性能，因为有网络开销，会导致整体的响应时间下降。为了挽救这样的性能开销，在业务允许的情况（不需要太实时的数据）下，使用缓存是非常必要的事情。</p>
<p>从另一个方面说，缓存在今天的移动互联网中是必不可少的一部分，因为网络质量不总是最好的，所以前端也会为所有的 API 加上缓存。不然，网络不通畅的时候，没有数据，前端都不知道怎么展示 UI 了。既然因为移动互联网的网络质量而导致我们必需容忍数据的不实时性，那么，从业务上来说，在大多数情况下是可以使用缓存的。</p>
<p>缓存是提高性能最好的方式，一般来说，缓存有以下三种模式。</p>
<h1 id="Cache-Aside-更新模式"><a href="#Cache-Aside-更新模式" class="headerlink" title="Cache Aside 更新模式"></a>Cache Aside 更新模式</h1><p>这是最常用的设计模式了，其具体逻辑如下。</p>
<ul>
<li><strong>失效</strong>：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中</strong>：应用程序从 cache 中取数据，取到后返回。</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><img src="../images/0a39fbce98c0d43e15b56b0ed09099d4.png" alt="img"></p>
<p><img src="../images/e0ecbc94d474f7bd0c8eb53dfd8bde94.png" alt="img"></p>
<p>这是标准的设计模式，包括 Facebook 的论文《<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">Scaling Memcache at Facebook</a>》中也使用了这个策略。为什么不是写完数据库后更新缓存？可以看一下 Quora 上的这个问答《<a href="https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend" target="_blank" rel="noopener">Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?</a>》，主要是怕两个并发的写操作导致脏数据。</p>
<p>那么，是不是这个 Cache Aside 就不会有并发问题了？不是的。比如，一个是读操作，但是没有命中缓存，就会到数据库中取数据。而此时来了一个写操作，写完数据库后，让缓存失效，然后之前的那个读操作再把老的数据放进去，所以会造成脏数据。</p>
<p>这个案例理论上会出现，但实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且有一个并发的写操作。实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，又要晚于写操作更新缓存，所有这些条件都具备的概率并不大。</p>
<p><strong>所以，这也就是 Quora 上的那个答案里说的，要么通过 2PC 或是 Paxos 协议保证一致性，要么就是拼命地降低并发时脏数据的概率。而 Facebook 使用了这个降低概率的玩法，因为 2PC 太慢，而 Paxos 太复杂。当然，最好还是为缓存设置好过期时间。</strong></p>
<h1 id="Read-Write-Through-更新模式"><a href="#Read-Write-Through-更新模式" class="headerlink" title="Read/Write Through 更新模式"></a>Read/Write Through 更新模式</h1><p>我们可以看到，在上面的 Cache Aside 套路中，应用代码需要维护两个数据存储，一个是缓存（cache），一个是数据库（repository）。所以，应用程序比较啰嗦。而 Read/Write Through 套路是把更新数据库（repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的 Cache。</p>
<h2 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h2><p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或 LRU 换出），Cache Aside 是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载，从而对应用方是透明的。</p>
<h2 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h2><p>Write Through 套路和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由 Cache 自己更新数据库（这是一个同步操作）。</p>
<p>下图自来 Wikipedia 的 <a href="">https://en.wikipedia.org/wiki/Cache_(computing">Cache 词条</a> 。其中的 Memory，可以理解为就是我们例子里的数据库。</p>
<p><img src="../images/2ce5afe305e60d98bf3b647ef23f3edd.png" alt="img"></p>
<h1 id="Write-Behind-Caching-更新模式"><a href="#Write-Behind-Caching-更新模式" class="headerlink" title="Write Behind Caching 更新模式"></a>Write Behind Caching 更新模式</h1><p>Write Behind 又叫 Write Back。一些了解 Linux 操作系统内核的同学对 write back 应该非常熟悉，这不就是 Linux 文件系统的 page cache 算法吗？基础知识全都是相通的。所以，基础很重要。</p>
<p>Write Back 套路就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的 I/O 操作飞快无比（因为直接操作内存嘛）。因为异步，Write Back 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道 Unix/Linux 非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间、空间换时间一个道理。有时候，强一致性和高性能，高可用和高性能是有冲突的。软件设计从来都是 trade-off（取舍）。</p>
<p>另外，Write Back 实现逻辑比较复杂，因为它需要 track 有哪些数据是被更新了的，需要刷到持久层上。操作系统的 Write Back 会在仅当这个 cache 需要失效的时候，才会把它真正持久起来。比如，内存不够了，或是进程退出了等情况，这又叫 lazy write。</p>
<p>在 Wikipedia 上有一张 Write Back 的流程图，基本逻辑可以在下图中看到。</p>
<p><img src="../images/dd7281e669f64165eedbbf228d74d756.png" alt="img"></p>
<h1 id="缓存设计的重点"><a href="#缓存设计的重点" class="headerlink" title="缓存设计的重点"></a>缓存设计的重点</h1><p>缓存更新的模式基本如前面所说，不过这还没完，缓存已经成为高并发高性能架构的一个关键组件了。现在，很多公司都在用 Redis 来搭建他们的缓存系统。一方面是因为 Redis 的数据结构比较丰富。另一方面，我们不能在 Service 内放 local cache，一是每台机器的内存不够大，二是我们的 Service 有多个实例，负载均衡器会把请求随机分布到不同的实例。缓存需要在所有的 Service 实例上都建好，这让我们的 Service 有了状态，更难管理了。</p>
<p>所以，在分布式架构下，一般都需要一个外部的缓存集群。关于这个缓存集群，需要保证的是内存要足够大，网络带宽也要好，因为缓存本质上是个内存和 IO 密集型的应用。</p>
<p>另外，如果需要内存很大，那么还要动用数据分片技术来把不同的缓存分布到不同的机器上。这样，可以保证我们的缓存集群可以不断地 scale 下去。</p>
<p>缓存的好坏要看命中率。缓存的命中率高说明缓存有效，一般来说命中率到 80% 以上就算很高了。当然，有的网络为了追求更高的性能，要做到 95% 以上，甚至可能会把数据库里的数据几乎全部装进缓存中。这当然是不必要的，也是没有效率的，因为通常来说，热点数据只会是少数。</p>
<p>另外，缓存是通过牺牲强一致性来提高性能的，这世上任何事情都不是免费的，所以并不是所有的业务都适合用缓存，这需要在设计的时候仔细调研好需求。使用缓存提高性能，就是会有数据更新的延迟。</p>
<p>缓存数据的时间周期也需要好好设计，太长太短都不好，过期期限不宜太短，因为可能导致应用程序不断从数据存储检索数据并将其添加到缓存。同样，过期期限不宜太长，因为这会导致一些没人访问的数据还在内存中不过期，而浪费内存。</p>
<p>使用缓存的时候，一般会使用 LRU 策略。也就是说，当内存不够需要有数据被清出内存时，会找最不活跃的数据清除。所谓最不活跃的意思是最长时间没有被访问过了。所以，开启 LRU 策略会让缓存在每个数据访问的时候把其调到前面，而要淘汰数据时，就从最后面开始淘汰。</p>
<p>于是，对于 LRU 的缓存系统来说，其需要在 key-value 这样的非顺序的数据结构中维护一个顺序的数据结构，并在读缓存时，需要改变被访问数据在顺序结构中的排位。于是，我们的 LRU 在读写时都需要加锁（除非是单线程无并发），因此 LRU 可能会导致更慢的缓存存取的时间。这点要小心。</p>
<p>最后，我们的世界是比较复杂的，很多网站都会被爬虫爬，要小心这些爬虫。因为这些爬虫可能会爬到一些很古老的数据，而程序会把这些数据加入到缓存中去，而导致缓存中那些真实的热点数据被挤出去（因为机器的速度足够快）。对此，一般来说，我们需要有一个爬虫保护机制，或是我们引导这些人去使用我们提供的外部 API。在那边，我们可以有针对性地做多租户的缓存系统（也就是说，把用户和第三方开发者的缓存系统分离开来）。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好了，我们来总结一下今天分享的主要内容。首先，缓存是为了加速数据访问，在数据库之上添加的一层机制。讲了几种典型的缓存模式，包括 Cache Aside、Read/Write Through 和 Write Behind Caching 以及它们各自的优缺点。</p>
<p>最后，介绍了缓存设计的重点，除了性能之外，在分布式架构下和公网环境下，对缓存集群、一致性、LRU 的锁竞争、爬虫等多方面都需要考虑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/%E5%BA%94%E5%AF%B9%E6%95%85%E9%9A%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/24/%E5%BA%94%E5%AF%B9%E6%95%85%E9%9A%9C/" class="post-title-link" itemprop="url">应对故障</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-24 17:44:07 / Modified: 17:47:23" itemprop="dateCreated datePublished" datetime="2020-02-24T17:44:07-06:00">2020-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>或多或少我们都会经历线上的故障。在我的职业生涯中，就经历过很多的线上故障。老实说，线上故障是技术人员成长中必须要经历的事。从故障中我们可以吸取到很多教训，能让我们学到很多书本上学不到的知识。坑踩多了，会变得越来越有经验，也就成为老司机了。</p>
<p>不过，很多公司处理线上故障的方式并不科学，而且存在很多问题，所以，分享一些我的经验。这些经验主要来自亚马逊和阿里这两家互联网公司，以及个人的经验总结。希望这套方法能够有帮助。</p>
<h1 id="故障发生时"><a href="#故障发生时" class="headerlink" title="故障发生时"></a>故障发生时</h1><p>在故障发生时，最重要的是快速恢复故障。而快速恢复故障的前提是快速定位故障源。因为在很多分布式系统中，一旦发生故障就会出现“多米诺骨牌效应”。也就是说，系统会随着一个故障开始一点一点地波及到其它系统，而且这个过程可能会很快。一旦很多系统都在报警，要想快速定位到故障源就不是一件简单的事了。</p>
<p>在亚马逊内部，每个开发团队至少都会有一位 oncall 的工程师。在 oncall 的时候，工程师要专心处理线上故障，轮换周期为每人一周。一旦发生比较大的故障，比如，S1 全部不可用，或 S2 某功能不可用，而且找不到替代方案，那么这个故障就会被提交到一个工单系统里。几乎所有相关团队 oncall 的工程师都会被叫到线上处理问题。</p>
<p>工作流是，先线上签到，然后自查自己的服务，如果自己的服务没有问题，那么就可以在旁边待命（standby），以备在需要时进行配合。如果问题没有被及时解决，就会自动升级到高层，直到 SVP 级别。</p>
<p>大家都知道，在亚马逊，不是按技能分工，而是按职责分工，也就是一个团队不是按前端、后端、运维等来分工，而是按所负责的 Service 来分工。所以，亚马逊的开发人员都是前端、后端、测试、运维全部都要干的。而亚马逊内部有很多的服务，一旦出现问题，为了避免一个工单在各个团队流转，需要所有团队上线处理，这样是最快的。</p>
<p>如果我们的系统架构是分布式服务化的，那么一个用户的请求可能会经过很多的服务，开发和运维起来是非常麻烦的。此时，跨团队跨部门的开发和运维就变得非常的重要了。就我的经历而言，在故障发生时，亚马逊的处理过程是比较有效和快速的，尤其是能够快速地定位故障源。对于被影响的其他团队也可以做一定的处理，比如做降级处理，这样可以控制故障的范围不被扩散。</p>
<p>故障源团队通常会有以下几种手段来恢复系统。</p>
<ul>
<li><strong>重启和限流</strong>。重启和限流主要解决的是可用性的问题，不是功能性的问题。重启还好说，但是限流这个事就需要相关的流控中间件了。</li>
<li><strong>回滚操作</strong>。回滚操作一般来说是解决新代码的 bug，把代码回滚到之前的版本是快速的方式。</li>
<li><strong>降级操作</strong>。并不是所有的代码变更都是能够被回滚的，如果无法回滚，就需要降级功能了。也就是说，需要挂一个停止服务的故障公告，主要是不要把事态扩大。</li>
<li><strong>紧急更新</strong>。紧急更新是常用的手段，这个需要强大的自动化系统，尤其是自动化测试和自动化发布系统。假如你要紧急更新 1000 多台服务器，没有一个强大的自动化发布系统是很难做到的。</li>
</ul>
<p>也就是说，出现故障时，<strong>最重要的不是 debug 故障，而是尽可能地减少故障的影响范围，并尽可能快地修复问题</strong>。</p>
<p>国内的很多公司，都是由专职的运维团队来处理线上问题的。然而，运维团队通常只能处理一些基础设施方面的问题，或是非功能性的问题。对于一些功能性的问题，运维团队是完全没有能力处理的，只能通过相应的联系人，把相关的开发人员叫到线上来看。而可能这个开发人员看到的是别的系统有问题，又会叫上其它团队的人来。所以，一级一级地传递下去，会浪费很多时间。</p>
<h1 id="故障前的准备工作"><a href="#故障前的准备工作" class="headerlink" title="故障前的准备工作"></a>故障前的准备工作</h1><p>为了能够在面临故障时做得有条不紊，我们需要做一些前期的准备工作。这些准备工作做得越细，那么故障处理起来也就越有条理。我们知道，故障来临时，一切都会变得混乱。此时，对于需要处理故障的我们来说，事可以乱，但人不能乱。如果人跟着事一起乱，那就是真正的混乱了。</p>
<p>所以，我们需要做一些故障前的准备工作。在这里，我给出一些我的经验。</p>
<ul>
<li><strong>以用户功能为索引的服务和资源的全视图</strong>。首先，我们需要一个系统来记录前端用户操作界面和后端服务，以及服务所使用到的硬件资源之间的关联关系。这个系统有点像 CMDB（配置管理数据库），但是比 CMDB 要大得多，是以用户端的功能来做索引的。然后，把后端的服务、服务的调用关系，以及服务使用到的资源都关联起来做成一个视图。</li>
</ul>
<p>这个视图最好是由相应的自动化监控系统生成。有了这个资源图后，我们就可以很容易地找到处理故障的路径了。<strong>这就好像一张地图，如果没有地图，我们只能像个无头苍蝇一样乱试了</strong>。</p>
<ul>
<li><strong>为地图中的各个服务制订关键指标，以及一套运维流程和工具，包括应急方案</strong>。以用户功能为索引，为每个用户功能的服务都制订一个服务故障的检测、处理和恢复手册，以及相关的检测、查错或是恢复的运维工具。对于基础层和一些通用的中间件，也需要有相应的最佳实践的方法。</li>
</ul>
<p>比如 Redis，怎样检查其是否存在问题，怎样查看其健康和运行状态？哪些是关键指标，面对常见的故障应该怎么应对，服务不可用的服务方案是什么，服务需要回滚了应该怎么操作，等等。<strong>这就好像一个导航仪，能够告诉你怎么做。而没有导航仪，就没有章法，会导致混乱</strong>。</p>
<ul>
<li><strong>设定故障的等级</strong>。还要设定不同故障等级的处理方式。比如，亚马逊一般将故障分为 4 级：1 级是全站不可用；2 级是某功能不可用，且无替代方案；3 级是某功能不可用，但有替代方案；4 级是非功能性故障，或是用户不关心的故障。阿里内的分类更多样一些，有时会根据影响多少用户来定故障等级。</li>
</ul>
<p>制定故障等级，主要是为了确定该故障要牵扯进多大规模的人员来处理。故障级别越高，牵扯进来的人就越多，参与进来的管理层级别也就越高。就像亚马逊内的全员上线 oncall 一样。<strong>这就好像是我们社会中常用的“红色警报”、“橙色警报”、“黄色警报”之类的，会触发不同的处理流程</strong>。</p>
<ul>
<li><strong>故障演练</strong>。故障是需要演练的。因为故障并不会时常发生，但我们又需要不断提升处理故障的能力，所以需要经常演练。一些大公司，如 Netflix，会有一个叫 Chaos Monkey 的东西，随机地在生产线上乱来。Facebook 也会有一些故障演习，比如，随机关掉线上的一些服务器。总之，要提升故障处理水平，最好的方式就是实践。见得多了，处理得多了，才能驾轻就熟。<strong>故障演练是一个非常好的实践</strong>。</li>
<li><strong>灰度发布系统</strong>。要减少线上故障的影响范围，通过灰度发布系统来发布是一个很不错的方式。毕竟，我们在测试环境中很难模拟出线上环境的所有情况，所以，在生产线上进行灰度发布或是 A/B 测试是一件很好的事。</li>
</ul>
<p>在亚马逊，发布系统中有一个叫 Weblab 的系统，就是用来做灰度发布的。另外，亚马逊全球会有多个站点。一般来说，会先发中国区。如果中国区没什么问题了，就发日本区，然后发欧洲区，最后是美国区。而如果没有很多站点的话，那么你就需要一个流量分配系统来做这个事了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/google%E6%8A%80%E6%9C%AF%E8%AF%84%E5%88%86%E5%8D%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/23/google%E6%8A%80%E6%9C%AF%E8%AF%84%E5%88%86%E5%8D%A1/" class="post-title-link" itemprop="url">google技术评分卡</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-23 20:43:36 / Modified: 20:44:56" itemprop="dateCreated datePublished" datetime="2020-02-23T20:43:36-06:00">2020-02-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h1><blockquote>
<p>0 - you are unfamiliar with the subject area.(0 -你不熟悉主题领域。)</p>
</blockquote>
<blockquote>
<p>1 - you can read / understand the most fundamental aspects of the subject area.(1 -你可以阅读/了解主题领域最基本的方面。)</p>
</blockquote>
<blockquote>
<p>2 - ability to implement small changes, understand basic principles and able to figure out additional details with minimal help.(2 -能够实现小的变化，理解基本原理，并能在最小的帮助下找出更多的细节。)</p>
</blockquote>
<blockquote>
<p>3 - basic proficiency in a subject area without relying on help.(3 -在不依赖帮助的情况下，熟练掌握某一科目。)</p>
</blockquote>
<blockquote>
<p>4 - you are comfortable with the subject area and all routine work on it: (4 -你对主题领域和所有日常工作都很熟悉:)</p>
<p>For software areas - ability to develop medium programs using all basic language features w/o book, awareness of more esoteric features (with book).(对于软件领域来说，能够使用所有基本的语言来开发中等的程序，使用w/o book，了解更深奥的特性(带书)。)</p>
<p>For systems areas - understanding of many fundamentals of networking and systems administration, ability to run a small network of systems including recovery, debugging and nontrivial troubleshooting that relies on the knowledge of internals.(对于系统领域——了解网络和系统管理的许多基础知识，能够运行一个小型的系统网络，包括恢复、调试和依赖于内部知识的重要故障排除。)</p>
</blockquote>
<blockquote>
<p>5 - an even lower degree of reliance on reference materials. Deeper skills in a field or specific technology in the subject area.(5 -对参考资料的依赖程度更低。在某一领域或某一特定技术领域有较深的技能。)</p>
</blockquote>
<blockquote>
<p>6 - ability to develop large programs and systems from scratch. Understanding of low level details and internals. Ability to design / deploy most large, distributed systems from scratch.(6 -能够从头开始开发大型程序和系统。了解低层次的细节和内部信息。能够设计/部署大多数大型的分布式系统。)</p>
</blockquote>
<blockquote>
<p>7 - you understand and make use of most lesser known language features, technologies, and associated internals. Ability to automate significant amounts of systems administration.(7 -你理解并利用最不知名的语言特征、技术和相关的内部信息。能够自动化大量的系统管理。)</p>
</blockquote>
<blockquote>
<p>8 - deep understanding of corner cases, esoteric features, protocols and systems including “theory of operation”. Demonstrated ability to design, deploy and own very critical or large infrastructure, build accompanying automation.(8 -深刻理解角落案例，深奥的特点，协议和系统，包括“操作理论”。演示了设计、部署和拥有非常关键或大型基础设施的能力，并建立了相应的自动化。)</p>
</blockquote>
<blockquote>
<p>9 - could have written the book about the subject area but didn’t; works with standards committees on defining new standards and methodologies.(9 -本可以写关于主题领域的书，但没有;与标准委员会一起制定新的标准和方法。)</p>
</blockquote>
<blockquote>
<p>10 - wrote the book on the subject area (there actually has to be a book). Recognized industry expert in the field, might have invented it.(10 -写在主题领域的书(实际上必须有一本书)。业内公认的业内专家，可能已经发明了它。)</p>
</blockquote>
<h1 id="Subject-Areas"><a href="#Subject-Areas" class="headerlink" title="Subject Areas"></a>Subject Areas</h1><blockquote>
<p>TCP/IP Networking (OSI stack, DNS etc)</p>
<p>Unix/Linux internals</p>
<p>Unix/Linux Systems administration</p>
<p>Algorithms and Data Structures</p>
<p>C</p>
<p>C++</p>
<p>Python</p>
<p>Java</p>
<p>Perl</p>
<p>Go</p>
<p>Shell Scripting (sh, Bash, ksh, csh)</p>
<p>SQL and/or Database Admin</p>
<p>Scripting language of your choice (not already mentioned) _</p>
<p>People Management</p>
<p>Project Management</p>
</blockquote>
<p>作者：carolsanders<br>链接：<a href="https://www.jianshu.com/p/b1f57417320d" target="_blank" rel="noopener">https://www.jianshu.com/p/b1f57417320d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yuanchen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanchen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/23/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" class="post-title-link" itemprop="url">配置中心</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-23 20:34:56 / Modified: 20:42:26" itemprop="dateCreated datePublished" datetime="2020-02-23T20:34:56-06:00">2020-02-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>软件还有一些配置信息，比如数据库的用户名和密码，还有一些我们不想写死在代码里的东西，像线程池大小、队列长度等运行参数，以及日志级别、算法策略等，还有一些是软件运行环境的参数，如 Java 的内存大小，应用启动的参数，包括操作系统的一些参数配置……</p>
<p>所有这些东西，我们都叫做软件配置。以前，我们把软件配置写在一个配置文件中，就像 Windows 下的 ini 文件，或是 Linux 下的 conf 文件。然而，在分布式系统下，这样的方式就变得非常不好管理，并容易出错。于是，为了便于管理，我们引入了一个集中式的配置管理系统，这就是配置中心的由来。</p>
<p>现在，软件的配置中心是分布式系统的一个必要组件。这个系统听起来很简单，但其实并不是。</p>
<h1 id="配置中心的设计"><a href="#配置中心的设计" class="headerlink" title="配置中心的设计"></a>配置中心的设计</h1><h2 id="区分软件的配置"><a href="#区分软件的配置" class="headerlink" title="区分软件的配置"></a>区分软件的配置</h2><p>首先，我们要区分软件的配置，软件配置的区分有多种方式。</p>
<p>有一种方式是把软件的配置分成静态配置和动态配置。所谓静态配置其实就是在软件启动时的一些配置，运行时基本不会进行修改，也可以理解为是环境或软件初始化时需要用到的配置。</p>
<p>例如，操作系统的网络配置，软件运行时 Docker 进程的配置，这些配置在软件环境初始化时就确定了，未来基本不会修改了。而所谓动态配置其实就是软件运行时的一些配置，在运行时会被修改。比如，日志级别、降级开关、活动开关。</p>
<p>当然，我们这里的内容主要针对动态配置的管理。</p>
<p>对于动态配置的管理，我们还要做好区分。一般来说，会有三个区分的维度。</p>
<ul>
<li><strong>按运行环境分</strong>。一般来说，会有开发环境、测试环境、预发环境、生产环境。这些环境上的运行配置都不完全一样，但是理论来说，应该是大同小异的。</li>
<li><strong>按依赖区分</strong>。一种是依赖配置，一种是不依赖的内部配置。比如，外部依赖的 MySQL 或 Redis 的连接配置。还有一种完全是自己内部的配置。</li>
<li><strong>按层次分</strong>。就像云计算一样，配置也可以分成 IaaS、PaaS、SaaS 三层。基础层的配置是操作系统的配置，中间平台层的配置是中间件的配置，如 Tomcat 的配置，上层软件层的配置是应用自己的配置。</li>
</ul>
<p>这些分类方式其实是为了更好地管理我们的配置项。小公司无所谓，而当一个公司变大了以后了，如果这些东西没有被很好地管理起来，那么会增加太多系统维护的复杂度。</p>
<h2 id="配置中心的模型"><a href="#配置中心的模型" class="headerlink" title="配置中心的模型"></a>配置中心的模型</h2><p>有了上面为配置项的分类，我们就可以设计软件配置模型了。</p>
<p>首先，软件配置基本上来说，每个配置项就是 key/value 的模型。</p>
<p>然后，我们把软件的配置分成三层。操作系统层和平台层的配置项得由专门的运维人员或架构师来配置。其中的 value 应该是选项，而不是让用户可以自由输入的，最好是有相关的模板来初始化全套的配置参数。而应用层的配置项，需要有相应的命名规范，最好有像 C++ 那样的名字空间的管理，确保不同应用的配置项不会冲突。</p>
<p>另外，配置参数中，如果有外部服务依赖的配置，强烈建议不要放在配置中心里，而要放在服务发现系统中。因为一方面这在语义上更清楚一些，另外，这样会减少因为运行不同环境而导致配置不同的差异性（如测试环境和生产环境的不同）。</p>
<p>对于不同运行环境中配置的差异来说，比如在开发环境和测试环境下，日志级别是 Debug 级，对于生产环境则是 Warning 或 Error 级，因为环境的不一样，会导致我们需要不同的配置项的值。这点需要考虑到。</p>
<p>还有，配置需要有一个整体的版本管理，每次变动都能将版本差异记录下来。当然，如果可能，最好能和软件的版本号做关联。</p>
<p>可以看到，其中有些配置是通过模板来选择的，有的配置需要在不同环境下配置不同值。所以，还需要一个配置管理的工具，可能是命令行的，也可以是 Web 的。这个工具的界面在文本中（下面这个 UI 的 mockup 只是想表明一个模型）。</p>
<p><img src="../images/5aeb4055738bd15188a007ccbbbc38b7.png" alt="img"></p>
<p>用户可以根据不同的机器型号还有不同的环境直接调出后台配置好的相关标准配置的模板。对于一些用户需要自己调整的参数也可以在这个模板上进行调整和配置（当然，为了方便运维和管理最好不要进行调整）。然后，用户可以在下面的那个表格中填写好自己的应用要用的参数和各个环境中的值。</p>
<p>这样一来，这个工具就可以非常方便地让开发人员来配置他们自己的软件配置。而我们的配置中心还需要提 API 来让应用获取配置。这个 API 上至少需要有如下参数：服务名，配置的版本号，配置的环境。</p>
<h2 id="配置中心的架构"><a href="#配置中心的架构" class="headerlink" title="配置中心的架构"></a>配置中心的架构</h2><p>接下来，要来解决配置落地的问题。我们可以看到，和一个软件运行有关系的各种配置隶属于不同的地方，所以，要让它们落地还需要些不一样的细节要处理。文本中，我们给了一个大概的架构图。</p>
<p><img src="../images/745c444c53457239de884a943adff1b5.png" alt="img"></p>
<p>在这个图中可以看到，我们把配置录入后，配置中心发出变更通知，配置变更控制器会来读取最新的配置，然后应用配置。这看上去很简单，但是有很多细节问题，下面我来一一说明。</p>
<ul>
<li><strong>为什么需要一个变更通知的组件，而不是让配置中心直接推送？</strong>原因是，分布式环境下，服务器太多，推送不太现实，而采用一个 Pub/Sub 的通知服务可以让数据交换经济一些。</li>
<li><strong>为什么不直接 Pub 数据过去，还要订阅方反向拉数据？</strong>直接推数据当然可以，但让程序反过来用 API 读配置的好处是，一方面，API 可以校验请求者的权限，另一方面，有时候还是需要调用配置中心的基本 API，比如下载最新的证书之类的。还有就是，服务启动时需要从服务中心拉一份配置下来。</li>
<li><strong>配置变更控制器部署在哪里？是在每个服务器上呢，还是在一个中心的地方？</strong>我觉得因为这个事是要变更配置，变更配置又是有很多步骤的，所以这些步骤算是一个事务。为了执行效率更好，事务成功率更大，建议把这个配置变更的控制放在每一台主机上。</li>
<li><strong>平台层的配置变更，有的参数是在服务启动的命令行上，这个怎么变更呢？</strong>一般来说，命令行上的参数需要通过 Shell 环境变量做成配置项，然后通过更改系统环境变量，并重启服务达到配置变更。</li>
<li><strong>操作系统的配置变更和平台层的配置变更最好模块化掉，就像云服务中的不同尺寸的主机型号一样。</strong>这样有利于维护和减少配置的复杂性。</li>
<li><strong>应用服务配置更新的标准化。</strong>因为一个公司的应用由不同的团队完成，所以，可能其配置会因为应用的属性不同而不一样。为了便于管理，最好有统一的配置更新。一般来说，有的应用服务的配置是在配置文件中，有的应用服务的配置是通过调用 Admin API 的方式变更，不同的应用系统完全不一样，你似乎完全没有方法做成统一的。这里给几个方案。</li>
<li>可以通过一个开发框架或 SDK 的方式来解决，也就是应用代码找你这个 SDK 来要配置，并通过 observer 模式订阅配置修改的事件，或是直接提供配置变更的 Admin 的 API。这种方式的好处在于在开发期标准化，并可以规范开发；不好的是，耦合语言。</li>
<li>通过一个标准应用运维脚本，让应用方自己来提供应用变更时的脚本动作。这种方式虽然通过运维的方式标准化掉配置变更的接口，就可以通过一个配置控制器来统一操作各个应用变更，但是在这个脚本中各个应用方依然使用着各种不同的方式来变更配置。这种方式的好处是不耦合语言，灵活，但对于标准化的建设可能不利，而且使用或者调用脚本是 Bug 很多的东西，容易出问题。</li>
<li>或是结合上述两种方案，不使用开发阶段的 SDK 方式嵌入到应用服务中，而是为每个应用服务单独做一个 Agent。这个 Agent 对外以 Admin API 的方式服务，后面则适配应用的配置变更手段，如更新配置文件，或者调用应用的 API 等。这种方式在落地方面是很不错的（这其中是另一种设计模式，后面会讲到）。</li>
</ul>
<h1 id="配置中心的设计重点"><a href="#配置中心的设计重点" class="headerlink" title="配置中心的设计重点"></a>配置中心的设计重点</h1><p>配置中心主要的用处是统一和规范化管理所有的服务配置，也算是一种配置上的治理活动。所以，配置中心的设计重点应该放在如何统一和标准化软件的配置项，其还会涉及到软件版本、运行环境、平台、中间件等一系列的配置参数。如果你觉得软件配置非常复杂，那么，你应该静下心来仔细梳理或治理一下现有的配置参数，并简化相应的配置，使用模块会是一种比较好的简化手段。</p>
<p>根据我们前面《编程范式游记》中所说的，编程的本质是对 logic 和 control 的分离，所以，对于配置也一样，其也有控制面上的配置和业务逻辑面上的配置，控制面上的配置最好能标准统一。</p>
<p>配置更新的时候是一个事务处理，需要考虑事务的问题，如果变更不能继续，需要回滚到上个版本的配置。配置版本最好和软件版本对应上。</p>
<p>配置更新控制器，需要应用服务的配合，比如，配置的 reload，服务的优雅重启，服务的 Admin API，或是通过环境变量……这些最好是由一个统一的开发框架搞定。</p>
<p>配置更新控制器还担任服务启动的责任，由配置更新控制器来启动服务。这样，配置控制器会从配置中心拉取所有的配置，更新操作系统，设置好启动时用的环境变量，并更新好服务需要的配置文件 ，然后启动服务。（当然，你也可以在服务启动的脚本中真正启动服务前放上一段让配置更新控制器更新配置的脚本。无论怎么样，这些都可以在运维层面实现，不需要业务开发人员知道。）</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好了，我们来总结一下今天分享的主要内容。首先，传统单机软件的配置通常保存在文件中，但在分布式系统下，为了管理方便，必须有一个配置中心。然后我讲了配置的区分：按静态和动态、运行环境、依赖和层次来区分。进一步，从区分出的情况出发，层次方面，平台、中间件和应用三个层次由不同职责的运维人员来配置。</p>
<p>外部依赖的配置并不适合放在配置中心里，而最好是由服务发现系统来提供。开发环境和生产环境的日志级别配置也会不同。出于这些特点，可以用一个配置管理工具来管理这些配置。接着，介绍了配置管理架构中几个关键问题的解决思路。最后，介绍了配置中心的几个设计重点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=26924746&auto=1&height=66"></iframe>
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yuanchen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanchen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
